#!/usr/bin/python3
'''
Fit-o-mat - a versatile program for nonlinear least-squares fitting
Copyright (C) 2017-2021  Andreas Moeglich, University of Bayreuth, Germany
contact me at andreas.moeglich@uni-bayreuth.de

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
'''
VERSION = '0.847'

from PyQt5 import QtCore, QtGui, QtWidgets
from sys import argv, exit, path, platform, exc_info
from glob import glob
from functools import partial, cmp_to_key
from copy import deepcopy
from ast import literal_eval
from time import asctime, time
from os.path import expanduser, isfile
import webbrowser
import zipfile, io
try:
  from pycorn import pc_res3
  PYCORN_PRESENT = True
except:
  PYCORN_PRESENT = False

import matplotlib
matplotlib.use("Qt5Agg")
import matplotlib.pyplot as plt
import matplotlib.legend as Legend
from matplotlib.widgets import RectangleSelector
from matplotlib.widgets import LassoSelector
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib import patheffects as PathEffects
from mpl_toolkits.axes_grid1 import make_axes_locatable, Size
import xlrd
try:
  import openpyxl
  OPENPYXL_PRESENT = True
except:
  OPENPYXL_PRESENT = False
import xlsxwriter
import numpy as np
import scipy.optimize as optim
import scipy.odr as odr
import warnings

# reimplement FigureCanvas to optimize graphics refresh  
class MyFigureCanvas(FigureCanvas):
  def __init__(self, parent=None, matplotlibCanvas=None, name='superunknown'):
    super(MyFigureCanvas, self).__init__(parent)
    self.parent = parent
    self.matplotlibCanvas = matplotlibCanvas
    self.refreshCount = 0
    self.destructCounter = 0
    self.name = name

  def myRefresh(self):
    # wrapper function to globally set how draw updates are done
    self.refreshCount += 1
    
    # ready to destruct?
    if(self.destructCounter):
      self.destructCounter -= 1
      if(not self.destructCounter):
        self.matplotlibCanvas.destructAboutLogo()
    
    # do we have arrows to take care of?
    for entry in ['x', 'y']:
      if(self.name == 'plot'):
        if((self.matplotlibCanvas.handleArrow[entry] != None) or (self.matplotlibCanvas.handleArrow2[entry] != None)):
          self.matplotlibCanvas.drawAxisArrow(axis=entry, redraw=False, target='plot')
      elif(self.name == 'resid'):
        if((self.matplotlibCanvas.handleArrowResid[entry] != None) or (self.matplotlibCanvas.handleArrowResid2[entry] != None)):
          self.matplotlibCanvas.drawAxisArrow(axis=entry, redraw=False, target='resid')
        
    # do we have split axis divider lines to take are of?
    # (the function call will also delete left-over previous divider lines)
    self.matplotlibCanvas.drawSplitAxisDivider(redraw=False, target=self.name)
    self.matplotlibCanvas.drawSplitYAxisDivider(redraw=False)

    # the actual draw command
    self.draw()
    
  def setDestructionCounter(self, counter=0):
    # sets up destruction of self.handlesAbout
    self.destructCounter = counter

  def getDestructionCounter(self):
    # returns destruction counter
    return self.destructCounter

# custom QTabWidget (to enable dynamic tooltips)
class myQTabWidget(QtWidgets.QTabWidget):
  def __init__(self, *args, **kwargs):
    super(myQTabWidget, self).__init__(*args, **kwargs)
    self.storedToolTips = []
    
  def toggleToolTips(self, state=True):
    # dynamically sets and unsets tab tool tips
    for tab in range(self.count()):
      if(state):
        if(len(self.storedToolTips) > tab):
          self.setTabToolTip(tab, self.storedToolTips[tab])
      else:
        if(len(self.storedToolTips) <= tab):
          self.storedToolTips.append(self.tabToolTip(tab))
        else:
          self.storedToolTips[tab] = self.tabToolTip(tab)
        self.setTabToolTip(tab, '')

# custom window for picture preview
class PreviewWindow(QtWidgets.QMainWindow):
  def __init__(self, *args, **kwargs):
    super(PreviewWindow, self).__init__(*args, **kwargs)
    ###self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
    self.NUMBER_TILES = 15
    self.displayPreview = None

  def paintEvent(self, event):
    # draw rounded corners
    s = self.size()
    winWidth, winHeight = s.width(), s.height()
    offsetX, offsetY = 0, 0
    targetWidth, targetHeight = winWidth, winHeight
    # adjust this to fit the draw area
    if((self.displayPreview != None) and (hasattr(self.displayPreview, 'size'))):
      targetSize = self.displayPreview.size()
      targetWidth, targetHeight = targetSize.width(), targetSize.height()
      offsetX, offsetY = winWidth - targetWidth, winHeight - targetHeight
    # do the actual painting
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.setPen(QtCore.Qt.NoPen)
    # draw background rectangle
    qp.setBrush(QtGui.QColor(180, 180, 180, 255))
    qp.drawRect(offsetX, offsetY, targetWidth, targetHeight)
    # draw checkered boxes
    qp.setBrush(QtGui.QColor('white'))
    deltaX, deltaY = int(targetWidth / self.NUMBER_TILES), int(targetHeight / self.NUMBER_TILES)
    for dx in range(self.NUMBER_TILES):
      for dy in range(self.NUMBER_TILES):
        if((dx + dy) % 2):
          qp.drawRect(offsetX + dx * deltaX, offsetY + dy * deltaY, deltaX, deltaY)
    # fini
    qp.end()

  def setDisplayPreview(self, displayPreview):
    # tells the preview window where to paint the checker marks
    self.displayPreview = displayPreview
    
  def keyPressEvent(self, event):
    # catches escape key
    if(event.key() == QtCore.Qt.Key_Escape):
      self.close()
    else:
      # activate normal event handling
      QtWidgets.QMainWindow.keyPressEvent(self, event)

# custom QComboBox to fix Qt layout bug on Mac :(
# exploit Mac stupidity to also implement pass-through of Ctrl key presses
class QComboBoxMac(QtWidgets.QComboBox):
  def __init__(self, *args, **kwargs):
    super(QComboBoxMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

  def keyPressEvent(self, event):
    # pass through events with Ctrl modifier
    if(event.modifiers() & QtCore.Qt.ControlModifier):
      event.ignore()
      return
    else:
      # normal event processing
      QtWidgets.QComboBox.keyPressEvent(self, event)

# custom QSpinBox for interactive display of tooltips
class QSpinBoxToolTip(QtWidgets.QSpinBox):
  def __init__(self, *args, **kwargs):
    super(QSpinBoxToolTip, self).__init__(*args, **kwargs)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

# custom QRadioButton for interactive display of tooltips
class QRadioButtonToolTip(QtWidgets.QRadioButton):
  def __init__(self, *args, **kwargs):
    super(QRadioButtonToolTip, self).__init__(*args, **kwargs)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

# custom QLabel for interactive display of tooltips
class QLabelToolTip(QtWidgets.QLabel):
  def __init__(self, *args, **kwargs):
    super(QLabelToolTip, self).__init__(*args, **kwargs)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)
  
# custom QPushButton to fix Qt layout bug on Mac :(
class QPushButtonMac(QtWidgets.QPushButton):
  def __init__(self, *args, **kwargs):
    super(QPushButtonMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

# subclass color button to have it work both with Fusion style and not mess up tool tips
class QPushButtonColor(QPushButtonMac):
  def __init__(self, *args, **kwargs):
    super(QPushButtonColor, self).__init__(*args, **kwargs)
    self.myColor = None
    
  def setMyColor(self, red=0, green=0, blue=0, alpha=255):
    # sets button color
    self.myColor = [red, green, blue, alpha]
    # issue update to ensure that color is displayed
    self.update()

  def paintEvent(self, event):
    # original draw event
    #QPushButtonMac.paintEvent(self, event)
  
    # draws colored area in button
    if(self.myColor != None):
      s = self.size()
      qp = QtGui.QPainter()
      qp.begin(self)
      qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
      qp.setPen(QtCore.Qt.NoPen)
      qp.setBrush(QtGui.QBrush(QtGui.QColor(*self.myColor)))
      qp.drawRoundedRect(0, 0, s.width(), s.height(), scaledDPI(3), scaledDPI(3))

      # overlay gradient
      pen = QtGui.QPen()
      pen.setStyle(QtCore.Qt.SolidLine)
      pen.setJoinStyle(QtCore.Qt.RoundJoin)
      pen.setColor(QtGui.QColor(171, 171, 171, 255))
      pen.setWidth(scaledDPI(0.5))
      pen.setCapStyle(QtCore.Qt.SquareCap)
      qp.setPen(pen)
  
      grad = QtGui.QLinearGradient(0, 0, 0, s.height())
      grad.setColorAt(0, QtGui.QColor(255, 255, 255, 150))
      grad.setColorAt(0.2, QtGui.QColor(255, 255, 255, 0))
      grad.setColorAt(0.8, QtGui.QColor(0, 0, 0, 0))
      grad.setColorAt(1, QtGui.QColor(0, 0, 0, 80))
      qp.setBrush(QtGui.QBrush(grad))
  
      qp.drawRoundedRect(0, 0, s.width(), s.height(), scaledDPI(3), scaledDPI(3))
      qp.end()

# a funky new push button
class QPushButtonCheckable(QPushButtonMac):
  def __init__(self, *args, **kwargs):
    super(QPushButtonCheckable, self).__init__(*args, **kwargs)
    self.setCheckable(True)
    self.checkMe = False
    self.padMe = 0
    
  def setCheckMe(self, state):
    # controls whether to draw check mark when checked
    self.checkMe = state

  def setPadMe(self, value):
    # controls whether to pad button
    self.padMe = value
    # activate specific style sheet
    if(self.padMe):
      self.setObjectName('listos')
    else:
      self.setObjectName('')

  def paintEvent(self, event):
    # original draw event
    QPushButtonMac.paintEvent(self, event)
    
    s = self.size()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)

    pen = QtGui.QPen()
    pen.setStyle(QtCore.Qt.SolidLine)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)

    # draw check mark?
    if(self.checkMe and self.isChecked()):
      pen.setColor(QtGui.QColor(0, 0, 0, 255))
      pen.setWidth(scaledDPI(1.5))
      pen.setCapStyle(QtCore.Qt.RoundCap)
      qp.setPen(pen)
      qp.setBrush(QtCore.Qt.NoBrush)
      
      path = QtGui.QPainterPath()
      path.moveTo(self.padMe + scaledDPI(5), self.padMe + scaledDPI(5))
      path.lineTo(s.width() - scaledDPI(5), s.height() - scaledDPI(5))
      path.moveTo(self.padMe + scaledDPI(5), s.height() - scaledDPI(5))
      path.lineTo(s.width() - scaledDPI(5), self.padMe + scaledDPI(5))
      qp.drawPath(path)
    
    # overlay gradient
    qp.setPen(QtCore.Qt.NoPen)

    if(self.isChecked()):
      grad = QtGui.QLinearGradient(self.padMe, s.height(), self.padMe, self.padMe)
    else:
      grad = QtGui.QLinearGradient(self.padMe, self.padMe, self.padMe, s.height())
    grad.setColorAt(0, QtGui.QColor(255, 255, 255, 150))
    grad.setColorAt(0.2, QtGui.QColor(255, 255, 255, 0))
    grad.setColorAt(0.88, QtGui.QColor(180, 180, 180, 0))
    grad.setColorAt(1, QtGui.QColor(180, 180, 180, 120))
    qp.setBrush(QtGui.QBrush(grad))

    qp.drawRoundedRect(self.padMe, self.padMe, s.width(), s.height(), scaledDPI(2), scaledDPI(2))
    qp.end()

# custom QWidget to fix Qt layout bug on Mac :(
class QWidgetMac(QtWidgets.QWidget):
  def __init__(self, *args, **kwargs):
    super(QWidgetMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)

# custom QMenu for pass-through of Ctrl-key
class MuhMenu(QtWidgets.QMenu):
  def __init__(self, *args, **kwargs):
    super(MuhMenu, self).__init__(*args, **kwargs)

  def keyPressEvent(self, event):
    # pass through events with Ctrl modifier
    if(event.modifiers() & QtCore.Qt.ControlModifier):
      # somehow event pass-through not working
      # explicitly call keypressevent of main gui as pass through from QMenu fails for some reason
      myapp.keyPressEvent(event)
      event.ignore()
    else:
      # normal event processing
      QtWidgets.QMenu.keyPressEvent(self, event)

  # enable normal tab stops
  def focusNextPrevChild(self, next):
    return QtWidgets.QWidget.focusNextPrevChild(self, next)

# custom-styled QMenu
class KuhMenu(MuhMenu):
  def __init__(self, *args, **kwargs):
    super(KuhMenu, self).__init__(*args, **kwargs)
    self.borderRadius = scaledDPI(5)
    
  def paintEvent(self, event):
    # draw rounded corners
    s = self.size()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.drawRoundedRect(0, 0, s.width(), s.height(), self.borderRadius, self.borderRadius)
    qp.end()

# custom QStatusbar for colored error messages
class KuhStatusBar(QtWidgets.QStatusBar):
  def __init__(self, *args, **kwargs):
    super(KuhStatusBar, self).__init__(*args, **kwargs)
    self.timer = None
    
  def showMessage(self, message='', timer=10000, color='red'):
    # set color
    self.setStyleSheet('QStatusBar{color:' + color + ';font-weight:bold;}')
    QtWidgets.QStatusBar.showMessage(self, message, timer)
    # set up timer to revert style sheet change (probably not needed b/c all messages should appear in same color)
    if(self.timer == None):
      self.timer = QtCore.QTimer()
      self.timer.timeout.connect(self.myTimeOut)
      self.timer.setSingleShot(True)
      self.timer.start(timer)
    else:
      # if timer already exists, reset timer
      self.timer.start(timer)
    
  def myTimeOut(self):
    # resets time sheet
    self.setStyleSheet('QStatusBar{color:black;font-weight:normal;}')
    self.timer = None
        
# a delegate for custom display of float numbers
class FloatFormatDelegate(QtWidgets.QStyledItemDelegate):
  def __init__(self):
    super(FloatFormatDelegate, self).__init__()

  def displayText(self, value, locale):
    if(type(value) == float):
      return QtWidgets.QStyledItemDelegate.displayText(self, value, locale).replace(',', '.')
    else:
      return QtWidgets.QStyledItemDelegate.displayText(self, value, locale)

# subclass delegate to highlight certain cells
class FloatFormatDelegateColor(FloatFormatDelegate):
  def paint(self, painter, option, index):
    QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
    retv = index.data(QtCore.Qt.UserRole)
    if (retv):
      painter.save()
      if(retv == 1):
        # good rows
        brushColor = QtCore.Qt.green
      else:
        # bad rows
        brushColor = QtCore.Qt.red
      painter.setBrush(QtGui.QBrush(brushColor))
      painter.setOpacity(0.4)
      painter.setPen(QtCore.Qt.NoPen)
      r = QtCore.QRect(option.rect)
      painter.drawRect(r)
      painter.restore()

# custom table model for speeding up data loading (QTableView vs. QTableWidget)
class TableModel(QtCore.QAbstractTableModel):
  def __init__(self, data, parent=None):
    super(TableModel, self).__init__(parent)
    self.parent = parent
    if(hasattr(data, 'tolist')):
      # deal with numpy data
      self._data = data.tolist()
    else:
      self._data = data
    self.headers = [str(i + 1) for i in range(self.columnCount())]
    self.parent.setAlternatingRowColors(True)

  def rowCount(self, parent=None):
    return len(self._data)

  def columnCount(self, parent=None):
    return len(self._data[0]) if self.rowCount() else 0

  def data(self, index, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole:
      row = index.row()
      if 0 <= row < self.rowCount():
        column = index.column()
        if 0 <= column < self.columnCount():
          return self._data[row][column]
    elif(role == QtCore.Qt.TextAlignmentRole):
      row, column = index.row(), index.column()
      if(type(self._data[row][column]) in [float, int]):
        return QtCore.Qt.AlignRight
      else:
        return QtCore.Qt.AlignLeft
        
  def dataByIndices(self, row=0, column=0):
    if 0 <= row < self.rowCount():
      if 0 <= column < self.columnCount():
        return self._data[row][column]
        
  def headerData(self, section, orientation, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
      if(section<len(self.headers)):
        return self.headers[section]
      else:
        # needed for UI calls while table empty
        return ''
    return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)        

  def setAllHeaders(self, headerData):
    maxIndex = min(self.columnCount(), len(headerData))
    self.headers[:maxIndex] = headerData[:maxIndex]

  def setSingleHeader(self, index, label):
    if(index < self.columnCount()):
      self.headers[index] = label
      
  def getDataRows(self, indices):
    retv = [self._data[index] for index in indices]
    return retv

  def getDataColumn(self, index):
    retv = [self._data[i][index] for i in range(self.rowCount())]
    return retv

  def getHeaders(self):
    return self.headers

  def getAllData(self):
    return self._data
  
  def setData(self, value, row, column):
    if((0 <= row < self.rowCount()) and (0 <= column < self.columnCount())):
      self._data[row][column] = value

  def pasteDataBlock(self, data, offsetRow=0, offsetColumn=0):
    for row in data:
      if(offsetRow < self.rowCount()):
        rowItems = len(row)
        self._data[offsetRow][offsetColumn:offsetColumn + rowItems] = row
      offsetRow += 1

# subclass custom table model for highlighting cells
class DataTableModel(TableModel):
  def __init__(self, data, parent=None):
    super(DataTableModel, self).__init__(data, parent)
    # cellhighlighting
    self.goodRows, self.badRows = [], []
    self.selCols = []
    self.timer = None
    self.defaultTimeOut = 5000
    self.parent.setObjectName('data')
    
  def data(self, index, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole:
      row = index.row()
      if 0 <= row < self.rowCount():
        column = index.column()
        if 0 <= column < self.columnCount():
          return self._data[row][column]
    elif(role == QtCore.Qt.UserRole):
      if(index.column() in self.selCols):
        if(index.row() in self.goodRows):
          return 1
        elif(index.row() in self.badRows):
          return 2
      return 0
    elif(role == QtCore.Qt.TextAlignmentRole):
      row, column = index.row(), index.column()
      if(type(self._data[row][column]) in [float, int]):
        return QtCore.Qt.AlignRight
      else:
        return QtCore.Qt.AlignLeft
    
  def setGoodBad(self, goodRows=[], badRows=[], selCols=[]):
    # updates good and bad rows
    self.goodRows, self.badRows, self.selCols = goodRows, badRows, selCols

    # set up timer to revert style sheet change (probably not needed b/c all messages should appear in same color)
    if(self.timer == None):
      self.timer = QtCore.QTimer()
      self.timer.timeout.connect(self.myTimeOut)
      self.timer.setSingleShot(True)
      self.timer.start(self.defaultTimeOut)
    else:
      # if timer already exists, reset timer
      self.timer.start(self.defaultTimeOut)
      
    # trigger update
    self.layoutChanged.emit()
    self.parent.setFocus()
    
  def myTimeOut(self):
    # resets coloring of cells
    self.goodRows, self.badRows, self.selCols = [], [], []
    self.timer = None
    # trigger update
    self.layoutChanged.emit()

# custom legend class
class MyLegend(Legend.Legend):
  def __init__(self, *args, **kwargs):
    super(MyLegend, self).__init__(*args, **kwargs)
    self.shadowDeltaX, self.shadowDeltaY = 2, -2
    self.shadowFaceColor = [0.5, 0.8, 0.9, 1.0]
    self.legendHatch, self.legendHatchMultiply = '', 1
    self.legendEdgeFallbackColor = [0.5, 0.5, 0.5, 1.0]
    self.legendRounding = 0.2
    # ensure that _drawFrame is initialized
    self._drawFrame = True
    
  def additionalConfig(self, shadowDeltaX=None, shadowDeltaY=None, shadowFaceColor=None, legendHatch=None, legendHatchMultiply=None, legendEdgeFallbackColor=None, legendRounding=None):
    # allows to set parameters for drop shadow
    if(shadowDeltaX != None):
      self.shadowDeltaX = shadowDeltaX
    if(shadowDeltaY != None):
      self.shadowDeltaY = shadowDeltaY
    if(shadowFaceColor != None):
      self.shadowFaceColor = shadowFaceColor
    if(legendHatch != None):
      self.legendHatch = legendHatch
    if(legendHatchMultiply != None):
      self.legendHatchMultiply = legendHatchMultiply
    if(legendEdgeFallbackColor != None):
      self.legendEdgeFallbackColor = legendEdgeFallbackColor
    if(legendRounding != None):
      self.legendRounding = legendRounding

  def draw(self, renderer):
    # the following is copied from matplotlib/legend.py and modified to allow customization of shadow patch
    "Draw everything that belongs to the legend."
    if not self.get_visible():
      return

    renderer.open_group('legend')
    fontsize = renderer.points_to_pixels(self._fontsize)

    # if mode == fill, set the width of the legend_box to the
    # width of the parent (minus pads)
    if self._mode in ["expand"]:
      pad = 2 * (self.borderaxespad + self.borderpad) * fontsize
      self._legend_box.set_width(self.get_bbox_to_anchor().width - pad)

    # update the location and size of the legend. This needs to
    # be done in any case to clip the figure right.
    bbox = self._legend_box.get_window_extent(renderer)
    self.legendPatch.set_bounds(bbox.x0, bbox.y0,
                                bbox.width, bbox.height)
    self.legendPatch.set_mutation_scale(fontsize)

    if self._drawFrame:
      # this bit is modified
      useHatch = self.legendHatch * self.legendHatchMultiply
      self.legendPatch.set_hatch(useHatch)
      if(np.isclose(sum(self.legendPatch.get_edgecolor()), 0.0)):
        # hatching is linked to edge color which is set to 0 when no edge
        # => need to trick legend here which is not a problem since we constantly generate new legend objects
        self.legendPatch.set_edgecolor(self.legendEdgeFallbackColor)
        self.legendPatch.set_linewidth(0)
      self.legendPatch.set_boxstyle("round", pad=0, rounding_size=self.legendRounding)
      # up to here
      
      if self.shadow:
        # this bit is modified
        shadow = matplotlib.patches.Shadow(self.legendPatch, self.shadowDeltaX, self.shadowDeltaY)
        shadow.set_facecolor(self.shadowFaceColor)
        if(len(self.shadowFaceColor) > 3):
          shadow.set_alpha(self.shadowFaceColor[3])
        # set edge color of shadow equal to facecolor
        shadow.set_edgecolor(self.shadowFaceColor)
        # until here
        shadow.draw(renderer)

      self.legendPatch.draw(renderer)

    self._legend_box.draw(renderer)

    renderer.close_group('legend')
    self.stale = False
   
# a custom cursor
class MyCursor(matplotlib.widgets.Cursor):
  def __init__(self, *args, **kwargs):
    super(MyCursor, self).__init__(*args, **kwargs)
    self.label = self.ax.text(1, 1, '', animated=True)
    self.label.set_fontsize(scaledDPI(11))
    # does not heed clip_on, mayhpas due to blitting
    self.label.set_clip_on(False)
    # need to store background for initial creation of cursor
    self.background = self.canvas.copy_from_bbox(self.ax.bbox)
    # initialize parent and ax2
    self.parent = None
    self.ax2 = None
    # initialize twin and slave
    self.twin = None
    self.twinVertical = None
    
  def setParent(self, parent=None):
    self.parent = parent
    
  def setAx2(self, ax2=None):
    self.ax2 = ax2

  def setTwin(self, twin=None):
    self.twin = twin

  def setTwinVertical(self, twinVertical=None):
    self.twinVertical = twinVertical

  def onmove(self, event):
    """on mouse motion draw the cursor if visible"""
    if self.ignore(event):
      return
    if not self.canvas.widgetlock.available(self):
      return
    if event.inaxes != self.ax:
      self.linev.set_visible(False)
      self.lineh.set_visible(False)
      self.label.set_visible(False)

      if self.needclear:
        self.canvas.draw()
        self.needclear = False
      return
    self.needclear = True
    if not self.visible:
      return
    
    self.refreshCrossHair(event)
    # check whether we are on canvas
    if ((event.xdata != None) and (event.ydata != None)):
      self._update()
      if(self.twin != None):
        self.twin._update()
      if(self.twinVertical != None):
        self.twinVertical._update()

  def refreshCrossHair(self, event):
    # update cross hair
    self.linev.set_xdata((event.xdata, event.xdata))
    self.lineh.set_ydata((event.ydata, event.ydata))
    self.linev.set_visible(self.visible and self.vertOn)
    self.lineh.set_visible(self.visible and self.horizOn)
    # update label size
    if(self.parent != None):
      currZoomLevel = self.parent.matplot.get_dpi()
      self.linev.set_linewidth(1.0 * 100.0 / currZoomLevel)
      self.lineh.set_linewidth(1.0 * 100.0 / currZoomLevel)
    # update label size
    if(self.parent != None):
      currZoomLevel = self.parent.matplot.get_dpi()
      self.label.set_fontsize(scaledDPI(11) * 100.0 / currZoomLevel)
    # check whether we are on canvas
    if ((event.xdata != None) and (event.ydata != None)):
      labelText = ' x: ' + self.formatNumber(event.xdata) + ' \n y: ' + self.formatNumber(event.ydata) + ' '
      if((self.parent != None) and (self.parent.isSecondAxesActive()) and (not self.parent.splitY)):
        secondX, secondY = self.parent.ax2.transData.inverted().transform((event.x, event.y))
        labelText += '\n y2: ' + self.formatNumber(secondY) + ' '
      self.label.set_text(labelText)
    # update color
    color = 'black'
    if(self.ax2 != None):
      canvasColor = self.ax2.patch.get_facecolor()
      # we need this check to deal with canvas having 'none' facecolor
      if(np.isclose(sum(canvasColor), 0.0)):
        figureColor = self.parent.matplot.get_facecolor()
        if(np.isclose(sum(figureColor), 0.0)):
          color = 'black'
        elif(sum(figureColor[0:3]) < 1.5):
          color = 'white'
      elif(sum(canvasColor[0:3]) < 1.5):
        color = 'white'
    self.label.set_color(color)
    self.lineh.set_color(color)
    self.linev.set_color(color)
    # check quadrant of plot
    if(event.x > ((self.ax.bbox.xmin + self.ax.bbox.xmax) / 2.0)):
      self.label.set_horizontalalignment('right')
    else:
      self.label.set_horizontalalignment('left')
    if(event.y > ((self.ax.bbox.ymin + self.ax.bbox.ymax) / 2.0)):
      self.label.set_verticalalignment('top')
    else:
      self.label.set_verticalalignment('bottom')
    # update label position
    self.label.set_x(event.xdata)
    self.label.set_y(event.ydata)
    self.label.set_visible(self.visible)
    # check twin
    if(self.twin != None):
      self.twin.lineh.set_visible(self.visible and self.twin.horizOn)
      self.twin.lineh.set_ydata((event.ydata, event.ydata))
      self.twin.lineh.set_color(color)
    # check twin vertical
    if(self.twinVertical != None):
      self.twinVertical.linev.set_visible(self.visible and self.twinVertical.vertOn)
      self.twinVertical.linev.set_xdata((event.xdata, event.xdata))
      self.twinVertical.linev.set_color(color)

  def getHandles(self):
    # returns handles to graphics elements
    handles = [self.linev, self.lineh, self.label]
    return handles

  def _update(self):
    if self.useblit:
      if self.background is not None:
        self.canvas.restore_region(self.background)
      # check whether axis object is visible (required for split x axis)
      if(self.ax.get_visible()):
        self.ax.draw_artist(self.linev)
        self.ax.draw_artist(self.lineh)
        self.ax.draw_artist(self.label)
        self.canvas.blit(self.ax.bbox)
    else:
      self.canvas.draw_idle()

    return False

  def toggleVisibility(self, state=False, event=None):
    self.visible = state
    if(event != None):
      if(self.visible):
        self.refreshCrossHair(event)
        # cross hair was toggled on split axis -- should not display the cross hairs
        if(event.inaxes != self.ax):
          self.linev.set_visible(False)
          self.lineh.set_visible(False)
          self.label.set_visible(False)
      else:
        self.linev.set_visible(self.visible and self.vertOn)
        self.lineh.set_visible(self.visible and self.horizOn)
        self.label.set_visible(self.visible)
      # check whether we are on canvas
      if ((event.xdata != None) and (event.ydata != None)):
        self._update()
        if(self.twin != None):
          self.twin._update()
        if((self.twinVertical != None) and self.parent.splitY):
          self.twinVertical._update()

  def formatNumber(self, number):
    # formats number for output
    precision = 2
    NUMBER_SWITCH = 10 ** (precision + 1)
    FORMAT_DECIMAL = '{:.' + str(precision + 1) + 'f}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
        # do this in mathtext
        # calculate exponent
        if(number != 0.0):
          try:
            exponent = int(np.floor(np.log10(np.abs(number))))
          except:
            exponent = 0
          # calculate preexponent
          try:
            pre = number / (10 ** exponent)
          except:
            pre, exponent = number, 0
        # assemble string
        if(number == 0.0):
          retstr = '{:.' + str(precision) + 'f}'
          retstr = retstr.format(0.0)
          numberstr = '$\\mathdefault{' + retstr + '}$' 
        elif(np.isclose(pre, 1.0)):
          numberstr = '$\\mathdefault{10^{' + str(exponent) + '}}$'
        elif(np.isclose(pre, -1.0)):
          numberstr = '$\\mathdefault{-10^{' + str(exponent) + '}}$'
        else:
          retstr = '{:.' + str(precision) + 'f}'
          retstr = retstr.format(pre)
          # cannot use \times here b/c of xkcd font which lacks the symbol
          numberstr = '$\\mathdefault{' + retstr + '\ x\ 10^{' + str(exponent) + '}}$'         
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

# validators that take care of commata once and for all
class MyValidInt(QtGui.QIntValidator):
  def __init__(self, *args, **kwargs):
    super(MyValidInt, self).__init__(*args, **kwargs)
    
  def validate(self, s, pos):
    if(',' in s):
      # plainly ignores commata
      s = s.replace(',', '')
      # correct pos for the character we deleted
      if(pos):
        pos -= 1
      
    # call the regular validator
    return QtGui.QIntValidator.validate(self, s, pos)

class MyValidFloat(QtGui.QDoubleValidator):
  def __init__(self, *args, **kwargs):
    super(MyValidFloat, self).__init__(*args, **kwargs)

  def validate(self, s, pos):
    if(',' in s):
      # plainly ignores commata
      s = s.replace(',', '.')
      
    # call the regular validator
    return QtGui.QDoubleValidator.validate(self, s, pos)

# a QSpinBox that finally behaves as I want
class QSpinClick(QtWidgets.QSpinBox):
  def __init__(self, argument=None):
    super(QSpinClick, self).__init__(argument)
    self._gainedFocus = False
    self._originalMousePressEvent = QtWidgets.QSpinBox.mousePressEvent
    self._originalFocusInEvent = QtWidgets.QSpinBox.focusInEvent
    self.setAlignment(QtCore.Qt.AlignRight)
    self.installEventFilter(self)
    self.setAccelerated(True)
    # implement your own adaptive increment as this only becomes standard in later PyQt versions
    self.adaptive = True
    # set up event filter
    self.thisLineEdit = self.lineEdit()
    self.thisLineEdit.installEventFilter(self)
    
  def setAdaptive(self, value=True):
    # toggles on/off adaptive size adjustment of increments
    self.adaptive = value

  def eventFilter(self, source, event):
    # filter events of child widget
    if(source == self.thisLineEdit):
      # hijack mouse button press on line edit
      if(event.type() == QtCore.QEvent.MouseButtonPress):
        try:
          # this call throws error under older Python versions due to accessing protected member
          self.thisLineEdit.mousePressEvent(event)
        except:
          self.thisLineEdit.deselect()
        if(self._gainedFocus):
          self.selectAll()
          self._gainedFocus = False
        return True

    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    
    # determine how we got focus (0 is via mouse action)
    if(event.reason() == 0):
      self._gainedFocus = True
      
  # reimplement stepBy() to fire event upon activation of arrow buttons
  def stepBy(self, step):
    # adjust increment if needed
    if(self.adaptive):
      increment = self.singleStep()
      value = self.value()
      # don't change anything if value is zero
      if(value):
        if(step > 0):
          increment = 10 ** np.floor(np.log10(np.abs(value) / 2.0))
          if(increment * 14 <= np.abs(value)):
            increment *= 2
          elif(increment * 3.0 > np.abs(value)):
            increment /= 2
        else:
          increment = 10 ** (np.ceil(np.log10(np.abs(value) / 2.00001)) - 1.0)
          if(increment * 14 < np.abs(value)):
            increment *= 2
          elif(increment * 3.0 >= np.abs(value)):
            increment /= 2
      increment = max(increment, 1)
      increment = int(increment)
      self.setSingleStep(increment)
    # normal event first
    QtWidgets.QSpinBox.stepBy(self, step)
    # then fire editing finished event
    self.editingFinished.emit()

# a QSpinBox that finally behaves as I want
class QDoubleSpinClick(QtWidgets.QDoubleSpinBox):
  def __init__(self, argument=None):
    super(QDoubleSpinClick, self).__init__(argument)
    self._gainedFocus = False
    self._originalMousePressEvent = QtWidgets.QDoubleSpinBox.mousePressEvent
    self._originalFocusInEvent = QtWidgets.QDoubleSpinBox.focusInEvent
    self.setAlignment(QtCore.Qt.AlignRight)
    self.installEventFilter(self)
    self.setDecimals(2)
    self.setAccelerated(True)
    # implement your own adaptive increment as this only becomes standard in later PyQt versions
    self.adaptive = True
    # set up event filter
    self.thisLineEdit = self.lineEdit()
    self.thisLineEdit.installEventFilter(self)
    
  def setAdaptive(self, value=True):
    # toggles on/off adaptive size adjustment of increments
    self.adaptive = value

  def eventFilter(self, source, event):
    # filter events of child widget
    if(source == self.thisLineEdit):
      # hijack mouse button press on line edit
      if(event.type() == QtCore.QEvent.MouseButtonPress):
        try:
          # this call throws error under older Python versions due to accessing protected member
          self.thisLineEdit.mousePressEvent(event)
        except:
          self.thisLineEdit.deselect()
        if(self._gainedFocus):
          self.selectAll()
          self._gainedFocus = False
        return True

    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    
    # determine how we got focus (0 is via mouse action)
    if(event.reason() == 0):
      self._gainedFocus = True

  # reimplement stepBy() to fire event upon activation of arrow buttons
  def stepBy(self, step):
    # adjust increment if needed
    if(self.adaptive):
      increment = self.singleStep()
      value = self.value()
      # don't change anything if value is zero
      if(value):
        if(step > 0):
          increment = 10 ** np.floor(np.log10(np.abs(value) / 2.0))
          if(increment * 14 <= np.abs(value)):
            increment *= 2
          elif(increment * 3.0 > np.abs(value)):
            increment /= 2
        else:
          increment = 10 ** (np.ceil(np.log10(np.abs(value) / 2.00001)) - 1.0)
          if(increment * 14 < np.abs(value)):
            increment *= 2
          elif(increment * 3.0 >= np.abs(value)):
            increment /= 2
      increment = max(increment, 0.1)
      self.setSingleStep(increment)
    # normal event first
    QtWidgets.QDoubleSpinBox.stepBy(self, step)
    # then fire editing finished event
    self.editingFinished.emit()

# a QLineEdit that finally behaves as I want
class QLineEditClick(QtWidgets.QLineEdit):
  def __init__(self, argument=None):
    super(QLineEditClick, self).__init__(argument)
    self._gainedFocus = False
    self._originalMousePressEvent = QtWidgets.QLineEdit.mousePressEvent
    self._originalFocusInEvent = QtWidgets.QLineEdit.focusInEvent
    self.setAlignment(QtCore.Qt.AlignRight)
    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    self.selectAll()
    
    # determine how we got focus (0 is via mouse action)
    if(event.reason() == 0):
      self._gainedFocus = True
      
  def setText(self, text):
    # ensure that long entries are scrolled to beginning
    QtWidgets.QLineEdit.setText(self, text)
    self.setCursorPosition(0)
    
  def focusOutEvent(self, event):
    # ensure that long entries are scrolled to beginning
    QtWidgets.QLineEdit.focusOutEvent(self, event)
    self.setCursorPosition(0)

  def mousePressEvent(self, event):
    self._originalMousePressEvent(self, event)
    if(self._gainedFocus):
      self.selectAll()
      self._gainedFocus = False

# menu for transforming columns in the data table
class TransformerMenu(MuhMenu):
  def __init__(self, parent=None, col=1, formula=''):
    super(TransformerMenu, self).__init__()
    self.parent = parent
    self.col = col
    self.formula = formula
      
    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      MuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[2]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.exportSettingLabel = QtWidgets.QLabel('Transform column')
    useFont = self.exportSettingLabel.font()
    useFont.setBold(True)
    self.exportSettingLabel.setFont(useFont)
    self.vLayout.addWidget(self.exportSettingLabel)
    
    # formula entry
    self.transformGroup = QtWidgets.QWidget()
    self.vLayout.addWidget(self.transformGroup)
    
    self.transformLayout = QtWidgets.QHBoxLayout(self.transformGroup)
    self.transformLayout.setContentsMargins(*[2]*4)
    self.transformLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.transformLabel = QtWidgets.QLabel('C' + str(self.col + 1) + ' = ')
    self.transformLabel.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.transformLabel.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.transformLayout.addWidget(self.transformLabel)

    self.transformEntry = QLineEditClick()
    self.transformEntry.setToolTip('Formula for column transformation.\nUse C1, C2, .. to denote 1st, 2nd, .. column in the data sheet.\nUse ROW to denote row index.')
    self.transformEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.transformEntry.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    if(self.formula == ''):
      self.transformEntry.setText('C' + str(self.col + 1) + ' + ROW')
    else:
      self.transformEntry.setText(self.formula)
    self.transformLayout.addWidget(self.transformEntry)
    
    # button
    self.transformButton = QPushButtonMac()
    self.transformButton.setText('Transform!')
    self.transformButton.setToolTip('Perform column transformation\n(previous cell contents will be overwritten)')
    self.transformButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.transformButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.transformButton.clicked.connect(self.doTransform)
    self.vLayout.addWidget(self.transformButton)

    self.setFocus()    
    self.focusNextChild()

  def doTransform(self):
    # starts transformation in parent object
    formula = self.transformEntry.text()
    self.parent.doTransformer(self.col, formula)
    self.close()

# the data table widget
class DataTable(QtWidgets.QTableView):
  def __init__(self, parent=None):
    super(DataTable, self).__init__(parent)
    self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.parent = parent
    self.tableModel = None
    self.currentRow, self.currentCol = 0, 0
    self.pageStep = 20
    self.minColWidth = scaledDPI(35)
    self.storeFontMetrics = False

    # set up and connect table header
    hheader = self.horizontalHeader()
    self.storedToolTip = '- Click left to assign role of column\n- Click right to sort table by column values\n- Ctrl key and click left to transform column'
    hheader.setToolTip(self.storedToolTip)
    hheader.sectionClicked.connect(self.changeRole)
    hheader.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    hheader.customContextMenuRequested.connect(self.sortitsch)

    btn = self.findChild(QtWidgets.QAbstractButton)
    self.storedCornerTip = 'Click to select entire table'
    btn.setToolTip(self.storedCornerTip)

    # set delegate
    self.setItemDelegate(FloatFormatDelegateColor())

    # set up namespace
    # import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()
    self.storeFormula = ''

  def toggleToolTips(self, state=True):
    # dynamically sets and unsets tool tips
    hheader = self.horizontalHeader()
    btn = self.findChild(QtWidgets.QAbstractButton)
    if(state):
      hheader.setToolTip(self.storedToolTip)
      btn.setToolTip(self.storedCornerTip)
    else:
      hheader.setToolTip('')
      btn.setToolTip('')

  def mySizeHintForColumn(self, index):
    # custom size hint for column sizing to eke out some speed
    # INIT_SEARCH ensures that initially visible cells are used
    INIT_SEARCH, MAX_SEARCH, SPACER = 20, 50, 10
    # for size calculation, truncate float numbers after 6 significant places
    PRECISION_STRING = '%.6g'
    if(not self.storeFontMetrics):
      self.storeFontMetrics = self.fontMetrics()
    
    # analyze column contents
    data = self.tableModel.getDataColumn(index)
    if(len(data) < MAX_SEARCH):
      # search through entire table
      sizes = [self.storeFontMetrics.width(PRECISION_STRING % i) if type(i) == type(2.3) else self.storeFontMetrics.width(str(i)) for i in data]
      return max(sizes) + SPACER
    else:
      # search through MAX_SEARCH randomly chosen cells
      sizes = data[:INIT_SEARCH] + np.random.choice(data[INIT_SEARCH:], size=MAX_SEARCH - INIT_SEARCH, replace=False).tolist()
      maxelement = max(sizes, key = lambda i: len(PRECISION_STRING % i) if type(i) == type(2.3) else len(str(i)))
      if(type(maxelement) == type(2.3)):
        maxelement = PRECISION_STRING % maxelement
      return self.storeFontMetrics.width(str(maxelement)) + SPACER

  def readjustSize(self):
    # fudge function to prevent PyQt5 from uncontrollably resizing row height
    vheader = self.verticalHeader()
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    vheader.setDefaultSectionSize(self.rowHeight)
    
  def configTable(self, dimx, dimy, retainRoles=False, retainSelection=False, init=False):
    # helper function called by different file importers
    # set row height and prevent from resizing
    self.rowHeight = int(self.fontMetrics().height() + scaledDPI(2))
    if(init):
      self.rowHeight = scaledDPI(18)
    vheader = self.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    for entry in range(dimy):
      vheader.setSectionResizeMode(entry, QtWidgets.QHeaderView.Fixed)
      
    # set col width
    self.colWidth = int(self.size().width() / 4.5)
    self.colWidth = min(scaledDPI(120), self.colWidth)
    hheader = self.horizontalHeader()
    if(not init):
      maxSize = int(0.8 * self.size().width())
      # limit resizing to first 15 columns as it becomes mortally slow otherwise
      maxDimX = min(dimx, 15)
      for entry in range(maxDimX):
        hheader.setSectionResizeMode(entry, QtWidgets.QHeaderView.Interactive)
        useSize = max(self.mySizeHintForColumn(entry) + scaledDPI(2), self.minColWidth)
        # restrict column size to max. 80% of visible area (to allow easy resizing)
        useSize = min(useSize, maxSize)
        hheader.resizeSection(entry, useSize)
    
    # set selection mode
    self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    
    # select all
    if(not retainSelection):
      self.selectAll()
    
    # connect event for selection update
    self.selectionModel().selectionChanged.connect(partial(self.parent.updateData, True))
    self.selectionModel().currentChanged.connect(self.currentCellChanged)
    
    # assign roles to columns (-1 means role is undefined)
    if(retainRoles):
      for item in ['x', 'y', 'xerr', 'yerr', 'labels']:
        if(item in self.roles):
          # check whether target column is available
          if(self.roles[item] >= dimx):
            self.roles[item] = -1
        else:
          self.roles[item] = -1
    else:
      self.roles = {'x': -1, 'y': -1, 'xerr': -1, 'yerr': -1, 'labels': -1}
      if (dimx):
        self.roles['x'] = 0
        if (dimx == 2):
          self.roles['y'] = 1
        elif(dimx >= 3):
          self.roles['y'] = 1
    self.rolestr = {'x':'x', 'y':'y', 'xerr':u'\N{GREEK CAPITAL LETTER DELTA}x', 'yerr':u'\N{GREEK CAPITAL LETTER DELTA}y', 'labels':'labels'}
    # asisgn numbered column headers
    headerData = [str(i + 1) for i in range(dimx)]
    # update headers for roles
    for key in self.roles:
      if(self.roles[key] + 1):
        headerData[self.roles[key]] = str(self.roles[key] + 1) + ' (' + self.rolestr[key] + ')'
    self.tableModel.setAllHeaders(headerData)
    self.setModel(self.tableModel)
    self.setFocus()

  def killTheComma(self):
    # processes sheet data and replaces all commata by period
    if(len(self.sheetData)):
      dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
      nuData = []
      for row in self.sheetData:
        nuData.append([self.killHelper(i) for i in row])
        
      self.sheetData = nuData
      self.tableModel = DataTableModel(self.sheetData, self)
      self.configTable(dimx, dimy, retainRoles=True, retainSelection=False)
      self.selectAll()

      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      self.tableModel.layoutChanged.emit()
      
      # for some strange reason we have to connect the event again, grrrr! (should've been done in self.configTable())
      self.selectionModel().currentChanged.connect(self.currentCellChanged)
      
  def killHelper(self, item):
    if(type(item) in [int, float]):
      return item
    elif((type(item) == str) and (',' in item)):
      convItem = item.replace(',', '.')
      try:
        convItem = float(convItem)
        return convItem
      except:
        return item
    else:
      return item

  def generateEmptyTable(self, columnCount=4, rowCount=20):
    # intializes blank table
    blankData = [[''] * columnCount for i in range(rowCount)]
    self.sheetData = blankData
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)
    self.configTable(columnCount, rowCount, init=True)

    self.clearSelection()
    if(rowCount):
      self.selectRow(0)
    nuIndex = self.model().index(self.currentRow, self.currentCol)
    self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    self.tableModel.layoutChanged.emit()

  def resizeTable(self, columnCount=4, rowCount=20):
    # grows/shrinks data table as needed
    if(self.tableModel != None):
      currData = self.tableModel.getAllData()
      
      # prepare new data, initialize empty
      nuData = [[''] * columnCount for i in range(rowCount)]
      cycleRow = min(len(currData), rowCount)
      if(len(currData)):
        cycleColumn = min(len(currData[0]), columnCount)
        
        for row in range(cycleRow):
          nuData[row][:cycleColumn] = currData[row][:cycleColumn]
      
        self.tableModel = DataTableModel(nuData, self)
        self.setModel(self.tableModel)
        
        # configure table
        self.configTable(columnCount, rowCount, retainRoles=True)

  def getDimension(self):
    return self.tableModel.rowCount(), self.tableModel.columnCount()

  def restoreTable(self, tableData=[]):
    # used by loadState fxn
    if(len(tableData)):
      self.currentRow, self.currentCol = 0, 0
      self.sheetData = tableData
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
      
      dimx, dimy = len(tableData[0]), len(tableData)
      self.configTable(dimx, dimy)
      
      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      self.tableModel.layoutChanged.emit()    

  def loadXLS(self, filename, transpose=False):
    # open XLS sheet
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    # first figure out whether this is a classic xls or a xml-based xlsx file
    splitName = filename.split('.')
    continueFlag, self.xlsxFlag = False, False
    if((len(splitName) > 1) and (splitName[1].lower() == 'xlsx')):
      # use openpyxl
      if(not OPENPYXL_PRESENT):
        # can try to use good old xlrd for people whose Python version still supports it
        try:
          self.wb = xlrd.open_workbook(filename)
        except:
          self.parent.parent.statusbar.showMessage('Try installing openpyxl module to load data file ' + filename, self.parent.parent.STATUS_TIME)
        else:
          self.sheetNames = self.wb.sheet_names()
          continueFlag = True
      else:
        self.xlsxFlag = True
        try:
          self.wb = openpyxl.load_workbook(filename, data_only=True)
        except:
          self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
        else:
          self.sheetNames = self.wb.sheetnames
          continueFlag = True
    else:
      try:
        self.wb = xlrd.open_workbook(filename)
      except:
        self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
      else:
        self.sheetNames = self.wb.sheet_names()
        continueFlag = True
      
    if(continueFlag):
      # update number of available sheets and current sheet
      self.parent.resetSheetSpinBox(currVal=1, maxVal=len(self.sheetNames), currName=self.sheetNames[0])
      
      # initally assume data is on first sheet
      self.sheetData = []
      if(self.xlsxFlag):
        self.sheet = self.wb.worksheets[0]
        (dimx, dimy) = (self.sheet.max_column, self.sheet.max_row)

        # populate the table
        for rowRead in self.sheet.values:
          row = [i if (i != None) else '' for i in rowRead]
          self.sheetData.append(row)
      else:
        self.sheet = self.wb.sheet_by_index(0)
        (dimx, dimy) = (self.sheet.ncols, self.sheet.nrows)
      
        # populate the table
        for entry in range(dimy):
          row = self.sheet.row_values(entry)
          self.sheetData.append(row)
        
      # transpose data?
      if((transpose) and (len(self.sheetData))):
        transposedData = []
        for entry1 in range(len(self.sheetData[0])):
          row = []
          for entry2 in range(len(self.sheetData)):
            row.append(self.sheetData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = dimy, dimx
      
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
      
      # configure table
      self.configTable(dimx, dimy)

    QtWidgets.QApplication.restoreOverrideCursor()
  
  def changeSheet(self, currVal=1, transpose=False):
    # update number of available sheets and current sheet
    self.parent.resetSheetSpinBox(currVal=currVal, maxVal=len(self.sheetNames), currName=self.sheetNames[currVal - 1])

    # changes sheet in multi-sheet Excel file
    self.sheetData = []
    if(self.xlsxFlag):
      self.sheet = self.wb.worksheets[currVal - 1]
      (dimx, dimy) = (self.sheet.max_column, self.sheet.max_row)

      # populate the table
      for rowRead in self.sheet.values:
        row = [i if (i != None) else '' for i in rowRead]
        self.sheetData.append(row)
    else:
      self.sheet = self.wb.sheet_by_index(currVal - 1)
      (dimx, dimy) = (self.sheet.ncols, self.sheet.nrows)
      
      # populate the table
      for entry in range(dimy):
        row = self.sheet.row_values(entry)
        self.sheetData.append(row)
    
    # transpose data?
    if((transpose) and (len(self.sheetData))):
      transposedData = []
      for entry1 in range(len(self.sheetData[0])):
        row = []
        for entry2 in range(len(self.sheetData)):
          row.append(self.sheetData[entry2][entry1])
        transposedData.append(row)
      self.sheetData = transposedData
      dimx, dimy = dimy, dimx
      
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)

    # configure table
    self.configTable(dimx, dimy, retainRoles=True)

  def transposeTable(self):
    # takes current data table and transposes contents
    if(self.tableModel != None):
      currData = self.tableModel.getAllData()
      
      # transpose data
      if(len(currData)):
        transposedData = []
        for entry1 in range(len(currData[0])):
          row = []
          for entry2 in range(len(currData)):
            row.append(currData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
        
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
  
      # configure table
      self.configTable(dimx, dimy, retainRoles=True)

  def loadUnicornFile(self, filename, transpose=False):
    # opens a Unicorn file
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    try:
      filecontent = pc_res3(filename)
      filecontent.load()
    except:
      self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
    else:
      tempSheetData = []
      dimx, dimy = 0, 0
      for entry in ['UV', 'Cond', 'pH', 'Pressure', 'Temp', 'Conc']:
        if((entry in filecontent) and ('data' in filecontent[entry])):
          if(len(filecontent[entry]['data'])):
            if(len(tempSheetData)):
              # write header
              tempSheetData[0].extend([''] * (len(filecontent[entry]['data'][0]) + 1))
              tempSheetData[0][-len(filecontent[entry]['data'][0])] = entry
              # write data
              curry = len(filecontent[entry]['data'])
              # is new entry larger?
              if(curry > dimy):
                for tilt in range(curry - dimy):
                  tempSheetData.append([''] * dimx)
                dimy = curry
              # now append new columns
              for row in range(dimy - 1):
                if(row < curry):
                  tempSheetData[row + 1].extend([''] + list(filecontent[entry]['data'][row]))
                else:
                  tempSheetData[row + 1].extend([''] * (len(filecontent[entry]['data'][0]) + 1))
              # adjust dimensions
              dimx += 1 + len(filecontent[entry]['data'][0])
            else:
              # write header
              tempSheetData = [[''] * len(filecontent[entry]['data'][0])]
              tempSheetData[0][0] = entry
              # write data
              tempSheetData.extend([list(i) for i in filecontent[entry]['data']])
              dimx, dimy = len(filecontent[entry]['data'][0]), len(filecontent[entry]['data']) + 1

      # did we find any data to import?
      if(len(tempSheetData)):
        self.sheetData = tempSheetData
  
        # transpose data?
        if((transpose) and (len(self.sheetData))):
          transposedData = []
          for entry1 in range(len(self.sheetData[0])):
            row = []
            for entry2 in range(len(self.sheetData)):
              row.append(self.sheetData[entry2][entry1])
            transposedData.append(row)
          self.sheetData = transposedData
          dimx, dimy = dimy, dimx
  
        self.tableModel = DataTableModel(self.sheetData, self)
        self.setModel(self.tableModel)
  
        # configure table
        self.configTable(dimx, dimy)            

    QtWidgets.QApplication.restoreOverrideCursor()

  def loadTextFile(self, filename, delimiter='\t', transpose=False):
    # open a text file
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    try:
      try:
        # try opening text file, first w/ UTF-16 (use the exception to discriminate)
        readhandle = open(filename, 'r', encoding='utf-16')
        filecontent = readhandle.readlines()
      except:
        # only if this fails, use regular UTF-8 but ignore any errors
        readhandle = open(filename, 'r', encoding='utf-8', errors='ignore')
        filecontent = readhandle.readlines()
    except:
      self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
    else:
      readhandle.close()
      
      # determine row and col count
      filecontent = [i.rstrip() for i in filecontent]
      dimy = len(filecontent)
      #dimx = max([i.count(delimiter) for i in filecontent]) + 1
      dimx = max([len(i.split(delimiter)) for i in filecontent])

      # turn off multiple sheet option
      self.parent.resetSheetSpinBox(currVal=1, maxVal=1, currName='')
      
      # populate the table
      maxNumberItems = 0
      self.sheetData = []
      for row in filecontent:
        splitline = row.split(delimiter)
        splitline = [float(i) if self.isNumber(i) else i for i in splitline]
        self.sheetData.append(splitline)
        maxNumberItems = np.max((maxNumberItems, len(splitline)))
      
      # fill sheetData with empty cells to make square (otherwise will have problems in TableModel)
      for entry in self.sheetData:
        while(len(entry) < maxNumberItems):
          entry.append('')

      # transpose data?
      if((transpose) and (len(self.sheetData))):
        transposedData = []
        for entry1 in range(len(self.sheetData[0])):
          row = []
          for entry2 in range(len(self.sheetData)):
            row.append(self.sheetData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = dimy, dimx

      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)

      # configure table
      self.configTable(dimx, dimy)

    QtWidgets.QApplication.restoreOverrideCursor()

  def sortitsch(self, position):
    # allows sorting by column
    col = self.horizontalHeader().logicalIndexAt(position)
    
    # open context menu
    self.menu = MuhMenu(self)
    self.menu.setTitle('Sort by column ' + str(col + 1))
    
    for index, entry in enumerate(['sort ascending', 'sort descending']):
      action = QtWidgets.QAction(entry, self)
      action.triggered.connect(partial(self.sortitschHelper, col, index==1))
      self.menu.addAction(action)
      
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
      
    # display menu at current column
    menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
    menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
    self.menu.popup(menuPos)

  def sortitschHelper(self, col, mode):
    # helper function for sort routine
    def mixedSort(col, alist, blist):
      # first analyze types
      a, b = alist[col], blist[col]
      #a, b = alist, blist
      if(type(a) == type(b)):
        return (a > b) - (a < b)
        #return cmp(a, b)
      else:
        if(type(a) == type(1.0)):
          return -1
        elif(type(b) == type(1.0)):
          return 1
        else:
          return 0

    # code continues -- generate sorted data
    currData = self.tableModel.getAllData()
    self.sheetData = sorted(currData, key=cmp_to_key(partial(mixedSort, col)))
    if(mode):
      self.sheetData = list(reversed(self.sheetData))
      
    # update table
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)

    # configure table
    dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
    self.configTable(dimx, dimy, retainRoles=True)

  def changeRole(self, col):
    # first check whether control button pressed -- if so, redirect to column transformations
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if(modifiers & QtCore.Qt.ControlModifier):
      self.transformColumn(col)
    else:
      # open context menu to assign roles
      options = ['x', 'xerr', 'y', 'yerr', 'labels']
      self.menu = MuhMenu(self)
      self.menu.setTitle('Assign role')
      
      for entry in options:
        action = QtWidgets.QAction(self.rolestr[entry], self)
        action.triggered.connect(partial(self.changeRoleHelper, col, entry))
        self.menu.addAction(action)
        
      action = QtWidgets.QAction('none', self)
      action.triggered.connect(partial(self.clear_role, col))
      self.menu.addAction(action)
  
      # apply styles to popup window
      if(QSTYLE != None):
        self.menu.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.menu.setStyleSheet(QSTYLESHEET)
        
      # display menu at current column
      menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
      menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
      self.menu.popup(menuPos)
  
  def changeRoleHelper(self, col, role):
    # actually assigns the new role
    # did this column have any role assigned?
    for key in self.roles:
      if(self.roles[key] == col):
        self.roles[key] = -1
    
    # is the new role already taken?
    if (self.roles[role] + 1):
      # reset old label
      self.tableModel.setSingleHeader(self.roles[role], str(self.roles[role] + 1))
      
    # assign new role
    self.roles[role] = col
    self.tableModel.setSingleHeader(col, str(col + 1) + ' (' + self.rolestr[role] + ')')
    self.tableModel.layoutChanged.emit()
    
    # trigger data update
    self.parent.updateData(docheck=True)

  def clear_role(self, col):
    # unassigns role of column
    # did this column have any role assigned?
    for key in self.roles:
      if(self.roles[key] == col):
        self.roles[key] = -1
        
    # reset label
    self.tableModel.setSingleHeader(col, str(col + 1))
    self.tableModel.layoutChanged.emit()

    # trigger data update
    self.parent.updateData(docheck=True)

  def transformColumn(self, col):
    # opens context menu to allow transformation of column contents
    self.menu = TransformerMenu(self, col, self.storeFormula)
    self.menu.setTitle('Transform column')
    
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
      
    # display menu at current column
    menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
    menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
    self.menu.popup(menuPos)
    
  def doTransformer(self, col, formula):
    # performs the actual column transformation
    targetCol = col
    if(formula == 'C' + str(col)):
      self.storeFormula = ''
    else:
      self.storeFormula = formula
    
    # analyze formula to determine which columns to use
    useCol = []
    for col in range(self.tableModel.columnCount()):
      probeCol = 'C' + str(col + 1)
      # check for presence of probeCol in formula
      if(probeCol in formula):
        flag = False
        splitty = formula.split(probeCol)
        for entry in splitty[1:]:
          # next character in formula string is not a number
          if((entry == '') or (not entry[0].isdigit())):
            flag = True
        if(flag):
          useCol.append(col)
          
    # analyze whether we should use row
    useRow = False
    if('ROW' in formula):
      useRow = True
    
    # define transformer function
    try:
      # check whether we have at least one input column
      if(len(useCol)):
        funcstr = 'def transformThis(self, inputs'
        if(useRow):
          funcstr += ', ROW):'
        else:
          funcstr += '):'
        for index, entry in enumerate(useCol):
          funcstr += '\n\tC' + str(entry + 1) + ' = inputs[:, ' + str(index) + ']'
        funcstr += '\n\toutput = ' + formula + '\n\treturn output'
      else:
        funcstr = 'def transformThis(self, zeroInput'
        if(useRow):
          funcstr += ', ROW):'
        else:
          funcstr += '):'
        funcstr += '\n\toutput = zeroInput + ' + formula + '\n\treturn output'
        
      # generate ffunc in local namespace (this is needed for Python3 vs. Python2, bummer)
      namespace = self.mySpace
      exec(funcstr, namespace)
      # now define the new function in the object scope
      setattr(DataTable, 'transformThis', namespace['transformThis'])
    except:
      self.parent.parent.statusbar.showMessage('Error when setting transformation for column ' + str(targetCol), self.parent.parent.STATUS_TIME)
    else:
      # do the actual transform
      # do some reporting
      goodRows, badRows = [], []
        
      # determine selected rows
      selind = self.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])
      if (len(selind)):
        # get all selected data rows
        selectedData = self.tableModel.getDataRows(selind)
        
        # reduce data to columns we are interested in
        for index, entry in enumerate(selectedData):
          selectedData[index] = [entry[i] for i in useCol]
        
        # process data to weed out problematic rows
        prunedData, prunedIndices = [], []
        for index, row in enumerate(selectedData):
          # only process rows where all required cells are numeric
          checkRow = [0 if(type(i) in [float, int]) else 1 for i in row]
          if(sum(checkRow) == 0):
            prunedData.append(row)
            prunedIndices.append(selind[index])
          else:
            badRows.append(selind[index])
        
        # do the concrete transform
        if(len(prunedData)):
          prunedData = np.array(prunedData)
          try:
            # check whether we have at least one input column
            if(len(useCol)):
              if(useRow):
                ROW = np.array(prunedIndices) + 1
                transCol = self.transformThis(prunedData, ROW=ROW)
              else:
                transCol = self.transformThis(prunedData)
            else:
              zeroInput = np.array([0] * len(prunedIndices))
              if(useRow):
                ROW = np.array(prunedIndices) + 1
                transCol = self.transformThis(zeroInput, ROW=ROW)
              else:
                transCol = self.transformThis(zeroInput)

            # everything has worked, so assign transformed values to data table
            for index, value in enumerate(transCol):
              if((not np.isnan(value)) and (not np.isinf(value))):
                self.tableModel.setData(float(value), prunedIndices[index], targetCol)
                goodRows.append(prunedIndices[index])
              else:
                self.tableModel.setData('', prunedIndices[index], targetCol)
                badRows.append(prunedIndices[index])
              # refresh table view
              cellIndex = self.tableModel.index(prunedIndices[index], targetCol)
              self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])
          except:
            self.parent.parent.statusbar.showMessage('Error when applying transformation for column ' + str(targetCol), self.parent.parent.STATUS_TIME)

        self.tableModel.setGoodBad(goodRows=goodRows, badRows=badRows, selCols=[targetCol])

  def hasComma(self):
    # cycles through selected cells and checks for presence of comma
    selind = self.selectionModel().selectedIndexes()
    retv = False
    index = 0
    while((not retv) and (index < len(selind))):
      if((type(selind[index].data()) == str) and (',' in selind[index].data())):
        retv = True
      index += 1

    return retv
    
  def getData(self, needXErr=True, needYErr=True):
    # returns selected data as numpy array
    # determine selected rows
    selind = self.selectionModel().selectedRows()
    selind = sorted([i.row() for i in selind])
     
    # retrieve data from table
    retv = []; roles = []
    # check whether at least x and y assigned
    if (((self.roles['x'] + 1) or (self.roles['labels'] + 1)) and (self.roles['y'] + 1)):
      if (len(selind)):
        # get all selected data rows
        selectedData = self.tableModel.getDataRows(selind)

        # deal with labels separately to allow non-numerical entries here
        if(self.roles['labels'] > -1):
          selectedLabels = []
          index = self.roles['labels']
          for entry in selectedData:
            selectedLabels.append(entry[index])
        
        # reduce data to columns we are interested in
        activeKeys = ['x', 'xerr', 'y', 'yerr']
        if(not needXErr):
          activeKeys.pop(activeKeys.index('xerr'))
        if(not needYErr):
          activeKeys.pop(activeKeys.index('yerr'))
        activeKeys = [key for key in activeKeys if (self.roles[key] > -1)]
        indices = [self.roles[key] for key in activeKeys]
        for index, entry in enumerate(selectedData):
          selectedData[index] = [entry[i] for i in indices]
        
        # do some reporting
        goodRows, badRows = [], []
        
        # prepare list for numpy array
        prunedData = []; no_items = len(activeKeys)
        for index, row in enumerate(selectedData):
          types = [1 if type(i) in [int, float] else 0 for i in row]
          if(np.sum(types) == no_items):
            # only numerical entries on row
            if(self.roles['labels'] > -1):
              row.append(selectedLabels[index])
            prunedData.append(row)
            goodRows.append(selind[index])
          elif(np.sum(types) > 0):
            # at least one numerical entry on row
            lengths = [len(i) for index, i in enumerate(row) if(not types[index])]
            if(np.sum(lengths) == 0):
              # all other cells empty => replace by zero
              row = [i if types[index] else 0.0 for index, i in enumerate(row)]
              if(self.roles['labels'] > -1):
                row.append(selectedLabels[index])
              prunedData.append(row)
              goodRows.append(selind[index])
            else:
              badRows.append(selind[index])
          else:
            # check for completely empty row
            lengths = [len(i) for index, i in enumerate(row) if(not types[index])]
            if(np.sum(lengths) != 0):
              # only spaces in line
              badRows.append(selind[index])
              
        # color table temporarily
        useKeys = ['x', 'xerr', 'y', 'yerr', 'labels']
        if(self.parent.errorModel or (not self.parent.errorSwitch)):
          useKeys.remove('yerr')
        if(self.parent.errorXModel or (not self.parent.errorXSwitch)):
          useKeys.remove('xerr')
        selCols = [self.roles[key] for key in useKeys if (self.roles[key] > -1)]
        self.tableModel.setGoodBad(goodRows=goodRows, badRows=badRows, selCols=selCols)
        
        # convert nested list to numpy array
        retv = prunedData
        roles = activeKeys
        if(self.roles['labels'] > -1):
          roles.append('labels')
    
        # sort data by ascending x values
        #if(len(retv)):
          # will sort according to first entry w/in nested list which should be 'x'
        #  retv = sorted(retv)
        # turned off this feature as it causes problems for cyclic data (e.g., voltammetry)
    return retv, roles

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Copy):
      # prepare output
      selind = self.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])      
      # get data
      selectedData = self.tableModel.getDataRows(selind)
      output = []
      for row in selectedData:
        row = [str(i) for i in row]
        output.append('\t'.join(row))
      output = '\n'.join(output)
      clipboard = QtWidgets.QApplication.clipboard()
      clipboard.setText(output)
    elif event.matches(QtGui.QKeySequence.Paste):
      clipboard = QtWidgets.QApplication.clipboard()
      clipMime = clipboard.mimeData()
      # check wether clip object contains text
      if(clipMime.hasText()):
        clipContent = clipboard.text()
        self.pasteText(pastedText=clipContent)
    elif event.matches(QtGui.QKeySequence.SelectAll):
      self.selectAll()
    elif(event.key() == QtCore.Qt.Key_Down):
      if(self.currentRow < self.tableModel.rowCount() - 1):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        self.currentRow += 1
        self.selectTo(self.currentRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_Up):
      if(self.currentRow > 0):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        self.currentRow -= 1
        self.selectTo(self.currentRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_PageDown):
      if(self.currentRow < self.tableModel.rowCount() - 1):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        origRow = self.currentRow
        self.currentRow += self.pageStep
        self.currentRow = min(self.currentRow, self.tableModel.rowCount() - 1)
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          origRow = self.currentRow
        self.selectTo(origRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_PageUp):
      if(self.currentRow > 0):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        origRow = self.currentRow
        self.currentRow -= self.pageStep
        self.currentRow = max(self.currentRow, 0)
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          origRow = self.currentRow
        self.selectTo(origRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Right]):
      # ignore event such that we can capture the left/right keys
      event.ignore()
      flag = False
      if(event.key() == QtCore.Qt.Key_Left):
        if(self.currentCol > 0):
          self.currentCol -= 1
          flag = True
      elif(self.currentCol < self.tableModel.columnCount() - 1):
        self.currentCol += 1
        flag = True
      if(flag):
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Home, QtCore.Qt.Key_End]):
      if(event.modifiers() & QtCore.Qt.ControlModifier):
        flag = False
        if(event.key() == QtCore.Qt.Key_Home):
          if(self.currentRow > 0):
            origRow = self.currentRow
            self.currentRow = 0
            flag = True
        elif(self.currentRow < self.tableModel.rowCount() - 1):
          origRow = self.currentRow
          self.currentRow = self.tableModel.rowCount() - 1
          flag = True
        if(flag):
          if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
            self.clearSelection()
            origRow = self.currentRow
          self.selectTo(origRow, self.currentRow)
          nuIndex = self.model().index(self.currentRow, self.currentCol)
          self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      else:
        flag = False
        if(event.key() == QtCore.Qt.Key_Home):
          if(self.currentCol > 0):
            self.currentCol = 0
            flag = True
        elif(self.currentCol < self.tableModel.columnCount() - 1):
          self.currentCol = self.tableModel.columnCount() - 1
          flag = True
        if(flag):
          nuIndex = self.model().index(self.currentRow, self.currentCol)
          self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab]):
      # advance cell on tab
      if(event.key() == QtCore.Qt.Key_Backtab):
        self.currentCol -= 1
        if(self.currentCol < 0):
          if(self.currentRow > 0):
            self.currentRow -= 1
            self.currentCol = self.tableModel.columnCount() - 1
          else:
            self.currentCol = 0
      else:
        self.currentCol += 1
        if(self.currentCol >= self.tableModel.columnCount()):
          if(self.currentRow < self.tableModel.rowCount() - 1):
            self.currentRow += 1
            self.currentCol = 0
          else:
            self.currentCol = self.tableModel.columnCount() - 1
      self.clearSelection()
      self.selectTo(self.currentRow, self.currentRow)
      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete]):
      # clear current cell
      self.tableModel.setData('', self.currentRow, self.currentCol)
      # refresh table view
      cellIndex = self.tableModel.index(self.currentRow, self.currentCol)
      self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])
    elif (event.matches(QtGui.QKeySequence.Save) or event.matches(QtGui.QKeySequence.Open) or event.matches(QtGui.QKeySequence.HelpContents)\
          or event.matches(QtGui.QKeySequence.Print) or event.matches(QtGui.QKeySequence.Quit) or event.matches(QtGui.QKeySequence.Italic)\
          or event.matches(QtGui.QKeySequence.ZoomIn) or event.matches(QtGui.QKeySequence.ZoomOut) or event.matches(QtGui.QKeySequence.Find)\
          or event.matches(QtGui.QKeySequence.New) or event.matches(QtGui.QKeySequence.Refresh) or event.matches(QtGui.QKeySequence.FindNext)):
      # pass event to main ui
      event.ignore()
    elif(not (event.key() in [QtCore.Qt.Key_Escape])):
      openDialog = False
      if(event.key() in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]):
        openDialog = True
        initialEdit = ''
      elif(len(event.text())):
        openDialog = True
        initialEdit = event.text()
      if(openDialog):
        # ensure that cell is visible
        indexAt = self.model().index(self.currentRow, self.currentCol)
        self.scrollTo(indexAt)
        # open edit QMenu at cell position
        rowViewport, colViewport = self.rowViewportPosition(self.currentRow), self.columnViewportPosition(self.currentCol) + self.verticalHeader().width()
        menuPos = self.mapToGlobal(QtCore.QPoint(colViewport, rowViewport))
        self.menu = EditDataMenu(parent=self, tableModel=self.tableModel, indexAt=indexAt, initialEdit=initialEdit)
        # apply styles to popup window
        if(QSTYLE != None):
          self.menu.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.menu.setStyleSheet(QSTYLESHEET)
        self.menu.popup(menuPos)    

  def selectTo(self, startRow=0, endRow=0):
    # selects target rows
    lowRow, hiRow = min(startRow, endRow), max(startRow, endRow)
    columnCount = self.tableModel.columnCount()
    
    topLeft = self.model().index(lowRow, 0)
    bottomRight = self.model().index(hiRow, columnCount - 1)
    itemSelection = QtCore.QItemSelection(topLeft, bottomRight)
    self.selectionModel().select(itemSelection, QtCore.QItemSelectionModel.Select)

  def pasteText(self, pastedText=''):
    # display busy pointer as this can take a long time for big data chunks
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    # store target cell
    offsetRow, offsetColumn = self.currentRow, self.currentCol
    # determine size of text to be pasted
    clipRows = pastedText.split('\n')
    clipCols = [i.split('\t') for i in clipRows]
    clipColCount = [len(i) for i in clipCols]
    # determine new data sheet dimensions
    nuRowCount, nuColCount = len(clipRows), max(clipColCount)
    # check for trailing all-empty columns which we won't copy
    index = nuColCount - 1
    trailCol = nuColCount
    while(index >= 0):
      for entry in clipCols:
        if(0 < index < len(entry)):
          if(len(entry[index])):
            trailCol = index + 1
            index = -1
      index -= 1
    # make clipped text square and truncate after trailCol
    clipCols = [i + ([''] * nuColCount) for i in clipCols]
    clipCols = [i[:trailCol] for i in clipCols]
    # convert to number where possible
    clipCols = [[float(j) if self.isNumber(j) else j for j in i] for i in clipCols]
    # prepare pasting of text -- resize if needed
    dimy, dimx = self.tableModel.rowCount(), self.tableModel.columnCount()
    if(((offsetColumn + trailCol) > dimx) or ((offsetRow + nuRowCount) > dimy)):
      # store current data
      currData = self.tableModel.getAllData()
      # blank data
      dimx, dimy = max(dimx, offsetColumn + trailCol), max(dimy, offsetRow + nuRowCount)
      blankData = [[''] * dimx for i in range(dimy)]
      self.tableModel = DataTableModel(blankData, self)
      self.setModel(self.tableModel)
      # restore original data
      self.tableModel.pasteDataBlock(data=currData, offsetRow=0, offsetColumn=0)
    
    # paste new data
    self.tableModel.pasteDataBlock(data=clipCols, offsetRow=offsetRow, offsetColumn=offsetColumn)
    self.configTable(offsetColumn + trailCol, offsetRow + nuRowCount, retainRoles=True, retainSelection=True)
    self.tableModel.layoutChanged.emit()
    
    # update self.sheetData as well
    self.sheetData = self.tableModel.getAllData()

    # restore cursor
    QtWidgets.QApplication.restoreOverrideCursor()
    
  def mouseDoubleClickEvent(self, event):
    # allow editing of cell on double click
    # perform original event
    QtWidgets.QTableView.mouseDoubleClickEvent(self, event)
    
    # determine indices of clicked cell and scroll to ensure visibility
    indexAt = self.indexAt(event.pos())
    self.scrollTo(indexAt)
    row, col = indexAt.row(), indexAt.column()
    rowViewport, colViewport = self.rowViewportPosition(row), self.columnViewportPosition(col)
    
    # open edit QMenu at cell position
    menuPos = self.mapToGlobal(QtCore.QPoint(colViewport + self.verticalHeader().width(), rowViewport))

    self.menu = EditDataMenu(parent=self, tableModel=self.tableModel, indexAt=indexAt)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
    self.menu.popup(menuPos)    

  def currentCellChanged(self, current):
    # keeps tabs on current cell
    self.currentRow, self.currentCol = current.row(), current.column()

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

# subclass edit to better capture key presses
class EditDataEdit(QtWidgets.QLineEdit):
  def __init__(self, parent=None):
    super(EditDataEdit, self).__init__(parent)
    self.parent = parent
  
  def keyPressEvent(self, event):
    # ignore alt keys as they would close the QMenu
    if(event.key() in [QtCore.Qt.Key_Alt, QtCore.Qt.Key_AltGr]):
      return

    # capture enter and arrow keys
    if(event.key() in [QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter]):
      if(event.modifiers() & QtCore.Qt.ShiftModifier):
        self.parent.advanceCell(-1, 0)
      else:
        self.parent.advanceCell(1, 0)
    elif(event.key() == QtCore.Qt.Key_Up):
      self.parent.advanceCell(-1, 0)
    elif(event.key() == QtCore.Qt.Key_Down):
      self.parent.advanceCell(1, 0)
    elif(event.key() == QtCore.Qt.Key_Left):
      if((event.modifiers() & QtCore.Qt.ControlModifier) or (self.cursorPosition() == 0)):
        self.parent.advanceCell(0, -1)
        return
    elif(event.key() == QtCore.Qt.Key_Right):
      if((event.modifiers() & QtCore.Qt.ControlModifier) or (self.cursorPosition() == len(self.text()))):
        self.parent.advanceCell(0, 1)
        return
      
    # normal event processing
    QtWidgets.QLineEdit.keyPressEvent(self, event)

class EditDataMenu(KuhMenu):
  def __init__(self, parent=None, tableModel=None, indexAt=None, initialEdit=''):
    super(EditDataMenu, self).__init__()
    if(None in [parent, tableModel, indexAt]):
      self.close()
    
    self.parent = parent
    self.tableModel = tableModel
    self.maxRow, self.maxCol = self.tableModel.rowCount(), self.tableModel.columnCount()
    self.indexAt = indexAt
    self.row, self.col = self.indexAt.row(), self.indexAt.column()
    self.minWidth = scaledDPI(100)
    self.finalUpdate = True
      
    # set up GUI
    self.buildRessource()
    
    # set QMenu position
    self.adjustWindowPosition(initialEdit=initialEdit)

  def adjustWindowPosition(self, initialEdit=''):
    # update label
    labelText = 'Edit cell ' + str(self.col + 1) + '/' + str(self.row + 1)
    useFont = self.editDataLabel.font()
    useFont.setBold(True)
    self.editDataLabel.setFont(useFont)
    self.editDataLabel.setText(labelText)

    # update QlineEdit
    if(len(initialEdit)):
      self.initValue = ''
      self.editData.setText(initialEdit)
    else:
      self.initValue = self.tableModel.dataByIndices(self.row, self.col)
      self.editData.setText(str(self.initValue))

    self.editData.selectAll()
    self.editData.setFocus()

    # ensure that cell is visible
    cellIndex = self.tableModel.index(self.row, self.col)
    self.parent.scrollTo(cellIndex)
    
    # adjust width of edit window -- use min/max size as resize not properly heeded
    cellWidth = max(self.minWidth, self.parent.columnWidth(self.col))
    self.editData.setMaximumSize(QtCore.QSize(cellWidth, scaledDPI(BASE_SIZE)))
    self.editData.setMinimumSize(QtCore.QSize(cellWidth, scaledDPI(BASE_SIZE)))
    self.setMaximumWidth(cellWidth)
    self.setMinimumWidth(cellWidth)

    # adjusts window position to currently edited cell
    rowViewport = self.parent.rowViewportPosition(self.row)
    colViewport = self.parent.columnViewportPosition(self.col) + self.parent.verticalHeader().width()
    menuPos = self.parent.mapToGlobal(QtCore.QPoint(colViewport, rowViewport))
    self.move(menuPos)
    
    if(len(initialEdit)):
      self.editData.deselect()
      self.editData.setCursorPosition(1)

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    # QlineEdit for data modification
    self.editDataLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.editDataLabel)
    
    self.editData = EditDataEdit(self)
    self.vLayout.addWidget(self.editData)
    self.editData.setFocus()
    
  def updateData(self):
    # updates data table if required
    currValue = self.editData.text()
    if(currValue != self.initValue):
      try:
        currValue = float(currValue)
      except:
        pass
      self.parent.tableModel.setData(currValue, self.row, self.col)

      # refresh table view
      cellIndex = self.tableModel.index(self.row, self.col)
      self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])
      
  def keyPressEvent(self, event):
    # process tab keys and escape
    if(event.key() == QtCore.Qt.Key_Backtab):
      self.advanceCell(0, -1)
    elif(event.key() == QtCore.Qt.Key_Tab):
      self.advanceCell(0, 1)
    elif(event.key() == QtCore.Qt.Key_Escape):
      self.finalUpdate = False
      self.close()
      
  def advanceCell(self, deltaRow=0, deltaCol=0):
    # update previous data
    self.updateData()
    
    # move edit window to new position
    # adjust cell indices
    self.deltaRow, self.deltaCol = deltaRow, deltaCol
    
    # apply column shift
    self.col += self.deltaCol
    if(self.col >= self.maxCol):
      if(self.row < self.maxRow - 1):
        self.col = 0; self.row += 1
      else:
        self.col = self.maxCol - 1
    elif(self.col < 0):
      if(self.row > 0):
        self.col = self.maxCol - 1; self.row -= 1
      else:
        self.col = 0

    # apply row shift
    self.row += deltaRow
    self.row = max(self.row, 0)
    self.row = min(self.row, self.maxRow - 1)

    # set cursor in data table to currently edited cell
    self.parent.currentCol, self.parent.currentRow = self.col, self.row
    self.parent.clearSelection()
    self.parent.selectTo(self.row, self.row)
    nuIndex = self.parent.model().index(self.row, self.col)
    self.parent.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)

    # move window
    self.adjustWindowPosition()
    
  def closeEvent(self, event):
    # perform final update
    if(self.finalUpdate):
      self.updateData()
    # perform original close event
    QtWidgets.QMenu.closeEvent(self, event)

class ResultsArea(QWidgetMac):
  def __init__(self, parent = None):
    super(ResultsArea, self).__init__()
    self.parent = parent
    self.rolestr = {'x':'x', 'y':'y', 'xerr':u'\N{GREEK CAPITAL LETTER DELTA}x', \
      'yerr':u'\N{GREEK CAPITAL LETTER DELTA}y', 'fit':'fit', 'resid':'resid'}
    self.descriptors = []
    self.buildRessource()
    
    # initialize filename
    self.currExportFile = None
    
  def buildRessource(self):
    # set up results table
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    # allow change of data set on display    
    self.dataSetBox = QWidgetMac()
    self.vLayout.addWidget(self.dataSetBox)
    self.dataSetLayout = QtWidgets.QHBoxLayout(self.dataSetBox)
    self.dataSetLayout.setContentsMargins(0, 0, 0, 0)
    self.dataSetLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data Set')
    self.dataSetLabel.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetLabel.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetLayout.addWidget(self.dataSetLabel)
    
    self.dataSetSpinBox = QSpinBoxToolTip()
    self.dataSetSpinBox.setAlignment(QtCore.Qt.AlignRight)
    self.dataSetSpinBox.setToolTip('Select data set to display in table')
    self.dataSetSpinBox.setMinimum(1)
    self.dataSetSpinBox.setMaximum(1)
    self.dataSetSpinBox.setValue(1)
    self.dataSetSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetSpinBox.valueChanged.connect(self.changeDataSet)
    self.dataSetSpinBox.setEnabled(False)
    self.dataSetLayout.addWidget(self.dataSetSpinBox)
    
    self.dataSetName = QtWidgets.QLabel()
    self.dataSetName.setText(self.parent.data[self.parent.activeData].name)
    self.dataSetLayout.addWidget(self.dataSetName)

    self.resultstable = QtWidgets.QTableView()
    self.resultstable.setObjectName('data')
    btn = self.resultstable.findChild(QtWidgets.QAbstractButton)
    self.storedCornerTip = 'Click to select entire table'
    btn.setToolTip(self.storedCornerTip)
    self.resultstable.setItemDelegate(FloatFormatDelegate())
    self.resultstable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.resultstable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    self.vLayout.addWidget(self.resultstable)
    self.tableModel = None

    self.rowHeight = int(self.resultstable.fontMetrics().height() + scaledDPI(2))
    vheader = self.resultstable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)

    self.buttonBox = QtWidgets.QWidget()
    self.vLayout.addWidget(self.buttonBox)
    self.buttonBoxLayout = QtWidgets.QHBoxLayout(self.buttonBox)
    self.buttonBoxLayout.setContentsMargins(0, 0, 0, 0)
    self.buttonBoxLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.exportButton = QPushButtonMac()
    self.exportButton.setText('Export Results')
    self.exportButton.setToolTip('Compile report of current graphics and fit results')
    self.exportButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.exportButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.exportButton.clicked.connect(self.exportWrapper)
    self.buttonBoxLayout.addWidget(self.exportButton, stretch=1)

    self.selectionButton = QPushButtonMac()
    self.selectionButton.setText('Update Selection')
    self.selectionButton.setToolTip('Update data selection')
    self.selectionButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.selectionButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.selectionButton.clicked.connect(self.updateSelection)
    self.buttonBoxLayout.addWidget(self.selectionButton, stretch=1)

    self.clearButton = QPushButtonMac()
    self.clearButton.setText('Clear Selection')
    self.clearButton.setToolTip('Clear data selection')
    self.clearButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.clearButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.clearButton.clicked.connect(self.clearSelection)
    self.buttonBoxLayout.addWidget(self.clearButton, stretch=1)
    self.clearButton.setEnabled(False)

    self.spawnButton = QPushButtonMac()
    self.spawnButton.setText('Spawn Data')
    self.spawnButton.setToolTip('Generate new data set from data selection')
    self.spawnButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.spawnButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.spawnButton.clicked.connect(self.spawnMe)
    self.buttonBoxLayout.addWidget(self.spawnButton, stretch=1)
    self.spawnButton.setEnabled(False)

  def spawnMe(self):
    # generates a new data set from current data selection
    values, roles = self.parent.selectedData.getData_n_Fit()
    name = self.parent.data[self.parent.activeData].name
    self.parent.objectsarea.dataSetCreate()
    self.parent.data[-1].setData(data=values, roles=roles)
    self.parent.data[-1].setName('spawned from ' + name)
    # display new data set
    self.parent.data[-1].drawMe(redraw=False)
    # need to update various tables
    self.parent.objectsarea.refreshDataTable()
    self.parent.globalarea.updateDataSetTable()
    # update results table
    self.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)
    # update legend if needed
    self.parent.objectsarea.updateLegend(redraw=True)

  def updateSelection(self):
    # uses table selection to select data points
    currIndex = self.dataSetSpinBox.value()
    if(self.parent.activeData != currIndex - 1):
      self.parent.statusbar.showMessage('Data set ' + str(currIndex) + ' is on display, but data set ' + str(self.parent.activeData + 1) + ' is active => no selection done!', self.parent.STATUS_TIME)
      return
    
    if(self.tableModel != None):
      # for good measure try/except this
      try:
        selind = self.resultstable.selectionModel().selectedRows()
        self.parent.selectedData.tableSelectIndices(selind)
        return
      except:
        pass
      
    self.parent.statusbar.showMessage('Results table appears to be empty, cannot update data set!', self.parent.STATUS_TIME)

  def clearSelection(self):
    # clears selection of data points
    self.resultstable.clearSelection()
    
    # clear selected data points (this will also control the display of the clear buttons)
    self.parent.selectedData.clearMe()

  def selectTheseRows(self, selind=[]):
    # selects rows in resultstable
    self.resultstable.clearSelection()
    if(len(selind)):
      # ensure that currently selected data set is on display
      if(self.parent.activeData + 1 != self.dataSetSpinBox.value()):
        self.dataSetSpinBox.setValue(self.parent.activeData + 1)
      selectionModel = self.resultstable.selectionModel()
      for index in selind:
        cellItem = selectionModel.model().index(index, 0)
        selectionModel.select(cellItem, QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows)

  def toggleToolTips(self, state=True):
    # dynamically sets and unsets tool tips
    btn = self.resultstable.findChild(QtWidgets.QAbstractButton)
    if(state):
      btn.setToolTip(self.storedCornerTip)
    else:
      btn.setToolTip('')

  def exportWrapper(self, modeHTMLOnly=False):
    # writes results to output file
    global REMEMBERDIR
    if(modeHTMLOnly):
      filter_options = ['HTML Files (*.html)']
    else:
      filter_options = ['HTML Files (*.html)','Excel Files (*.xlsx)']
    filterstring = ';;'.join(filter_options)
    usedir = REMEMBERDIR
    if(self.currExportFile != None):
      usedir = self.currExportFile
    if(modeHTMLOnly):
      caption = 'Compile Report'
    else:
      caption = 'Export Results'
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self, filter=filterstring, directory=usedir, caption=caption)
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    if(len(filename) > 0):
      mode = filter_options.index(filter_)
      if(modeHTMLOnly or (mode == 0)):
        self.writeHTML(filename=filename)
      elif(mode == 1):
        self.writeXLS(filename=filename)

  def writeHTML(self, filename=None):
    # writes Results table to HTML file
    if(filename != None):
      # set SVG export to path to ensure correct display in browser
      prevSVGSetting = None
      if('svg.fonttype' in matplotlib.rcParams):
        prevSVGSetting = matplotlib.rcParams['svg.fonttype']
      matplotlib.rcParams.update({'svg.fonttype': 'path'})
      # save current figure temporarily under new filename
      if(self.parent.plotArea.figureFill):
        useFaceColor = self.parent.plotArea.figureColor
      else:
        useFaceColor = 'none'
      if(self.parent.plotArea.frameDraw):
        useFrameColor = self.parent.plotArea.frameColor
      else:
        useFrameColor = 'none'
      try:
        self.parent.plotArea.matplot.savefig(filename, format='svg', dpi=600, facecolor=useFaceColor, edgecolor=useFrameColor)
        flag = True
      except:
        flag = False
      # store contents of SVG file in memory
      if(flag):
        readhandle = open(filename, 'r', encoding='utf-8')
        svg_plot = readhandle.readlines()
        readhandle.close()
      else:
        svg_plot = []
      
      # save current residuals temporarily under new filename
      try:
        self.parent.plotArea.residplot.savefig(filename, format='svg', dpi=600, facecolor=useFaceColor, edgecolor=useFrameColor)
        flag2 = True
      except:
        flag2 = False

      # store contents of SVG file in memory
      if(flag2):
        readhandle = open(filename, 'r', encoding='utf-8')
        svg_resid = readhandle.readlines()
        readhandle.close()
      else:
        svg_resid = []

      # restore SVG export setting to previous value
      if(prevSVGSetting != None):
        matplotlib.rcParams.update({'svg.fonttype': prevSVGSetting})
        
      # generate actual HTML file
      writehandle = open(filename, 'w', encoding='utf-8')
      
      if(writehandle):
        # write header
        writehandle.write('<html xmlns="http://www.w3.org/1999/xhtml">\n<head>\n')
        writehandle.write('<title>Fit-o-mat Results</title>\n')
        writehandle.write('<meta charset="UTF-8">\n')
        writehandle.write('<meta author="Moeglich laboratory, University of Bayreuth">\n')
        writehandle.write('<meta description="Fit-o-mat Fit Results">\n')
        writehandle.write('</head>\n<body>\n')
        
        writehandle.write('<h2>Fit-o-mat Results</h2>\n')
        writehandle.write(asctime() + '\n')
        # check whether current fit results are available
        if(self.parent.lastFitType != 'none'):
          # write heading and div
          writehandle.write('<div style="padding: 5px;">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'results\')" class="toggle">\n')
          writehandle.write('<h3 id="results_ctrl">&#9744; Fit Results</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="results" style="display:none;">\n')
          writehandle.write('<button id="results_button" class="little">Copy Results</button>\n')
          writehandle.write('<div id="results_content">\n')
          # further check whether these are local or global results
          writehandle.write('<span class="mypre">\n')
          if(self.parent.lastFitType == 'local'):
            if('<br>' in self.parent.fitarea.outstring.lower()):
              fitresults = self.parent.fitarea.outstring.split('<br>')
            else:
              fitresults = self.parent.fitarea.outstring.splitlines()
          else:
            if('<br>' in self.parent.globalarea.globalOutstring.lower()):
              fitresults = self.parent.globalarea.globalOutstring.split('<br>')
            else:
              fitresults = self.parent.globalarea.globalOutstring.splitlines()
            writehandle.write('<h4>Global fit</h4>')
          writehandle.write('\n'.join(fitresults[1:]) + '\n')
          writehandle.write('</span>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
        else:
          pass
            
        writehandle.write('<div class="container">\n')

        # write graphics
        if(flag or flag2):
          writehandle.write('<div class="flexmatic2">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'plot\')" class="toggle">\n')
          writehandle.write('<h3 id="plot_ctrl">&#9746; Plot and Residuals</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="plot" style="display:block;">\n')
          writehandle.write('<button id="plot_button" class="little">Copy Plots</button>\n')
          writehandle.write('<div id="plot_content">\n')
          max_width = 0
  
          # write plot figure if available
          if(flag):
            output = False
            for entry in svg_plot:
              if('<svg' in entry):
                output = True
                # extract width of SVG item
                if('width' in entry):
                  red = entry.split('width')[1]
                  max_width = red.split('"')[1]
              if(output):
                writehandle.write(entry)
              if('</svg' in entry):
                output = False
              
          # write residuals figure if available
          if(flag2):
            output = False
            for entry in svg_resid:
              if('<svg' in entry):
                output = True
              if(output):
                writehandle.write(entry)
              if('</svg' in entry):
                output = False
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')

        # count how many curves are on display currently
        curvesOnDisplay = [i for i in self.parent.fit if i.visibility]
        
        # write parameters
        if(len(curvesOnDisplay)):
          writehandle.write('<div class="flexmatic">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'param\')" class="toggle">\n')
          writehandle.write('<h3 id="param_ctrl">&#9746; Parameter Values</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="param" style="display:block;">\n')
          writehandle.write('<button id="param_button" class="little">Copy Parameters</button>\n')
          writehandle.write('<div id="param_content">\n')
  
          # function to write parameter values and statistics for one curve
          def writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq, globalparam):
            writehandle.write('<table class="param">\n<thead>\n<tr>\n')
            writehandle.write('<th>Name</th>\n<th>Value</th>\n<th>Confidence</th>\n<th>Conf. <i>a priori</i></th>\n')
            writehandle.write('</tr>\n</thead>\n')
    
            writehandle.write('<tbody>\n')
            for i, j, k, l, m, n in zip(paramList, param, confidence, confidence_apriori, param_active, globalparam):
              if(i == paramList[-1]):
                writehandle.write('<tr class="last">\n')
              else:
                writehandle.write('<tr>\n')
              if(m):
                if(n):
                  writehandle.write('<td class="global">' + str(i) + '</td>\n')
                else:
                  writehandle.write('<td>' + str(i) + '</td>\n')
              else:
                if(n):
                  writehandle.write('<td class="fixed global">' + str(i) + '</td>\n')
                else:
                  writehandle.write('<td class="fixed">' + str(i) + '</td>\n')
              if(m):
                if(n):
                  tdString = '<td class="rite global">'
                else:
                  tdString = '<td class="rite">'
              else:
                if(n):
                  tdString = '<td class="rite fixed global">'
                else:
                  tdString = '<td class="rite fixed">'
              writehandle.write(tdString + self.parent.formatNumber(j) + '</td>\n')
              writehandle.write(tdString + self.parent.formatNumber(k) + '</td>\n')
              writehandle.write(tdString + self.parent.formatNumber(l) + '</td>\n')
              writehandle.write('</tr>\n')
            writehandle.write('</tbody>\n</table>\n')
            if(1):
            ###if(self.parent.lastFitType != 'none'):
              try:
                useChi = self.parent.formatNumber(chisq)
              except:
                useChi = str(chisq)
              writehandle.write('<i>&#x1D6D8;</i><sup>2</sup> = ' + useChi + '\n')
              try:
                useRedChi = self.parent.formatNumber(redchisq)
              except:
                useRedChi = str(redchisq)
              writehandle.write('<br/>reduced <i>&#x1D6D8;</i><sup>2</sup> = ' + useRedChi + '\n')
  
          # check whether last fit local or global
          if(self.parent.lastFitType != 'global'):
            for index, entry in enumerate(self.parent.fit):
              if(entry.visibility):
                tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in entry.style['color'][0:3]]) + ');\nfont-size:150%;\'>&#x2015;</span>'
                writehandle.write('<h4>' + tempLineString + ' ' + str(index) + ' -- '  + entry.name + '</h4>\n')
                paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq = entry.retrieveInfoReport()
                globalParam = [False for i in param]
                writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq, globalParam)
                writehandle.write('<br/>(fixed parameters in <i>italics</i>)\n')
                writehandle.write('<br/>\n')
          else:
            writehandle.write('<h4>Global fit</h4>\n')
            paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq, globalParam = self.parent.globalarea.reportGlobalParam()
            writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq, globalParam)
            writehandle.write('<br/>(fixed parameters in <i>italics</i>)\n')
            writehandle.write('<br/>(global parameters in <b>bold</b>)\n')
  
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')

        # define HTML translation of plot symbols
        translatedStyles = {'.': '&#x2022;', ',': '&#x2015;', 'o': '&#x25cf;', 'v': '&#x25bc;', '^': '&#x25b2;', '<': '&#x25c0;', '>': '&#x25b6;',\
                            '1': 'Y', '2': 'Y', '3': 'Y', '4': 'Y', '8': '&#x25cf;', 's': '&#x25fc;', 'p': '&#x2b1f;', '*': '&#x2605;',\
                            'h': '&#x2b22;', 'H': '&#x2b22;', '+': '<b>+</b>', 'x': '&#x00d7;', 'D': '&#x25c6;', 'd': '&#x25c6;',\
                            '|': '|', '_': '-', 'P': '&#x2b1f;', 'X': '&#x00d7;', 0: '-', 1: '-', 2: '|', 3: '|', 4: '&#x25c0;', 5: '&#x25b6;',\
                            6: '&#x25b2;', 7: '&#x25bc;', 8: '&#x25c0;', 9: '&#x25b6;', 10: '&#x25b2;', 11: '&#x25bc;',\
                            'None': '&#x2015;', None: '&#x2015;', ' ': '&#x2015;', '': '&#x2015;'}
        filledStyles = ['.', 'o', 'v', '^', '<', '>', '8', 's', 'p', 'P', '*', 'h', 'H', 'd', 'D', 'X', 4, 5, 6, 7, 8, 9, 10, 11]
        translatedOpenStyles = {'.': '&#x25cb;', 'o': '&#x25cb;', 'v': '&#x25bd;', '^': '&#x25b3;', '<': '&#x25c1;', '>': '&#x25b7;',\
                            '8': '&#x25cb;', 's': '&#x25fb;', 'p': '&#x2b20;', '*': '&#x2606;',\
                            'h': '&#x2b21;', 'H': '&#x2b21;', 'x': '&#x00d7;', 'D': '&#x25c7;', 'd': '&#x25c7;',\
                            'P': '&#x2b20;', 'X': '&#x00d7;', 4: '&#x25c1;', 5: '&#x25b7;',\
                            6: '&#x25b3;', 7: '&#x25bd;', 8: '&#x25c1;', 9: '&#x25b7;', 10: '&#x25b3;', 11: '&#x25bd;'}
        noneStyles = ['None', None, ' ', '']

        # write data
        dataFlag, dataButtons = False, []
        if(self.parent.lastFitType != 'global'):
          # collate and order data sets
          useDatasets = [i for i in self.parent.data if (i.visibility)]
          useDatasets = sorted(useDatasets, key=lambda k: k.zorder)
          if(len(useDatasets)):
            writehandle.write('<div class="flexmatic">\n')
            for entry in useDatasets:
              index = useDatasets.index(entry)
              dataButtons.append(index)
              values, roles = entry.getData_n_Fit()
              writehandle.write('<a href="javascript:;" onclick="togglitsch(\'data_' + str(index) + '\')" class="toggle">\n')
              useSymbol = entry.style['marker']
              if((useSymbol in filledStyles) or (useSymbol in CUSTOM_MARKERS)):
                useColor = entry.style['markerfacecolor']
                if((not entry.style['doFill']) and (useSymbol in translatedOpenStyles)):
                  useColor = entry.style['markeredgecolor']
              elif(useSymbol in noneStyles):
                useColor = entry.style['color']
              else:
                useColor = entry.style['markeredgecolor']
              if(useSymbol in translatedStyles):
                translatedSymbol = translatedStyles[useSymbol]
                if((not entry.style['doFill']) and (useSymbol in translatedOpenStyles)):
                  translatedSymbol = translatedOpenStyles[useSymbol]
              elif(useSymbol in CUSTOM_MARKERS):
                # replace funky symbols by default circle
                translatedSymbol = translatedStyles['o']
                if(not entry.style['doFill']):
                  translatedSymbol = translatedOpenStyles['o']
              else:
                translatedSymbol = translatedStyles['None']
              tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in useColor[0:3]]) + ');\nfont-size:150%;\'>' + translatedSymbol + '</span>'
              writehandle.write('<h3 id="data_' + str(index) + '_ctrl">&#9744; ' + tempLineString + ' Data set ' + entry.name + '</h3>\n')
              writehandle.write('</a>\n')
              writehandle.write('<div id="data_' + str(index) + '" style="display:none;">\n')
              writehandle.write('<button id="data_' + str(index) + '_button" class="little">Copy Data</button>\n')
              writehandle.write('<div id="data_' + str(index) + '_content">\n')
              writehandle.write('<table>\n<thead>\n<tr>\n')
              for header in roles:
                writehandle.write('<th>' + str(header) + '</th>\n')
              writehandle.write('</tr>\n</thead>\n')
              # write data table
              writehandle.write('<tbody>\n')
              resultsData = values
              # check for selection
              if(self.parent.selectedData.isLive and (entry == self.parent.data[self.parent.activeData])):
                indices = self.parent.selectedData.getIndices()
              else:
                indices = []
              for count, row in enumerate(resultsData):
                # deal with selection
                if(len(roles) and (count < len(indices)) and indices[count]):
                  if(count + 1 < len(resultsData)):
                    writehandle.write('<tr class="selected">\n')
                  else:
                    writehandle.write('<tr class="selected last">\n')
                elif(count + 1 < len(resultsData)):
                  writehandle.write('<tr>\n')
                else:
                  writehandle.write('<tr class="last">\n')
                row = [self.parent.formatNumber(i) for i in row]
                rowstring = '</td><td>'.join(row)
                writehandle.write('<td>' + rowstring + '</td>')
                writehandle.write('\n</tr>\n')
    
              writehandle.write('</tbody>\n</table>\n')
              # did we have selected data?
              if(len(indices)):
                writehandle.write('<br/>(selected data in <span style="background-color:#aaaaee;">blue</span>)\n')
              writehandle.write('</div>\n')
              writehandle.write('</div>\n')

            writehandle.write('</div>\n')
        else:
          if(len(self.parent.lastFitGlobalDataSets)):
            for index in self.parent.lastFitGlobalDataSets:
              if(index < len(self.parent.data)):
                dataFlag = True
                
            if(dataFlag):
              writehandle.write('<div class="flexmatic">\n')
              for index in self.parent.lastFitGlobalDataSets:
                if(index < len(self.parent.data)):
                  dataButtons.append(index)
                  values, roles = self.parent.data[index].getData_n_Fit()
                  writehandle.write('<a href="javascript:;" onclick="togglitsch(\'data_' + str(index) + '\')" class="toggle">\n')
                  useSymbol = self.parent.data[index].style['marker']
                  if((useSymbol in filledStyles) or (useSymbol in CUSTOM_MARKERS)):
                    useColor = self.parent.data[index].style['markerfacecolor']
                    if((not self.parent.data[index].style['doFill']) and (useSymbol in translatedOpenStyles)):
                      useColor = self.parent.data[index].style['markeredgecolor']
                  elif(useSymbol in noneStyles):
                    useColor = self.parent.data[index].style['color']
                  else:
                    useColor = self.parent.data[index].style['markeredgecolor']
                  if(useSymbol in translatedStyles):
                    translatedSymbol = translatedStyles[useSymbol]
                    if((not self.parent.data[index].style['doFill']) and (useSymbol in translatedOpenStyles)):
                      translatedSymbol = translatedOpenStyles[useSymbol]
                  elif(useSymbol in CUSTOM_MARKERS):
                    # replace funky symbols by default circle
                    translatedSymbol = translatedStyles['o']
                    if(not self.parent.data[index].style['doFill']):
                      translatedSymbol = translatedOpenStyles['o']
                  else:
                    translatedSymbol = translatedStyles['None']
                  tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in useColor[0:3]]) + ');\nfont-size:150%;\'>' + translatedSymbol + '</span>'
                  writehandle.write('<h3 id="data_' + str(index) + '_ctrl">&#9744; ' + tempLineString + ' Data set ' + self.parent.data[index].name + '</h3>\n')
                  writehandle.write('</a>\n')
                  writehandle.write('<div id="data_' + str(index) + '" style="display:none;">\n')
                  writehandle.write('<button id="data_' + str(index) + '_button" class="little">Copy Data</button>\n')
                  writehandle.write('<div id="data_' + str(index) + '_content">\n')
                  writehandle.write('<table>\n<thead>\n<tr>\n')
                  for header in roles:
                    writehandle.write('<th>' + str(header) + '</th>\n')
                  writehandle.write('</tr>\n</thead>\n')
                  # write data table
                  writehandle.write('<tbody>\n')
                  resultsData = values
                  for count, row in enumerate(resultsData):
                    if(count + 1 < len(resultsData)):
                      writehandle.write('<tr>\n')
                    else:
                      writehandle.write('<tr class="last">\n')
                    row = [self.parent.formatNumber(i) for i in row]
                    rowstring = '</td><td>'.join(row)
                    writehandle.write('<td>' + rowstring + '</td>')
                    writehandle.write('\n</tr>\n')
    
                  writehandle.write('</tbody>\n</table>\n')
                  writehandle.write('</div>\n')
                  writehandle.write('</div>\n')
              
              writehandle.write('</div>\n')

        # write simulated data as well
        functionFlag, functionButtons = False, []
        if(self.parent.lastFitType != 'global'):
          # collate and order curves
          useCurves = [i for i in self.parent.fit if (i.visibility)]
          useCurves = sorted(useCurves, key=lambda k: k.zorder)
          if(len(useCurves)):
            writehandle.write('<div class="flexmatic">\n')
            for entry in useCurves:
              index = useCurves.index(entry)
              functionButtons.append(index)
              simX, simY = entry.x, entry.y
              writehandle.write('<a href="javascript:;" onclick="togglitsch(\'fxn_' + str(index) + '\')" class="toggle">\n')
              tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in entry.style['color'][0:3]]) + ');\nfont-size:150%;\'>&#x2015;</span>'
              writehandle.write('<h3 id="fxn_' + str(index) + '_ctrl">&#9744; ' + tempLineString + ' Curve ' + entry.name + '</h3>\n')
              writehandle.write('</a>\n')
              writehandle.write('<div id="fxn_' + str(index) + '" style="display:none;">\n')
              writehandle.write('<span class="mypre">\n' + entry.ffuncstr_base + '</span>\n<br/><br/>\n')
              writehandle.write('<button id="fxn_' + str(index) + '_button" class="little">Copy Curve</button>\n')
              writehandle.write('<div id="fxn_' + str(index) + '_content">\n')
              writehandle.write('<table>\n<thead>\n<tr>\n')
              writehandle.write('<th>x</th>\n<th>f(x)</th>\n')
              writehandle.write('<tbody>\n')
              for count, row in enumerate(range(len(simX))):
                if(count + 1 < len(simX)):
                  writehandle.write('<tr>\n')
                else:
                  writehandle.write('<tr class="last">\n')
                writehandle.write('<td>' + self.parent.formatNumber(simX[row]) + '</td>')
                writehandle.write('<td>' + self.parent.formatNumber(simY[row]) + '</td>')
                writehandle.write('\n</tr>\n')
              writehandle.write('</tbody>\n</table>\n')
              writehandle.write('</div>\n')
              writehandle.write('</div>\n')

            writehandle.write('</div>\n')
        else:
          if(len(self.parent.lastFitGlobalCurves)):
            for index in self.parent.lastFitGlobalCurves:
              if(index < len(self.parent.fit)):
                functionFlag = True
                
          if(functionFlag):
            writehandle.write('<div class="flexmatic">\n')
            for index in self.parent.lastFitGlobalCurves:
              if(index < len(self.parent.fit)):
                functionButtons.append(index)
                simX, simY = self.parent.fit[index].x, self.parent.fit[index].y
                writehandle.write('<a href="javascript:;" onclick="togglitsch(\'fxn_' + str(index) + '\')" class="toggle">\n')
                tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in self.parent.fit[index].style['color'][0:3]]) + ');\nfont-size:150%;\'>&#x2015;</span>'
                writehandle.write('<h3 id="fxn_' + str(index) + '_ctrl">&#9744; ' + tempLineString + ' Curve ' + self.parent.fit[index].name + '</h3>\n')
                writehandle.write('</a>\n')
                writehandle.write('<div id="fxn_' + str(index) + '" style="display:none;">\n')
                writehandle.write('<span class="mypre">\n' + self.parent.fit[index].ffuncstr_base + '</span>\n<br/><br/>\n')
                writehandle.write('<button id="fxn_' + str(index) + '_button" class="little">Copy Curve</button>\n')
                writehandle.write('<div id="fxn_' + str(index) + '_content">\n')
                writehandle.write('<table>\n<thead>\n<tr>\n')
                writehandle.write('<th>x</th>\n<th>f(x)</th>\n')
                writehandle.write('<tbody>\n')
                for count, row in enumerate(range(len(simX))):
                  if(count + 1 < len(simX)):
                    writehandle.write('<tr>\n')
                  else:
                    writehandle.write('<tr class="last">\n')
                  writehandle.write('<td>' + self.parent.formatNumber(simX[row]) + '</td>')
                  writehandle.write('<td>' + self.parent.formatNumber(simY[row]) + '</td>')
                  writehandle.write('\n</tr>\n')
                writehandle.write('</tbody>\n</table>\n')
                writehandle.write('</div>\n')
                writehandle.write('</div>\n')

            writehandle.write('</div>\n')
          
        writehandle.write('</div>\n')
        writehandle.write('<div class="disclaimer">generated by fit-o-mat v' + VERSION + ' by @MoeglichLab</div>\n')

        # add style definitions
        writehandle.write('</body>\n')
        writehandle.write('<style type="text/css">\n')
        writehandle.write('.container {\npadding: 0;\nmargin: 0;\ndisplay: flex;\nflex-direction: row;\
          \nalign-items: flex-start;\n}\n')
        writehandle.write('.flexmatic {\npadding: 5px;\nmargin: 0;\nflex: 0 0 auto;\n}\n')
        writehandle.write('.flexmatic2 {\npadding: 5px;\nmargin: 0;\nflex: 1 1 auto;\n')
        if(max_width != 0):
          writehandle.write('max-width: ' + max_width + ';\n')
        writehandle.write('min-width: 250pt;\n}\n')
        writehandle.write('svg {\nwidth: 100%;\nheight: auto;\n}\n')
        writehandle.write('h3 {\ntext-align: left;\nwhite-space: nowrap;\n}\n')
        writehandle.write('.disclaimer {\nposition: fixed;\nbottom: 0px;\nright: 0px;\nfont-size: 125%;\
                                        \ncolor: #333333;\nbackground-color: rgba(255, 255, 255, 0.5);\
                                        \nborder: 1px;\nborder-style: solid;\nborder-radius: 2px;\
                                        \nborder-color: #333333;\npadding: 2px 10px 2px 10px;\n}\n')
        writehandle.write('td.rite {\ntext-align: right;\n}\n')
        writehandle.write('td.fixed {\ncolor: #555555;\nfont-style: italic;\n}\n')
        writehandle.write('td.global {\nfont-weight: bold;\n}\n')
        writehandle.write('tr.last > td {\nborder-bottom: 1px solid #333333;\n}\n')
        writehandle.write('tr.selected > td {\nbackground-color: #aaaaee;\n}\n')
        writehandle.write('th {\nborder-bottom: 1px solid #333333;\n}\n')
        writehandle.write('table.param  > tbody > tr:nth-child(odd) > td {\nbackground-color: #cccccc;\n}\n')
        writehandle.write('a.toggle {\ntext-decoration: none;\ncolor: inherit;\n}\n')
        writehandle.write('button.little {\nfont-size: 75%;\n}\n')
        writehandle.write('.mypre {\nwhite-space: pre;\n}\n')
        writehandle.write('</style>\n\n')

        # add script controls
        writehandle.write('<script language="javascript">\n')
        writehandle.write('function togglitsch(id){\n')
        writehandle.write('\tvar content;\n')
        writehandle.write('\tif(document.getElementById(id).style.display == \'none\'){\n')
        writehandle.write('\t\tdocument.getElementById(id).style.display = \'block\';\n')
        writehandle.write('\t\tcontent = document.getElementById(id + \'_ctrl\').innerHTML;\n')
        writehandle.write('\t\tdocument.getElementById(id + \'_ctrl\').innerHTML = \'&#9746;\' + content.slice(1)\n')
        writehandle.write('\t} else {\n')
        writehandle.write('\t\tdocument.getElementById(id).style.display = \'none\';\n')
        writehandle.write('\t\tcontent = document.getElementById(id + \'_ctrl\').innerHTML;\n')
        writehandle.write('\t\tdocument.getElementById(id + \'_ctrl\').innerHTML = \'&#9744;\' + content.slice(1)\n')
        writehandle.write('\t}\n}\n\n')

        writehandle.write('// controls for copy to clipboard\n')
        writehandle.write('function copyHelper(item, mode){\n')
        writehandle.write('\t// selects target range and then restores previous selection\n')
        writehandle.write('\tvar sel, backup = [];\n\n')
        writehandle.write('\t// backup ranges\n')
        writehandle.write('\tsel = window.getSelection();\n')
        writehandle.write('\tfor(let i = 0; i < sel.rangeCount; i++) {\n')
        writehandle.write('\t\tbackup[i] = sel.getRangeAt(i);\n')
        writehandle.write('\t}\n\n')
        writehandle.write('\t// delete previous ranges\n')
        writehandle.write('\tsel.removeAllRanges();\n')
        writehandle.write('\tif(mode){\n')
        writehandle.write('\t\tsel.addRange(item);\n')
        writehandle.write('\t} else {\n')
        writehandle.write('\t\titem.focus();\n')
        writehandle.write('\t\titem.select();\n')
        writehandle.write('\t}\n')
        writehandle.write('\t// copy selection\n')
        writehandle.write('\tdocument.execCommand(\'copy\');\n')
        writehandle.write('\t// restore previous selection\n')
        writehandle.write('\tsel.removeAllRanges();\n')
        writehandle.write('\tfor(let i = 0; i < backup.length; i++) {\n')
        writehandle.write('\t\tsel.addRange(backup[i]);\n')
        writehandle.write('\t}\n}\n\n')

        writehandle.write('function copyThis(targetId){\n')
        writehandle.write('\tvar body = document.body, target, range;\n')
        writehandle.write('\ttarget = document.getElementById(targetId);\n\n')
        writehandle.write('\tif (document.createRange && window.getSelection) {\n')
        writehandle.write('\t\t// select target stuff\n')
        writehandle.write('\t\trange = document.createRange();\n')
        writehandle.write('\t\ttry {\n')
        writehandle.write('\t\t\trange.selectNodeContents(target);\n')
        writehandle.write('\t\t} catch (e) {\n')
        writehandle.write('\t\t\trange.selectNode(target);\n')
        writehandle.write('\t\t}\n')
        writehandle.write('\t\tcopyHelper(range, true);\n')
        writehandle.write('\t}\n}\n\n')
        
        writehandle.write('// enable copy of SVG plots\n')
        writehandle.write('function copyThisInnerHTML(targetId){\n')
        writehandle.write('\tvar target, textarea, scrollX, scrollY;\n')
        writehandle.write('\ttarget = document.getElementById(targetId);\n')
        writehandle.write('\t// create dummy text area to temporarily paste innerHTML data\n')
        writehandle.write('\ttextarea = document.createElement(\'textarea\');\n')
        writehandle.write('\ttextarea.style.height = 0;\n')
        writehandle.write('\tscrollX = window.scrollX;\n')
        writehandle.write('\tscrollY = window.scrollY;\n')
        writehandle.write('\tdocument.body.appendChild(textarea);\n')
        writehandle.write('\t// now fill in textarea\n')
        writehandle.write('\ttextarea.value = target.innerHTML;\n')
        writehandle.write('\t// now call copyThis() on the temp object\n')
        writehandle.write('\tcopyHelper(textarea, false);\n')
        writehandle.write('\t// clean up the mess\n')
        writehandle.write('\tdocument.body.removeChild(textarea);\n')
        writehandle.write('\twindow.scroll(scrollX, scrollY);\n')
        writehandle.write('}\n\n')

        writehandle.write('// set up ctrl buttons\n')
        if(self.parent.lastFitType != 'none'):
          items = ['results']
        else:
          items = []
        for entry in dataButtons:
          items.append('data_' + str(entry))
        if(len(curvesOnDisplay)):
          items.append('param')
        for entry in functionButtons:
          items.append('fxn_' + str(entry))
        for entry in items:
          writehandle.write('var btn_' + entry + ' = document.getElementById(\'' + entry + '_button\');\n')
          writehandle.write('btn_' + entry + '.addEventListener(\'click\', function(event) {\n')
          writehandle.write('\tcopyThis(\'' + entry + '_content\');\n')
          writehandle.write('});\n\n')
      
        writehandle.write('var btn_plot = document.getElementById(\'plot_button\');\n')
        writehandle.write('btn_plot.addEventListener(\'click\', function(event) {\n')
        writehandle.write('\tcopyThisInnerHTML(\'plot_content\');\n')
        writehandle.write('});\n\n')

        writehandle.write('</script>\n')
        writehandle.write('</html>\n')
        writehandle.close()
        
        # save filename for future use
        self.currExportFile = filename
      
  def writeXLS(self, filename=None):
    # writes Results table to Excel file
    if(filename != None):
      try:
        workbook = xlsxwriter.Workbook(filename)
        worksheet = workbook.add_worksheet()
      except:
        self.parent.statusbar.showMessage('Cannot write data file ' + filename, self.parent.STATUS_TIME)
      else:
        # check whether current fit results are available
        index = 0
        if(self.parent.lastFitType != 'none'):
          # further check whether these are local or global results
          if(self.parent.lastFitType == 'local'):
            fitresults = self.parent.fitarea.outstring.splitlines()
          else:
            fitresults = self.parent.globalarea.globalOutstring.splitlines()
          for index, entry in enumerate(fitresults):
            worksheet.write(index, 0, entry)
        offset = index + 2
        # write header
        if((self.tableModel != None) and (self.tableModel.columnCount() > 0)):
          resultsHeader = self.tableModel.getHeaders()
          worksheet.write_row(offset, 0, resultsHeader)
          # write data
          resultsData = self.tableModel.getAllData()
          for rowIndex, row in enumerate(resultsData):
            row = [float(self.parent.formatNumber(i)) if (j != 'labels') else i for i, j in zip(row, resultsHeader)]
            worksheet.write_row(rowIndex + offset + 1, 0, row)
          coloffset = self.tableModel.columnCount() + 1
        else:
          coloffset = 0
        # write simulated data as well
        simX, simY = self.parent.fit[self.parent.activeFit].x, self.parent.fit[self.parent.activeFit].y
        worksheet.write(offset, coloffset, 'x')
        worksheet.write(offset, coloffset + 1, 'f(x)')
        for row in range(len(simX)):
          worksheet.write(row + offset + 1, coloffset, simX[row])
          worksheet.write(row + offset + 1, coloffset + 1, simY[row])
        # write graphics
        chart = workbook.add_chart({'type': 'scatter'})
        worksheet.insert_chart(chr(coloffset+1+67)+str(offset+2), chart)
        # write fit
        chart.add_series({'categories': ['Sheet1', offset+1, coloffset, offset + row + 1, coloffset],\
                          'values': ['Sheet1', offset+1, coloffset + 1, offset + row + 1, coloffset + 1],\
                          'line': {'color': 'red'},\
                          'name': 'fit',\
                          'marker': {'type': 'none'}})
        # write data (if present)
        if(('x' in self.descriptors) and ('y' in self.descriptors)):
          xcol = self.descriptors.index('x'); ycol = self.descriptors.index('y')
          rowcount = self.tableModel.rowCount()
          chartdict = {'categories': ['Sheet1', offset+1, xcol, offset + rowcount, xcol],\
                            'values': ['Sheet1', offset+1, ycol, offset + rowcount, ycol],\
                            'name': 'data',\
                            'marker': {'type': 'diamond'}}
          # include x-errors
          if('xerr' in self.descriptors):
            xerrcol = self.descriptors.index('xerr')
            rangestring = 'Sheet1!$' + chr(xerrcol + 65) + '$' + str(offset + 2) + ':$' + chr(xerrcol + 65) + '$' + str(offset + 1 + rowcount)
            chartdict['x_error_bars'] = {'type': 'custom',\
                     'plus_values': rangestring,\
                     'minus_values': rangestring}
          # include y-errors
          if('yerr' in self.descriptors):
            yerrcol = self.descriptors.index('yerr')
            rangestring = 'Sheet1!$' + chr(yerrcol + 65) + '$' + str(offset + 2) + ':$' + chr(yerrcol + 65) + '$' + str(offset + 1 + rowcount)
            chartdict['y_error_bars'] = {'type': 'custom',\
                     'plus_values': rangestring,\
                     'minus_values': rangestring}
          chart.add_series(chartdict)
    
        workbook.close()

  def setDataSet(self, currIndex=0, maxIndex=None):
    # updates spinbox for dataset selection
    if(maxIndex != None):
      self.dataSetSpinBox.setMaximum(maxIndex + 1)
      if(maxIndex):
        self.dataSetSpinBox.setEnabled(True)
      else:
        self.dataSetSpinBox.setEnabled(False)
    # set spin box
    self.dataSetSpinBox.blockSignals(True)
    self.dataSetSpinBox.setValue(currIndex + 1)
    self.dataSetSpinBox.blockSignals(False)
    # trigger update
    self.changeDataSet()

  def changeDataSet(self):
    # change dataset to display
    currIndex = self.dataSetSpinBox.value()
    values, descriptors = self.parent.data[currIndex - 1].getData_n_Fit()
    labels = self.parent.data[currIndex - 1].getLabels()
    self.dataSetName.setText(self.parent.data[currIndex - 1].name)
    # now set table content
    self.updateResults(values=values, descriptors=descriptors, labels=labels)
    # now check for presence of selectedData and update row selection
    if(self.parent.selectedData.isLive and (currIndex == self.parent.activeData + 1)):
      selectIndices = [i for i, j in enumerate(self.parent.selectedData.getIndices()) if j]
      self.selectTheseRows(selectIndices)
    
  def updateResults(self, values=[], descriptors=[], labels=[]):
    # updates results table
    if(len(values)):
      # prepare table
      if(len(labels)):
        descriptors.append('labels')
        values = values.tolist()
        values = [i + [str(j)] for i, j in zip(values, labels)]
      self.descriptors = descriptors
      self.tableModel = TableModel(values, self.resultstable)
      self.resultstable.setModel(self.tableModel)
      self.tableModel.setAllHeaders(self.descriptors)

      # set col width
      self.colWidth = int(self.resultstable.size().width() / 4.5)
      hheader = self.resultstable.horizontalHeader()
      hheader.setDefaultSectionSize(self.colWidth)

      # sponsored by recent PyQt5 version, we have to reset the row height
      vheader = self.resultstable.verticalHeader()
      vheader.setDefaultSectionSize(self.rowHeight)
      vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    else:
      self.tableModel = None
      nullModel = TableModel([], self.resultstable)
      self.resultstable.setModel(nullModel)

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Copy):
      # prepare output
      selind = self.resultstable.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])      
      # get data
      selectedData = self.tableModel.getDataRows(selind)
      output = ''
      for row in selectedData:
        row = [str(i) for i in row]
        output += '\t'.join(row) + '\n'
      
      clipboard = QtWidgets.QApplication.clipboard()
      clipboard.setText(output)
    else:
      QtWidgets.QWidget.keyPressEvent(self, event)

class BlankResizeMenu(KuhMenu):
  def __init__(self, parent = None, tableWidget = None):
    super(BlankResizeMenu, self).__init__()
    self.parent = parent
    self.tableWidget = tableWidget
    self.nrow, self.ncol = self.tableWidget.getDimension()
      
    # int validator
    self.validInt = MyValidInt()

    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[2]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.blankResizeLabel = QtWidgets.QLabel()
    useFont = self.blankResizeLabel.font()
    useFont.setBold(True)
    self.blankResizeLabel.setFont(useFont)
    self.blankResizeLabel.setText('Blank/resize table')
    self.vLayout.addWidget(self.blankResizeLabel)
    
    # rows
    self.setRowGroup = QWidgetMac()
    self.vLayout.addWidget(self.setRowGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.setRowGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.setRowLabel = QtWidgets.QLabel('# rows')
    self.setRowLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.setRowLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.setRowLabel)

    self.setRowEntry = QLineEditClick()
    self.setRowEntry.setToolTip('Number of rows in data table')
    self.setRowEntry.setText(str(self.nrow))
    self.setRowEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setRowEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setRowEntry.editingFinished.connect(partial(self.setDimension, self.setRowEntry, 'row', 1, 1e6))
    self.setRowEntry.setValidator(self.validInt)
    self.hLayout.addWidget(self.setRowEntry)

    # cols
    self.setColGroup = QWidgetMac()
    self.vLayout.addWidget(self.setColGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.setColGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.setColLabel = QtWidgets.QLabel('# cols')
    self.setColLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.setColLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.setColLabel)

    self.setColEntry = QLineEditClick()
    self.setColEntry.setToolTip('Number of columns in data table')
    self.setColEntry.setText(str(self.ncol))
    self.setColEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setColEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setColEntry.editingFinished.connect(partial(self.setDimension, self.setColEntry, 'col', 1, 1e6))
    self.setColEntry.setValidator(self.validInt)
    self.hLayout2.addWidget(self.setColEntry)
    
    # resize button
    self.resizeButton = QPushButtonMac()
    self.resizeButton.setText('Resize table')
    self.resizeButton.setToolTip('Resize data table to new dimensions\n(cell contents outside new limits will irretrievably be deleted)')
    self.resizeButton.clicked.connect(self.resizeTable)
    self.resizeButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resizeButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.vLayout.addWidget(self.resizeButton)

    # blank button
    self.blankButton = QPushButtonMac()
    self.blankButton.setText('Blank table')
    self.blankButton.setToolTip('Create blank data table with new dimensions\n(previous cell contents will irretrievably be deleted)')
    self.blankButton.clicked.connect(self.blankTable)
    self.blankButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.blankButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.vLayout.addWidget(self.blankButton)

    self.setFocus()    
    self.focusNextChild()

  def setDimension(self, entryfield=None, target=None, minval=1, maxval=100):
    # sets number of rows/cols in data table
    if((entryfield != None) and (target != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = min(value, maxval)
      value = max(value, minval)
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))

      # update row/column count
      if(target == 'row'):
        self.nrow = value
      else:
        self.ncol = value
          
  def blankTable(self):
    # resets table to empty new table
    self.tableWidget.generateEmptyTable(self.ncol, self.nrow)
    self.close()
    
  def resizeTable(self):
    # resizes table to new dimensions
    self.tableWidget.resizeTable(self.ncol, self.nrow)
    self.close()

class DataArea(QWidgetMac):
  def __init__(self, parent = None):
    super(DataArea, self).__init__()
    self.parent = parent
    self.errorSwitch, self.errorXSwitch = True, False
    self.errorModel, self.errorXModel = 0, 1
    self.errorConst, self.errorXConst = 1.0, 1.0
    self.errorPercent, self.errorXPercent = 5.0, 5.0
    self.errorMultiply, self.errorXMultiply = 1.0, 1.0
    self.errorPropagate = True
    self.reductionSwitch, self.reductionModel = False, 1
    self.reductionSkip = 1
    self.reductionAvg = 2
    self.reductionMovAvg = 2
    self.reductionLog = 100
    self.sheetNumber = 1
    self.transposeData = False
    self.importFilter = ''
    self.firstLoad = True

    self.buildRessource()
    self.tableWidget.generateEmptyTable(3, 50)
    
    # set up namespace
    # import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()

  def buildRessource(self):
    # set up GUI
    self.validFloat = MyValidFloat()
    self.validInt = MyValidInt()
    self.validInt.setBottom(1)

    # set up data table
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.importBox = QWidgetMac()
    self.vLayout.addWidget(self.importBox)
    self.importLayout = QtWidgets.QHBoxLayout(self.importBox)
    self.importLayout.setContentsMargins(0, 0, 0, 0)
    self.importLayout.setAlignment(QtCore.Qt.AlignLeft)
    
    self.importButton = QPushButtonMac()
    self.importButton.setText('Open File')
    if(PYCORN_PRESENT):
      self.importButton.setToolTip('Import Excel, text or unicorn data\n(Ctrl-I)')
    else:
      self.importButton.setToolTip('Import Excel or text data\n(Ctrl-I)')
    self.importButton.clicked.connect(self.loadData)
    self.importButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.importButton)

    self.resizeButton = QPushButtonMac()
    self.resizeButton.setText('Blank/Resize \u25be')
    self.resizeButton.setToolTip('Clear the data sheet and/or alter its dimensions')
    self.resizeButton.clicked.connect(partial(self.blankResizeTable, self.resizeButton))
    self.resizeButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.resizeButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.resizeButton)

    self.killCommaButton = QPushButtonMac()
    self.killCommaButton.setText('Replace Comma')
    self.killCommaButton.setToolTip('Replace all commata in data sheet by periods')
    self.killCommaButton.clicked.connect(self.killTheComma)
    self.killCommaButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.killCommaButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.killCommaButton)

    self.transposeCheck = QPushButtonCheckable()
    self.transposeCheck.setText('transpose?')
    self.transposeCheck.setToolTip('Swap columns and rows in data sheet')
    self.transposeCheck.setChecked(False)
    self.transposeCheck.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.transposeCheck.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.transposeCheck.clicked.connect(self.dataTransposition)
    self.importLayout.addWidget(self.transposeCheck)
    
    self.sheetBox = QWidgetMac()
    self.vLayout.addWidget(self.sheetBox)
    self.sheetLayout = QtWidgets.QHBoxLayout(self.sheetBox)
    self.sheetLayout.setContentsMargins(0, 0, 0, 0)
    self.sheetLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.importSheetLabel = QtWidgets.QLabel('sheet')
    self.importSheetLabel.setMaximumSize(scaledDPI(28), scaledDPI(BASE_SIZE))
    self.importSheetLabel.setMinimumSize(scaledDPI(28), scaledDPI(BASE_SIZE))
    self.sheetLayout.addWidget(self.importSheetLabel)
    self.importSheetLabel.setEnabled(False)
    
    self.importSheetSpinBox = QSpinBoxToolTip()
    self.importSheetSpinBox.setToolTip('Select data sheet within Excel file')
    self.importSheetSpinBox.setAlignment(QtCore.Qt.AlignRight)
    self.importSheetSpinBox.setMinimum(1)
    self.importSheetSpinBox.setMaximum(self.sheetNumber)
    self.importSheetSpinBox.setValue(1)
    self.importSheetSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.importSheetSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.importSheetSpinBox.valueChanged.connect(self.changeSheet)
    self.importSheetSpinBox.setEnabled(False)
    self.sheetLayout.addWidget(self.importSheetSpinBox)
    
    self.importSheetName = QtWidgets.QLabel()
    self.sheetLayout.addWidget(self.importSheetName)
    self.sheetBox.hide()

    self.tableWidget = DataTable(self)
    self.vLayout.addWidget(self.tableWidget)
    
    # import options
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.dataImportLabel = QtWidgets.QLabel()
    useFont = self.dataImportLabel.font()
    useFont.setBold(True)
    self.dataImportLabel.setFont(useFont)
    self.dataImportLabel.setText('Data Import Options')
    self.vLayout.addWidget(self.dataImportLabel)

    # set up box for x-error specification
    self.errorXSelectorBox = QWidgetMac()
    self.errorXSelectorBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorXSelectorBox)
    self.errorXSelectorLayout = QtWidgets.QHBoxLayout(self.errorXSelectorBox)
    self.errorXSelectorLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setSpacing(scaledDPI(2))
    
    self.errorXSelectorLabel = QPushButtonCheckable()
    self.errorXSelectorLabel.setChecked(self.errorXSwitch)
    self.errorXSelectorLabel.setText('error x')
    self.errorXSelectorLabel.setToolTip('Set error \u0394x for x values')
    self.errorXSelectorLabel.clicked.connect(partial(self.toggleErrorSwitch, 'x'))
    self.errorXSelectorLabel.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorXSelectorLabel.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorXSelectorLayout.addWidget(self.errorXSelectorLabel)
    
    self.errorXSelectorGroup = QtWidgets.QGroupBox()
    self.errorXSelectorGroup.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorXSelectorGroup.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorXSelectorLayout.addWidget(self.errorXSelectorGroup)

    self.errorXGroupLayout = QtWidgets.QHBoxLayout()
    self.errorXSelectorGroup.setLayout(self.errorXGroupLayout)
    
    self.errorXSelectorButtons = []
    self.errorXSelectorButtons.append(QRadioButtonToolTip(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(236), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(False)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 0))
    self.errorXSelectorButtons[-1].setText('\u0394x \u00D7')
    self.errorXSelectorButtons[-1].setToolTip('Use assigned \u0394x error column')
    self.errorXDeltaEntry = QLineEditClick(self.errorXSelectorGroup)
    self.errorXDeltaEntry.setGeometry(QtCore.QRect(scaledDPI(284), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorXDeltaEntry.setText(str(self.errorXMultiply))
    self.errorXDeltaEntry.setToolTip('Multiply assigned \u0394x by factor')
    self.errorXDeltaEntry.setValidator(self.validFloat)
    self.errorXDeltaEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorXDeltaEntry, 'errorXMultiply'))
    self.errorXDeltaEntry.focusOutEvent = partial(self.lostFocus, self.errorXDeltaEntry, 'errorXMultiply', self.errorXDeltaEntry.focusOutEvent)
    self.errorXDeltaEntry.focusInEvent = partial(self.gainFocus, self.errorXSelectorButtons[-1], self.errorXDeltaEntry.focusInEvent)
    
    self.errorXSelectorButtons.append(QRadioButtonToolTip(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(True)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 1))
    self.errorXSelectorButtons[-1].setText('const')
    self.errorXSelectorButtons[-1].setToolTip('Use constant \u0394x error')
    self.errorXConstEntry = QLineEditClick(self.errorXSelectorGroup)
    self.errorXConstEntry.setGeometry(QtCore.QRect(scaledDPI(56), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorXConstEntry.setText(str(self.errorXConst))
    self.errorXConstEntry.setToolTip('Use constant \u0394x error')
    self.errorXConstEntry.setValidator(self.validFloat)
    self.errorXConstEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorXConstEntry, 'errorXConst'))
    self.errorXConstEntry.focusOutEvent = partial(self.lostFocus, self.errorXConstEntry, 'errorXConst', self.errorXConstEntry.focusOutEvent)
    self.errorXConstEntry.focusInEvent = partial(self.gainFocus, self.errorXSelectorButtons[-1], self.errorXConstEntry.focusInEvent)
    
    self.errorXSelectorButtons.append(QRadioButtonToolTip(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(122), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(False)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 2))
    self.errorXSelectorButtons[-1].setText('prop')
    self.errorXSelectorButtons[-1].setToolTip('Use \u0394x error proportional to x value')
    self.errorXPercentEntry = QLineEditClick(self.errorXSelectorGroup)
    self.errorXPercentEntry.setGeometry(QtCore.QRect(scaledDPI(168), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorXPercentEntry.setText(str(self.errorXPercent))
    self.errorXPercentEntry.setToolTip('Use \u0394x error proportional to x value')
    self.errorXPercentEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorXPercentEntry, 'errorXPercent'))
    self.errorXPercentEntry.focusOutEvent = partial(self.lostFocus, self.errorXPercentEntry, 'errorXPercent', self.errorXPercentEntry.focusOutEvent)
    self.errorXPercentEntry.focusInEvent = partial(self.gainFocus, self.errorXSelectorButtons[-1], self.errorXPercentEntry.focusInEvent)
    self.errorXPercentEntry.setValidator(self.validFloat)
    self.errorXPercentLabel = QtWidgets.QLabel(self.errorXSelectorGroup)
    self.errorXPercentLabel.setGeometry(QtCore.QRect(scaledDPI(212), scaledDPI(2), scaledDPI(18), scaledDPI(BASE_SIZE)))
    self.errorXPercentLabel.setText('%')

    # set up controls for y error
    self.errorSelectorBox = QWidgetMac()
    self.errorSelectorBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorSelectorBox)
    self.errorSelectorLayout = QtWidgets.QHBoxLayout(self.errorSelectorBox)
    self.errorSelectorLayout.setContentsMargins(0, 0, 0, 0)
    
    self.errorSelectorLabel = QPushButtonCheckable()
    self.errorSelectorLabel.setChecked(self.errorSwitch)
    self.errorSelectorLabel.setText('error y')
    self.errorSelectorLabel.setToolTip('Set error \u0394y for y values')
    self.errorSelectorLabel.clicked.connect(partial(self.toggleErrorSwitch, 'y'))
    self.errorSelectorLabel.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorSelectorLabel.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorSelectorLayout.addWidget(self.errorSelectorLabel)

    self.errorSelectorGroup = QtWidgets.QGroupBox()
    self.errorSelectorGroup.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorSelectorGroup.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorSelectorLayout.addWidget(self.errorSelectorGroup)

    self.errorGroupLayout = QtWidgets.QHBoxLayout()
    self.errorSelectorGroup.setLayout(self.errorGroupLayout)
    
    self.errorSelectorButtons = []
    self.errorSelectorButtons.append(QRadioButtonToolTip(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(236), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(True)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 0))
    self.errorSelectorButtons[-1].setText('\u0394y \u00D7')
    self.errorSelectorButtons[-1].setToolTip('Use assigned \u0394y error column')
    self.errorDeltaEntry = QLineEditClick(self.errorSelectorGroup)
    self.errorDeltaEntry.setGeometry(QtCore.QRect(scaledDPI(284), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorDeltaEntry.setText(str(self.errorMultiply))
    self.errorDeltaEntry.setToolTip('Multiply assigned \u0394y by factor')
    self.errorDeltaEntry.setValidator(self.validFloat)
    self.errorDeltaEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorDeltaEntry, 'errorMultiply'))
    self.errorDeltaEntry.focusOutEvent = partial(self.lostFocus, self.errorDeltaEntry, 'errorMultiply', self.errorDeltaEntry.focusOutEvent)
    self.errorDeltaEntry.focusInEvent = partial(self.gainFocus, self.errorSelectorButtons[-1], self.errorDeltaEntry.focusInEvent)
    
    self.errorSelectorButtons.append(QRadioButtonToolTip(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(False)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 1))
    self.errorSelectorButtons[-1].setText('const')
    self.errorSelectorButtons[-1].setToolTip('Use constant \u0394y error')
    self.errorConstEntry = QLineEditClick(self.errorSelectorGroup)
    self.errorConstEntry.setGeometry(QtCore.QRect(scaledDPI(56), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorConstEntry.setText(str(self.errorConst))
    self.errorConstEntry.setToolTip('Use constant \u0394y error')
    self.errorConstEntry.setValidator(self.validFloat)
    self.errorConstEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorConstEntry, 'errorConst'))
    self.errorConstEntry.focusOutEvent = partial(self.lostFocus, self.errorConstEntry, 'errorConst', self.errorConstEntry.focusOutEvent)
    self.errorConstEntry.focusInEvent = partial(self.gainFocus, self.errorSelectorButtons[-1], self.errorConstEntry.focusInEvent)
    
    self.errorSelectorButtons.append(QRadioButtonToolTip(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(122), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(False)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 2))
    self.errorSelectorButtons[-1].setText('prop')
    self.errorSelectorButtons[-1].setToolTip('Use \u0394y error proportional to y value')
    self.errorPercentEntry = QLineEditClick(self.errorSelectorGroup)
    self.errorPercentEntry.setGeometry(QtCore.QRect(scaledDPI(168), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorPercentEntry.setText(str(self.errorPercent))
    self.errorPercentEntry.setToolTip('Use \u0394y error proportional to y value')
    self.errorPercentEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorPercentEntry, 'errorPercent'))
    self.errorPercentEntry.focusOutEvent = partial(self.lostFocus, self.errorPercentEntry, 'errorPercent', self.errorPercentEntry.focusOutEvent)
    self.errorPercentEntry.focusInEvent = partial(self.gainFocus, self.errorSelectorButtons[-1], self.errorPercentEntry.focusInEvent)
    self.errorPercentEntry.setValidator(self.validFloat)
    self.errorPercentLabel = QtWidgets.QLabel(self.errorSelectorGroup)
    self.errorPercentLabel.setGeometry(QtCore.QRect(scaledDPI(212), scaledDPI(2), scaledDPI(18), scaledDPI(BASE_SIZE)))
    self.errorPercentLabel.setText('%')
    
    # set up controls for error propagation
    self.errorPropagateBox = QWidgetMac()
    self.errorPropagateBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorPropagateBox)
    self.errorPropagateLayout = QtWidgets.QHBoxLayout(self.errorPropagateBox)
    self.errorPropagateLayout.setContentsMargins(0, 0, 0, 0)
    
    self.errorPropagateCheck = QPushButtonCheckable()
    self.errorPropagateCheck.setToolTip('Propagate data errors through transformation')
    self.errorPropagateCheck.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorPropagateCheck.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.errorPropagateCheck.setChecked(self.errorPropagate)
    self.errorPropagateCheck.setText('propagate?')
    self.errorPropagateCheck.clicked.connect(self.toggleErrorPropagation)
    self.errorPropagateLayout.addWidget(self.errorPropagateCheck)
    self.errorPropagateLayout.addStretch()
    self.vLayout.addWidget(self.HLine())

    # set up box for data reduction
    self.dataReductionBox = QWidgetMac()
    self.dataReductionBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataReductionBox)
    self.dataReductionLayout = QtWidgets.QHBoxLayout(self.dataReductionBox)
    self.dataReductionLayout.setContentsMargins(0, 0, 0, 0)
    
    self.dataReductionLabel = QPushButtonCheckable()
    self.dataReductionLabel.setChecked(self.reductionSwitch)
    self.dataReductionLabel.setText('reduce')
    self.dataReductionLabel.setToolTip('Reduction of data upon import')
    self.dataReductionLabel.clicked.connect(self.toggleReductionSwitch)
    self.dataReductionLabel.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataReductionLabel.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataReductionLayout.addWidget(self.dataReductionLabel)
    
    self.dataReductionGroup = QtWidgets.QGroupBox()
    self.dataReductionGroup.setMinimumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataReductionGroup.setMaximumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataReductionLayout.addWidget(self.dataReductionGroup)
    
    self.dataReductionButtons = []
    self.dataReductionButtons.append(QRadioButtonToolTip(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(True)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 1))
    self.dataReductionButtons[-1].setText('skip')
    self.dataReductionButtons[-1].setToolTip('Skip n data points')

    self.dataSkipEntry = QLineEditClick(self.dataReductionGroup)
    self.dataSkipEntry.setGeometry(QtCore.QRect(scaledDPI(56), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataSkipEntry.setText(str(self.reductionSkip))
    self.dataSkipEntry.setToolTip('Skip n data points')
    self.dataSkipEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataSkipEntry, 'reductionSkip'))
    self.dataSkipEntry.focusOutEvent = partial(self.lostFocusInt, self.dataSkipEntry, 'reductionSkip', self.dataSkipEntry.focusOutEvent)
    self.dataSkipEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataSkipEntry.focusInEvent)
    self.dataSkipEntry.setValidator(self.validInt)
    
    self.dataSkipLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataSkipLabel.setGeometry(QtCore.QRect(scaledDPI(100), scaledDPI(2), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataSkipLabel.setText('pts')

    self.dataReductionButtons.append(QRadioButtonToolTip(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(122), scaledDPI(2), scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 2))
    self.dataReductionButtons[-1].setText('avg')
    self.dataReductionButtons[-1].setToolTip('Average n data points')

    self.dataAvgEntry = QLineEditClick(self.dataReductionGroup)
    self.dataAvgEntry.setGeometry(QtCore.QRect(scaledDPI(168), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataAvgEntry.setText(str(self.reductionAvg))
    self.dataAvgEntry.setToolTip('Average n data points')
    self.dataAvgEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataAvgEntry, 'reductionAvg'))
    self.dataAvgEntry.focusOutEvent = partial(self.lostFocusInt, self.dataAvgEntry, 'reductionAvg', self.dataAvgEntry.focusOutEvent)
    self.dataAvgEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataAvgEntry.focusInEvent)
    self.dataAvgEntry.setValidator(self.validInt)
    
    self.dataAvgLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataAvgLabel.setGeometry(QtCore.QRect(scaledDPI(212), scaledDPI(2), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataAvgLabel.setText('pts')

    self.dataReductionButtons.append(QRadioButtonToolTip(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(BASE_SIZE + 4), scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 3))
    self.dataReductionButtons[-1].setText('mvavg')
    self.dataReductionButtons[-1].setToolTip('Moving average of n data points')

    self.dataMovAvgEntry = QLineEditClick(self.dataReductionGroup)
    self.dataMovAvgEntry.setGeometry(QtCore.QRect(scaledDPI(56), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataMovAvgEntry.setText(str(self.reductionMovAvg))
    self.dataMovAvgEntry.setToolTip('Moving average of n data points')
    self.dataMovAvgEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataMovAvgEntry, 'reductionMovAvg'))
    self.dataMovAvgEntry.focusOutEvent = partial(self.lostFocusInt, self.dataMovAvgEntry, 'reductionMovAvg', self.dataMovAvgEntry.focusOutEvent)
    self.dataMovAvgEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataMovAvgEntry.focusInEvent)
    self.dataMovAvgEntry.setValidator(self.validInt)
    
    self.dataMovAvgLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataMovAvgLabel.setGeometry(QtCore.QRect(scaledDPI(100), scaledDPI(BASE_SIZE + 4), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataMovAvgLabel.setText('pts')

    self.dataReductionButtons.append(QRadioButtonToolTip(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(122), scaledDPI(BASE_SIZE + 4), scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 4))
    self.dataReductionButtons[-1].setText('log')
    self.dataReductionButtons[-1].setToolTip('Logarithmically reduce data to ~ n data points')

    self.dataLogEntry = QLineEditClick(self.dataReductionGroup)
    self.dataLogEntry.setGeometry(QtCore.QRect(scaledDPI(168), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataLogEntry.setText(str(self.reductionLog))
    self.dataLogEntry.setToolTip('Logarithmically reduce data to ~ n data points')
    self.dataLogEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataLogEntry, 'reductionLog'))
    self.dataLogEntry.focusOutEvent = partial(self.lostFocusInt, self.dataLogEntry, 'reductionLog', self.dataLogEntry.focusOutEvent)
    self.dataLogEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataLogEntry.focusInEvent)
    self.dataLogEntry.setValidator(self.validInt)

    self.dataLogLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataLogLabel.setGeometry(QtCore.QRect(scaledDPI(212), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataLogLabel.setText('pts (ca.)')
    self.vLayout.addWidget(self.HLine())

    # set up box for data transform
    self.dataTransformBox = QWidgetMac()
    self.dataTransformBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataTransformBox)
    self.dataTransformLayout = QtWidgets.QHBoxLayout(self.dataTransformBox)
    self.dataTransformLayout.setContentsMargins(0, 0, 0, 0)
    
    self.dataTransformXCheck = QPushButtonCheckable()
    self.dataTransformXCheck.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataTransformXCheck.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataTransformXCheck.setChecked(False)
    self.dataTransformXCheck.setText('transform x')
    self.dataTransformLayout.addWidget(self.dataTransformXCheck)
    self.dataTransformXCheck.setToolTip('Transformation of x values upon import')

    self.dataTransformLabel = QtWidgets.QLabel('x = ')
    self.dataTransformLabel.setMaximumSize(scaledDPI(20), scaledDPI(BASE_SIZE))
    self.dataTransformLabel.setMinimumSize(scaledDPI(20), scaledDPI(BASE_SIZE))
    self.dataTransformLayout.addWidget(self.dataTransformLabel)

    self.dataTransformXEntry = QLineEditClick()
    self.dataTransformXEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.dataTransformXEntry.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.dataTransformXEntry.setMinimumSize(scaledDPI(300), scaledDPI(BASE_SIZE))
    self.dataTransformXEntry.setText('x')
    self.dataTransformXEntry.setToolTip('Formula for transforming x values')
    self.dataTransformXEntry.textChanged.connect(partial(self.dataTransformXCheck.setChecked, True))
    self.dataTransformLayout.addWidget(self.dataTransformXEntry)

    self.dataTransformYBox = QWidgetMac()
    self.dataTransformYBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataTransformYBox)
    self.dataTransformYLayout = QtWidgets.QHBoxLayout(self.dataTransformYBox)
    self.dataTransformYLayout.setContentsMargins(0, 0, 0, 0)

    self.dataTransformYCheck = QPushButtonCheckable()
    self.dataTransformYCheck.setMaximumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataTransformYCheck.setMinimumSize(scaledDPI(64), scaledDPI(BASE_SIZE))
    self.dataTransformYCheck.setChecked(False)
    self.dataTransformYCheck.setText('transform y')
    self.dataTransformYLayout.addWidget(self.dataTransformYCheck)
    self.dataTransformYCheck.setToolTip('Transformation of y values upon import')

    self.dataTransformYLabel = QtWidgets.QLabel('y = ')
    self.dataTransformYLabel.setMaximumSize(scaledDPI(20), scaledDPI(BASE_SIZE))
    self.dataTransformYLabel.setMinimumSize(scaledDPI(20), scaledDPI(BASE_SIZE))
    self.dataTransformYLayout.addWidget(self.dataTransformYLabel)

    self.dataTransformYEntry = QLineEditClick()
    self.dataTransformYEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.dataTransformYEntry.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.dataTransformYEntry.setMinimumSize(scaledDPI(300), scaledDPI(BASE_SIZE))
    self.dataTransformYEntry.setText('y')
    self.dataTransformYEntry.setToolTip('Formula for transforming y values')
    self.dataTransformYEntry.textChanged.connect(partial(self.dataTransformYCheck.setChecked, True))
    self.dataTransformYLayout.addWidget(self.dataTransformYEntry)

    # set up data import controls
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    
    self.refreshBox = QWidgetMac()
    self.refreshBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.refreshBox)
    self.refreshLayout = QtWidgets.QHBoxLayout(self.refreshBox)
    self.refreshLayout.setContentsMargins(0, 0, 0, 0)
    self.refreshButton = QPushButtonMac()
    self.refreshButton.setText('Import Data')
    self.refreshButton.setToolTip('Import the currently selected cells in the data table')
    self.refreshButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.refreshButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.refreshButton.clicked.connect(partial(self.updateData, False, True, False, False))
    self.refreshLayout.addWidget(self.refreshButton, stretch=2)

    self.refreshCreateButton = QPushButtonMac()
    self.refreshCreateButton.setText('Import && Create')
    self.refreshCreateButton.setToolTip('Generate a new data object and import the currently selected cells in the data table')
    self.refreshCreateButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.refreshCreateButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.refreshCreateButton.clicked.connect(partial(self.updateData, False, True, False, True))
    self.refreshLayout.addWidget(self.refreshCreateButton, stretch=1)

    self.dataSeriesButton = QPushButtonMac()
    self.dataSeriesButton.setText('Import Series')
    self.dataSeriesButton.setToolTip('Import y column and all data columns to its right')
    self.dataSeriesButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.dataSeriesButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.dataSeriesButton.clicked.connect(self.importDataSeries)
    self.refreshLayout.addWidget(self.dataSeriesButton, stretch=1)
    
    self.refreshCheck = QPushButtonCheckable()
    self.refreshCheck.setText('Auto Import?')
    self.refreshCheck.setChecked(False)
    self.refreshCheck.clicked.connect(partial(self.updateData, True, True, False, False))
    #self.refreshLayout.addWidget(self.refreshCheck)

  def reportState(self):
    # reports data content for saveState function
    retv = self.tableWidget.tableModel.getAllData()
    return retv

  def restoreState(self, data):
    # restores data content from loadState function
    try:
      tableData = literal_eval(data[0])
      self.resetSheetSpinBox(currVal=1, maxVal=1, currName='')
      self.transposeCheck.setChecked(False)
      
      self.tableWidget.restoreTable(tableData=tableData)
    except:
      print('Failed to restore data table ' + data[0])

  def killTheComma(self):
    # scour data table for commata and replace them
    self.tableWidget.killTheComma()

  def dataTransposition(self):
    # set data transposition flag
    self.transposeData = self.transposeCheck.isChecked()
    # trigger data transposition
    self.tableWidget.transposeTable()

  def resetSheetSpinBox(self, currVal=1, maxVal=1, currName=''):
    # updates import spin box
    self.importSheetSpinBox.setMaximum(maxVal)
    self.sheetNumber = currVal
    self.importSheetSpinBox.setValue(self.sheetNumber)
    
    if(maxVal > 1):
      self.sheetBox.show()
      self.importSheetSpinBox.setEnabled(True)
      self.importSheetLabel.setEnabled(True)
      self.importSheetName.setText(currName)
    else:
      self.importSheetSpinBox.setEnabled(False)
      self.importSheetLabel.setEnabled(False)
      self.importSheetName.setText('')
      self.sheetBox.hide()

  def changeSheet(self):
    # change current sheet in Excel files with several sheets
    self.sheetNumber = self.importSheetSpinBox.value()
    self.tableWidget.changeSheet(self.sheetNumber, transpose=self.transposeData)

  def gainFocus(self, toggleOption=None, defaultHandler=None, event=None):
    # entry field gained focus
    # select corresponding option
    if(toggleOption != None):
      toggleOption.setChecked(True)

    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)

  def toggleDataReduction(self, mode=0):
    # change error model
    self.reductionModel = mode
    # check switch button
    self.dataReductionLabel.setChecked(True)
    self.reductionSwitch = True

  def toggleReductionSwitch(self):
    # do data reduction?
    value = self.dataReductionLabel.isChecked()
    self.reductionSwitch = value

  def toggleErrorModel(self, mode=0):
    # change error model
    self.errorModel = mode
    # check switch button
    self.errorSelectorLabel.setChecked(True)
    self.errorSwitch = True

  def toggleErrorXModel(self, mode=0):
    # change error model
    self.errorXModel = mode
    # check switch button
    self.errorXSelectorLabel.setChecked(True)
    self.errorXSwitch = True

  def toggleErrorSwitch(self, axis='y'):
    # use errors?
    if(axis in ['x', 'y']):
      if(axis == 'y'):
        value = self.errorSelectorLabel.isChecked()
        self.errorSwitch = value
      else:
        value = self.errorXSelectorLabel.isChecked()
        self.errorXSwitch = value

  def toggleErrorPropagation(self):
    # toggles error propagation
    self.errorPropagate = self.errorPropagateCheck.isChecked()

  def lostFocusInt(self, entryobject=None, quantity=None, defaultHandler=None, event=None):
    # entry field lost focus, perform sanity check
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        self.__dict__[quantity] = int(entrytext)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))
    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)
    
  def validateReductionEntry(self, entryobject=None, quantity=None):
    # validates entryfield
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        newnumber = int(entrytext)
        self.__dict__[quantity] = np.abs(newnumber)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))

  def lostFocus(self, entryobject=None, quantity=None, defaultHandler=None, event=None):
    # entry field lost focus, perform sanity check
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        self.__dict__[quantity] = float(entrytext)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))
    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)
    
  def validateErrorEntry(self, entryobject=None, quantity=None):
    # validates entryfield
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        newnumber = float(entrytext)
        self.__dict__[quantity] = np.abs(newnumber)
        if(newnumber < 0):
          entryobject.setText(str(np.abs(newnumber)))
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def importDataSeries(self):
    # greedy import of data
    cycleColors = self.parent.objectsarea.cycleColors
    # check whether any data has been loaded
    if((self.tableWidget.tableModel == None) or (self.tableWidget.tableModel.rowCount() == 0)):
      self.parent.statusbar.showMessage('Open a data file first!', self.parent.STATUS_TIME)
    else:
      # can do this by repeatedly calling updateData
      roles = self.tableWidget.roles
      columnCount = self.tableWidget.tableModel.columnCount()
      
      # check for presence of x and y
      if((not 'x' in roles) or (not 'y' in roles)):
        self.parent.statusbar.showMessage('Assign x and y columns!', self.parent.STATUS_TIME)
      else:
        # remember original y column
        originalY = roles['y']
        
        # change dataset style to line and no symbol
        style = self.parent.data[self.parent.activeData].getStyle()
        if(style['linestyle'] == 'None'):
          self.parent.data[self.parent.activeData].setStyle('linestyle', 'solid', redraw=False)
        if(style['marker'] != 'None'):
          self.parent.data[self.parent.activeData].setStyle('marker', 'None', redraw=False)
        
        # loop over columns
        successes = 0
        currY = originalY
        while((currY < columnCount) and (successes < 100)):
          # check whether current column is already assigned to sth. else
          if((currY == originalY) or (not (currY in list(roles.values())))):
            # update status message as this can take a while
            self.parent.statusbar.showMessage('Now processing column ' + str(currY + 1) + '!', self.parent.STATUS_TIME, color='blue')
            # set current color
            currColor = (currY - originalY) % len(cycleColors)
            self.parent.data[self.parent.activeData].setStyle('color', cycleColors[currColor], redraw=False)
            # assign new y column
            self.tableWidget.roles['y'] = currY
            # get the new data
            self.updateData(docheck=False, redraw=False, quiet=True, create=False)
            # check the new data
            nuData = self.parent.data[self.parent.activeData].value()
            if(('x' in nuData) and (len(nuData['x']))):
              # keep track of successes
              successes += 1
              if((currY + 1 < columnCount) and (successes < 100)):
                # generate a new data set (if needed)
                self.parent.data.append(DataObject(self.parent))
                self.parent.data[-1].setName('Data_' + str(len(self.parent.data)-1))
                # need to copy contents of original object
                self.parent.data[-1].spawned(self.parent.data[self.parent.activeData])
                # reinit values (as they were copied by spawned)
                self.parent.data[-1].initValues()
                # set new data object as active
                self.parent.activeData = (len(self.parent.data) - 1)
                # need to update dataset table, otherwise updateData() will fail
                self.parent.objectsarea.refreshDataTable()
          currY += 1
        
        # restore original roles
        self.tableWidget.roles['y'] = originalY
        
        # update objects area
        self.parent.objectsarea.refreshDataTable()
        self.parent.objectsarea.refreshResidTable()
        self.parent.objectsarea.refreshCurvesTable()
        self.parent.objectsarea.refreshExtrasTable()
        self.parent.globalarea.updateDataSetTable()
        
        # update results table
        self.parent.resultsarea.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)

        # issue refresh of plots
        self.parent.plotArea.dataplotwidget.myRefresh()
        self.parent.plotArea.residplotwidget.myRefresh()

  def updateData(self, docheck=False, redraw=True, quiet=False, create=False):
    # check whether autoimport enabled
    if ((not docheck) or (self.refreshCheck.isChecked())):
      # check whether any data has been loaded
      if((self.tableWidget.tableModel == None) or (self.tableWidget.tableModel.rowCount() == 0)):
        self.parent.statusbar.showMessage('Open a data file first!', self.parent.STATUS_TIME)
      else:
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        QtCore.QCoreApplication.processEvents()

        # if selected dataset exists, clear it
        if(self.parent.selectedData.isLive):
          self.parent.selectedData.clearMe(redraw=False)
        
        # check whether we need to retrieve x-err and y-err columns at all
        needXErr, needYErr = self.errorXSwitch and (not self.errorXModel), self.errorSwitch and (not self.errorModel)
        # get and process data
        useLabelFlag = False
        new_data, roles = self.tableWidget.getData(needXErr=needXErr, needYErr=needYErr)
        if(needXErr and ('xerr' in roles)):
          # apply factor to x errors
          errXCol = roles.index('xerr')
          new_data = [[k if (j != errXCol) else (k * self.errorXMultiply) for j, k in enumerate(i)] for i in new_data]
        if(needYErr and ('yerr' in roles)):
          # apply factor to x errors
          errYCol = roles.index('yerr')
          new_data = [[k if (j != errYCol) else (k * self.errorMultiply) for j, k in enumerate(i)] for i in new_data]
        if('labels' in roles):
          # separate numerical data from labels
          labelCol = roles.index('labels')
          labels = [str(i[labelCol]) for i in new_data]
          new_data = [[k for j, k in enumerate(i) if j != labelCol] for i in new_data]
          newRoles = [i for i in roles if i != 'labels']
          # check whether x values in roles
          # if no x-values present (but labels), generate pseudo-x categories on the fly
          if(not 'x' in roles):
            newRoles.append('x')
            roles.append('x')
            for index, row in enumerate(new_data):
              row.append(index)
            useLabelFlag = True
        else:
          labels = []
          newRoles = roles
        labels = np.array(labels)
        new_data = np.array(new_data)
 
        # check for presence of x and y
        if((not 'x' in roles) or (not 'y' in roles)):
          if(not quiet):
            self.parent.statusbar.showMessage('Assign x (or, labels) and y columns!', self.parent.STATUS_TIME)
        else:
          # check whether the new selection makes sense
          array_dim = new_data.shape
          if(len(array_dim) == 1):
            if(array_dim[0] > 0):
              if(not quiet):
                self.parent.statusbar.showMessage('Select at least two data rows!', self.parent.STATUS_TIME)
            elif(self.tableWidget.hasComma()):
              if(not quiet):
                self.parent.statusbar.showMessage('Select some data to import them -- try replacing comma in data!', self.parent.STATUS_TIME)
            else:
              if(not quiet):
                self.parent.statusbar.showMessage('Select some data to import them!', self.parent.STATUS_TIME)
          elif ((len(array_dim) > 1) and (array_dim[1] > 1)):
            # process the error model for y
            if(self.errorSwitch):
              if(self.errorModel):
                if(self.errorModel == 1):
                  # use const
                  errors = [self.errorConst] * array_dim[0]
                  errors = np.array(errors)
                elif(self.errorModel ==2):
                  # use percentage of y
                  if('y' in newRoles):
                    index = newRoles.index('y')
                    errors = [self.errorPercent / 100.0 * i for i in new_data[:, index]]
                    errors = np.array(errors)
                    #errors = errors.transpose()
                  else:
                    if(not quiet):
                      self.parent.statusbar.showMessage('Cannot locate y values for percentage error calculation!', self.parent.STATUS_TIME, color='blue')
                    
                # check if y-error column already exists
                if('yerr' in newRoles):
                  index = newRoles.index('yerr')
                  new_data[:, index] = errors
                else:
                  newRoles.append('yerr')
                  # repackage errors to enable hstacking
                  errors = [[i] for i in errors]
                  errors = np.array(errors)
                  new_data = np.hstack((new_data, errors))
            else:
              # no errors => possibly delete yerr column
              if('yerr' in newRoles):
                index = newRoles.index('yerr')
                newRoles.pop(index)
                new_data = np.delete(new_data, index, 1)
              
            # process the error model for x
            if(self.errorXSwitch):
              if(self.errorXModel):
                if(self.errorXModel == 1):
                  # use const
                  errors = [self.errorXConst] * array_dim[0]
                  errors = np.array(errors)
                elif(self.errorXModel ==2):
                  # use percentage of x
                  if('x' in newRoles):
                    index = newRoles.index('x')
                    errors = [self.errorXPercent / 100.0 * i for i in new_data[:,index]]
                    errors = np.array(errors)
                  else:
                    if(not quiet):
                      self.parent.statusbar.showMessage('Cannot locate x values for percentage error calculation!', self.parent.STATUS_TIME, color='blue')
                    
                # check if x-error column already exists
                if('xerr' in newRoles):
                  index = newRoles.index('xerr')
                  new_data[:,index] = errors
                else:
                  newRoles.append('xerr')
                  # repackage errors to enable hstacking
                  errors = [[i] for i in errors]
                  errors = np.array(errors)
                  new_data = np.hstack((new_data, errors))
            else:
              # no x errors => possibly delete xerr column
              if('xerr' in newRoles):
                index = newRoles.index('xerr')
                newRoles.pop(index)
                new_data = np.delete(new_data, index, 1)
              
             # process the data reduction model
            if(self.reductionSwitch):
              if(self.reductionModel == 1):
                # skip data points by numpy slicing
                new_data = new_data[::self.reductionSkip + 1]
                if('labels' in roles):
                  labels = labels[::self.reductionSkip + 1]
              elif(self.reductionModel == 2):
                # average with error propagation
                if('labels' in roles):
                  new_data, labels = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionAvg, stepsize=self.reductionAvg, labels=labels)
                else:
                  new_data = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionAvg, stepsize=self.reductionAvg)
              elif(self.reductionModel == 3):
                # moving average with error propagation
                if('labels' in roles):
                  new_data, labels = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionMovAvg, stepsize=1, labels=labels)
                else:
                  new_data = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionMovAvg, stepsize=1)
              elif(self.reductionModel == 4):
                # logarithmic data reduction
                if('labels' in roles):
                  new_data, labels = self.logAverage(sourceData=new_data, roles=newRoles, targetpoints=self.reductionLog, labels=labels)
                else:
                  new_data = self.logAverage(sourceData=new_data, roles=newRoles, targetpoints=self.reductionLog)
                
            # do data transform if necessary
            # make copy of original data in case we also have to transform y axis
            if(self.dataTransformYCheck.isChecked()):
              new_data2 = deepcopy(new_data)
            if(self.dataTransformXCheck.isChecked()):
              formula = str(self.dataTransformXEntry.text())
              if(len(formula) > 0):
                # transformer
                formula = 'x = ' + formula
                new_data = self.transformer(sourceData=new_data, roles=newRoles, formula=formula, axis='x')
              else:
                if(not quiet):
                  self.parent.statusbar.showMessage('Enter formula for x transformation!', self.parent.STATUS_TIME)
                
            if(self.dataTransformYCheck.isChecked()):
              formula = str(self.dataTransformYEntry.text())
              if(len(formula) > 0):
                # transformer
                formula = 'y = ' + formula
                new_data2 = self.transformer(sourceData=new_data2, roles=newRoles, formula=formula, axis='y')
                # replace y and yerr columns in new_data
                ycol = newRoles.index('y')
                new_data[:,ycol] = new_data2[:,ycol]
                # do error propagation?
                if(('yerr' in newRoles) and self.errorPropagate):
                  yerrcol = newRoles.index('yerr')
                  new_data[:,yerrcol] = new_data2[:,yerrcol]
              else:
                if(not quiet):
                  self.parent.statusbar.showMessage('Enter formula for y transformation!', self.parent.STATUS_TIME)
                
            # delete all rows with non-numerical content
            for role in newRoles:
              index = newRoles.index(role)
              if('labels' in roles):
                labels = labels[np.isfinite(new_data[:,index])]
              new_data = new_data[np.isfinite(new_data[:,index])]
  
            # assign new data
            if(create):
              self.parent.objectsarea.dataSetCreate()
              self.parent.activeData = len(self.parent.data) - 1
            if('labels' in roles):
              labels = list(labels)
              self.parent.data[self.parent.activeData].setData(new_data, newRoles, labels=labels)
            else:
              self.parent.data[self.parent.activeData].setData(new_data, newRoles)
            
            # make data object visibile
            self.parent.objectsarea.dataSetTable.cellWidget(self.parent.activeData, 0).setChecked(True)
            self.parent.data[self.parent.activeData].setVisibility(True, redraw=False)
            
            # here we should update the plot
            self.parent.data[self.parent.activeData].handleData, self.parent.data[self.parent.activeData].handleErr, self.parent.data[self.parent.activeData].handleErrShady,\
              self.parent.data[self.parent.activeData].handleBar, self.parent.data[self.parent.activeData].handleStack, self.parent.data[self.parent.activeData].handleStackNeg,\
              self.parent.data[self.parent.activeData].handleText, self.parent.data[self.parent.activeData].handleViolin = \
              self.parent.plotArea.plotData(self.parent.data[self.parent.activeData].value(), dataobject = self.parent.data[self.parent.activeData], \
              handleData = self.parent.data[self.parent.activeData].handleData, handleErr = self.parent.data[self.parent.activeData].handleErr, handleErrShady=self.parent.data[self.parent.activeData].handleErrShady,\
              handleBar = self.parent.data[self.parent.activeData].handleBar, handleStack = self.parent.data[self.parent.activeData].handleStack,\
              handleStackNeg = self.parent.data[self.parent.activeData].handleStackNeg, handleText = self.parent.data[self.parent.activeData].handleText, handleViolin = self.parent.data[self.parent.activeData].handleViolin, redraw=False, autoIgnoreCurrentY=True)
            self.parent.data[self.parent.activeData].handleData_div, self.parent.data[self.parent.activeData].handleErr_div, self.parent.data[self.parent.activeData].handleErrShady_div,\
              self.parent.data[self.parent.activeData].handleBar_div, self.parent.data[self.parent.activeData].handleStack_div, self.parent.data[self.parent.activeData].handleStackNeg_div,\
              self.parent.data[self.parent.activeData].handleText_div, self.parent.data[self.parent.activeData].handleViolin_div = \
              self.parent.plotArea.plotData(self.parent.data[self.parent.activeData].value(), dataobject = self.parent.data[self.parent.activeData], \
              handleData = self.parent.data[self.parent.activeData].handleData_div, handleErr = self.parent.data[self.parent.activeData].handleErr_div, handleErrShady=self.parent.data[self.parent.activeData].handleErrShady_div,\
              handleBar = self.parent.data[self.parent.activeData].handleBar_div, handleStack = self.parent.data[self.parent.activeData].handleStack_div,\
              handleStackNeg = self.parent.data[self.parent.activeData].handleStackNeg_div, handleText = self.parent.data[self.parent.activeData].handleText_div, handleViolin = self.parent.data[self.parent.activeData].handleViolin_div, redraw=False, splitX=True, autoIgnoreCurrentY=True)
            # and we should redraw the fit function to cover new x-range
            self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
              redraw=False, doAutoZoom=False)
            self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
              redraw=False, splitX=True, doAutoZoom=False)
            # copy in case split axes are shown
            curve = self.parent.fit[self.parent.activeFit]
            if(self.parent.plotArea.splitY and curve.onBothAxes):
              curve.duplicateForSplit()
            # check whether we should set category labels on x-axis
            if(useLabelFlag):
              self.parent.plotArea.setDataAxisTicks(dataSet=self.parent.activeData, redraw=False, target='plot')
              self.parent.plotArea.setDataAxisTicks(dataSet=self.parent.activeData, redraw=False, target='resid')
            # and we should update the legend
            self.updateLegend(redraw=redraw)
            # and we should update the corresponding residuals
            self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
              self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText = self.parent.plotArea.plotResid(\
              dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
              handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
              handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
              handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
            self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
              self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div = self.parent.plotArea.plotResid(\
              dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
              handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
              handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
              handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, redraw=False, splitX=True)
            # and we should update the resid plot (as x-axis will most likely have rescaled)
            self.parent.plotArea.setAxisLimits(lower=self.parent.plotArea.minX, upper=self.parent.plotArea.maxX, axis='x',\
              updateLabel=False, target='resid', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=self.parent.plotArea.minX_div, upper=self.parent.plotArea.maxX_div, axis='x2',\
              updateLabel=False, target='resid', redraw=False, updateGrid=True)
            # draw resid line (again) to ensure coverage of entire x range
            self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=False)
            self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=True)
            
            # and we should update the results table
            self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)
          
        QtWidgets.QApplication.restoreOverrideCursor()

  def transformer(self, sourceData=None, roles=None, formula='', axis='x'):
    self.EPSILON = 1e-9
    # does axis transform
    if(axis in ['x', 'y']):
      if(type(sourceData) != type(None)):
        if(axis in roles):
          # try defining transformation function
          try:
            funcstr = 'def transformThis(self, x, y):'
            funcstr += '\n\t' + formula + '\n\treturn ' + axis
            # generate ffunc in local namespace (this is needed for Python3 vs. Python2, bummer)
            namespace = self.mySpace
            exec(funcstr, namespace)
            # now define the new function in the object scope
            setattr(DataArea, 'transformThis', namespace['transformThis'])
          except:
            self.parent.statusbar.showMessage('Error when setting transformation for ' + axis, self.parent.STATUS_TIME)
          else:
            # do the actual transform
            index = roles.index(axis); #val = sourceData[:,index]
            xindex = roles.index('x'); xval = deepcopy(sourceData[:,xindex])
            yindex = roles.index('y'); yval = deepcopy(sourceData[:,yindex])
            try:
              newVal = self.transformThis(xval, yval)
              # now copy transformed data to data matrix
              sourceData[:,index] = newVal
            except:
              self.parent.statusbar.showMessage('Error when calculating transform for ' + axis, self.parent.STATUS_TIME)
            else:
              # deal with data errors
              errname = axis + 'err'
              if(errname in roles):
                errindex = roles.index(errname)
                # numerically determine derivatives in x and y
                # consider x
                if('xerr' in roles):
                  xerrindex = roles.index('xerr'); xerrval = sourceData[:,xerrindex]; xerrval = xerrval ** 2
                  try:
                    xderiv = self.transformThis(xval + self.EPSILON, yval)
                    xderiv = (xderiv - newVal) / self.EPSILON
                    xderiv = xderiv ** 2
                    newErr = xerrval * xderiv
                  except:
                    pass
                else:
                  newErr = np.array([0] * len(newVal))
                
                # consider y
                if('yerr' in roles):
                  yerrindex = roles.index('yerr'); yerrval = sourceData[:,yerrindex]; yerrval = yerrval ** 2
                  try:
                    yderiv = self.transformThis(xval, yval + self.EPSILON)
                    yderiv = (yderiv - newVal) / self.EPSILON
                    yderiv = yderiv ** 2
                    newErr = newErr + (yerrval * yderiv)
                  except:
                    pass
                  
                # calculate root of error
                newErr = newErr ** 0.5
                sourceData[:,errindex] = newErr

    return sourceData

  def logAverage(self, sourceData=None, roles=None, targetpoints=100, labels=np.array([])):
    # reduces data logarithmically to (approx.) target no. of points
    if(type(sourceData) != type(None)):
      if(('x' in roles) and ('y' in roles)):
        # locate x values
        xcol = roles.index('x')
        xval = sourceData[:,xcol]

        # get positive x values
        posXval = xval[xval > 0]
        if(len(posXval) > 0):
          # calculate target x values on log-spaced scale
          logXval = np.linspace(np.log(np.min(posXval)), np.log(np.max(posXval)), targetpoints)
          targetXval = np.exp(logXval)
          targetBoundary = [0]
          targetBoundary.extend([(targetXval[i] + targetXval[i+1])/2 for i in range(len(targetXval)-1)])
          targetBoundary.append(targetXval[-1])

          # cycle through boundary list
          output = np.array([]); avgLabels = []
          for index, entry in enumerate(targetBoundary[:-1]):
            targetRows = sourceData[sourceData[:,xcol] > targetBoundary[index]]
            labelIndex = len(sourceData[sourceData[:,xcol] <= targetBoundary[index]])
            targetRows = targetRows[targetRows[:,xcol] <= targetBoundary[index+1]]
          
            # check current entry
            if(targetRows.size > 0):
              if((len(targetRows.shape) > 1) and (targetRows.shape[0] > 1)):
                # calculate averages
                newRow = []
                for index2, entry2 in enumerate(roles):
                  if(entry2 in ['x', 'y']):
                    # numerically average x and y values
                    newRow.append(np.average(targetRows[:,index2]))
                  elif(entry2 in ['xerr', 'yerr']):
                    errVal = (targetRows[:,index2] / len(targetRows[:,index2])) ** 2
                    errVal = np.sum(errVal) ** 0.5
                    newRow.append(errVal)
                    
                targetRows = np.array(newRow)
                
              if(labels.size):
                avgLabels.append(labels[labelIndex])

              # append current line to output
              if(len(output) > 0):
                output = np.vstack((output, targetRows))
              else:
                output = targetRows
          
          if(labels.size):
            return output, np.array(avgLabels)
          else:
            return output
  
        else:
          self.parent.statusbar.showMessage('No positive x values, cannot do any reduction!', self.parent.STATUS_TIME)
          return sourceData

  def movingAverage(self, sourceData=None, roles=None, average=1, stepsize=1, labels=np.array([])):
    # calculate a moving average with error propagation
    if(type(sourceData) != type(None)):
      if(('x' in roles) and ('y' in roles)):
        # locate x and y values
        xcol = roles.index('x'); ycol = roles.index('y')
        xval = sourceData[:,xcol]
        yval = sourceData[:,ycol]
        # moving average
        avgXval = np.array([np.average(xval[i: i + average]) for i in range(0, len(xval) - average + 1, stepsize)])
        avgYval = np.array([np.average(yval[i: i + average]) for i in range(0, len(yval) - average + 1, stepsize)])
        # check for presence of error values
        if('yerr' in roles):
          # need to do error propagation
          yerrcol = roles.index('yerr')
          yerrval = sourceData[:,yerrcol]
          yerrval = (yerrval / average) ** 2
          # error propagation
          avgYerrval = np.array([np.sum(yerrval[i: i + average]) for i in range(0, len(yerrval) - average + 1, stepsize)])
          avgYerrval = avgYerrval ** 0.5
        elif('xerr' in roles):
          # need to do error propagation
          xerrcol = roles.index('xerr')
          xerrval = sourceData[:,xerrcol] 
          xerrval = (xerrval / average) ** 2
          # error propagation
          avgXerrval = np.array([np.sum(xerrval[i: i + average]) for i in range(0, len(xerrval) - average + 1, stepsize)])
          avgXerrval = avgXerrval ** 0.5
          
        # deal with data labels
        if(labels.size):
          # use label of first data point to be averaged
          avgLabel = np.array([labels[i] for i in range(0, len(xval) - average + 1, stepsize)])

        # now need to assemble columns according to roles
        procData = np.array([])
        for entry in roles:
          # get current column
          if(entry == 'x'):
            addItem = avgXval
          elif(entry == 'y'):
            addItem = avgYval
          elif(entry == 'xerr'):
            addItem = avgXerrval
          elif(entry == 'yerr'):
            addItem = avgYerrval
          
          # assemble output data
          if(procData.size > 0):
            procData = np.vstack((procData, addItem))
          else:
            procData = addItem

        if(labels.size):
          return procData.transpose(), avgLabel
        else:
          return procData.transpose()
        
  def loadData(self):
    global REMEMBERDIR
    filter_options = ['Excel Files (*.xls; *.xlsx)', 'Text Tab Delimited (*.txt)', 'Text Comma Separated (*.txt; *.csv)', 'Text Whitespace Delimited (*.txt)']
    if(PYCORN_PRESENT):
      filter_options.append('Unicorn Files (*.res)')
    filterstring = ';;'.join(filter_options)
    filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self, filter=filterstring, directory = REMEMBERDIR, caption='Open Data', initialFilter=self.importFilter)
    self.importFilter = filter_
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    if(len(filename) > 0):
      mode = filter_options.index(filter_)
      if(mode == 0):
        self.tableWidget.loadXLS(filename=filename, transpose=self.transposeData)
      elif(mode == 1):
        self.tableWidget.loadTextFile(filename=filename, delimiter='\t', transpose=self.transposeData)
      elif(mode == 2):
        self.tableWidget.loadTextFile(filename=filename, delimiter=',', transpose=self.transposeData)
      elif(mode == 3):
        self.tableWidget.loadTextFile(filename=filename, delimiter=None, transpose=self.transposeData)
      elif(mode == 4):
        self.tableWidget.loadUnicornFile(filename=filename, transpose=self.transposeData)
    else:
      return False
    
    # mayhaps display tool tip (only do this on first time after program start)
    if(self.firstLoad):
      self.firstLoad = False
      QtWidgets.QToolTip.showText(self.refreshButton.mapToGlobal(QtCore.QPoint(scaledDPI(50), scaledDPI(-20))), '\u2199 After selecting data, click here to import and plot them', self.refreshButton)

    return True

  def blankResizeTable(self, callButton=None):
    # opens a QMenu to allow blanking and resizing of data table
    self.menu = BlankResizeMenu(self, self.tableWidget)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuY += callButton.geometry().height()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    # open at mouse pointer
    self.menu.popup(QtCore.QPoint(menuX, menuY))

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.plotArea.setLegend(value=value, redraw=redraw)
      
class ShrinkoWidget(QWidgetMac):
  def __init__(self, notify=None, notifyResid=False, parent=None):
    super(ShrinkoWidget, self).__init__()
    self.notify = notify
    self.notifyResid = notifyResid
    self.parent = parent
    
  def resizeEvent(self, event):
    # do the regular resize event
    QtWidgets.QWidget.resizeEvent(self, event)
    # is this the container with the matplot inside?
    if(self.notify != None):
      if(self.notifyResid):
        # can probably skip the horizontal resize as this is already done by the partner shrink-o-widget
        self.notify.verticalRulerResid.updateRuler()
        # also need to update tick entry fields and axis grid
        if(self.parent != None):
          self.parent.updateTickEntryField(axis='resid')
          for axis in ['x', 'x2', 'y']:
            self.parent.drawAxisGrid(axis=axis, target='resid', redraw=False)
      else:
        self.notify.horizontalRuler.updateRuler()
        self.notify.verticalRuler.updateRuler()
        self.parent.destructAboutLogo()
        # also need to update tick entry fields and axis grid
        # still does not fix the issue on split axis toggling
        if(self.parent != None):
          for axis in ['x', 'x2', 'y', 'y2']:
            self.parent.updateTickEntryField(axis=axis)
            self.parent.drawAxisGrid(axis=axis, target='plot', redraw=False)

class Ruler(QtWidgets.QFrame):
  def __init__(self, parent=None, mode=0, resid=False, numTicks=5):
    super(Ruler, self).__init__()
    self.parent = parent
    self.mode = mode
    self.resid = resid
    self.ticks = {}
    self.LARGE_RECTANGLE = 1000
    self.NUMBER_TICKS = numTicks
    self.ROUNDNESS = 3
    self.currwidth, self.currheight, self.currheight_resid = 4.0, 4.0, 1.0
    
    # init appearance
    self.setFrameShape(QtWidgets.QFrame.Box)
    self.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.setStyleSheet('background-color: rgb(255, 255, 255);')

  def paintEvent(self, event):
    # draw ruler
    s = self.size()
    width, height = s.width(), s.height()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.drawRoundedRect(0, 0, width, height, scaledDPI(self.ROUNDNESS), scaledDPI(self.ROUNDNESS))
    
    # draw ticks
    if(self.mode):
      # vertical ruler
      qp.rotate(90)
      for entry in self.ticks:
        posY = int(entry * height + 0.5 - self.LARGE_RECTANGLE / 2)
        label = self.ticks[entry]
        if(entry > 0):
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, label)
          
      # draw dots in between
      labelPos = sorted(list(self.ticks.keys()))
      if(len(labelPos) > 1):
        # extend by one to draw dots beyond last number
        labelPos.append(2.0 * labelPos[-1] - labelPos[-2])
      for index in range(len(labelPos) - 1):
        posY = ((labelPos[index] + labelPos[index + 1]) / 2.0)
        posY = int(posY * height + 0.5 - self.LARGE_RECTANGLE / 2)
        qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u2022')
        ###if((self.resid and (self.currheight_resid >= 2.5)) or ((not self.resid) and (self.currheight > 2.5))):
        # always draw small dots
        if(1):
          # small dots
          posY = ((3.0 * labelPos[index] + labelPos[index + 1]) / 4.0)
          posY = int(posY * height + 0.5 - self.LARGE_RECTANGLE / 2)
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u00b7')
          posY = ((labelPos[index] + 3.0 * labelPos[index + 1]) / 4.0)
          posY = int(posY * height + 0.5 - self.LARGE_RECTANGLE / 2)
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u00b7')
      qp.rotate(-90)
    else:
      # horizontal ruler
      for entry in self.ticks:
        posX = int(entry * width + 0.5 - self.LARGE_RECTANGLE / 2)
        label = self.ticks[entry]
        if(entry > 0):
          # for alignment of text, need to specify a bounding box (which can be fairly large)
          qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, label)
          
      # draw dots in between
      labelPos = sorted(list(self.ticks.keys()))
      if(len(labelPos) > 1):
        # extend by one to draw dots beyond last number
        labelPos.append(2.0 * labelPos[-1] - labelPos[-2])
      for index in range(len(labelPos) - 1):
        posX = ((labelPos[index] + labelPos[index + 1]) / 2.0)
        posX = int(posX * width + 0.5 - self.LARGE_RECTANGLE / 2)
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u2022')
        # small dots
        posX = ((3.0 * labelPos[index] + labelPos[index + 1]) / 4.0)
        posX = int(posX * width + 0.5 - self.LARGE_RECTANGLE / 2)
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u00b7')
        posX = ((labelPos[index] + 3.0 * labelPos[index + 1]) / 4.0)
        posX = int(posX * width + 0.5 - self.LARGE_RECTANGLE / 2)
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u00b7')
      
    qp.end()

  def resizeEvent(self, event):
    # custom resize event
    QtWidgets.QFrame.resizeEvent(self, event)
    ###self.updateRuler()
    ### need to get the synchronization right, has to trigger after canvas resize
    ### we better trigger the update in the parental shrink-o-widget

  def updateRuler(self):
    # updates the ruler
    # first delete all previous ticks
    self.ticks = {}

    # caluclate new ones
    if(self.resid):
      currwidth, currheight = self.parent.residplot.get_size_inches()
      self.currheight_resid = currheight
    else:
      currwidth, currheight = self.parent.matplot.get_size_inches()
      self.currwidth, self.currheight = currwidth, currheight
    
    if(self.mode):
      # vertical ruler
      useTicks = self.NUMBER_TICKS
      if(currheight < 2.5):
        useTicks = 2
      incrementV = int(currheight / useTicks)
      # check for large zoom scale
      escalate = 1
      while(not incrementV):
        escalate *= 2.0
        incrementV = int(escalate * currheight / useTicks)
      incrementV *= 1.0 / escalate
      # and the actual calculation
      currPos, incPos = 0, 1.0 * incrementV / currheight
      while((currPos * incPos) < 1):
        posY = currPos * incPos
        label = currPos * incrementV
        self.ticks[posY] = '{0:g}'.format(label)
        currPos += 1
    else:
      # horizontal ruler
      useTicks = self.NUMBER_TICKS
      if(currwidth < 2.5):
        useTicks = 2
      incrementH = int(currwidth / useTicks)
      # check for large zoom scale
      escalate = 1
      while(not incrementH):
        escalate *= 2.0
        incrementH = int(escalate * currwidth / useTicks)
      incrementH *= 1.0 / escalate
      # and the actual calculation
      currPos, incPos = 0, 1.0 * incrementH / currwidth
      while((currPos * incPos) < 1):
        posX = currPos * incPos
        label = currPos * incrementH
        self.ticks[posX] = '{0:g}'.format(label)
        currPos += 1
      
    # issue paint event
    self.update()

class MyAutoMinorLocator(matplotlib.ticker.AutoMinorLocator):
  # custom minor locator to heed missing major ticks
  def __init__(self, n=None):
    super(MyAutoMinorLocator, self).__init__(n=n)

  def __call__(self):
    'Return the locations of the ticks'
    majorlocs = self.axis.get_majorticklocs()
    # are we on a log scale?
    mode = self.axis.get_scale()

    if(mode != 'log'):
      try:
        majorstep = majorlocs[1] - majorlocs[0]
      except IndexError:
        return []
    else:
      try:
        majorstep = majorlocs[1] / majorlocs[0]
      except IndexError:
        return []
      except ZeroDivisionError:
        return []

    if self.ndivs is None:
      ndivs = 9
    else:
      ndivs = self.ndivs

    # view interval
    vmin, vmax = self.axis.get_view_interval()
    if vmin > vmax:
      vmin, vmax = vmax, vmin

    # calculate minor ticks
    locs = np.array([])
    for index in range(len(majorlocs) - 1):
      # can treat linear and log axes the same
      nulocs = np.linspace(majorlocs[index], majorlocs[index + 1], ndivs + 1)
      locs = np.hstack((locs, nulocs[1: -1]))
    
    # run through conditions
    cond1 = locs >= vmin
    cond2 = locs <= vmax
    locs = locs.compress(cond1 & cond2)

    return self.raise_if_exceeds(np.array(locs))

class MyLassoli(LassoSelector):
  def __init__(self, *args, **kwargs):
    super(MyLassoli, self).__init__(*args, **kwargs)
    self.line.set_linewidth(2.0)
    self.line.set_solid_capstyle('round')
    self.line.set_color([0.2, 0.15, 0.9, 1.0])
    self.line.set_path_effects([PathEffects.withStroke(linewidth=4.0, foreground=[1.0, 1.0, 1.0, 1.0])])
    # to coordinate crosstalk with rectangle selector
    self.drawMe = True

  def _onmove(self, event):
    if(self.drawMe):
      LassoSelector._onmove(self, event)

  # this is required for older matplotlib versions (e.g. under my Linux distro)
  def onmove(self, event):
    if(self.drawMe):
      LassoSelector.onmove(self, event)

class MyRectangli(RectangleSelector):
  def __init__(self, *args, **kwargs):
    super(MyRectangli, self).__init__(*args, **kwargs)
    # to coordinate crosstalk with lasso selector
    self.visible = True
    # older matplotlib versions do not accept keyword interactive => set this here
    self.interactive = False

  def update(self):
    # don't draw anything if turned off
    if(self.visible):
      RectangleSelector.update(self)
    return False

class MatplotlibCanvas(QWidgetMac):
  def __init__(self, parent=None):
    super(MatplotlibCanvas, self).__init__()
    self.parent = parent
    
    # initialize param values
    self.initParam()

    # set initial matplotlib style
    originalFont = matplotlib.rcParams.get('mathtext.fontset')
    matplotlib.style.use(self.stylemodel)
    # ensure that Dejavu Sans is used for mathtext (rather use original font as dejavusans is platform/version-depedent)
    matplotlib.rc('mathtext', fontset=originalFont)
    
    # a validator
    self.validFloat = MyValidFloat()
    
    # generate GUI elements
    self.buildRessource()
    
    # initialize plot
    self.initPlot(initialize=True)

    # toggle split axes
    self.toggleSplit(redraw=False, toggled=False)
    
    # update rulers
    self.horizontalRuler.updateRuler()
    self.verticalRuler.updateRuler()
    self.verticalRulerResid.updateRuler()
    
  def initParam(self):
    # allow some spacing around data when autoscaling
    self.data_spacer = 0.025
    
    # initialize some values
    self.x, self.y, self.y2 = np.array([]), np.array([]), np.array([])
    self.minX = 0.0; self.maxX = 1.0
    self.minY = 0.0; self.maxY = 1.0
    self.storeCoord = []
    self.minResidY = -0.5; self.maxResidY = 0.5
    self.modeX, self.modeY = 'linear', 'linear'
    self.EPSILON = 1e-6
    self.DATAPOINTS_SIMULATION = 2000
    self.autoScaleX, self.autoScaleY = True, True
    self.labelX = 'x'
    self.labelY = 'y'
    self.labelXShow, self.labelYShow = True, True
    self.labelXColor, self.labelYColor = [0.2, 0.2, 0.2, 1.0], [0.2, 0.2, 0.2, 1.0]
    self.labelXSize, self.labelYSize = 14.0, 14.0
    self.labelXWeight, self.labelYWeight = 'normal', 'normal'
    self.labelXStyle, self.labelYStyle = 'italic', 'italic'
    self.labelXVariant, self.labelYVariant = 'normal', 'normal'
    self.labelXPad, self.labelYPad = 4.0, 4.0
    self.labelXPos, self.labelYPos = 0.5, 0.5
    self.labelXAngle, self.labelYAngle = 0.0, 90.0
    self.labelXAlignment, self.labelYAlignment = 'center', 'center'
    self.labelXAlignmentVertical, self.labelYAlignmentVertical = 'top', 'baseline'
    self.axisVisible = {'left':True, 'right':True, 'bottom':True, 'top':True, 'left2':True, 'right2':True}
    self.axisWidth = {'left':1.0, 'right':1.0, 'bottom':1.0, 'top':1.0, 'left2':1.0, 'right2':1.0}
    self.axisStyle = {'left':'solid', 'right':'solid', 'bottom':'solid', 'top':'solid', 'left2':'solid', 'right2':'solid'}
    self.axisDashStyle = {'left':'butt', 'right':'butt', 'bottom':'butt', 'top':'butt', 'left2':'butt', 'right2':'butt'}
    self.axisColor = {'left':[0.2, 0.2, 0.2, 1.0], 'right':[0.2, 0.2, 0.2, 1.0], 'bottom':[0.2, 0.2, 0.2, 1.0],\
                      'top':[0.2, 0.2, 0.2, 1.0], 'left2':[0.2, 0.2, 0.2, 1.0], 'right2':[0.2, 0.2, 0.2, 1.0]}
    self.axisFont = {'x': 'DejaVu Sans', 'y': 'DejaVu Sans', 'y2': 'DejaVu Sans'}
    self.axisPosition = {'left':'axes', 'right':'axes', 'bottom':'axes', 'top':'axes', 'left2':'axes', 'right2':'axes'}
    self.axisPositionValue = {'left':0.0, 'right':1.0, 'bottom':0.0, 'top':1.0, 'left2':0.0, 'right2':1.0}
    self.axisBoundary = {'left':[0.0, 1.0], 'right':[0.0, 1.0], 'bottom':[0.0, 1.0], 'top':[0.0, 1.0], 'left2':[0.0, 1.0], 'right2':[0.0, 1.0]}
    self.axisBoundaryCheck = {'left':False, 'right':False, 'bottom':False, 'top':False, 'left2':False, 'right2':False}
    self.tickFont = {'x': 'DejaVu Sans', 'y': 'DejaVu Sans', 'y2': 'DejaVu Sans'}
    self.ticksVisible = {'left':True, 'right':True, 'bottom':True, 'top':True, 'left2':False, 'right2':True}
    self.ticksWidth = {'left':0.5, 'right':0.5, 'bottom':0.5, 'top':0.5, 'left2':0.5, 'right2':0.5}
    self.ticksLength = {'left':5.0, 'right':5.0, 'bottom':5.0, 'top':5.0, 'left2':5.0, 'right2':5.0}
    self.ticksColor = {'left':[0.2, 0.2, 0.2, 1.0], 'right':[0.2, 0.2, 0.2, 1.0], 'bottom':[0.2, 0.2, 0.2, 1.0],\
                       'top':[0.2, 0.2, 0.2, 1.0], 'left2':[0.2, 0.2, 0.2, 1.0], 'right2':[0.2, 0.2, 0.2, 1.0]}
    self.ticksDirection = {'left':'in', 'right':'in', 'bottom':'in', 'top':'in', 'left2':'in', 'right2':'in'}
    self.ticksLabelShow = {'left': True, 'right': False, 'bottom': True, 'top': False, 'left2': False, 'right2': True}
    self.canvasColor = [0.9, 0.9, 0.9, 1.0]
    self.canvasFill, self.figureFill, self.frameDraw = True, True, False
    self.figureColor = [1.0, 1.0, 1.0, 1.0]
    self.ticksX, self.ticksY, self.ticksResidY = [], [], []
    self.ticksXShow, self.ticksYShow, self.ticksResidYShow = True, True, True
    self.ticksXAuto, self.ticksYAuto, self.ticksResidYAuto = True, True, True
    self.ticksXMinor, self.ticksYMinor, self.ticksY2Minor, self.ticksResidYMinor = 2, 2, 2, 2
    self.ticksXMinorRelativeLength, self.ticksYMinorRelativeLength, self.ticksY2MinorRelativeLength, self.ticksResidYMinorRelativeLength = 0.5, 0.5, 0.5, 0.5
    self.ticksXLabel = []
    self.ticksXColor = [0.2, 0.2, 0.2, 1.0]
    self.ticksYColor = [0.2, 0.2, 0.2, 1.0]
    self.ticksXSize, self.ticksYSize = 12.0, 12.0
    self.ticksXWeight, self.ticksYWeight = 'normal', 'normal'
    self.ticksXStyle, self.ticksYStyle = 'normal', 'normal'
    self.ticksXAngle, self.ticksYAngle = 0.0, 0.0
    self.ticksXAlignment, self.ticksYAlignment = 'center', 'right'
    self.ticksXAlignmentVertical, self.ticksYAlignmentVertical = 'top', 'center'
    self.ticksXPad, self.ticksYPad = 4.0, 4.0
    self.ticksXPad2, self.ticksYPad2 = 0.0, 0.0
    self.ticksXFormat, self.ticksYFormat, self.ticksY2Format, self.ticksResidYFormat = 'default', 'default', 'default', 'default'
    self.ticksXFormatPrecision, self.ticksYFormatPrecision, self.ticksY2FormatPrecision, self.ticksResidYFormatPrecision = 2, 2, 2, 2
    self.ticksXFormatTrailZero, self.ticksYFormatTrailZero, self.ticksY2FormatTrailZero, self.ticksResidYFormatTrailZero = False, False, False, False
    self.ticksXFormatSeparator, self.ticksYFormatSeparator, self.ticksY2FormatSeparator, self.ticksResidYFormatSeparator = False, False, False, False
    self.ticksXFormatComma, self.ticksYFormatComma, self.ticksY2FormatComma, self.ticksResidYFormatComma = False, False, False, False
    self.ticksXFormatPrefix, self.ticksYFormatPrefix, self.ticksY2FormatPrefix, self.ticksResidYFormatPrefix = '', '', '', ''
    self.ticksXFormatPostfix, self.ticksYFormatPostfix, self.ticksY2FormatPostfix, self.ticksResidYFormatPostfix = '', '', '', ''
    self.fallback_ticksXFormat, self.fallback_ticksYFormat, self.fallback_ticksY2Format, self.fallback_ticksResidYFormat = None, None, None, None
    self.gridVisible = {'x': False, 'x2': False, 'y': False, 'y2': False}
    self.gridLinesStore = {'x': [], 'x2': [], 'y': [], 'y2': []}
    self.gridLinesStore_resid = {'x': [], 'x2': [], 'y': [], 'y2': []}
    self.gridWidth = {'x': 0.5, 'x2': 0.5, 'y': 0.5, 'y2': 0.5}
    self.gridStyle = {'x': 'solid', 'x2': 'solid', 'y': 'solid', 'y2': 'solid'}
    self.gridDashStyle = {'x': 'butt', 'x2': 'butt', 'y': 'butt', 'y2': 'butt'}
    self.gridColor = {'x': [0.2, 0.2, 0.2, 1.0], 'x2': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0], 'y2': [0.2, 0.2, 0.2, 1.0]}
    self.gridOrder = {'x': 'back', 'x2': 'back', 'y': 'back', 'y2': 'back'}
    self.exportWidth = 8.0; self.exportHeight = 6.0
    self.padSize = {'left':0.15, 'right':0.95, 'bottom':0.15, 'top':0.95}
    self.frameWidth, self.frameColor, self.frameStyle, self.frameDashStyle = 0.5, [0.2, 0.2, 0.2, 1.0], 'solid', 'butt'
    self.visibilityResidLine = True
    self.zorderResidLine = 1
    self.legendVisible = True
    self.legendPlacement = 'upper right'
    self.placementStyles = 'upper right;upper left;lower left;lower right;right;center left;center right;lower center;upper center;center'.split(';')
    self.legendColor = {'face':[1.0, 1.0, 1.0, 0.5], 'edge':[0.2, 0.2, 0.2, 1.0]}
    self.legendEdgeWidth = 0.5
    self.legendShadow = False
    self.legendShadowDeltaX, self.legendShadowDeltaY, self.legendShadowFaceColor = 2, -2, [0.5, 0.5, 0.5, 1.0]
    self.legendLabelColor = [0.0, 0.0, 0.0, 1.0]
    self.legendLabelSize = 14
    self.legendLabelWeight, self.legendLabelStyle = 'normal', 'normal'
    self.legendLabelFont = 'DejaVu Sans'
    self.legendNumPoints = 1
    self.legendMarkerFirst = True
    self.legendNumCol = 1
    self.legendMarkerScale = 1.0
    self.legendBorderPad = 0.4
    self.legendLabelSpacing = 0.4
    self.legendColumnSpacing = 2
    self.legendFill, self.legendEdge = True, True
    self.legendHatch, self.legendHatchMultiply, self.legendRounding = '', 1, 0.2
    self.xkcd = False
    self.xkcdScale, self.xkcdLength, self.xkcdRandomness = 1.0, 100.0, 2.0
    self.xkcdStoreFonts = ['DejaVu Sans']
    self.applyPathStroke = False
    self.pathStrokeWidth, self.pathStrokeColor = 2.0, [1.0, 1.0, 1.0, 1.0]
    self.applyPathShadow = False
    self.pathShadowX, self.pathShadowY, self.pathShadowColor, self.pathShadowAlpha = 2, -2, [0.4, 0.4, 0.4, 0.5], 0.5
    self.pathRhoCheck, self.pathRho = True, 0.5
    self.handleArrow = {'x': None, 'y': None}
    self.handleArrowResid = {'x': None, 'y': None}
    self.handleArrow2 = {'x': None, 'y': None}
    self.handleArrowResid2 = {'x': None, 'y': None}
    self.arrowVisible = {'x': False, 'y': False}
    self.arrowOverhang = {'x': 0.1, 'y': 0.1}
    self.arrowColor = {'x': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0]}
    self.arrowFill = {'x': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0]}
    self.arrowHeadLength = {'x': 0.05, 'y': 0.05}
    self.arrowHeadWidth = {'x': 0.03, 'y': 0.03}
    self.arrowEdge = {'x': 0.5, 'y': 0.5}
    self.arrowOffset = {'x': 0.2, 'y': 0.2}
    self.arrowEdgeShow = {'x': True, 'y': True}
    self.arrowFillShow = {'x': True, 'y': True}
    self.arrowLocation = {'x': 'bottom', 'y': 'left'}
    self.tickLabelData = False
    self.cursorVisible = False
    self.cursor = None
    self.pickedExtra, self.pickedAxes, self.pickedBackground, self.pickedMode, self.inAxes = None, None, None, 0, None
    
    # second y axis
    self.minY2, self.maxY2 = 0.0, 1.0
    self.modeY2 = 'linear'
    self.autoScaleY2 = True
    self.ticksY2 = []
    self.ticksY2Show = True
    self.ticksY2Auto = True
    self.ticksY2Color = [0.2, 0.2, 0.2, 1.0]
    self.ticksY2Size = 12.0
    self.ticksY2Weight = 'normal'
    self.ticksY2Style = 'normal'
    self.ticksY2Angle = 0.0
    self.ticksY2Alignment = 'left'
    self.ticksY2AlignmentVertical = 'center'
    self.ticksY2Pad, self.ticksY2Pad2 = 4.0, 0.0
    self.labelY2 = 'y'
    self.labelY2Show = True
    self.labelY2Color = [0.2, 0.2, 0.2, 1.0]
    self.labelY2Size = 14.0
    self.labelY2Weight = 'normal'
    self.labelY2Style = 'italic'
    self.labelY2Variant = 'normal'
    self.labelY2Pad = 4.0
    self.labelY2Pos = 0.5
    self.labelY2Angle = 90.0
    self.labelY2Alignment = 'center'
    self.labelY2AlignmentVertical = 'top'
    
    self.splitShow, self.splitFraction, self.splitPad = False, 1.0, 0.1
    self.splitDivider, self.splitDividerLength, self.splitDividerWidth, self.splitDividerLocation = True, 0.07, 0.5, 'both'
    self.splitDividerColor, self.splitDividerDashStyle, self.splitDividerAngle = [0.2, 0.2, 0.2, 1.0], 'round', 60
    self.handleDivider, self.handleDividerResid, self.handleDividerY = None, None, None
    self.minX_div, self.maxX_div, self.modeX_div = 0, 1.0, 'linear'
    self.innerAxes, self.innerTicks = False, False
    self.ticksX_div, self.ticksXLabel_div, self.ticksXAuto_div, self.ticksXShow_div, self.ticksXShow_resid_div = [], [], True, True, True
    self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.fallback_ticksXFormat_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.ticksXFormatComma_div = 'default', 2, None, False, False, False
    self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div = '', ''
    self.cursor_div, self.cursor2, self.cursor2_div = None, None, None
    self.autoScaleX_div = True
    self.ticksXMinor_div = 2
    
    self.canvasGradientVisible = False
    self.canvasGradient = []
    self.canvasGradientStyle = 'linear'
    self.canvasGradientColor1, self.canvasGradientColor2 = [0.8, 0.8, 0.8, 1.0], [0.2, 0.2, 0.2, 1.0]
    self.canvasGradientAngle, self.canvasGradientWidth, self.canvasGradientCenter = 0.0, 0.5, [0.5, 0.5]
    
    # controls for split y axis
    self.splitY = False
    self.splitYFraction, self.splitYPad = 1.0, 0.03
    self.innerAxesY, self.innerTicksY = False, False
    self.splitYDivider, self.splitYDividerLength, self.splitYDividerWidth, self.splitYDividerLocation = True, 0.07, 0.5, 'both'
    self.splitYDividerColor, self.splitYDividerDashStyle, self.splitYDividerAngle = [0.2, 0.2, 0.2, 1.0], 'round', 30
    self.splitYBackup = {}
    
    # interactive drawing of freehand shape
    self.drawFreehand = False
    self.thisLasso = None
    self.pick2Freehand = False

    # store information for graphics export as Python script
    self.rememberSetting = {}
    self.rememberSettingResidLine = {}
    
    # generate copies of certain settings for improved drawing control for resid window
    items = 'axisVisible,axisWidth,axisStyle,axisDashStyle,axisPosition,axisPositionValue,axisBoundaryCheck,axisBoundary,axisColor,labelX,labelY,labelXShow,labelYShow'.split(',')
    items.extend('labelXColor,labelYColor,labelXSize,labelYSize,labelXWeight,labelYWeight,labelXStyle,labelYStyle,labelXVariant,labelYVariant'.split(','))
    items.extend('labelXPad,labelYPad,labelXPos,labelYPos,labelXAlignment,labelYAlignment,labelXAlignmentVertical,labelYAlignmentVertical,labelXAngle,labelYAngle,axisFont'.split(','))
    items.extend('tickFont,ticksVisible,ticksWidth,ticksLength,ticksColor,ticksDirection,ticksLabelShow'.split(','))
    items.extend('ticksXShow,ticksYShow,ticksXColor,ticksYColor,ticksXSize,ticksYSize,ticksXWeight,ticksYWeight,ticksXStyle,ticksYStyle'.split(','))
    items.extend('ticksXAngle,ticksYAngle,ticksXMinorRelativeLength'.split(','))
    items.extend('ticksXAlignment,ticksYAlignment,ticksXAlignmentVertical,ticksYAlignmentVertical,ticksXPad,ticksYPad,ticksXPad2,ticksYPad2'.split(','))
    items.extend('gridVisible,gridWidth,gridStyle,gridDashStyle,gridColor,gridOrder,padSize,frameWidth,frameColor,frameStyle,frameDashStyle,frameDraw'.split(','))
    items.extend('canvasGradientStyle,canvasGradientColor1,canvasGradientColor2,canvasGradientAngle,canvasGradientWidth,canvasGradientCenter'.split(','))
    items.extend('arrowEdgeShow,arrowFillShow,arrowLocation'.split(','))
    for entry in items:
      self.__dict__[entry + '_resid'] = deepcopy(self.__dict__[entry])

    if('bmh' in matplotlib.style.available):
      self.stylemodel = 'bmh'
    else:
      self.stylemodel = matplotlib.style.available[0]
      
    # pick event handling
    self.lastPickEvent = None
            
  def buildRessource(self):
    # set up matplotlib and canvas
    self.vLayout_master = QtWidgets.QVBoxLayout(self)
    self.vLayout_master.setContentsMargins(0, 0, 0, 0)

    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Vertical)
    self.vLayout_master.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)
    self.masterwidget.setOpaqueResize(False)
    
    self.mainPlotBox = QWidgetMac()
    self.masterwidget.addWidget(self.mainPlotBox)
    self.hLayout = QtWidgets.QHBoxLayout(self.mainPlotBox)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setSpacing(scaledDPI(1))
    
    # controls for y-axis
    self.yControlBox = QWidgetMac(self)
    self.yControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(50), scaledDPI(500)))
    self.yControlBox.setMaximumSize(QtCore.QSize(scaledDPI(50), 16777215))
    self.yControlBox.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(200)))

    self.hLayout.addWidget(self.yControlBox)
    self.vLayout = QtWidgets.QVBoxLayout(self.yControlBox)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    self.SpacerBox0 = QWidgetMac(self)
    self.SpacerBox0.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.SpacerBox0.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.vLayout.addWidget(self.SpacerBox0)
    
    # controls for main plot
    self.yControlsPlotContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.yControlsPlotContainer)
    self.LayoutYControlsPlotContainer = QtWidgets.QVBoxLayout(self.yControlsPlotContainer)
    self.LayoutYControlsPlotContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutYControlsPlotContainer.setSpacing(scaledDPI(1))
    
    self.autoScaleBoxY = QWidgetMac(self)
    self.autoScaleBoxY.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.autoScaleBoxY.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.Layout_ScaleBoxY = QtWidgets.QHBoxLayout(self.autoScaleBoxY)
    self.Layout_ScaleBoxY.setContentsMargins(0, 0, 0, 0)
    self.Layout_ScaleBoxY.setSpacing(scaledDPI(1))
    self.Layout_ScaleBoxY.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
    self.autoScaleButtonY = QPushButtonMac()
    self.autoScaleButtonY.setText('Auto')
    self.autoScaleButtonY.setToolTip('Scale y axis to current data set and/or curve')
    self.autoScaleButtonY.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonY.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonY.clicked.connect(partial(self.doAutoScale, 'y', True))
    self.Layout_ScaleBoxY.addWidget(self.autoScaleButtonY)
    self.autoScaleCheckY = QPushButtonCheckable()
    self.autoScaleCheckY.setToolTip('Automatically scale y axis')
    self.autoScaleCheckY.setCheckMe(True)
    self.autoScaleCheckY.setChecked(self.autoScaleY)
    self.autoScaleCheckY.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckY.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckY.clicked.connect(partial(self.setAutoScale, 'y'))
    self.Layout_ScaleBoxY.addWidget(self.autoScaleCheckY)
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.autoScaleBoxY)
    
    self.upperLimity = QLineEditClick()
    self.upperLimity.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimity.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimity.setValidator(self.validFloat)
    self.upperLimity.setText(str(self.parent.formatNumber(self.maxY)))
    self.upperLimity.setToolTip('Upper limit of y axis')
    self.upperLimity.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'plot', True))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.upperLimity)

    self.modeSelectory = QComboBoxMac()
    self.modeSelectory.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.modeSelectory.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.modeSelectory)
    self.modeSelectory.addItem('linear')
    self.modeSelectory.addItem('log')
    self.modeSelectory.currentIndexChanged.connect(partial(self.changeAxisMode, 'y', True))
    self.modeSelectory.setToolTip('Set scale of y axis')
    
    self.lowerLimity = QLineEditClick()
    self.lowerLimity.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimity.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimity.setValidator(self.validFloat)
    self.lowerLimity.setText(str(self.parent.formatNumber(self.minY)))
    self.lowerLimity.setToolTip('Lower limit of y axis')
    self.lowerLimity.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'plot', True))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.lowerLimity)

    self.flipAxisButtonY = QPushButtonCheckable()
    self.flipAxisButtonY.setText('Flip')
    self.flipAxisButtonY.setToolTip('Swap upper and lower limits of y axis')
    self.flipAxisButtonY.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonY.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonY.clicked.connect(partial(self.flipAxis, 'y', redraw=True))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.flipAxisButtonY)

    self.LayoutYControlsPlotContainer.addStretch()
    self.splitYButton = QPushButtonCheckable()
    self.splitYButton.setText('Split')
    self.splitYButton.setToolTip('Toggle split y axis')
    self.splitYButton.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.splitYButton.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.splitYButton.setChecked(self.splitY)
    self.LayoutYControlsPlotContainer.addWidget(self.splitYButton)
    self.splitYButton.clicked.connect(self.toggleSplitYCallback)
    blah = self.HLine()
    self.LayoutYControlsPlotContainer.addWidget(blah)

    # middle box
    self.mainMiddleBox = QWidgetMac(self)
    self.hLayout.addWidget(self.mainMiddleBox)
    self.vLayout_mainMiddleBox = QtWidgets.QVBoxLayout(self.mainMiddleBox)
    self.vLayout_mainMiddleBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout_mainMiddleBox.setSpacing(scaledDPI(1))
    
    # horizontal ruler
    self.horizontalRulerBox = QWidgetMac(self)
    self.horizontalRulerBox.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.horizontalRulerBox.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.vLayout_mainMiddleBox.addWidget(self.horizontalRulerBox)
    self.LayoutHorizontalRulerBox = QtWidgets.QHBoxLayout(self.horizontalRulerBox)
    self.LayoutHorizontalRulerBox.setContentsMargins(0, 0, 0, 0)
    self.LayoutHorizontalRulerBox.setSpacing(scaledDPI(1))
    
    self.horizontalRuler = Ruler(parent=self, mode=0)
    self.horizontalRuler.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.horizontalRuler.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.LayoutHorizontalRulerBox.addWidget(self.horizontalRuler)
    
    self.SpacerBox1 = QWidgetMac(self)
    self.SpacerBox1.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
    self.SpacerBox1.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
    self.LayoutHorizontalRulerBox.addWidget(self.SpacerBox1)

    # container for plot and residuals
    self.plotContainer = ShrinkoWidget(notify=self, parent=self)
    self.LayoutPlotContainer = QtWidgets.QHBoxLayout(self.plotContainer)
    self.LayoutPlotContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutPlotContainer.setSpacing(scaledDPI(1))
    self.vLayout_mainMiddleBox.addWidget(self.plotContainer)
    
    # the actual matplotlib canvas
    self.matplot = plt.figure()
    self.originalPlotDPI = self.matplot.get_dpi()
    zoomDifference = [abs(scaledDPI(self.originalPlotDPI) - i) for i in self.parent.zoomLevels]
    zoomIndex = zoomDifference.index(min(zoomDifference))
    self.matplot.set_dpi(self.parent.zoomLevels[zoomIndex])
    self.dataplotwidget = MyFigureCanvas(self.matplot, self, 'plot')
    self.LayoutPlotContainer.addWidget(self.dataplotwidget)

    # vertical ruler
    self.verticalRuler = Ruler(parent=self, mode=1)
    self.verticalRuler.setMinimumWidth(scaledDPI(BASE_SIZE))
    self.verticalRuler.setMaximumWidth(scaledDPI(BASE_SIZE))
    self.LayoutPlotContainer.addWidget(self.verticalRuler)
 
    # controls for resid plot
    self.residPlotBox = ShrinkoWidget(notify=self, notifyResid=True, parent=self)
    self.masterwidget.addWidget(self.residPlotBox)
    self.hLayout_resid = QtWidgets.QHBoxLayout(self.residPlotBox)
    self.hLayout_resid.setContentsMargins(0, 0, 0, 0)
    self.hLayout_resid.setSpacing(scaledDPI(1))

    self.yControlsResidContainer = QWidgetMac(self)
    self.yControlsResidContainer.setMaximumWidth(scaledDPI(50))
    self.hLayout_resid.addWidget(self.yControlsResidContainer)
    self.LayoutYControlsResidContainer = QtWidgets.QVBoxLayout(self.yControlsResidContainer)
    self.LayoutYControlsResidContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutYControlsResidContainer.setSpacing(scaledDPI(1))
    
    self.upperLimitResidy = QLineEditClick()
    self.upperLimitResidy.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimitResidy.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimitResidy.setValidator(self.validFloat)
    self.upperLimitResidy.setText(str(self.parent.formatNumber(self.maxResidY)))
    self.upperLimitResidy.setToolTip('Upper limit of residuals y axis')
    self.upperLimitResidy.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'resid', True))
    self.LayoutYControlsResidContainer.addWidget(self.upperLimitResidy)
    
    self.autoScaleButtonResidY = QPushButtonMac()
    self.autoScaleButtonResidY.setText('Auto')
    self.autoScaleButtonResidY.setToolTip('Scale y axis to current residuals object')
    self.autoScaleButtonResidY.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonResidY.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonResidY.clicked.connect(partial(self.doAutoScale, 'resid', True))
    self.LayoutYControlsResidContainer.addWidget(self.autoScaleButtonResidY)

    self.lowerLimitResidy = QLineEditClick()
    self.lowerLimitResidy.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimitResidy.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimitResidy.setValidator(self.validFloat)
    self.lowerLimitResidy.setText(str(self.parent.formatNumber(self.minResidY)))
    self.lowerLimitResidy.setToolTip('Lower limit of residuals y axis')
    self.lowerLimitResidy.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'resid', True))
    self.LayoutYControlsResidContainer.addWidget(self.lowerLimitResidy)

    # define the plot for the residuals
    plt.rcParams.update({'svg.fonttype': 'none'})
    self.residplot = plt.figure()
    self.residplot.set_dpi(self.parent.zoomLevels[zoomIndex])

    # residuals middle box
    self.residMiddleBox = QWidgetMac(self)
    self.hLayout_resid.addWidget(self.residMiddleBox)
    self.vLayout_residMiddleBox = QtWidgets.QVBoxLayout(self.residMiddleBox)
    self.vLayout_residMiddleBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout_residMiddleBox.setSpacing(scaledDPI(1))
    
    # set up canvas for the residuals
    self.residContainer = QWidgetMac()
    self.vLayout_residMiddleBox.addWidget(self.residContainer)
    self.LayoutResidContainer = QtWidgets.QHBoxLayout(self.residContainer)
    self.LayoutResidContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutResidContainer.setSpacing(scaledDPI(1))
    self.residplotwidget = MyFigureCanvas(self.residplot, self, 'resid')
    self.LayoutResidContainer.addWidget(self.residplotwidget)
    
    # vertical ruler resid
    self.verticalRulerResid = Ruler(parent=self, mode=1, resid=1)
    self.verticalRulerResid.setMinimumWidth(scaledDPI(BASE_SIZE))
    self.verticalRulerResid.setMaximumWidth(scaledDPI(BASE_SIZE))
    self.hLayout_resid.addWidget(self.verticalRulerResid)
    
    # controls for x-axis
    self.xControlBox = QWidgetMac(self)
    self.xControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(BASE_SIZE + 1)))
    self.xControlBox.setMaximumSize(QtCore.QSize(16777215, scaledDPI(BASE_SIZE + 1)))
    self.xControlBox.setMinimumSize(QtCore.QSize(scaledDPI(200), scaledDPI(BASE_SIZE + 1)))
    self.xControlBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout_master.addWidget(self.xControlBox)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.xControlBox)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setSpacing(scaledDPI(2))

    self.SpacerBox_xctrl = QWidgetMac(self)
    self.SpacerBox_xctrl.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.SpacerBox_xctrl.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.SpacerBox_xctrl)

    self.clearButton = QPushButtonMac()
    self.clearButton.setText('Clear Selection')
    self.clearButton.setToolTip('Clear data selection')
    self.clearButton.setMaximumSize(QtCore.QSize(scaledDPI(90), scaledDPI(BASE_SIZE)))
    self.clearButton.setMinimumSize(QtCore.QSize(scaledDPI(90), scaledDPI(BASE_SIZE)))
    self.clearButton.clicked.connect(self.clearSelection)
    self.hLayout2.addWidget(self.clearButton)
    self.hLayout2.addStretch()
    self.clearButton.setEnabled(False)

    self.autoScaleBoxX = QWidgetMac(self)
    self.autoScaleBoxX.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.autoScaleBoxX.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.autoScaleBoxX)
    self.Layout_ScaleBoxX = QtWidgets.QHBoxLayout(self.autoScaleBoxX)
    self.Layout_ScaleBoxX.setContentsMargins(0, 0, 0, 0)
    self.Layout_ScaleBoxX.setSpacing(scaledDPI(1))
    self.Layout_ScaleBoxX.setAlignment(QtCore.Qt.AlignLeft)
    self.autoScaleButtonX = QPushButtonMac()
    self.autoScaleButtonX.setText('Auto')
    self.autoScaleButtonX.setToolTip('Scale x axis to current data set')
    self.autoScaleButtonX.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonX.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonX.clicked.connect(partial(self.doAutoScale, 'x', True))
    self.Layout_ScaleBoxX.addWidget(self.autoScaleButtonX)
    self.autoScaleCheckX = QPushButtonCheckable()
    self.autoScaleCheckX.setToolTip('Automatically scale x axis')
    self.autoScaleCheckX.setCheckMe(True)
    self.autoScaleCheckX.setChecked(self.autoScaleX)
    self.autoScaleCheckX.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckX.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckX.clicked.connect(partial(self.setAutoScale, 'x'))
    self.Layout_ScaleBoxX.addWidget(self.autoScaleCheckX)

    self.lowerLimitx = QLineEditClick()
    self.lowerLimitx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimitx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lowerLimitx.setValidator(self.validFloat)
    self.lowerLimitx.setText(str(self.parent.formatNumber(self.minX)))
    self.lowerLimitx.setToolTip('Lower limit of x axis')
    self.lowerLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x', 'plot', True))
    self.hLayout2.addWidget(self.lowerLimitx)

    self.modeSelectorx = QComboBoxMac()
    self.modeSelectorx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.modeSelectorx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.modeSelectorx)
    self.modeSelectorx.addItem('linear')
    self.modeSelectorx.addItem('log')
    self.modeSelectorx.currentIndexChanged.connect(partial(self.changeAxisMode, 'x', True))
    self.modeSelectorx.setToolTip('Set scale of x axis')
    
    self.upperLimitx = QLineEditClick()
    self.upperLimitx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimitx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.upperLimitx.setValidator(self.validFloat)
    self.upperLimitx.setText(str(self.parent.formatNumber(self.maxX)))
    self.upperLimitx.setToolTip('Upper limit of x axis')
    self.upperLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x', 'plot', True))
    self.hLayout2.addWidget(self.upperLimitx)
    
    self.flipAxisButtonX = QPushButtonCheckable()
    self.flipAxisButtonX.setText('Flip')
    self.flipAxisButtonX.setToolTip('Swap upper and lower limits of x axis')
    self.flipAxisButtonX.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonX.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonX.clicked.connect(partial(self.flipAxis, 'x', redraw=True))
    self.hLayout2.addWidget(self.flipAxisButtonX)

    self.firstSplitBox = QWidgetMac()
    self.firstSplitBox.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.firstSplitBox.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.firstSplitBox)
    self.LayoutFirstSplitBox = QtWidgets.QHBoxLayout(self.firstSplitBox)
    self.LayoutFirstSplitBox.setContentsMargins(0, 0, 0, 0)

    self.splitAxisButton = QPushButtonCheckable()
    self.splitAxisButton.setText('Split')
    self.splitAxisButton.setToolTip('Toggle split x axis')
    self.splitAxisButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.splitAxisButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.splitAxisButton.setChecked(self.splitShow)
    self.LayoutFirstSplitBox.addWidget(self.splitAxisButton)
    self.splitAxisButton.clicked.connect(partial(self.toggleSplit, True, True))
    
    # controls for split x-axis
    self.xSplitControlBox = QWidgetMac(self)
    self.xSplitControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setMaximumSize(QtCore.QSize(16777215, scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setMinimumSize(QtCore.QSize(scaledDPI(200), scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout_master.addWidget(self.xSplitControlBox)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.xSplitControlBox)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setSpacing(scaledDPI(2))
    self.hLayout3.addStretch()
    
    self.xSplitLabel = QtWidgets.QLabel('split x')
    self.hLayout3.addWidget(self.xSplitLabel)
    
    self.xSplitAutoScaleBoxX = QWidgetMac(self)
    self.xSplitAutoScaleBoxX.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitAutoScaleBoxX.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.xSplitAutoScaleBoxX)
    self.Layout_xSplitScaleBoxX = QtWidgets.QHBoxLayout(self.xSplitAutoScaleBoxX)
    self.Layout_xSplitScaleBoxX.setContentsMargins(0, 0, 0, 0)
    self.Layout_xSplitScaleBoxX.setSpacing(scaledDPI(1))
    self.Layout_xSplitScaleBoxX.setAlignment(QtCore.Qt.AlignLeft)
    self.xSplitAutoScaleButtonX = QPushButtonMac()
    self.xSplitAutoScaleButtonX.setText('Auto')
    self.xSplitAutoScaleButtonX.setToolTip('Scale split x axis to current data set')
    self.xSplitAutoScaleButtonX.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.xSplitAutoScaleButtonX.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.xSplitAutoScaleButtonX.clicked.connect(partial(self.doAutoScale, 'x2', True))
    self.Layout_xSplitScaleBoxX.addWidget(self.xSplitAutoScaleButtonX)
    self.xSplitAutoScaleCheckX = QPushButtonCheckable()
    self.xSplitAutoScaleCheckX.setToolTip('Automatically scale split x axis')
    self.xSplitAutoScaleCheckX.setCheckMe(True)
    self.xSplitAutoScaleCheckX.setChecked(self.autoScaleX_div)
    self.xSplitAutoScaleCheckX.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.xSplitAutoScaleCheckX.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.xSplitAutoScaleCheckX.clicked.connect(partial(self.setAutoScale, 'x2'))
    self.Layout_xSplitScaleBoxX.addWidget(self.xSplitAutoScaleCheckX)

    self.xSplitLowerLimitx = QLineEditClick()
    self.xSplitLowerLimitx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitLowerLimitx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitLowerLimitx.setValidator(self.validFloat)
    self.xSplitLowerLimitx.setText(str(self.parent.formatNumber(self.minX_div)))
    self.xSplitLowerLimitx.setToolTip('Lower limit of split x axis')
    self.xSplitLowerLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x2', 'plot', True))
    self.hLayout3.addWidget(self.xSplitLowerLimitx)

    self.xSplitModeSelectorx = QComboBoxMac()
    self.xSplitModeSelectorx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitModeSelectorx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.xSplitModeSelectorx)
    self.xSplitModeSelectorx.addItem('linear')
    self.xSplitModeSelectorx.addItem('log')
    self.xSplitModeSelectorx.currentIndexChanged.connect(partial(self.changeAxisMode, 'x2', True))
    self.xSplitModeSelectorx.setToolTip('Set scale of split x axis')
    
    self.xSplitUpperLimitx = QLineEditClick()
    self.xSplitUpperLimitx.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitUpperLimitx.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.xSplitUpperLimitx.setValidator(self.validFloat)
    self.xSplitUpperLimitx.setText(str(self.parent.formatNumber(self.maxX_div)))
    self.xSplitUpperLimitx.setToolTip('Upper limit of split x axis')
    self.xSplitUpperLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x2', 'plot', True))
    self.hLayout3.addWidget(self.xSplitUpperLimitx)

    self.flipAxisButtonX2 = QPushButtonCheckable()
    self.flipAxisButtonX2.setText('Flip')
    self.flipAxisButtonX2.setToolTip('Swap upper and lower limits of split x axis')
    self.flipAxisButtonX2.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonX2.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonX2.clicked.connect(partial(self.flipAxis, 'x2', redraw=True))
    self.hLayout3.addWidget(self.flipAxisButtonX2)

    self.altSplitBox = QWidgetMac()
    self.altSplitBox.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.altSplitBox.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.altSplitBox)
    self.LayoutAltSplitBox = QtWidgets.QHBoxLayout(self.altSplitBox)
    self.LayoutAltSplitBox.setContentsMargins(0, 0, 0, 0)

    # controls for secondAxes
    self.secondAxesContainer = QWidgetMac(self)
    self.secondAxesContainer.setGeometry(QtCore.QRect(0, 0, scaledDPI(51), scaledDPI(500)))
    self.secondAxesContainer.setMaximumSize(QtCore.QSize(scaledDPI(51), 16777215))
    self.secondAxesContainer.setMinimumSize(QtCore.QSize(scaledDPI(51), scaledDPI(200)))
    self.hLayout.addWidget(self.secondAxesContainer)
    self.LayoutSecondAxesContainer = QtWidgets.QVBoxLayout(self.secondAxesContainer)
    self.LayoutSecondAxesContainer.setContentsMargins(0, scaledDPI(1), 0, 0)
    self.LayoutSecondAxesContainer.setSpacing(scaledDPI(1))

    self.SpacerBox3 = QWidgetMac(self)
    self.SpacerBox3.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.SpacerBox3.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.LayoutSecondAxesContainer.addWidget(self.SpacerBox3)
    
    self.secondAxesControlContainer = QWidgetMac(self)
    self.LayoutSecondAxesContainer.addWidget(self.secondAxesControlContainer)
    self.LayoutSecondAxesControlContainer = QtWidgets.QVBoxLayout(self.secondAxesControlContainer)
    self.LayoutSecondAxesControlContainer.setContentsMargins(0, 0, 0, 0)
    
    self.LayoutSecondAxesControlContainer.addStretch()
    self.secondAutoScaleBoxY = QWidgetMac(self)
    self.secondAutoScaleBoxY.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondAutoScaleBoxY.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.Layout_secondScaleBoxY = QtWidgets.QHBoxLayout(self.secondAutoScaleBoxY)
    self.Layout_secondScaleBoxY.setContentsMargins(0, 0, 0, 0)
    self.Layout_secondScaleBoxY.setSpacing(scaledDPI(1))
    self.Layout_secondScaleBoxY.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.secondAutoScaleButtonY = QPushButtonMac()
    self.secondAutoScaleButtonY.setText('Auto')
    self.secondAutoScaleButtonY.setToolTip('Scale second y axis to current data set and/or curve')
    self.secondAutoScaleButtonY.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.secondAutoScaleButtonY.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.secondAutoScaleButtonY.clicked.connect(partial(self.doAutoScale, 'y2', True))
    self.Layout_secondScaleBoxY.addWidget(self.secondAutoScaleButtonY)
    self.secondAutoScaleCheckY = QPushButtonCheckable()
    self.secondAutoScaleCheckY.setToolTip('Automatically scale second y axis')
    self.secondAutoScaleCheckY.setCheckMe(True)
    self.secondAutoScaleCheckY.setChecked(self.autoScaleY2)
    self.secondAutoScaleCheckY.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.secondAutoScaleCheckY.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.secondAutoScaleCheckY.clicked.connect(partial(self.setAutoScale, 'y2'))
    self.Layout_secondScaleBoxY.addWidget(self.secondAutoScaleCheckY)
    self.LayoutSecondAxesControlContainer.addWidget(self.secondAutoScaleBoxY)

    self.secondUpperLimit = QLineEditClick()
    self.secondUpperLimit.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondUpperLimit.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondUpperLimit.setValidator(self.validFloat)
    self.secondUpperLimit.setText(str(self.parent.formatNumber(self.maxY2)))
    self.secondUpperLimit.setToolTip('Upper limit of second y axis')
    self.secondUpperLimit.editingFinished.connect(partial(self.changeAxisLimits, 'y2', 'plot', True))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondUpperLimit)

    self.secondModeSelector = QComboBoxMac()
    self.secondModeSelector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondModeSelector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondModeSelector)
    self.secondModeSelector.addItem('linear')
    self.secondModeSelector.addItem('log')
    self.secondModeSelector.currentIndexChanged.connect(partial(self.changeAxisMode, 'y2', True))
    self.secondModeSelector.setToolTip('Set scale of second y axis')
    
    self.secondLowerLimit = QLineEditClick()
    self.secondLowerLimit.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondLowerLimit.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.secondLowerLimit.setValidator(self.validFloat)
    self.secondLowerLimit.setText(str(self.parent.formatNumber(self.minY2)))
    self.secondLowerLimit.setToolTip('Lower limit of second y axis')
    self.secondLowerLimit.editingFinished.connect(partial(self.changeAxisLimits, 'y2', 'plot', True))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondLowerLimit)
    
    self.flipAxisButtonY2 = QPushButtonCheckable()
    self.flipAxisButtonY2.setText('Flip')
    self.flipAxisButtonY2.setToolTip('Swap upper and lower limits of second y axis')
    self.flipAxisButtonY2.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonY2.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.flipAxisButtonY2.clicked.connect(partial(self.flipAxis, 'y2', redraw=True))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.flipAxisButtonY2)
    
    self.LayoutSecondAxesControlContainer.addStretch()
    self.splitYSpacer = QWidgetMac(self)
    self.splitYSpacer.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.splitYSpacer.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.LayoutSecondAxesControlContainer.addWidget(self.splitYSpacer)
    blah = self.HLine()
    self.LayoutSecondAxesControlContainer.addWidget(blah)    

    self.pseudoContainer = QWidgetMac(self)
    self.pseudoContainer.setMaximumWidth(scaledDPI(50))
    self.hLayout_resid.addWidget(self.pseudoContainer)
    self.LayoutPseudoContainer = QtWidgets.QVBoxLayout(self.pseudoContainer)
    self.LayoutPseudoContainer.setContentsMargins(0, scaledDPI(1), 0, 0)

    self.SpacerBox5 = QWidgetMac(self)
    self.SpacerBox5.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(25)))
    self.SpacerBox5.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(25)))
    self.LayoutPseudoContainer.addWidget(self.SpacerBox5)

    # initially turn off the second axes controls
    self.toggleSecondAxes(state=False)
    
    # set initial size ratio of QSplitter()
    # this call of no consequence as widget will be resized after creation
    # => readjust in main ui, see below
    ###self.masterwidget.setSizes([4, 1])

  def clearSelection(self):
    # callback for clear selection button
    if(hasattr(self.parent, 'resultsarea')):
      self.parent.resultsarea.clearSelection()

  def toggleSecondAxes(self, state=False):
    # toggles visibility of control elements for second axes
    ###if(state):
    if(True):
      self.secondAxesContainer.setVisible(state)
      self.pseudoContainer.setVisible(state)
      if((hasattr(self.parent, 'tabWidget')) and (hasattr(self.parent, 'tab_7'))):
        if(state):
          if(self.parent.tabWidget.indexOf(self.parent.tab_7) < 0):
            self.parent.tabWidget.addTab(self.parent.tab_7, "2nd Axes")
            # need to set again the tool tip upon recreation of tab
            toolText = 'This tab contains options for configuring the second axes graphics.\n(Ctrl-7)'
            if(myapp.toolTipsShow):
              self.parent.tabWidget.setTabToolTip(self.parent.tabWidget.indexOf(self.parent.tab_7), toolText)
            elif(len(self.parent.tabWidget.storedToolTips) <= self.parent.tabWidget.indexOf(self.parent.tab_7)):
              self.parent.tabWidget.storedToolTips.append(toolText)
        else:
          if(self.parent.tabWidget.indexOf(self.parent.tab_7) > -1):
            self.parent.tabWidget.removeTab(self.parent.tabWidget.indexOf(self.parent.tab_7))
      # toggle visibility of plot elements
      if(hasattr(self.parent, 'plotArea')):
        self.toggleSecondAxesItems(state=state)
    # need to solve inner situation -- but check whether plot object is already instantiated
    if(hasattr(self, 'ax')):
      self.updateInnerSituation()
      
  def toggleSecondAxesItems(self, state=False):
    # turns on/off all relevant plot elements of self.ax2
#    if(state):
    if(True):
      self.ax2.spines['right'].set_visible(state and self.axisVisible['right2'])
      self.ax2.yaxis.set_visible(state)
  
      self.ax2_div.spines['left'].set_visible(state and self.axisVisible['left2'])
      self.ax2_div.spines['right'].set_visible(state and self.axisVisible['right2'])
      self.ax2_div.yaxis.set_visible(state)
    
    # delete all grid lines on the second axes
    if(state):
      if(self.gridVisible['y2']):
        self.drawAxisGrid(axis='y2', redraw=False, target='plot')
    else:
      for line in self.gridLinesStore['y2']:
        line.remove()
      self.gridLinesStore['y2'] = []
    
  def isSecondAxesActive(self):
    # checks whether any items are on second axis
    onSecondItems = [1 if (i.onSecondAxes) else 0 for i in (self.parent.data + self.parent.fit + self.parent.extras)]
    if(sum(onSecondItems) or self.splitY):
      return True

    return False

  def toggleSplit(self, redraw=True, toggled=False):
    # toggles on/off split x axis
    state = self.splitAxisButton.isChecked()
    self.splitShow = state
    self.ax_div.set_visible(state)
    self.ax2_div.set_visible(state)
    self.ax_resid_div.set_visible(state)
    if(state):
      if(hasattr(self.parent, 'graphicsarea')):
        self.parent.graphicsarea.configInnerBox.show()
        self.parent.graphicsarea.configInnerTickXBox.show()
        self.parent.graphicsarea.configGridBox['x2'].show()
        # check whether advanced graphics enabled
        if(self.parent.graphicsarea.advancedExport['advancedGraphics']):
          if(hasattr(self.parent.graphicsarea, 'configInnerBox2')):
            self.parent.graphicsarea.configInnerBox2.show()
          if(hasattr(self.parent.graphicsarea, 'configInnerBox3')):
            self.parent.graphicsarea.configInnerBox3.show()
          if(hasattr(self.parent.graphicsarea, 'configInnerBox5')):
            self.parent.graphicsarea.configInnerBox5.show()
          if(hasattr(self.parent.graphicsarea, 'configInnerBox6')):
            self.parent.graphicsarea.configInnerBox6.show()
        if(self.parent.graphicsarea.advancedExport['advancedGraphics']):
          if(hasattr(self.parent.graphicsarea, 'configInnerMinorTickBox')):
            self.parent.graphicsarea.configInnerMinorTickBox.show()
      
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax2))))
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax_resid))))
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax))))

      # if called further up, the following command produces a warning under Linux
      # b/c the underlying call to axis._get_pixel_distance_along_axis() fails
      # => work around: move it here
      self.xSplitControlBox.show()
      self.LayoutAltSplitBox.addWidget(self.splitAxisButton)
      
      # need to ensure correct positioning of second axis label
      if(self.isSecondAxesActive()):
        self.ax2.yaxis.label.set_visible(False)
        self.ax2_div.yaxis.label.set_visible(self.labelY2Show)
      
      # set visibility of inner items correctly
      self.updateInnerSituation()
      
      # set axis mode and limits to match those of first axes
      self.xSplitModeSelectorx.blockSignals(True)
      index = self.xSplitModeSelectorx.findText(self.modeX)
      self.xSplitModeSelectorx.setCurrentIndex(index)
      self.xSplitModeSelectorx.blockSignals(False)
      self.changeAxisMode('x2', redraw=False)
      # set axes limits for split effect
      if(toggled):
        # only do this upon first display of split x axes
        if(self.modeX == 'linear'):
          splitXAt = self.minX + 1.0 / (self.splitFraction + 1.0) * (self.maxX - self.minX)
        else:
          splitXAt = np.exp(np.log(self.minX) + 1.0 / (self.splitFraction + 1.0) * (np.log(self.maxX) - np.log(self.minX)))
        self.setAxisLimits(lower=splitXAt, upper=self.maxX, axis='x2', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.setAxisLimits(lower=splitXAt, upper=self.maxX, axis='x2', updateLabel=False, target='resid', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.xSplitLowerLimitx.setText(self.parent.formatNumber(splitXAt))
        self.xSplitUpperLimitx.setText(self.upperLimitx.text())
        self.setAxisLimits(lower=self.minX, upper=splitXAt, axis='x', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.setAxisLimits(lower=self.minX, upper=splitXAt, axis='x', updateLabel=False, target='resid', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.upperLimitx.setText(self.parent.formatNumber(splitXAt))

      # need to update tick formatting if split axis is turned on
      for target in ['plot', 'resid']:
        self.setTickOne4All(axis='x', redraw=False, target=target)
    else:
      self.xSplitControlBox.hide()
      self.LayoutFirstSplitBox.addWidget(self.splitAxisButton)
      if(hasattr(self.parent, 'graphicsarea')):
        self.parent.graphicsarea.configInnerBox.hide()
        self.parent.graphicsarea.configInnerTickXBox.hide()
        self.parent.graphicsarea.configGridBox['x2'].hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerBox2')):
          self.parent.graphicsarea.configInnerBox2.hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerBox3')):
          self.parent.graphicsarea.configInnerBox3.hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerBox5')):
          self.parent.graphicsarea.configInnerBox5.hide()
          if(hasattr(self.parent.graphicsarea, 'configInnerBox6')):
            self.parent.graphicsarea.configInnerBox6.hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerMinorTickBox')):
          self.parent.graphicsarea.configInnerMinorTickBox.hide()
      
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(0), Size.Fixed(0)))
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(0), Size.Fixed(0)))
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(0), Size.Fixed(0)))

      # clean up the mess that may have been caused by toggling visibility of inner items
      self.setAxisVisibility(value=self.axisVisible['right'], axis='right', redraw=False, target='plot')
      self.ax2.spines['right'].set_visible(self.axisVisible['right2'] and self.isSecondAxesActive())
      self.setAxisVisibility(value=self.axisVisible_resid['right'], axis='right', redraw=False, target='resid')

      self.setTickMarkVisibility(value=self.ticksVisible['right'], axis='right', redraw=False, target='plot', initMode=True)
      self.setTickMarkVisibility(value=self.ticksVisible['left2'], axis='left2', redraw=False, target='plot', initMode=True)
      self.setTickMarkVisibility(value=self.ticksVisible_resid['right'], axis='right', redraw=False, target='resid', initMode=True)
      
      # need to ensure correct positioning of second axis label
      if(self.isSecondAxesActive()):
        self.ax2.yaxis.label.set_visible(self.labelY2Show)
        self.ax2_div.yaxis.label.set_visible(False)
        
      # reset axis limits to nonsplit
      if(self.modeX == self.modeX_div):
        self.setAxisLimits(lower=self.minX, upper=self.maxX_div, axis='x', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.setAxisLimits(lower=self.minX, upper=self.maxX_div, axis='x', updateLabel=False, target='resid', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.upperLimitx.setText(self.parent.formatNumber(self.maxX_div))

      # also need to update tick formatting if split axis is turned off
      for target in ['plot', 'resid']:
        self.setTickOne4All(axis='x', redraw=False, target=target)
      if(self.isSecondAxesActive()):
        self.setTickOne4All(axis='y2', redraw=False, target='plot')

    # draw plot and resid line (again) to ensure coverage of entire x range
    if(toggled):
      # only do this upon first display of split x axes
      if(hasattr(self.parent, 'plotArea')):
        self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
          fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
          redraw=False, doAutoZoom=False)
        self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
          fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
          redraw=False, splitX=True, doAutoZoom=False)
        # copy in case split axes are shown
        curve = self.parent.fit[self.parent.activeFit]
        if(self.parent.plotArea.splitY and curve.onBothAxes):
          curve.duplicateForSplit()
        self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=False)
        self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=False, splitX=True)

    # refresh plots
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()

      # finally we have to take care of the crosshair cursor b/c as of matplotlib 3.1.2 we can only initialize
      # it upon first display of div plot --- bummer!
      if(state and (self.cursor != None) and (self.cursor_div == None)):
        self.cursor_div = MyCursor(self.ax_div, useblit=True, color='black', linewidth=1)
        self.cursor_div.setParent(self)
        self.cursor_div.setAx2(self.ax2_div)
        
        # link cursors
        self.cursor.setTwin(self.cursor_div)
        self.cursor_div.setTwin(self.cursor)
        
        # toggle visibility
        self.cursor_div.toggleVisibility(self.cursorVisible, None)

      if(state and self.splitY and (self.cursor_div != None) and (self.cursor2_div == None)):
        self.cursor2_div = MyCursor(self.ax2_div, useblit=True, color='black', linewidth=0.5)
        self.cursor2_div.setParent(self)
        self.cursor2_div.setAx2(self.ax2_div)
        
        # link cursors
        if(self.cursor_div != None):
          self.cursor_div.setTwinVertical(self.cursor2_div)
          self.cursor2_div.setTwinVertical(self.cursor_div)
        if(self.cursor2 != None):
          self.cursor2.setTwin(self.cursor2_div)
          self.cursor2_div.setTwin(self.cursor2)

    # also need to update tick entry fields
    self.updateTickEntryField(axis='x')
    self.updateTickEntryField(axis='x2')
      
  def updateSplitDivider(self, param='color', value=[0.2, 0.2, 0.2, 1.0], redraw=True):
    # update parameter for split x axis inner divider line
    items = {'color': 'splitDividerColor', 'length': 'splitDividerLength', 'width': 'splitDividerWidth',\
             'dash': 'splitDividerDashStyle', 'angle': 'splitDividerAngle', 'location': 'splitDividerLocation'}
    if(param in items):
      if(value == self.__dict__[items[param]]):
        redraw = False
      self.__dict__[items[param]] = value

    # refresh plots
    if(redraw and self.splitShow and self.splitDivider):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()

  def setSplitDivider(self, value=True, redraw=True):
    # toggles display of split divider lines
    if(value == self.splitDivider):
      redraw = False
    self.splitDivider = value

    # refresh plots
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()

  def changeSplitFraction(self, value=1.0, redraw=True):
    # update parameters
    if (value == self.splitFraction):
      redraw = False
    self.splitFraction = value
    # call toggleSplit fxn
    self.toggleSplit(redraw=redraw, toggled=False)

  def changeSplitPad(self, value=0.02, redraw=True):
    # update parameters
    if (value == self.splitPad):
      redraw = False
    self.splitPad = value
    # call toggleSplit fxn
    self.toggleSplit(redraw=redraw, toggled=False)

  def toggleSplitYCallback(self):
    # callback function splitY button
    state = self.splitYButton.isChecked()
    # toggle button on 2nd axes tab
    if(hasattr(self.parent, 'graphicsarea2')):
      self.parent.graphicsarea2.configSplitYLabel.setChecked(state)
    # do the actual toggling
    self.setSplitY(value=state, redraw=True)

  def updateSplitYDivider(self, param='color', value=[0.2, 0.2, 0.2, 1.0], redraw=True):
    # update parameter for split x axis inner divider line
    items = {'color': 'splitYDividerColor', 'length': 'splitYDividerLength', 'width': 'splitYDividerWidth',\
             'dash': 'splitYDividerDashStyle', 'angle': 'splitYDividerAngle', 'location': 'splitYDividerLocation'}
    if(param in items):
      if(value == self.__dict__[items[param]]):
        redraw = False
      self.__dict__[items[param]] = value

    # refresh plots
    if(redraw and self.splitY and self.splitYDivider):
      self.dataplotwidget.myRefresh()

  def setSplitYDivider(self, value=True, redraw=True):
    # toggles display of split y divider lines
    if(value == self.splitYDivider):
      redraw = False
    self.splitYDivider = value

    # refresh plots
    if(redraw):
      self.dataplotwidget.myRefresh()

  def setSplitY(self, value=True, redraw=True):
    # toggles splitting of y axes
    if(value == self.splitY):
      redraw = False
    self.splitY = value
    # update button in y control menu
    self.splitYButton.setChecked(self.splitY)
    # call toggleSplitY fxn
    self.toggleSplitY(redraw=redraw)

  def changeSplitYFraction(self, value=1.0, redraw=True):
    # update parameters
    if (value == self.splitYFraction):
      redraw = False
    self.splitYFraction = value
    # call toggleSplitY fxn
    self.toggleSplitY(redraw=redraw, toggled=False)

  def changeSplitYPad(self, value=0.02, redraw=True):
    # update parameters
    if (value == self.splitYPad):
      redraw = False
    self.splitYPad = value
    # call toggleSplit fxn
    self.toggleSplitY(redraw=redraw, toggled=False)

  def setInnerYParameter(self, param='axes', state=True, redraw=True):
    # changes parameters for display of items at split y axis interface
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        self.innerAxesY = state
      else:
        self.innerTicksY = state
        
      # apply these settings
      self.updateInnerYSituation()

      # issue plot refreshs
      if(redraw):
        self.dataplotwidget.myRefresh()

  def updateInnerYSituation(self):
    # deals with axis and tick settings at inner boundary of split y axis
    if(self.splitY):
      # deal with axis spines at interface
      for axis in [self.ax, self.ax_div]:
        axis.spines['bottom'].set_visible(self.innerAxesY and self.axisVisible['bottom'])
        axis.spines['bottom'].set_linewidth(self.axisWidth['bottom'])
        axis.spines['bottom'].set_linestyle(self.axisStyle['bottom'])
        axis.spines['bottom'].set_capstyle(self.axisDashStyle['bottom'])
        axis.spines['bottom'].set_color(self.axisColor['bottom'])
        if(self.axisBoundaryCheck['bottom']):
          lower, upper = self.axisBoundary['bottom']
          axis.spines['bottom'].set_bounds(lower, upper)
        else:
          axis.spines['bottom']._bounds = None

      # deal with axis on secondary plot
      for axis in [self.ax, self.ax_div, self.ax2, self.ax2_div]:
        if(axis in [self.ax, self.ax_div]):
          axis.spines['top'].set_visible(self.axisVisible['top'])
        else:
          axis.spines['top'].set_visible(self.innerAxesY and self.axisVisible['top'])
        axis.spines['top'].set_linewidth(self.axisWidth['top'])
        axis.spines['top'].set_linestyle(self.axisStyle['top'])
        axis.spines['top'].set_capstyle(self.axisDashStyle['top'])
        axis.spines['top'].set_color(self.axisColor['top'])
        if(self.axisBoundaryCheck['top']):
          lower, upper = self.axisBoundary['top']
          axis.spines['top'].set_bounds(lower, upper)
        else:
          axis.spines['top']._bounds = None
      
      # now deal with ticks
      for axis in [self.ax, self.ax_div]:
        # need to enable axis visibility to show ticks
        axis.xaxis.set_visible(True)
        axis.xaxis.set_tick_params(which='both', top=self.ticksVisible['top'], bottom=self.ticksVisible['bottom'] and self.innerTicksY,\
                                   width=self.ticksWidth['top'], color=self.ticksColor['top'], direction=self.ticksDirection['top'])
        axis.xaxis.set_tick_params(which='major', length=self.ticksLength['top'])
        axis.xaxis.set_tick_params(which='minor', length=self.ticksLength['top'] * self.ticksXMinorRelativeLength)

      for axis in [self.ax2, self.ax2_div]:
        axis.xaxis.set_tick_params(which='both', top=self.ticksVisible['top'] and self.innerTicksY, bottom=self.ticksVisible['bottom'])

      # ensure that no tick labels displayed at split
      self.ax.xaxis.set_tick_params(which='both', labeltop=self.ticksLabelShow['top'] and self.ticksXShow, labelbottom=False)
      self.ax_div.xaxis.set_tick_params(which='both', labeltop=self.ticksLabelShow['top'] and self.ticksXShow, labelbottom=False)
      self.ax2.xaxis.set_tick_params(which='both', labeltop=False, labelbottom=self.ticksLabelShow['bottom'] and self.ticksXShow)
      self.ax2_div.xaxis.set_tick_params(which='both', labeltop=False, labelbottom=self.ticksLabelShow['bottom'] and self.ticksXShow)

  def toggleSplitYHelper(self, state=True):
    # helper function called by toggleSplitY and loadState to deal with split cursors
    if(state):
      # activate rectangle selectors
      self.rectSelector2.set_active(True)
      self.rectSelector2_div.set_active(True)
      self.storeCoord = []
  
      if((self.cursor != None) and (self.cursor2 == None)):
        self.cursor2 = MyCursor(self.ax2, useblit=True, color='black', linewidth=0.5)
        self.cursor2.setParent(self)
        self.cursor2.setAx2(self.ax2)
        
        # link cursors
        self.cursor.setTwinVertical(self.cursor2)
        self.cursor2.setTwinVertical(self.cursor)
        
        # toggle visibility
        self.cursor2.toggleVisibility(self.cursorVisible, None)
        
      if(self.splitShow and (self.cursor_div != None) and (self.cursor2_div == None)):
        self.cursor2_div = MyCursor(self.ax2_div, useblit=True, color='black', linewidth=0.5)
        self.cursor2_div.setParent(self)
        self.cursor2_div.setAx2(self.ax2_div)
        
        # link cursors
        if(self.cursor_div != None):
          self.cursor_div.setTwinVertical(self.cursor2_div)
          self.cursor2_div.setTwinVertical(self.cursor_div)
        if(self.cursor2 != None):
          self.cursor2.setTwin(self.cursor2_div)
          self.cursor2_div.setTwin(self.cursor2)
        
        # toggle visibility
        self.cursor2_div.toggleVisibility(self.cursorVisible, None)
    else:
      # deactivate rectangle selectors
      self.rectSelector2.set_active(False)
      self.rectSelector2_div.set_active(False)
      self.storeCoord = []
      
      if(self.cursor != None):
        self.cursor.setTwinVertical(None)
      if(self.cursor_div != None):
        self.cursor_div.setTwinVertical(None)
      if(self.cursor2 != None):
        del self.cursor2
        self.cursor2 = None
      if(self.cursor2_div != None):
        del self.cursor2_div
        self.cursor2_div = None

  def toggleSplitY(self, redraw=True, toggled=True):
    # toggle second axes
    self.toggleSecondAxes(self.isSecondAxesActive())
    
    # helper function for split y axes
    if(self.splitY):
      ybreak = (self.padSize['top'] - self.padSize['bottom'] - self.splitYPad) * self.splitYFraction / (1.0 + self.splitYFraction)
      self.ax.set_position(matplotlib.transforms.Bbox([[self.padSize['left'], self.padSize['bottom'] + ybreak + self.splitYPad], [self.padSize['right'], self.padSize['top']]]))
      self.ax2.set_position(matplotlib.transforms.Bbox([[self.padSize['left'], self.padSize['bottom']], [self.padSize['right'], self.padSize['bottom'] + ybreak]]))
    else:
      self.matplot.subplots_adjust(left=self.padSize['left'], right=self.padSize['right'],\
        bottom=self.padSize['bottom'], top=self.padSize['top'])

    # adjust some graphic settings if y axes are split/unsplit
    if(self.splitY):
      if(toggled):
        if(self.canvasFill):
          # deal with patch background
          self.ax.patch.set_visible(True)
          self.ax_div.patch.set_visible(True)
          if(self.canvasGradientVisible):
            self.ax.patch.set_facecolor('none')
            self.ax_div.patch.set_facecolor('none')
          else:
            self.ax.patch.set_facecolor(self.canvasColor)
            self.ax_div.patch.set_facecolor(self.canvasColor)
  
        # store some settings
        items = 'axisVisible,axisWidth,axisStyle,axisDashStyle,axisColor,axisPosition,axisPositionValue'.split(',')
        items.extend('ticksVisible,ticksWidth,ticksLength,ticksColor,ticksDirection,ticksLabelShow'.split(','))
        for item in items:
          self.splitYBackup[item] = {}
          for item2 in ['left', 'right']:
            self.splitYBackup[item][item2] = self.__dict__[item][item2 + '2']
            
        items = 'ticksY2Show,ticksY2Color,ticksY2Size,ticksY2Weight,ticksY2Style,ticksY2Angle'.split(',')
        items.extend('ticksY2Alignment,ticksY2AlignmentVertical,ticksY2Pad,ticksY2Pad2,labelY2Show'.split(','))
        items.extend('ticksY2Minor,ticksY2MinorRelativeLength,ticksY2Format,ticksY2FormatPrecision,ticksY2FormatTrailZero'.split(','))
        items.extend('ticksY2FormatSeparator,ticksY2FormatComma,ticksY2FormatPrefix,ticksY2FormatPostfix'.split(','))
        for item in items:
          self.splitYBackup[item] = self.__dict__[item]
  
        items = 'tickFont,gridVisible,gridWidth,gridStyle,gridDashStyle,gridColor,gridOrder'.split(',')
        for item in items:
          self.splitYBackup[item] = self.__dict__[item]['y2']
          
        # adjust display of axis
        for item in ['left', 'right']:
          self.setAxisVisibility(value=self.axisVisible[item], axis=item + '2', redraw=False, target='plot')
          self.setAxisWidth(value=self.axisWidth[item], axis=item + '2', redraw=False, target='plot')
          self.setAxisStyle(value=self.axisStyle[item], axis=item + '2', redraw=False, target='plot')
          self.setAxisDashStyle(value=self.axisDashStyle[item], axis=item + '2', redraw=False, target='plot')
          self.setAxisColor(value=self.axisColor[item], axis=item + '2', redraw=False, target='plot')
          # also need to copy axis position settings
          self.setAxisPosition(value=self.axisPosition[item], axis=item + '2', redraw=False, target='plot')
          self.setAxisPositionValue(value=self.axisPositionValue[item], axis=item + '2', redraw=False, target='plot')
          
        # also need to turn on shifted top and bottom axis
        for item in ['top', 'bottom']:
          # phew, we will need to update setAxisPositionHelper() to accommodate this option
          self.setAxisPositionHelper(axis=item, plotobject=self.dataplotwidget, axisobject=self.ax, target='plot', secondAxes=False, splitX=False, splitY=True)
          self.setAxisPositionHelper(axis=item, plotobject=self.dataplotwidget, axisobject=self.ax_div, target='plot', secondAxes=False, splitX=False, splitY=True)
  
        # adjust display of ticks
        for item in ['left', 'right']:
          self.setTickMarkVisibility(value=self.ticksVisible[item], axis=item + '2', redraw=False, target='plot')
          self.setTickMarkWidth(value=self.ticksWidth[item], axis=item + '2', redraw=False, target='plot')
          self.setTickMarkLength(value=self.ticksLength[item], axis=item + '2', redraw=False, target='plot')
          self.setTickMarkColor(value=self.ticksColor[item], axis=item + '2', redraw=False, target='plot')
          self.setTickMarkDirection(value=self.ticksDirection[item], axis=item + '2', redraw=False, target='plot')
          self.setTickMarkLabelShow(value=self.ticksLabelShow[item], axis=item + '2', redraw=False, target='plot')
  
        # tick marks
        self.toggleTicksLabel(value=self.ticksYShow, axis='y2', redraw=False, target='plot')
        self.setTickLabelColor(value=self.ticksYColor, axis='y2', redraw=False, target='plot')
        self.setTickLabelSize(value=self.ticksYSize, axis='y2', redraw=False, target='plot')
        self.setTickLabelBold(value=self.ticksYWeight, axis='y2', redraw=False, target='plot')
        self.setTickLabelItalic(value=self.ticksYStyle, axis='y2', redraw=False, target='plot')
        self.setTickLabelAngle(value=self.ticksYAngle, axis='y2', redraw=False, target='plot')
        self.setTickLabelAlignment(value=self.ticksYAlignment, axis='y2', redraw=False, target='plot')
        self.setTickLabelAlignmentVertical(value=self.ticksYAlignmentVertical, axis='y2', redraw=False, target='plot')
        self.setTickLabelPad(value=self.ticksYPad, axis='y2', redraw=False, target='plot')
        self.setTickLabelPad2(value=self.ticksYPad2, axis='y2', redraw=False, target='plot')
        self.setTickFont(value=self.tickFont['y'], axis='y2', redraw=False, target='plot')
  
        # grid and axis labels
        self.toggleAxisLabel(value=False, axis='y2', redraw=False, target='plot')
        self.setGridVisibility(value=self.gridVisible['y'], axis='y2', redraw=False, target='plot')
        self.setGridWidth(value=self.gridWidth['y'], axis='y2', redraw=False, target='plot')
        self.setGridStyle(value=self.gridStyle['y'], axis='y2', redraw=False, target='plot')
        self.setGridDashStyle(value=self.gridDashStyle['y'], axis='y2', redraw=False, target='plot')
        self.setGridColor(value=self.gridColor['y'], axis='y2', redraw=False, target='plot')
        self.setGridOrder(value=self.gridOrder['y'], axis='y2', redraw=False, target='plot')
  
        # deal with the innner situation
        self.updateInnerYSituation()
  
        # update graphiscarea 2
        if(hasattr(self.parent, 'graphicsarea2')):
          self.parent.graphicsarea2.updateFields()
  
          self.parent.graphicsarea2.configSplitYBox.show()
          self.parent.graphicsarea2.splitYSeparator.show()
          # check whether advanced graphics enabled
          if(self.parent.graphicsarea.advancedExport['advancedGraphics']):
            if(hasattr(self.parent.graphicsarea2, 'configSplitYBox2')):
              self.parent.graphicsarea2.configSplitYBox2.show()
            if(hasattr(self.parent.graphicsarea2, 'configSplitYBox3')):
              self.parent.graphicsarea2.configSplitYBox3.show()
  
        # draw all items on split axes and check them
        for data in self.parent.data:
          if(data.visibility):
            data.onBothAxes = True
            data.duplicateForSplit()
  
        for curve in self.parent.fit:
          if(curve.visibility):
            curve.onBothAxes = True
            curve.duplicateForSplit()
          
        for extra in self.parent.extras:
          if(extra.visibility):
            extra.onBothAxes = True
            extra.duplicateForSplit()
            
        # also draw selected data on both axes
        if(self.parent.selectedData.isLive):
          self.parent.selectedData.duplicateForSplit()
          self.parent.selectedData.style.update(self.parent.selectedData.theseStyles)
          
        # set axis mode and limits to match those of first axes
        self.secondModeSelector.blockSignals(True)
        index = self.secondModeSelector.findText(self.modeY)
        self.secondModeSelector.setCurrentIndex(index)
        self.secondModeSelector.blockSignals(False)
        self.changeAxisMode('y2', redraw=False)
        # set axes limits for split effect
        if(self.modeY == 'linear'):
          splitYAt = self.minY + self.splitYFraction / (self.splitYFraction + 1) * (self.maxY - self.minY)
        else:
          splitYAt = np.exp(np.log(self.minY) + self.splitYFraction / (self.splitYFraction + 1) * (np.log(self.maxY) - np.log(self.minY)))
        self.setAxisLimits(lower=self.minY, upper=splitYAt, axis='y2', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.secondLowerLimit.setText(self.lowerLimity.text())
        self.secondUpperLimit.setText(self.parent.formatNumber(splitYAt))
        self.setAxisLimits(lower=splitYAt, upper=self.maxY, axis='y', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.lowerLimity.setText(self.parent.formatNumber(splitYAt))

        # also need to copy custom tick formatting (if axis modes on y axes are the same)
        # => but we just copied the mode, so this is always the case
        self.setMinorTick(value=self.ticksYMinor, axis='y2', redraw=False, target='plot')
        self.setMinorTickRelativeLength(value=self.ticksYMinorRelativeLength, axis='y2', redraw=False, target='plot')
        self.setTickFormat(axis='y2', value=self.ticksYFormat, redraw=False)
        self.setTickFormatPrecision(axis='y2', value=self.ticksYFormatPrecision, redraw=False)
        self.setFormatTrailZero(axis='y2', value=self.ticksYFormatTrailZero, redraw=False)
        self.setFormatSeparator(axis='y2', value=self.ticksYFormatSeparator, redraw=False)
        self.setFormatComma(axis='y2', value=self.ticksYFormatComma, redraw=False)
        self.setFormatFix(axis='y2', value=self.ticksYFormatPrefix, redraw=False, prefix=True)
        self.setFormatFix(axis='y2', value=self.ticksYFormatPostfix, redraw=False, prefix=False)
        
        # activate rectangle selectors and generate new cursor if needed
        self.toggleSplitYHelper(state=True)
    else:
      # deal with patch background
      self.ax.patch.set_visible(False)
      self.ax_div.patch.set_visible(False)
      
      # adjust display of axis
      for item in ['left', 'right']:
        if(('axisVisible' in self.splitYBackup) and (item in self.splitYBackup['axisVisible'])):
          if(self.splitShow and (item == 'right')):
            self.setAxisVisibility(value=self.innerAxes and self.axisVisible['right2'], axis='right2', redraw=False, target='plot')
          else:
            self.setAxisVisibility(value=self.splitYBackup['axisVisible'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisWidth' in self.splitYBackup) and (item in self.splitYBackup['axisWidth'])):
          self.setAxisWidth(value=self.splitYBackup['axisWidth'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisStyle' in self.splitYBackup) and (item in self.splitYBackup['axisStyle'])):
          self.setAxisStyle(value=self.splitYBackup['axisStyle'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisDashStyle' in self.splitYBackup) and (item in self.splitYBackup['axisDashStyle'])):
          self.setAxisDashStyle(value=self.splitYBackup['axisDashStyle'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisColor' in self.splitYBackup) and (item in self.splitYBackup['axisColor'])):
          self.setAxisColor(value=self.splitYBackup['axisColor'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisPosition' in self.splitYBackup) and (item in self.splitYBackup['axisPosition'])):
          self.setAxisPosition(value=self.splitYBackup['axisPosition'][item], axis=item + '2', redraw=False, target='plot')
        if(('axisPositionValue' in self.splitYBackup) and (item in self.splitYBackup['axisPositionValue'])):
          self.setAxisPositionValue(value=self.splitYBackup['axisPositionValue'][item], axis=item + '2', redraw=False, target='plot')

      # adjust display of ticks
      for item in ['left', 'right']:
        if(('ticksVisible' in self.splitYBackup) and (item in self.splitYBackup['ticksVisible'])):
          self.setTickMarkVisibility(value=self.splitYBackup['ticksVisible'][item], axis=item + '2', redraw=False, target='plot')
        if(('ticksWidth' in self.splitYBackup) and (item in self.splitYBackup['ticksWidth'])):
          self.setTickMarkWidth(value=self.splitYBackup['ticksWidth'][item], axis=item + '2', redraw=False, target='plot')
        if(('ticksLength' in self.splitYBackup) and (item in self.splitYBackup['ticksLength'])):
          self.setTickMarkLength(value=self.splitYBackup['ticksLength'][item], axis=item + '2', redraw=False, target='plot')
        if(('ticksColor' in self.splitYBackup) and (item in self.splitYBackup['ticksColor'])):
          self.setTickMarkColor(value=self.splitYBackup['ticksColor'][item], axis=item + '2', redraw=False, target='plot')
        if(('ticksDirection' in self.splitYBackup) and (item in self.splitYBackup['ticksDirection'])):
          self.setTickMarkDirection(value=self.splitYBackup['ticksDirection'][item], axis=item + '2', redraw=False, target='plot')
        if(('ticksLabelShow' in self.splitYBackup) and (item in self.splitYBackup['ticksLabelShow'])):
          self.setTickMarkLabelShow(value=self.splitYBackup['ticksLabelShow'][item], axis=item + '2', redraw=False, target='plot')

      # tick marks
      if('ticksY2Show' in self.splitYBackup):
        self.toggleTicksLabel(value=self.splitYBackup['ticksY2Show'], axis='y2', redraw=False, target='plot')
      if('ticksY2Color' in self.splitYBackup):
        self.setTickLabelColor(value=self.splitYBackup['ticksY2Color'], axis='y2', redraw=False, target='plot')
      if('ticksY2Size' in self.splitYBackup):
        self.setTickLabelSize(value=self.splitYBackup['ticksY2Size'], axis='y2', redraw=False, target='plot')
      if('ticksY2Weight' in self.splitYBackup):
        self.setTickLabelBold(value=self.splitYBackup['ticksY2Weight'], axis='y2', redraw=False, target='plot')
      if('ticksY2Style' in self.splitYBackup):
        self.setTickLabelItalic(value=self.splitYBackup['ticksY2Style'], axis='y2', redraw=False, target='plot')
      if('ticksY2Angle' in self.splitYBackup):
        self.setTickLabelAngle(value=self.splitYBackup['ticksY2Angle'], axis='y2', redraw=False, target='plot')
      if('ticksY2Alignment' in self.splitYBackup):
        self.setTickLabelAlignment(value=self.splitYBackup['ticksY2Alignment'], axis='y2', redraw=False, target='plot')
      if('ticksY2AlignmentVertical' in self.splitYBackup):
        self.setTickLabelAlignmentVertical(value=self.splitYBackup['ticksY2AlignmentVertical'], axis='y2', redraw=False, target='plot')
      if('ticksY2Pad' in self.splitYBackup):
        self.setTickLabelPad(value=self.splitYBackup['ticksY2Pad'], axis='y2', redraw=False, target='plot')
      if('ticksY2Pad2' in self.splitYBackup):
        self.setTickLabelPad2(value=self.splitYBackup['ticksY2Pad2'], axis='y2', redraw=False, target='plot')
      if(('tickFont' in self.splitYBackup) and ('y2' in self.splitYBackup['tickFont'])):
        self.setTickFont(value=self.splitYBackup['tickFont']['y2'], axis='y2', redraw=False, target='plot')
        
      # custom tick formatting
      if('ticksY2Minor' in self.splitYBackup):
        self.setMinorTick(value=self.splitYBackup['ticksY2Minor'], axis='y2', redraw=False, target='plot')
      if('ticksY2MinorRelativeLength' in self.splitYBackup):
        self.setMinorTickRelativeLength(value=self.splitYBackup['ticksY2MinorRelativeLength'], axis='y2', redraw=False, target='plot')
      if('ticksY2Format' in self.splitYBackup):
        self.setTickFormat(axis='y2', value=self.splitYBackup['ticksY2Format'], redraw=False)
      if('ticksY2FormatPrecision' in self.splitYBackup):
        self.setTickFormatPrecision(axis='y2', value=self.splitYBackup['ticksY2FormatPrecision'], redraw=False)
      if('ticksY2FormatTrailZero' in self.splitYBackup):
        self.setFormatTrailZero(axis='y2', value=self.splitYBackup['ticksY2FormatTrailZero'], redraw=False)
      if('ticksY2FormatSeparator' in self.splitYBackup):
        self.setFormatSeparator(axis='y2', value=self.splitYBackup['ticksY2FormatSeparator'], redraw=False)
      if('ticksY2FormatComma' in self.splitYBackup):
        self.setFormatComma(axis='y2', value=self.splitYBackup['ticksY2FormatComma'], redraw=False)
      if('ticksY2FormatPrefix' in self.splitYBackup):
        self.setFormatFix(axis='y2', value=self.splitYBackup['ticksY2FormatPrefix'], redraw=False, prefix=True)
      if('ticksYFormatPostfix' in self.splitYBackup):
        self.setFormatFix(axis='y2', value=self.splitYBackup['ticksYFormatPostfix'], redraw=False, prefix=False)

      # grid and axis labels
      if('labelY2Show' in self.splitYBackup):
        self.toggleAxisLabel(value=self.splitYBackup['labelY2Show'], axis='y2', redraw=False, target='plot')
      if('gridVisible' in self.splitYBackup):
        self.setGridVisibility(value=self.splitYBackup['gridVisible'], axis='y2', redraw=False, target='plot')
      if('gridWidth' in self.splitYBackup):
        self.setGridWidth(value=self.splitYBackup['gridWidth'], axis='y2', redraw=False, target='plot')
      if('gridStyle' in self.splitYBackup):
        self.setGridStyle(value=self.splitYBackup['gridStyle'], axis='y2', redraw=False, target='plot')
      if('gridDashStyle' in self.splitYBackup):
        self.setGridDashStyle(value=self.splitYBackup['gridDashStyle'], axis='y2', redraw=False, target='plot')
      if('gridColor' in self.splitYBackup):
        self.setGridColor(value=self.splitYBackup['gridColor'], axis='y2', redraw=False, target='plot')
      if('gridOrder' in self.splitYBackup):
        self.setGridOrder(value=self.splitYBackup['gridOrder'], axis='y2', redraw=False, target='plot')

      # deal with axis on secondary plot
      for axis in [self.ax, self.ax_div]:
        axis.spines['top'].set_visible(False)
      for axis in [self.ax2, self.ax2_div]:
        axis.spines['top'].set_visible(self.axisVisible['top'])

      # update graphiscarea 2
      if(hasattr(self.parent, 'graphicsarea2')):
        self.parent.graphicsarea2.updateFields()

        self.parent.graphicsarea2.configSplitYBox.hide()
        self.parent.graphicsarea2.configSplitYBox2.hide()
        self.parent.graphicsarea2.configSplitYBox3.hide()
        self.parent.graphicsarea2.splitYSeparator.hide()

      # clear all duplicated graphics
      for data in self.parent.data:
        data.removeFromSplit()

      for curve in self.parent.fit:
        curve.removeFromSplit()

      for extra in self.parent.extras:
        extra.removeFromSplit()

      # remove selected data from both axes
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.removeFromSplit()
          
      # clear stored info
      self.splitYBackup = {}
      
      # reset axis limits to nonsplit
      if((self.modeY == 'linear') or (self.minY2 > 0)):
        self.setAxisLimits(lower=self.minY2, upper=self.maxY, axis='y', updateLabel=False, target='plot', redraw=False, updateTicks=True, updateGrid=True, preserveInverted=True)
        self.lowerLimity.setText(self.parent.formatNumber(self.minY2))
      
      # deactivate cursors
      self.toggleSplitYHelper(state=False)

    # refresh tables in objects tab
    self.parent.objectsarea.refreshDataTable()
    self.parent.objectsarea.refreshCurvesTable()
    self.parent.objectsarea.refreshExtrasTable()

    # refresh plots
    if(redraw):
      self.dataplotwidget.myRefresh()

  def reportState(self):
    # returns current settings for save state function
    reportItems = ['minX', 'maxX', 'minY', 'maxY', 'minResidY', 'maxResidY', 'modeX', 'modeY', 'autoScaleX', 'autoScaleY']
    reportItems.extend(['minY2', 'maxY2', 'modeY2', 'autoScaleY2'])
    reportItems.extend(['splitShow', 'splitY', 'minX_div', 'maxX_div', 'modeX_div', 'autoScaleX_div'])
    retv = {}

    for entry in reportItems:
      if(hasattr(self, entry)):
        value = getattr(self, entry)
        retv[entry] = value
        
    # also add current zoom level (which, however, belongs to parent object)
    currZoomIndex = self.parent.zoomSelector.currentIndex()
    retv['zoomLevel'] = self.parent.zoomLevels[::-1][currZoomIndex]
    
    return retv
  
  def restoreState(self, settings, updateTicks=True):
    # restores settings from load state function
    for entry in settings:
      if(hasattr(self, entry)):
        self.__dict__[entry] = settings[entry]

    # remember desired axes limits
    orig_minX, orig_maxX = self.minX, self.maxX
    orig_minY, orig_maxY = self.minY, self.maxY
    orig_minResidY, orig_maxResidY = self.minResidY, self.maxResidY
    orig_minY2, orig_maxY2 = self.minY2, self.maxY2
    orig_minX_div, orig_maxX_div = self.minX_div, self.maxX_div
    
    # apply these settings
    # autoscale
    self.autoScaleCheckX.setChecked(self.autoScaleX)
    self.autoScaleCheckY.setChecked(self.autoScaleY)
    self.xSplitAutoScaleCheckX.setChecked(self.autoScaleX_div)

    # axes modes
    index = self.modeSelectorx.findText(self.modeX)
    if((index + 1) and (index != self.modeSelectorx.currentIndex())):
      self.modeSelectorx.blockSignals(True)
      self.modeSelectorx.setCurrentIndex(index)
      self.modeSelectorx.blockSignals(False)
      self.changeAxisMode('x', redraw=False)
    index = self.modeSelectory.findText(self.modeY)
    if((index + 1) and (index != self.modeSelectory.currentIndex())):
      self.modeSelectory.blockSignals(True)
      self.modeSelectory.setCurrentIndex(index)
      self.modeSelectory.blockSignals(False)
      self.changeAxisMode('y', redraw=False)
    index = self.secondModeSelector.findText(self.modeY2)
    if((index + 1) and (index != self.secondModeSelector.currentIndex())):
      self.secondModeSelector.blockSignals(True)
      self.secondModeSelector.setCurrentIndex(index)
      self.secondModeSelector.blockSignals(False)
      self.changeAxisMode('y2', redraw=False)
    index = self.xSplitModeSelectorx.findText(self.modeX_div)
    if((index + 1) and (index != self.xSplitModeSelectorx.currentIndex())):
      self.xSplitModeSelectorx.blockSignals(True)
      self.xSplitModeSelectorx.setCurrentIndex(index)
      self.xSplitModeSelectorx.blockSignals(False)
      self.changeAxisMode('x2', redraw=False)
    
    # need to counteract resetting of axis ticks when adjusting axis mode
    minX, maxX = self.minX, self.maxX
    minY, maxY = self.minY, self.maxY
    minResidY, maxResidY = self.minResidY, self.maxResidY
    minY2, maxY2 = self.minY2, self.maxY2
    minX_div, maxX_div = self.minX_div, self.maxX_div
    
    # apply tick formatting
    if(self.ticksXAuto):
      self.setAutoTicks(axis='x', redraw=False, target='plot')
      self.setAutoTicks(axis='x', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel = ticksXLabel
      if(len(self.ticksXLabel)):
        for axisobject in [self.ax, self.ax_resid]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel)
    if(self.ticksXAuto_div):
      self.setAutoTicks(axis='x2', redraw=False, target='plot')
      self.setAutoTicks(axis='x2', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel_div
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel_div = ticksXLabel
      if(len(self.ticksXLabel_div)):
        for axisobject in [self.ax2_div, self.ax_resid_div]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel_div)
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='y', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY, axis='y', redraw=False, target='plot')
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='resid', redraw=False, target='resid')
    else:
      self.setAxisTicks(value=self.ticksResidY, axis='resid', redraw=False, target='resid')

    if(self.ticksY2Auto):
      self.setAutoTicks(axis='y2', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY2, axis='y2', redraw=False, target='plot')

    # retrieve settings
    self.minX, self.maxX = minX, maxX
    self.minY, self.maxY = minY, maxY
    self.minResidY, self.maxResidY = minResidY, maxResidY
    self.minY2, self.maxY2 = minY2, maxY2
    self.minX_div, self.maxX_div = minX_div, maxX_div
    
    # check wether we can go to original values specified in state
    if(self.modeX == 'linear'):
      self.minX, self.maxX = orig_minX, orig_maxX
    else:
      self.minX, self.maxX = [i if (i > 0) else j for i, j in zip([orig_minX, orig_maxX], [self.minX, self.maxX])]
    if(self.modeY == 'linear'):
      self.minY, self.maxY = orig_minY, orig_maxY
    else:
      self.minY, self.maxY = [i if (i > 0) else j for i, j in zip([orig_minY, orig_maxY], [self.minY, self.maxY])]
    if(self.modeY2 == 'linear'):
      self.minY2, self.maxY2 = orig_minY2, orig_maxY2
    else:
      self.minY2, self.maxY2 = [i if (i > 0) else j for i, j in zip([orig_minY2, orig_maxY2], [self.minY2, self.maxY2])]
    self.minResidY, self.maxResidY = orig_minResidY, orig_maxResidY
    if(self.modeX_div == 'linear'):
      self.minX_div, self.maxX_div = orig_minX_div, orig_maxX_div
    else:
      self.minX_div, self.maxX_div = [i if (i > 0) else j for i, j in zip([orig_minX_div, orig_maxX_div], [self.minX_div, self.maxX_div])]
    
    # adjust zoom level if specified
    if('zoomLevel' in settings):
      # set actual zoom level
      self.setZoomLevel(settings['zoomLevel'], redraw=False)
      # adjust selection dialog
      zoomDifference = [abs(settings['zoomLevel'] - i) for i in self.parent.zoomLevels[::-1]]
      zoomIndex = zoomDifference.index(min(zoomDifference))
      self.parent.zoomSelector.blockSignals(True)
      self.parent.zoomSelector.setCurrentIndex(zoomIndex)
      self.parent.zoomSelector.blockSignals(False)
      
    # toggle split x axis
    if(self.splitAxisButton.isChecked() != self.splitShow):
      self.splitAxisButton.setChecked(self.splitShow)
      self.toggleSplit(redraw=False, toggled=False)
      
    # toggle split y axis
    if(self.splitYButton.isChecked() != self.splitY):
      self.splitYButton.setChecked(self.splitY)
      self.toggleSplitY(redraw=False, toggled=False)

    # axes limits
    self.setAxisLimits(lower=self.minX, upper=self.maxX, axis='x', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minY2, upper=self.maxY2, axis='y2', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minY, upper=self.maxY, axis='y', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minX, upper=self.maxX, axis='x', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minResidY, upper=self.maxResidY, axis='y', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)

    self.setAxisLimits(lower=self.minX_div, upper=self.maxX_div, axis='x2', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minX_div, upper=self.maxX_div, axis='x2', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)
    
    # draw zero resid line over (updated) x range
    self.handleResidZero = self.plotResidZero(self.handleResidZero, redraw=False)
    self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, redraw=False, splitX=True)

    # update tick entry fields
    for axis in ['x', 'x2', 'y', 'y2', 'resid']:
      self.updateTickEntryField(axis=axis)

  def incZoomLevel(self, increment=1):
    # used by mouse wheel to adjust zoom level
    currZoomIndex = self.parent.zoomSelector.currentIndex()
    # alter zoom level but restrain in bounds
    nuZoomIndex = currZoomIndex + increment
    nuZoomIndex = max(0, nuZoomIndex)
    nuZoomIndex = min(len(self.parent.zoomLevels) -1, nuZoomIndex)
    # do we need to change anything?
    if(currZoomIndex != nuZoomIndex):
      self.parent.zoomSelector.setCurrentIndex(nuZoomIndex)

  def setZoomLevel(self, zoomLevel=100, redraw=True):
    # sets zoom level of plots
    if(self.matplot.get_dpi() != zoomLevel):
      # get current size and scale factor
      scaleFactor = self.matplot.get_dpi() / zoomLevel
      currSize = self.matplot.get_size_inches()
      # change canvas DPI
      self.matplot.set_dpi(zoomLevel)
      # adjust size accordingly
      nuSize = [i * scaleFactor for i in currSize]
      self.matplot.set_size_inches(nuSize)
      self.horizontalRuler.updateRuler()
      self.verticalRuler.updateRuler()
      # check for presence of data selection (which would need to be adjusted)
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.adjustMarkerSize(resid=False)
      # issue plot refresh
      if(redraw):
        self.dataplotwidget.myRefresh()
    
    if(self.residplot.get_dpi() != zoomLevel):
      # get current size and scale factor
      scaleFactor = self.residplot.get_dpi() / zoomLevel
      currSize = self.residplot.get_size_inches()
      # change canvas DPI
      self.residplot.set_dpi(zoomLevel)
      # adjust size accordingly
      nuSize = [i * scaleFactor for i in currSize]
      self.residplot.set_size_inches(nuSize)
      self.verticalRulerResid.updateRuler()
      # check for presence of data selection (which would need to be adjusted)
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.adjustMarkerSize(resid=True)
      # issue plot refresh
      if(redraw):
        self.residplotwidget.myRefresh()

  def setTickFormatHelper(self, axis='x', redraw=True):
    # accessory function to format tick labels
    if(axis in ['x', 'residx']):
      useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, useFallback =\
        self.ax2, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXFormatTrailZero, self.ticksXFormatSeparator, self.ticksXFormatComma, self.fallback_ticksXFormat
      usePrefix, usePostfix = self.ticksXFormatPrefix, self.ticksXFormatPostfix
      if(axis == 'residx'):
        useAxisobject, item = self.ax_resid, 'resid'
      else:
        item = 'plot'
    elif(axis in ['x2', 'residx2']):
      useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, useFallback =\
        self.ax2_div, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.ticksXFormatComma_div, self.fallback_ticksXFormat_div
      usePrefix, usePostfix = self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div
      if(axis == 'residx2'):
        useAxisobject, item = self.ax_resid_div, 'resid'
      else:
        item = 'plot'
    elif(axis == 'y'):
      useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, useFallback =\
        self.ax, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.ticksYFormatComma, self.fallback_ticksYFormat
      usePrefix, usePostfix = self.ticksYFormatPrefix, self.ticksYFormatPostfix
      item = 'plot'
    elif(axis == 'y2'):
      useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, useFallback =\
        self.ax2, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.ticksY2FormatComma, self.fallback_ticksY2Format
      usePrefix, usePostfix = self.ticksY2FormatPrefix, self.ticksY2FormatPostfix
      item = 'plot'
    elif(axis == 'resid'):
      useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, useFallback =\
        self.ax_resid, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.ticksResidYFormatComma, self.fallback_ticksResidYFormat
      usePrefix, usePostfix = self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix
      item = 'resid'
    else:
      useTicksFormat = 'tilt'
      item = 'none'
    
    if(item in ['plot', 'resid']):
      # now apply the altered tick formatting
      # this should be easy as long as we turn on custom formatting
      if(useTicksFormat != 'default'):
        autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, usePrefix, usePostfix))
      elif(useFallback != None):
        autolabels = useFallback
      else:
        # scalar formatter should be safe (except when using data ticks but then fallback should exist)
        autolabels = matplotlib.ticker.ScalarFormatter()
      if(axis in ['x', 'x2', 'residx', 'residx2']):
        useAxisobject.xaxis.set_major_formatter(autolabels)
      else:
        useAxisobject.yaxis.set_major_formatter(autolabels)
      
      # issue plot redraw
      if(redraw):
        if(item == 'plot'):
          self.dataplotwidget.myRefresh()
        else:
          self.residplotwidget.myRefresh()    

  def setTickFormatPrecision(self, axis='x', value=2, redraw=True):
    # changes precision in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatPrecision) or (axis == 'residx')):
          self.ticksXFormatPrecision, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatPrecision_div) or (axis == 'residx2')):
          self.ticksXFormatPrecision_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatPrecision):
          self.ticksYFormatPrecision, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatPrecision):
          self.ticksY2FormatPrecision, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatPrecision):
          self.ticksResidYFormatPrecision, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False
      self.setTickFormatHelper(axis=axis, redraw=redraw)
          
  def setTickFormat(self, axis='x', value='float', redraw=True):
    # changes type of custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormat) or (axis == 'residx')):
          self.ticksXFormat = value
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormat_div) or (axis == 'residx2')):
          self.ticksXFormat_div = value
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormat):
          self.ticksYFormat = value
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2Format):
          self.ticksY2Format = value
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormat):
          self.ticksResidYFormat = value
        else:
          redraw = False
      else:
        redraw = False

      self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatTrailZero(self, axis='x', value=True, redraw=True):
    # set trailing zeros of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatTrailZero) or (axis == 'residx')):
          self.ticksXFormatTrailZero, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatTrailZero_div) or (axis == 'residx2')):
          self.ticksXFormatTrailZero_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatTrailZero):
          self.ticksYFormatTrailZero, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatTrailZero):
          self.ticksY2FormatTrailZero, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatTrailZero):
          self.ticksResidYFormatTrailZero, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False
      self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatComma(self, axis='x', value=True, redraw=True):
    # set comma as decimal sign in tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatComma) or (axis == 'residx')):
          self.ticksXFormatComma, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatComma_div) or (axis == 'residx2')):
          self.ticksXFormatComma_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatComma):
          self.ticksYFormatComma, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatComma):
          self.ticksY2FormatComma, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatComma):
          self.ticksResidYFormatComma, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False
      self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatSeparator(self, axis='x', value=True, redraw=True):
    # set separate 1000s of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatSeparator) or (axis == 'residx')):
          self.ticksXFormatSeparator, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatSeparator_div) or (axis == 'residx2')):
          self.ticksXFormatSeparator_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatSeparator):
          self.ticksYFormatSeparator, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatSeparator):
          self.ticksY2FormatSeparator, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatSeparator):
          self.ticksResidYFormatSeparator, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat != 'float'):
        redraw = False
      self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatFix(self, axis='x', value=True, redraw=True, prefix=True):
    # sets pre/postfix of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if(prefix):
          if((value != self.ticksXFormatPrefix) or (axis == 'residx')):
            self.ticksXFormatPrefix, useTicksFormat = value, self.ticksXFormat
          else:
            redraw = False
        else:
          if((value != self.ticksXFormatPostfix) or (axis == 'residx')):
            self.ticksXFormatPostfix, useTicksFormat = value, self.ticksXFormat
          else:
            redraw = False
      elif(axis in ['x2', 'residx2']):
        if(prefix):
          if((value != self.ticksXFormatPrefix_div) or (axis == 'residx2')):
            self.ticksXFormatPrefix_div, useTicksFormat = value, self.ticksXFormat_div
          else:
            redraw = False
        else:
          if((value != self.ticksXFormatPostfix_div) or (axis == 'residx2')):
            self.ticksXFormatPostfix_div, useTicksFormat = value, self.ticksXFormat_div
          else:
            redraw = False
      elif(axis == 'y'):
        if(prefix):
          if(value != self.ticksYFormatPrefix):
            self.ticksYFormatPrefix, useTicksFormat = value, self.ticksYFormat
          else:
            redraw = False
        else:
          if(value != self.ticksYFormatPostfix):
            self.ticksYFormatPostfix, useTicksFormat = value, self.ticksYFormat
          else:
            redraw = False
      elif(axis == 'y2'):
        if(prefix):
          if(value != self.ticksY2FormatPrefix):
            self.ticksY2FormatPrefix, useTicksFormat = value, self.ticksY2Format
          else:
            redraw = False
        else:
          if(value != self.ticksY2FormatPostfix):
            self.ticksY2FormatPostfix, useTicksFormat = value, self.ticksY2Format
          else:
            redraw = False
      elif(axis == 'resid'):
        if(prefix):
          if(value != self.ticksResidYFormatPrefix):
            self.ticksResidYFormatPrefix, useTicksFormat = value, self.ticksResidYFormat
          else:
            redraw = False
        else:
          if(value != self.ticksResidYFormatPostfix):
            self.ticksResidYFormatPostfix, useTicksFormat = value, self.ticksResidYFormat
          else:
            redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False
      self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setInnerParameter(self, param='axes', state=True, redraw=True):
    # changes parameters for display of items at split axis interface
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        self.innerAxes = state
      else:
        self.innerTicks = state
        
      # apply these settings
      self.updateInnerSituation()

      # issue plot refreshs
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()

  def updateInnerSituation(self):
    # updates graphic items at interface between split axes
    # do this only when split is activated as otherwise right axis and tick marks will be messed up
    if(self.splitShow):
      # deal with axis spines
      secondAxes = self.isSecondAxesActive()
      self.ax.spines['right'].set_visible(self.innerAxes and self.axisVisible['right'])
      self.ax_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left'])
      self.ax_resid.spines['right'].set_visible(self.innerAxes and self.axisVisible['right'])
      self.ax_resid_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left'])
      if(secondAxes):
        self.ax2.spines['right'].set_visible(self.innerAxes and self.axisVisible['right2'])
        self.ax2_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left2'])
      
      # now deal with ticks
      self.ax.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], right=self.ticksVisible['right'] and self.innerTicks)
      self.ax_div.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'] and self.innerTicks, right=self.ticksVisible['right'])
      self.ax_resid.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], right=self.ticksVisible['right'] and self.innerTicks)
      self.ax_resid_div.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'] and self.innerTicks, right=self.ticksVisible['right'])
  
      # ensure that no tick labels displayed on self.ax_div nor on self.ax_resid_div
      self.ax.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left'] and self.ticksYShow, labelright=False)
      self.ax_div.yaxis.set_tick_params(which='both', labelleft=False, labelright=self.ticksLabelShow['right'] and self.ticksYShow)
      self.ax_resid.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left'] and self.ticksResidYShow, labelright=False)
      self.ax_resid_div.yaxis.set_tick_params(which='both', labelleft=False, labelright=self.ticksLabelShow['right'] and self.ticksResidYShow)
  
      # now do the same for second axes
      if(secondAxes):
        # now deal with ticks
        self.ax2.yaxis.set_tick_params(which='both', left=self.ticksVisible['left2'], right=self.ticksVisible['right2'] and self.innerTicks)
        self.ax2_div.yaxis.set_tick_params(which='both', left=self.ticksVisible['left2'] and self.innerTicks, right=self.ticksVisible['right2'])
  
        # ensure that no tick labels displayed on self.ax_div nor on self.ax_resid_div
        self.ax2.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left2'] and self.ticksY2Show, labelright=False)
        self.ax2_div.yaxis.set_tick_params(which='both', labelleft=False, labelright=self.ticksLabelShow['right2'] and self.ticksY2Show)

  def setZOrderResidLine(self, zorder=0, redraw=True):
    # updates z order of residuals
    if(self.zorderResidLine != zorder):
      self.zorderResidLine = zorder
      # update plot if necessary
      plotUpdate = False
      if(self.handleResidZero != None):
        self.handleResidZero.set_zorder(self.zorderResidLine + self.parent.zOffset)
        plotUpdate = True
        self.rememberSettingResidLine['zorder'] = 'set_zorder(' + repr(self.zorderResidLine + self.parent.zOffset) + ')'
      if(self.handleResidZero_div != None):
        self.handleResidZero_div.set_zorder(self.zorderResidLine + self.parent.zOffset)
        plotUpdate = True

      # update plot
      if(redraw and plotUpdate):
        self.residplotwidget.myRefresh()

  def setVisibilityResidLine(self, state=True, redraw=True):
    # toggles visibility of residual zero line
    if(self.visibilityResidLine != state):
      self.visibilityResidLine = state
      # update plot if necessary
      plotUpdate = False
      if(self.handleResidZero != None):
        self.handleResidZero.set_visible(state)
        plotUpdate = True
        self.rememberSettingResidLine['visibility'] = 'set_visible(' + repr(state) + ')'
      if(self.handleResidZero_div != None):
        self.handleResidZero_div.set_visible(state)
        plotUpdate = True

      # update plot
      if(redraw and plotUpdate):
        self.residplotwidget.myRefresh()

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def legendHelper(self, axisobject=None):
    # helper function called by legend formatters
    if(axisobject == None):
      axisobject = self.ax
    
    # build axis legend objects
    items = []
    for entry in self.parent.data:
      if((entry.handleData != None) and (entry.visibility)):
        # manually process escape characters
        name = entry.name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
        name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
        # test for potential Mathttext errors by creating a dummy text label
        tempText = axisobject.text(1, 1, name)
        try:
          tempText._get_layout(self.matplot.canvas.renderer)
        except:
          # some kind of problem with item label
          self.parent.statusbar.showMessage('Problems with data set label ' + name, self.parent.STATUS_TIME)
          name = name.replace('$', '')
        tempText.remove()
        if(not name.startswith('_')):
          if((entry.handleData != None) and ((not entry.style['marker'] in ['None', None, '', ' ']) or (entry.style['linestyle'] != 'None'))):
            useHandle = entry.handleData
          elif((entry.handleBar != None) and entry.Barstyle['showBar']):
            useHandle = entry.handleBar
          elif((entry.handleStack != None) and entry.Stackstyle['showStack']):
            useHandle = entry.handleStack
          else:
            useHandle = entry.handleData
          items.append([useHandle, name, entry.zorder])
    for entry in self.parent.fit:
      if((entry.handlePlot != None) and (entry.visibility)):
        # manually process escape characters
        name = entry.name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
        name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
        # test for potential Mathttext errors by creating a dummy text label
        tempText = axisobject.text(1, 1, name)
        try:
          tempText._get_layout(self.matplot.canvas.renderer)
        except:
          # some kind of problem with item label
          self.parent.statusbar.showMessage('Problems with curve label ' + name, self.parent.STATUS_TIME)
          name = name.replace('$', '')
        tempText.remove()
        if(not name.startswith('_')):
          items.append([entry.handlePlot, name, entry.zorder])
    # order according to zorder
    items = sorted(items, key=lambda k: k[2])
    handles = [i[0] for i in items]
    labels = [i[1] for i in items]
    bbox_to_anchor = (self.padSize['left'], self.padSize['bottom'],\
                      self.padSize['right'] - self.padSize['left'], self.padSize['top'] - self.padSize['bottom'])
    
    # have to discriminate for Linux versions b/c markerfirst may be unknown
    try:
      self.legendHandle = self.createCustomLegend(axisobject, handles, labels, loc=self.legendPlacement, shadow=self.legendShadow,\
        numpoints=self.legendNumPoints, markerfirst=self.legendMarkerFirst, ncol=self.legendNumCol, markerscale=self.legendMarkerScale,\
        borderpad=self.legendBorderPad, labelspacing=self.legendLabelSpacing, columnspacing=self.legendColumnSpacing,\
        handlelength=2.0 * self.legendMarkerScale, bbox_to_anchor=bbox_to_anchor)
    except:
      self.legendHandle = self.createCustomLegend(axisobject, handles, labels, loc=self.legendPlacement, shadow=self.legendShadow,\
        numpoints=self.legendNumPoints, ncol=self.legendNumCol, markerscale=self.legendMarkerScale,\
        borderpad=self.legendBorderPad, labelspacing=self.legendLabelSpacing, columnspacing=self.legendColumnSpacing,\
        handlelength=2.0 * self.legendMarkerScale, bbox_to_anchor=bbox_to_anchor)
    
    if(self.legendHandle != None):
      # go via frame properties for enhanced controls
      frame = self.legendHandle.get_frame()
      if(frame != None):
        frame.set_linewidth(self.legendEdgeWidth)
        if(self.legendEdge):
          frame.set_edgecolor(self.legendColor['edge'])
        else:
          frame.set_edgecolor('none')
        if(self.legendFill):
          frame.set_facecolor(self.legendColor['face'])
        else:
          frame.set_facecolor('none')
        frame.set_alpha(self.legendColor['face'][-1])
      
      # set text properties
      texts = self.legendHandle.texts
      for entry in texts:
        entry.set_color(self.legendLabelColor)
        entry.set_fontsize(self.legendLabelSize)
        entry.set_fontweight(self.legendLabelWeight)
        entry.set_fontstyle(self.legendLabelStyle)
        entry.set_fontname(self.legendLabelFont)
        
      # set additional config settings (brought to you by AM)
      self.legendHandle.additionalConfig(shadowDeltaX=self.legendShadowDeltaX, shadowDeltaY=self.legendShadowDeltaY,\
                                         shadowFaceColor=self.legendShadowFaceColor, legendHatch=self.legendHatch,\
                                         legendHatchMultiply=self.legendHatchMultiply, legendEdgeFallbackColor=self.legendColor['edge'],\
                                         legendRounding=self.legendRounding)
      
      # set z-order to display in front (note that aboutLogo is at 1000)
      self.legendHandle.set_zorder(999)
      
      # and now remember all this
      axisname = 'ax'
      if(self.isSecondAxesActive()):
        self.rememberSetting['legend'] = 'collateHandles = [i[\'handle\'] for i in (dataset + curves)]\n'
        self.rememberSetting['legend'] += 'collateLabels = [i[\'handle\'].get_label() for i in (dataset + curves)]\n'
        self.rememberSetting['legend'] += 'handleLegend = ' + axisname + '.legend(collateHandles, collateLabels, loc=' + repr(self.legendPlacement) + ', shadow=' + repr(self.legendShadow)
      else:
        self.rememberSetting['legend'] = 'handleLegend = ' + axisname + '.legend(loc=' + repr(self.legendPlacement) + ', shadow=' + repr(self.legendShadow)
      if(platform in ['linux', 'darwin']):
        self.rememberSetting['legend'] += ', numpoints=' + repr(self.legendNumPoints)
      else:
        self.rememberSetting['legend'] += ', numpoints=' + repr(self.legendNumPoints) + ', markerfirst=' + repr(self.legendMarkerFirst)
      self.rememberSetting['legend'] += ', ncol=' + repr(self.legendNumCol) + ', markerscale=' + repr(self.legendMarkerScale)  + ', borderpad=' + repr(self.legendBorderPad)
      self.rememberSetting['legend'] +=  ', labelspacing=' + repr(self.legendLabelSpacing) + ', columnspacing=' + repr(self.legendColumnSpacing) + ')\n'
      self.rememberSetting['legend'] += 'if(handleLegend != None):\n'
      self.rememberSetting['legend'] += '\tframe = handleLegend.get_frame()\n'
      self.rememberSetting['legend'] += '\tif(frame != None):\n'
      self.rememberSetting['legend'] += '\t\tframe.set_linewidth(' + repr(self.legendEdgeWidth) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_edgecolor(' + repr(self.legendColor['edge']) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_facecolor(' + repr(self.legendColor['face']) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_alpha(' + repr(self.legendColor['face'][-1]) + ')\n'
      self.rememberSetting['legend'] += '\ttexts = handleLegend.texts\n'
      self.rememberSetting['legend'] += '\tfor entry in texts:\n'
      self.rememberSetting['legend'] += '\t\tentry.set_color(' + repr(self.legendLabelColor) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontsize(' + repr(self.legendLabelSize) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontweight(' + repr(self.legendLabelWeight) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontstyle(' + repr(self.legendLabelStyle) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontname(' + repr(self.legendLabelFont) + ')\n'
      self.rememberSetting['legend'] += '\thandleLegend.set_zorder(' + repr(999) + ')\n'

  def createCustomLegend(self, axisobject, handles, labels, *args, **kwargs):
    # adapter function to allow generation of custom legend
    # the proper way throws an error under Linux due to matplotlib versions
    # => better avoid this call, which we can as we have a fairly good idea which arguments we pass
    ###handles, labels, extra_args, kwargs = Legend._parse_legend_args([axisobject], *args, **kwargs)
    ###self.legend_ = MyLegend(axisobject, handles, labels, **kwargs)
    # put the legend on the figure, not on the axes => better for split plots and the likes
    if(('loc' in kwargs) and (not (kwargs['loc'] in self.placementStyles))):
      kwargs['loc'] = self.placementStyles[0]
    self.legend_ = MyLegend(self.matplot, handles, labels, **kwargs)
    # trick axisobject into accepting MyLegend
    try:
      self.legend_._remove_method = axisobject._remove_legend
    except:
      self.legend_._remove_method = lambda h: setattr(self, 'legend_', None)

    axisobject.legend_ = self.legend_
    return self.legend_

  def toggleLegendEdge(self, value=True, redraw=True, target='plot'):
    # toggles whether legend is boxed or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      # sets canvas color
      if(self.legendEdge == value):
        redraw = False

      self.legendEdge = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def toggleLegendFill(self, value=True, redraw=True, target='plot'):
    # toggles whether legend is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      # sets canvas color
      if(self.legendFill == value):
        redraw = False

      self.legendFill = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerFirst(self, value=True, redraw=True, target='plot'):
    # sets marker location in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendMarkerFirst == value):
        redraw = False
        
      self.legendMarkerFirst= value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerScale(self, value=1.0, redraw=True, target='plot'):
    # sets marker scale in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendMarkerScale == value):
        redraw = False
        
      self.legendMarkerScale = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendNCol(self, value=1, redraw=True, target='plot'):
    # sets number of columns in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendNumCol == value):
        redraw = False
        
      self.legendNumCol = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerNumPoints(self, value=1, redraw=True, target='plot'):
    # sets number of marker points in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendNumPoints == value):
        redraw = False
        
      self.legendNumPoints = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()
          
  def setLegendPlacement(self, value='upper right', redraw=True, target='plot'):
    # sets placement of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendPlacement == value):
        redraw = False
        
      self.legendPlacement = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendShadow(self, value=False, redraw=True, target='plot'):
    # sets placement of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendShadow == value):
        redraw = False
        
      self.legendShadow = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegend(self, value=True, redraw=True, target='plot'):
    # sets legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      self.legendVisible = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
      else:
        legend = self.legendHandle
        if(legend != None):
          try:
            legend.remove()
          except:
            pass
          self.ax.legend_ = None
          self.legendHandle = None
          
        if('legend' in self.rememberSetting):
          del self.rememberSetting['legend']
      
      if(redraw):
        plotobject.myRefresh()

  def setLegendColor(self, value=[0.5, 0.5, 0.5, 0.5], prop='face', redraw=True, target='plot'):
    # sets color of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
    else:
      prop = 'abort'

    # update color
    if(prop in ['face', 'edge']):
      if(self.legendColor[prop] == value):
        redraw=False
      if((prop == 'face') and (not self.legendFill)):
        redraw = False
      if((prop == 'edge') and (not self.legendEdge) and (self.legendHatch == '')):
        redraw = False
        
      self.legendColor[prop] = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendRounding(self, value=0.2, redraw=True, target='plot'):
    # alters rounding for legend box
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      if(self.legendRounding == value):
        redraw = False
      self.legendRounding = value

      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendHatchParameter(self, item='hatch', value='', redraw=True, target='plot'):
    # alters parameter for legend hatch
    if(item in ['hatch', 'multiply']):
      if(target in ['plot', 'resid']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid

        if(item == 'hatch'):
          if(self.legendHatch == value):
            redraw = False
          self.legendHatch = value
        else:
          if(self.legendHatchMultiply == value):
            redraw = False
          self.legendHatchMultiply = value
          
        if(self.legendVisible):
          self.legendHelper(axisobject)
          if(redraw):
            plotobject.myRefresh()

  def setLegendShadowParameter(self, item='color', value=[0.5, 0.5, 0.5, 1.0], redraw=True, target='plot'):
    # alters parameter for legend shadow
    if(item in ['color', 'x', 'y']):
      if(target in ['plot', 'resid']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid

        if(item == 'color'):
          if(self.legendShadowFaceColor == value):
            redraw = False
          self.legendShadowFaceColor = value
        elif(item == 'x'):
          if(self.legendShadowDeltaX == value):
            redraw = False
          self.legendShadowDeltaX = value
        else:
          if(self.legendShadowDeltaY == value):
            redraw = False
          self.legendShadowDeltaY = value
          
        if(self.legendVisible and self.legendShadow):
          self.legendHelper(axisobject)
          if(redraw):
            plotobject.myRefresh()

  def setLegendLabelColor(self, value=[0.5, 0.5, 0.5, 0.5], redraw=True, target='plot'):
    # sets color of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelColor == value):
        redraw = False
        
      self.legendLabelColor = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelBold(self, value='normal', redraw=True, target='plot'):
    # sets formatting of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelWeight == value):
        redraw = False
        
      self.legendLabelWeight = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelItalic(self, value='normal', redraw=True, target='plot'):
    # sets formatting of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelStyle == value):
        redraw = False
        
      self.legendLabelStyle = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendEdgeWidth(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if((self.legendEdgeWidth == value) or (not self.legendEdge)):
        redraw = False
        
      self.legendEdgeWidth = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadBorder(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendBorderPad == value):
        redraw = False
        
      self.legendBorderPad = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadRow(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendLabelSpacing == value):
        redraw = False
        
      self.legendLabelSpacing = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadCol(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendColumnSpacing == value):
        redraw = False
        
      self.legendColumnSpacing = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelSize(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendLabelSize == value):
        redraw = False
        
      self.legendLabelSize = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelFont(self, value='DejaVu Sans', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      prevFont = self.legendLabelFont
      if(self.legendLabelFont == value):
        redraw = False
        
      self.legendLabelFont = value
      self.legendHelper(axisobject)
      
      # have to capture errors in case a strange font is set
      try:
        if(redraw):
          plotobject.myRefresh()
      except:
        self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.legendLabelFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)

        self.legendLabelFont = prevFont
        self.legendHelper(axisobject)
        # also capture errors with previous font (can happen if selecting two bad fonts in a row)
        try:
          if(redraw):
            plotobject.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Also experiencing problems setting font ' + self.legendLabelFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.legendLabelFont = safeFont
          self.legendHelper(axisobject)

  def setDataAxisTicks(self, dataSet=0, redraw=True, target='plot', splitX=False):
    # set x ticks to label values
    useData, roles = self.parent.data[dataSet].getData_n_Fit()
    if('x' in roles):
      xcol = roles.index('x')
      xval = list(useData[:, xcol])
      labels = list(self.parent.data[self.parent.activeData].getLabels())
      minLength = np.min((len(xval), len(labels)))
      if(minLength):
        # we have some labels to place
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(splitX):
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax2_div, self.modeX_div, self.minX_div, self.maxX_div, self.ticksXMinor_div
          else:
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax2, self.modeX, self.minX, self.maxX, self.ticksXMinor
        else:
          plotobject = self.residplotwidget
          if(splitX):
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax_resid_div, self.modeX_div, self.minX_div, self.maxX_div, self.ticksXMinor_div
          else:
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax_resid, self.modeX, self.minX, self.maxX, self.ticksXMinor

        flag = False
        labels = labels[:minLength]; xval = xval[:minLength]

        # manually process labels for escape characters
        for index, entry in enumerate(labels):
          # ensure that labels are string
          if(type(entry) != type('tse')):
            entry = str(entry)
          name = entry.replace('\n', '\\n')
          name = name.replace('\t', '\\t')
          name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
          name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
          labels[index] = name
        
        # first set new ticks
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(xval))
        ###if(useModeX == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        lower, upper = useMinX, useMaxX
        if(len(xval)):
          # check for empty list
          if(np.min(xval) < np.min((useMinX, useMaxX))):
            flag = True
            # disable rescaling on assignment of axis labels
            ###lower = np.min(xval)
          if(np.max(xval) > np.max((useMinX, useMaxX))):
            flag = True
            # disable rescaling on assignment of axis labels
            ###upper = np.max(xval)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
            
        # now set new tick labels
        axisobject.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(labels))
        
        # store settings
        if(splitX):
          self.ticksX_div, self.ticksXLabel_div, self.ticksXAuto_div = xval, labels, False
          self.parent.graphicsarea.configInnerTickXAuto.setChecked(False)
        else:
          self.ticksX, self.ticksXLabel, self.ticksXAuto = xval, labels, False
          self.parent.graphicsarea.configTickXAuto.setChecked(False)
          self.rememberSetting['ax_tickX'] = 'ax2.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(xval)) + '))\n'
          self.rememberSetting['ax_tickX'] += 'ax2.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(' + repr(list(labels)) + '))\n'

        # check whether the new ticks necessitate axis rescaling
        if(flag):
          if(splitX):
            self.setAxisLimits(lower=lower, upper=upper, axis='x2', updateLabel=True, target=target, redraw=False, updateGrid=True)
            if(target == 'plot'):
              # and we should redraw the fit function to cover new x-range
              self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
                redraw=False, splitX=splitX)
              # copy in case split axes are shown
              curve = self.parent.fit[self.parent.activeFit]
              if(self.parent.plotArea.splitY and curve.onBothAxes):
                curve.duplicateForSplit()
              if(redraw):
                self.parent.plotArea.dataplotwidget.myRefresh()
            else:
              # and we should update the resid plot (as x-axis will most likely have rescaled)
              self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=splitX)
          else:
            self.setAxisLimits(lower=lower, upper=upper, axis='x', updateLabel=True, target=target, redraw=False, updateGrid=True)
            if(target == 'plot'):
              # and we should redraw the fit function to cover new x-range
              self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
                redraw=False)
              # copy in case split axes are shown
              curve = self.parent.fit[self.parent.activeFit]
              if(self.parent.plotArea.splitY and curve.onBothAxes):
                curve.duplicateForSplit()
              if(redraw):
                self.parent.plotArea.dataplotwidget.myRefresh()
            else:
              # and we should update the resid plot (as x-axis will most likely have rescaled)
              self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=redraw)
        else:
          # update axis grid lines
          if(splitX):
            if(self.gridVisible['x2']):
              self.drawAxisGrid(axis='x2', redraw=False, target=target)
          else:
            if(self.gridVisible['x']):
              self.drawAxisGrid(axis='x', redraw=False, target=target)
        
          if(redraw):
            plotobject.myRefresh()
      else:
        self.parent.statusbar.showMessage('Data set ' + str(dataSet) + ' contains no labels!', self.parent.STATUS_TIME)
    else:
      self.parent.statusbar.showMessage('Current data set ' + str(dataSet) + ' is empty!', self.parent.STATUS_TIME)

  def myFormatterFunction(self, mode='float', precision=2, trailZero=True, separator=True, comma=True, prefix='', postfix='', x=0, pos=None):
    # a custom formatter function
    prefix, postfix = prefix.replace('\\', '\\\\'), postfix.replace('\\', '\\\\')
    prefix, postfix = prefix.replace('$', '\$'), postfix.replace('$', '\$')
    if(mode == 'float'):
      # for float formatting consider separator for 1000s (by contrast, not relevant for scientific/mathdefault)
      if(separator):
        formatstr = '{:,.' + str(precision) + 'f}'
      else:
        formatstr = '{:.' + str(precision) + 'f}'
      formatstr = formatstr.format(x)
      # check whether commata should be used rather than decimal points
      if(comma):
        checkItem = ','
        formatstr = formatstr.replace('.', '|')
        formatstr = formatstr.replace(',', '.')
        formatstr = formatstr.replace('|', ',')
      else:
        checkItem = '.'
      # test at level of output string, as is_integer() runs into problems with precision of floats
      if((not trailZero) and (checkItem in formatstr)):
        while(formatstr.endswith('0')):
          formatstr = formatstr[:-1]
        if(formatstr.endswith(checkItem)):
          formatstr = formatstr[:-1]
      # need to enclose commata in curly brackets to prevent trailing space
      formatstr = formatstr.replace(',', '{,}')
      formatstr = '$\\mathdefault{' + formatstr + '}$'
      return prefix + formatstr + postfix
    elif(mode == 'scientific'):
      formatstr = '{:.' + str(precision) + 'e}'
      formatstr = formatstr.format(x)
      if(not trailZero):
        if('e' in formatstr.lower()):
          eString = formatstr[formatstr.lower().find('e')]
          preString, exponentString = formatstr.split(eString)
          while(preString.endswith('0')):
            preString = preString[:-1]
          if(preString.endswith('.')):
            preString = preString[:-1]
          formatstr = preString + eString + exponentString
      if(comma):
        formatstr = formatstr.replace('.', '{,}')
      formatstr = '$\\mathdefault{' + formatstr + '}$'
      return prefix + formatstr + postfix
    elif(mode == 'mathtext'):
      # calculate exponent
      if(x != 0.0):
        try:
          exponent = int(np.floor(np.log10(np.abs(x))))
        except:
          exponent = 0
        # calculate preexponent
        try:
          pre = x / (10 ** exponent)
        except:
          pre, exponent = x, 0
      # assemble string
      if(x == 0.0):
        retstr = '{:.' + str(precision) + 'f}'
        retstr = retstr.format(0.0)
        if(not trailZero):
          retstr = '0'
        if(comma):
          retstr = retstr.replace('.', '{,}')
        retstr = '$\\mathdefault{' + retstr + '}$' 
      elif(np.isclose(pre, 1.0)):
        retstr = '$\\mathdefault{10^{' + str(exponent) + '}}$'
      elif(np.isclose(pre, -1.0)):
        retstr = '$\\mathdefault{-10^{' + str(exponent) + '}}$'
      else:
        retstr = '{:.' + str(precision) + 'f}'
        retstr = retstr.format(pre)
        # testing with is_integer() struggles with float precision - test directly at level of string
        #if((not trailZero) and pre.is_integer()):
        if((not trailZero) and precision):
          front, trail = retstr.split('.')
          while(trail.endswith('0')):
            trail = trail[:-1]
          if(trail == ''):
            retstr = front
          else:
            retstr = front + '.' + trail
        if(comma):
          retstr = retstr.replace('.', '{,}')
        # should not use \times here as some fonts don't possess this symbol
        retstr = '$\\mathdefault{' + retstr + '\ x\ 10^{' + str(exponent) + '}}$' 
      # return value
      return prefix + retstr + postfix
    else:
      return str(x)

  def setAutoTicks(self, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
    else:
      axis = 'abort'
    # automatically sets axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useModeX, useAxisobject, useTicksXFormat, useTicksXFormatPrecision, useTicksXMinor, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma =\
            self.modeX, axisobject, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXMinor, self.ticksXFormatTrailZero, self.ticksXFormatSeparator, self.ticksXFormatComma
          usePrefix, usePostfix = self.ticksXFormatPrefix, self.ticksXFormatPostfix
        else:
          useModeX, useAxisobject, useTicksXFormat, useTicksXFormatPrecision, useTicksXMinor, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma =\
            self.modeX_div, axisobject2, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXMinor_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.ticksXFormatComma_div
          usePrefix, usePostfix = self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div

        if(useModeX == 'linear'):
          autoticks = matplotlib.ticker.AutoLocator()
          autolabels = matplotlib.ticker.ScalarFormatter()
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          useAxisobject.xaxis.set_minor_locator(minorAutoticks)
          useAxisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        else:
          autoticks = matplotlib.ticker.LogLocator()
          ###if(platform in ['linux', 'darwin']):
          try:
            autolabels = matplotlib.ticker.LogFormatterSciNotation()
          except:
            autolabels = matplotlib.ticker.ScalarFormatter()
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          useAxisobject.xaxis.set_minor_locator(minorAutoticks)
          useAxisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # apply custom formatting?
        if(useTicksXFormat != 'default'):
          # store fallback
          if(axis == 'x'):
            self.fallback_ticksXFormat = autolabels
          else:
            self.fallback_ticksXFormat_div = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, useTicksXFormat, useTicksXFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useTicksFormatComma, usePrefix, usePostfix))
        useAxisobject.xaxis.set_major_locator(autoticks)
        useAxisobject.xaxis.set_major_formatter(autolabels)

        # store information
        if(axis == 'x'):
          self.ticksX = self.getAxisTicks(axis)
          nuticks = self.ticksX
          # clear labels
          self.ticksXLabel, self.ticksXAuto = [], True
        else:
          self.ticksX_div = self.getAxisTicks(axis)
          nuticks = self.ticksX_div
          # clear labels
          self.ticksXLabel_div, self.ticksXAuto_div = [], True
      elif(axis == 'y'):
        axisobject = self.ax; axisobject2 = self.ax_div
        for useAxisobject in [axisobject, axisobject2]:
          if(self.modeY == 'linear'):
            autoticks = matplotlib.ticker.AutoLocator()
            autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            autoticks = matplotlib.ticker.LogLocator()
            ###if(platform in ['linux', 'darwin']):
            try:
              autolabels = matplotlib.ticker.LogFormatterSciNotation()
            except:
              autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          # apply custom formatting?
          if(self.ticksYFormat != 'default'):
            # store fallback
            self.fallback_ticksYFormat = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.ticksYFormatComma, self.ticksYFormatPrefix, self.ticksYFormatPostfix))
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
        # store information
        self.ticksY = self.getAxisTicks(axis)
        nuticks = self.ticksY
        self.ticksYAuto = True
      elif(axis == 'y2'):
        for useAxisobject in [axisobject, axisobject2]:
          if(self.modeY2 == 'linear'):
            autoticks = matplotlib.ticker.AutoLocator()
            autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            autoticks = matplotlib.ticker.LogLocator()
            ###if(platform in ['linux', 'darwin']):
            try:
              autolabels = matplotlib.ticker.LogFormatterSciNotation()
            except:
              autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          # apply custom formatting?
          if(self.ticksY2Format != 'default'):
            # store fallback
            self.fallback_ticksY2Format = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.ticksY2FormatComma, self.ticksY2FormatPrefix, self.ticksY2FormatPostfix))
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
        # store information
        self.ticksY2 = self.getAxisTicks(axis)
        nuticks = self.ticksY2
        self.ticksY2Auto = True
      else:
        for useAxisobject in [axisobject, axisobject2]:
          autoticks = matplotlib.ticker.AutoLocator()
          autolabels = matplotlib.ticker.ScalarFormatter()
          # apply custom formatting?
          if(self.ticksResidYFormat != 'default'):
            # store fallback
            self.fallback_ticksResidYFormat = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.ticksResidYFormatComma, self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix))
          minorAutoticks = MyAutoMinorLocator(self.ticksResidYMinor)
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_minor_locator(minorAutoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
          useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store information
        self.ticksResidY = self.getAxisTicks(axis)
        nuticks = self.ticksResidY
        self.ticksResidYAuto = True

      # update axis grid lines
      if(axis == 'resid'):
        item = 'y'
      else:
        item = axis
      if(self.gridVisible[item]):
        if((item != 'y2') or self.isSecondAxesActive()):
          self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      if(redraw):
        plotobject.myRefresh()
      return nuticks

  def setAxisTicks(self, value=np.array([]), axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisname = 'ax2'; useTicksXMinor = self.ticksXMinor
        if(axis == 'x2'):
          axisobject, useTicksXMinor = self.ax2_div, self.ticksXMinor_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisname = 'ax_resid'; useTicksXMinor = self.ticksXMinor
        if(axis == 'x2'):
          axisobject, useTicksXMinor = self.ax_resid_div, self.ticksXMinor_div
    else:
      axis='abort'
    # sets axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      flag = False
      if(axis == 'x'):
        if(self.modeX == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          ###if(platform in ['linux', 'darwin']):
          try:
            blah = matplotlib.ticker.LogFormatterSciNotation()
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
          except:
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
        # apply custom formatting?
        if(self.ticksXFormat != 'default'):
          # store fallback
          self.fallback_ticksXFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXFormatTrailZero, self.ticksXFormatSeparator, self.ticksXFormatComma, self.ticksXFormatPrefix, self.ticksXFormatPostfix))
        axisobject.xaxis.set_major_formatter(autolabels)
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeX == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksX = value
        self.rememberSetting[axisname + '_tickX'] = axisname + '.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickX'] += axisname + '.xaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minX, self.maxX
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minX, self.maxX))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minX, self.maxX))):
            flag = True
            upper = np.max(value)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
        # clear labels
        self.ticksXLabel = []
        self.ticksXAuto = False
        self.parent.graphicsarea.configTickXAuto.setChecked(False)
      elif(axis == 'x2'):
        if(self.modeX_div == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
        # apply custom formatting?
        if(self.ticksXFormat_div != 'default'):
          # store fallback
          self.fallback_ticksXFormat_div = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.ticksXFormatComma_div, self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div))
        axisobject.xaxis.set_major_formatter(autolabels)
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeX_div == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksX_div = value
        lower, upper = self.minX_div, self.maxX_div
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minX_div, self.maxX_div))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minX_div, self.maxX_div))):
            flag = True
            upper = np.max(value)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
        # clear labels
        self.ticksXLabel_div = []
        self.ticksXAuto_div = False
        self.parent.graphicsarea.configInnerTickXAuto.setChecked(False)
      elif(axis == 'y'):
        axisobject = self.ax; axisname = 'ax'
        if(self.modeY == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          ###if(platform in ['linux', 'darwin']):
          try:
            blah = matplotlib.ticker.LogFormatterSciNotation()
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
          except:
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
        # apply custom formatting?
        if(self.ticksYFormat != 'default'):
          # store fallback
          self.fallback_ticksYFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.ticksYFormatComma, self.ticksYFormatPrefix, self.ticksYFormatPostfix))
        axisobject.yaxis.set_major_formatter(autolabels)
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeY == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
          axisobject.yaxis.set_minor_locator(minorAutoticks)
          axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksY = value
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minY, self.maxY
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minY, self.maxY))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minY, self.maxY))):
            flag = True
            upper = np.max(value)
        self.ticksYAuto = False
        self.parent.graphicsarea.configTickYAuto.setChecked(False)
      elif(axis == 'y2'):
        if(self.modeY2 == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          ###if(platform in ['linux', 'darwin']):
          try:
            blah = matplotlib.ticker.LogFormatterSciNotation()
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
          except:
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
        # apply custom formatting?
        if(self.ticksY2Format != 'default'):
          # store fallback
          self.fallback_ticksY2Format = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.ticksY2FormatComma, self.ticksY2FormatPrefix, self.ticksY2FormatPostfix))
        axisobject.yaxis.set_major_formatter(autolabels)
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeY2 == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
          axisobject.yaxis.set_minor_locator(minorAutoticks)
          axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksY2 = value
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minY2, self.maxY2
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minY2, self.maxY2))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minY2, self.maxY2))):
            flag = True
            upper = np.max(value)
        self.ticksY2Auto = False
        self.parent.graphicsarea2.configTickYAuto.setChecked(False)
      else:
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        autolabels = matplotlib.ticker.ScalarFormatter()
        # apply custom formatting?
        if(self.ticksResidYFormat != 'default'):
          # store fallback
          self.fallback_ticksResidYFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.ticksResidYFormatComma, self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix))
        minorAutoticks = MyAutoMinorLocator(self.ticksResidYMinor)
        axisobject.yaxis.set_minor_locator(minorAutoticks)
        axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        formatterName = 'matplotlib.ticker.ScalarFormatter()'
        axisobject.yaxis.set_major_formatter(autolabels)
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minResidY, self.maxResidY
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minResidY, self.maxResidY))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minResidY, self.maxResidY))):
            flag = True
            upper = np.max(value)
        self.ticksResidYAuto = False
        self.parent.graphicsarea.configTickResidYAuto.setChecked(False)
        
      # check whether the new ticks necessitate axis rescaling
      if(flag):
        if(axis in ['y', 'y2']):
          self.setAxisLimits(lower = lower, upper = upper, axis = axis, updateLabel = True, target=target, redraw=redraw, updateGrid=True)
        elif(axis == 'resid'):
          self.setAxisLimits(lower = lower, upper = upper, axis = 'y', updateLabel = True, target='resid', redraw=redraw, updateGrid=True)
        else:
          self.setAxisLimits(lower = lower, upper = upper, axis = axis, updateLabel = True, target=target, redraw=False, updateGrid=True)
          if(target == 'plot'):
            # and we should redraw the fit function to cover new x-range
            if(axis == 'x'):
              self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
                redraw=False)
              # copy in case split axes are shown
              curve = self.parent.fit[self.parent.activeFit]
              if(self.parent.plotArea.splitY and curve.onBothAxes):
                curve.duplicateForSplit()
              if(redraw):
                self.parent.plotArea.dataplotwidget.myRefresh()
            else:
              self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
                redraw=False, splitX=True)
              # copy in case split axes are shown
              curve = self.parent.fit[self.parent.activeFit]
              if(self.parent.plotArea.splitY and curve.onBothAxes):
                curve.duplicateForSplit()
              if(redraw):
                self.parent.plotArea.dataplotwidget.myRefresh()
          else:
            # and we should update the resid plot (as x-axis will most likely have rescaled)
            if(axis == 'x'):
              self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=redraw)
            else:
              self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=True)
      else:
        # update axis grid lines
        if(axis == 'resid'):
          item = 'y'
        else:
          item = axis
        if(self.gridVisible[item]):
          if((item != 'y2') or self.isSecondAxesActive()):
            self.drawAxisGrid(axis=item, redraw=False, target=target)
      
        if(redraw):
          plotobject.myRefresh()

  def getAxisTicks(self, axis='x'):
    # reports back axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        ticks = self.ax.xaxis.get_ticklocs()
      elif(axis == 'x2'):
        ticks = self.ax_div.xaxis.get_ticklocs()
      elif(axis == 'y'):
        ticks = self.ax.yaxis.get_ticklocs()
      elif(axis == 'y2'):
        ticks = self.ax2.yaxis.get_ticklocs()
      else:
        ticks = self.ax_resid.yaxis.get_ticklocs()
      return ticks
    else:
      return []

  def setTickLabelPad2(self, value=0.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'; plotfig = self.matplot
          if((self.ticksXPad2 == value) or (not self.ticksXShow)):
            redraw = False
          self.ticksXPad2 = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'; plotfig = self.residplot
          if((self.ticksXPad2_resid == value) or (not self.ticksXShow_resid)):
            redraw = False
          self.ticksXPad2_resid = value
        #
        tickLabels = axisobject.get_xticklabels(which='both')
        tickLabels.extend(axisobject2.get_xticklabels(which='both'))
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'; plotfig = self.matplot
          if((self.ticksYPad2 == value) or (not self.ticksYShow)):
            redraw = False
          self.ticksYPad2 = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'; plotfig = self.residplot
          if((self.ticksYPad2_resid == value) or (not self.ticksResidYShow)):
            redraw = False
          self.ticksYPad2_resid = value
        #
        tickLabels = axisobject.get_yticklabels(which='both')
        tickLabels.extend(axisobject2.get_yticklabels(which='both'))
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'; plotfig = self.matplot
        if((self.ticksY2Pad2 == value) or (not self.ticksY2Show)):
          redraw = False
        self.ticksY2Pad2 = value
        #
        tickLabels = axisobject.get_yticklabels(which='both')
        tickLabels.extend(axisobject2.get_yticklabels(which='both'))

      # set orthogonal padding using transforms
      if(axis == 'x'):
        offset = matplotlib.transforms.ScaledTranslation(value/72.0, 0, plotfig.dpi_scale_trans)
      else:
        offset = matplotlib.transforms.ScaledTranslation(0, value/72.0, plotfig.dpi_scale_trans)
      for entry in tickLabels:
        # strip transform down to inner CompositeGenericTransform
        transformA, transformB = entry.get_transform(), matplotlib.transforms.IdentityTransform()
        while(isinstance(transformA, matplotlib.transforms.CompositeGenericTransform)):
          transformA, transformB = transformA._a, transformA._b
        # compile new transform
        transAll = transformA + transformB + offset
        entry.set_transform(transAll)

      # take care of moved axes (otherwise padding set to zero)
      if(axis == 'x'):
        # adjust spine lines if needed
        for spine in ['top', 'bottom']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=False, splitX=True)
      elif(axis == 'y'):
        # adjust spine lines if needed
        for spine in ['left', 'right']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=False)
      elif(axis == 'y2'):
        for spine in ['left2', 'right2']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.dataplotwidget, axisobject=self.ax2, target='plot', secondAxes=True)
            self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.dataplotwidget, axisobject=self.ax2_div, target='plot', secondAxes=True)

      # remember settings
      ### this will be hard to remember right -- not supported for time being

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setTickLabelPad(self, value=4.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.ticksXPad == value) or (not self.ticksXShow)):
            redraw = False
          self.ticksXPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.ticksXPad_resid == value) or (not self.ticksXShow_resid)):
            redraw = False
          self.ticksXPad_resid = value
        #
        ticks = axisobject.xaxis.get_major_ticks()
        ticks.extend(axisobject.xaxis.get_minor_ticks())
        ticks.extend(axisobject2.xaxis.get_major_ticks())
        ticks.extend(axisobject2.xaxis.get_minor_ticks())
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.ticksYPad == value) or (not self.ticksYShow)):
            redraw = False
          self.ticksYPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.ticksYPad_resid == value) or (not self.ticksResidYShow)):
            redraw = False
          self.ticksYPad_resid = value
        #
        ticks = axisobject.yaxis.get_major_ticks()
        ticks.extend(axisobject.yaxis.get_minor_ticks())
        ticks.extend(axisobject2.yaxis.get_major_ticks())
        ticks.extend(axisobject2.yaxis.get_minor_ticks())
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.ticksY2Pad == value) or (not self.ticksY2Show)):
          redraw = False
        self.ticksY2Pad = value
        #
        ticks = axisobject.yaxis.get_major_ticks()
        ticks.extend(axisobject.yaxis.get_minor_ticks())
        ticks.extend(axisobject2.yaxis.get_major_ticks())
        ticks.extend(axisobject2.yaxis.get_minor_ticks())

      # set padding
      for entry in ticks:
        entry.set_pad(value)
        
      # remember settings
      tempRememberSetting = 'ticks = ' + axisname + '.' + axis[:1] + 'axis.get_major_ticks()\n'
      tempRememberSetting += 'ticks.extend(' + axisname + '.' + axis[:1] + 'axis.get_minor_ticks())\n'
      tempRememberSetting += 'for entry in ticks:\n\tentry.set_pad(' + repr(value) + ')\n'
      self.rememberSetting[axisname + '_tickPad' + axis] = tempRememberSetting

      # now we should call setTickLabelPad2 to prevent undoing of perpendicular shift (kind of ugly thing to do)
      # maybe in the future use a single handler function
      if(axis == 'x'):
        self.setTickLabelPad2(value=self.ticksXPad2, axis=axis, redraw=False, target=target)
      elif(axis == 'y'):
        if(target == 'plot'):
          self.setTickLabelPad2(value=self.ticksYPad2, axis=axis, redraw=False, target=target)
        else:
          self.setTickLabelPad2(value=self.ticksYPad2_resid, axis=axis, redraw=False, target=target)
      elif(axis == 'y2'):
        self.setTickLabelPad2(value=self.ticksY2Pad2, axis=axis, redraw=False, target=target)

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setTickLabelBold(self, value='normal', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXWeight == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXWeight = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYWeight == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYWeight = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif((axis == 'y2') or (not self.ticksY2Show)):
            if(self.ticksY2Weight == value):
              redraw = False
            self.ticksY2Weight = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXWeight_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXWeight_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYWeight_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYWeight_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontweight(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontweight(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickWeight' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()
      
  def setTickLabelItalic(self, value='normal', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXStyle == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXStyle = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYStyle == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYStyle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Style == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Style = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXStyle_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXStyle_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYStyle_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYStyle_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontstyle(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontstyle(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickStyle' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAngle(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAngle == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAngle = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAngle == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAngle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Angle == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Angle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAngle_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAngle_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAngle_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYAngle_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_rotation(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_rotation(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAngle' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAlignment(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAlignment == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAlignment = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAlignment == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAlignment = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Alignment == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Alignment = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAlignment_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAlignment_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAlignment_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYAlignment_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_horizontalalignment(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_horizontalalignment(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAlignment' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAlignmentVertical(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAlignmentVertical == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAlignmentVertical = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAlignmentVertical == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAlignmentVertical = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2AlignmentVertical == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2AlignmentVertical = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAlignmentVertical_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAlignmentVertical_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAlignmentVertical_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYAlignmentVertical_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_verticalalignment(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_verticalalignment(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAlignmentVertical' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelSize(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXSize == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXSize = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYSize == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYSize = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Size == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Size = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXSize_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXSize_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYSize_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYSize_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontsize(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontsize(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickFontSize' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def toggleTicksLabel(self, value=True, axis='x', redraw=True, target='plot'):
    # toggles visibility of tick labels
    # Matplotlib 3.1.2 only returns handles to visible labels which is counter-intuitive and overall bad
    # rather go via set_tick_params
    if((target in ['plot', 'resid']) and (axis in ['x', 'x2', 'y', 'y2'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div 
        if(axis == 'y'):
          axisobject = self.ax; axisobject2 = self.ax_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
        
      if(axis == 'x'):
        if(target == 'plot'):
          if(self.ticksXShow == value):
            redraw = False
          self.ticksXShow = value
        else:
          if(self.ticksXShow_resid == value):
            redraw = False
          self.ticksXShow_resid = value
        offsetLabel = axisobject.xaxis.get_offset_text()
      elif(axis == 'x2'):
        if(target == 'plot'):
          if(self.ticksXShow_div == value):
            redraw = False
          self.ticksXShow_div = value
        else:
          if(self.ticksXShow_resid_div == value):
            redraw = False
          self.ticksXShow_resid_div = value
        offsetLabel = axisobject2.xaxis.get_offset_text()
      elif(axis == 'y'):
        if(target == 'plot'):
          if(self.ticksYShow == value):
            redraw = False
          self.ticksYShow = value
        else:
          if(self.ticksResidYShow == value):
            redraw = False
          self.ticksResidYShow = value
        offsetLabel = axisobject.yaxis.get_offset_text()
      elif(axis == 'y2'):
        if(self.ticksY2Show == value):
          redraw = False
        self.ticksY2Show = value
        offsetLabel = axisobject.yaxis.get_offset_text()
      else:
        redraw = False
        offsetLabel = None

      # set visibility of tick labels
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useAxisobject = axisobject
        else:
          useAxisobject = axisobject2

        if(value):
          useAxisobject.xaxis.set_tick_params(which='both', labelbottom=self.ticksLabelShow['bottom'], labeltop=self.ticksLabelShow['top'])
          if((axis == 'x') and (hasattr(self.parent, 'graphicsarea'))):
            for useAxis in ('bottom', 'top'):
              self.parent.graphicsarea.configTickMarkLabelShow[useAxis].setChecked(self.ticksLabelShow[useAxis])
        else:
          useAxisobject.xaxis.set_tick_params(which='both', labelbottom=False, labeltop=False)
          if((axis == 'x') and (hasattr(self.parent, 'graphicsarea'))):
            for useAxis in ('bottom', 'top'):
              self.parent.graphicsarea.configTickMarkLabelShow[useAxis].setChecked(False)
      elif(axis == 'y'):
        if(value):
          # let updateInnerSituation() handle this
          if(self.splitShow):
            self.updateInnerSituation()
          else:
            axisobject.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left'], labelright=self.ticksLabelShow['right'])            
            axisobject2.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left'], labelright=self.ticksLabelShow['right'])            
          if(hasattr(self.parent, 'graphicsarea')):
            for useAxis in ('left', 'right'):
              self.parent.graphicsarea.configTickMarkLabelShow[useAxis].setChecked(self.ticksLabelShow[useAxis])
        else:
          axisobject.yaxis.set_tick_params(which='both', labelleft=False, labelright=False)
          axisobject2.yaxis.set_tick_params(which='both', labelleft=False, labelright=False)
          if(hasattr(self.parent, 'graphicsarea')):
            for useAxis in ('left', 'right'):
              self.parent.graphicsarea.configTickMarkLabelShow[useAxis].setChecked(False)
      elif(axis == 'y2'):
        if(value):
          # let updateInnerSituation() handle this
          if(self.splitShow):
            self.updateInnerSituation()
          else:
            axisobject.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left2'], labelright=self.ticksLabelShow['right2'])            
            axisobject2.yaxis.set_tick_params(which='both', labelleft=self.ticksLabelShow['left2'], labelright=self.ticksLabelShow['right2'])            
          if(hasattr(self.parent, 'graphicsarea2')):
            for useAxis in ('left2', 'right2'):
              self.parent.graphicsarea2.configTickMarkLabelShow[useAxis].setChecked(self.ticksLabelShow[useAxis])
        else:
          axisobject.yaxis.set_tick_params(which='both', labelleft=False, labelright=False)
          axisobject2.yaxis.set_tick_params(which='both', labelleft=False, labelright=False)
          if(hasattr(self.parent, 'graphicsarea2')):
            for useAxis in ('left2', 'right2'):
              self.parent.graphicsarea2.configTickMarkLabelShow[useAxis].setChecked(False)
        
      # need to update tick formatting if labels are displayed again
      if(value):
        self.setTickOne4All(axis=axis, redraw=False, target=target)
        
      # offset label
      if(offsetLabel != None):
        offsetLabel.set_visible(value)
      
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleAxisLabel(self, value=True, axis='x', redraw=True, target='plot'):
    # toggles visibility of axis label
    if((target in ['plot', 'resid']) and (axis in ['x', 'y', 'y2'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
        if(axis == 'y'):
          axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
        
      if(axis == 'x'):
        if(target == 'plot'):
          if(self.labelXShow == value):
            redraw = False
          self.labelXShow = value
        else:
          if(self.labelXShow_resid == value):
            redraw = False
          self.labelXShow_resid = value
        axisobject.xaxis.label.set_visible(value) 
      elif(axis == 'y'):
        if(target == 'plot'):
          if(self.labelYShow == value):
            redraw = False
          self.labelYShow = value
        else:
          if(self.labelYShow_resid == value):
            redraw = False
          self.labelYShow_resid = value
        axisobject.yaxis.label.set_visible(value) 
      elif(axis == 'y2'):
        if(self.labelY2Show == value):
          redraw = False
        self.labelY2Show = value
        if(self.splitShow):
          axisobject2.yaxis.label.set_visible(value) 
          # this is needed when activating split y axis
          if(not self.labelY2Show):
            axisobject.yaxis.label.set_visible(value) 
        else:
          axisobject.yaxis.label.set_visible(value) 
      else:
        redraw = False
      
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelSize(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXSize == value) or (not self.labelXShow)):
            redraw = False
          self.labelXSize = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXSize_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXSize_resid = value

        handleAxis = axisobject.xaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.xaxis.label
        handleAxis.set_size(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYSize == value) or (not self.labelYShow)):
            redraw = False
          self.labelYSize = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYSize_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYSize_resid = value

        handleAxis = axisobject.yaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_size(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Size == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Size = value
        handleAxis = axisobject.yaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_size(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelSize' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_size(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelPad(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXPad == value) or (not self.labelXShow)):
            redraw = False
          self.labelXPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid; axisname = 'ax_resid'
          if((self.labelXPad_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXPad_resid = value

        axisobject.xaxis.labelpad = value
        axisobject2.xaxis.labelpad = value
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYPad == value) or (not self.labelYShow)):
            redraw = False
          self.labelYPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYPad_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYPad_resid = value

        axisobject.yaxis.labelpad = value
        axisobject2.yaxis.labelpad = value
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Pad == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Pad = value
        axisobject.yaxis.labelpad = value
        axisobject2.yaxis.labelpad = value
      # remember settings
      self.rememberSetting[axisname + '_axisLabelPad' + axis] = axisname + '.' + axis[:1] + 'axis.labelpad = ' + repr(value) + '\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelPos(self, value=0.5, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXPos == value) or (not self.labelXShow)):
            redraw = False
          self.labelXPos = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXPos_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXPos_resid = value

        axisobject.xaxis.label.set_x(value)
        axisobject2.xaxis.label.set_x(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYPos == value) or (not self.labelYShow)):
            redraw = False
          self.labelYPos = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYPos_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYPos_resid = value

        axisobject.yaxis.label.set_y(value)
        axisobject2.yaxis.label.set_y(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Pos == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Pos = value
        axisobject.yaxis.label.set_y(value)
        axisobject2.yaxis.label.set_y(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelPos' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + axis[:1] + '(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelAngle(self, value=0.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXAngle == value) or (not self.labelXShow)):
            redraw = False
          self.labelXAngle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXAngle_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXAngle_resid = value

        axisobject.xaxis.label.set_rotation(value)
        axisobject2.xaxis.label.set_rotation(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYAngle == value) or (not self.labelYShow)):
            redraw = False
          self.labelYAngle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYAngle_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYAngle_resid = value

        axisobject.yaxis.label.set_rotation(value)
        axisobject2.yaxis.label.set_rotation(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Angle == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Angle = value
        axisobject.yaxis.label.set_rotation(value)
        axisobject2.yaxis.label.set_rotation(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelAngle' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_rotation(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelBold(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label bold
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXWeight == value) or (not self.labelXShow)):
            redraw = False
          self.labelXWeight = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXWeight_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXWeight_resid = value

        axisobject.xaxis.label.set_fontweight(value)
        axisobject2.xaxis.label.set_fontweight(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYWeight == value) or (not self.labelYShow)):
            redraw = False
          self.labelYWeight = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYWeight_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYWeight_resid = value

        axisobject.yaxis.label.set_fontweight(value)
        axisobject2.yaxis.label.set_fontweight(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Weight == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Weight = value
        axisobject.yaxis.label.set_fontweight(value)
        axisobject2.yaxis.label.set_fontweight(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelWeight' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontweight(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelItalic(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label italic
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXStyle == value) or (not self.labelXShow)):
            redraw = False
          self.labelXStyle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXStyle_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXStyle_resid = value

        axisobject.xaxis.label.set_fontstyle(value)
        axisobject2.xaxis.label.set_fontstyle(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYStyle == value) or (not self.labelYShow)):
            redraw = False
          self.labelYStyle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYStyle_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYStyle_resid = value

        axisobject.yaxis.label.set_fontstyle(value)
        axisobject2.yaxis.label.set_fontstyle(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Style == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Style = value
        axisobject.yaxis.label.set_fontstyle(value)
        axisobject2.yaxis.label.set_fontstyle(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelStyle' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontstyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelVariant(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label small-caps
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXVariant == value) or (not self.labelXShow)):
            redraw = False
          self.labelXVariant = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXVariant_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXVariant_resid = value

        axisobject.xaxis.label.set_variant(value)
        axisobject2.xaxis.label.set_variant(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYVariant == value) or (not self.labelYShow)):
            redraw = False
          self.labelYVariant = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYVariant_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYVariant_resid = value

        axisobject.yaxis.label.set_variant(value)
        axisobject2.yaxis.label.set_variant(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Variant == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Variant = value
        axisobject.yaxis.label.set_variant(value)
        axisobject2.yaxis.label.set_variant(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelVariant' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_variant(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisArrow(self, state=True, axis='x', item='all', redraw=True, target='plot'):
    # toggles drawing of arrow
    if((target in ['plot', 'resid']) and (axis in ['x', 'y']) and (item in ['all', 'edge', 'fill'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; arrowhandle = self.handleArrow; arrowhandle2 = self.handleArrow2
      else:
        plotobject = self.residplotwidget; arrowhandle = self.handleArrowResid; arrowhandle2 = self.handleArrowResid2
      
      if(item == 'all'):
        self.arrowVisible[axis] = state
        if(state):
          self.drawAxisArrow(axis=axis, redraw=redraw, target=target)
        elif((arrowhandle[axis] != None) or (arrowhandle2[axis] != None)):
          if(arrowhandle[axis] != None):
            arrowhandle[axis].remove()
            arrowhandle[axis] = None
          if(arrowhandle2[axis] != None):
            arrowhandle2[axis].remove()
            arrowhandle2[axis] = None
          if(redraw):
            plotobject.myRefresh()        
      else:
        if(item == 'edge'):
          if(target == 'plot'):
            if(self.arrowEdgeShow[axis] == state):
              redraw = False
            self.arrowEdgeShow[axis] = state
          else:
            if(self.arrowEdgeShow_resid[axis] == state):
              redraw = False
            self.arrowEdgeShow_resid[axis] = state
        else:
          if(target == 'plot'):
            if(self.arrowFillShow[axis] == state):
              redraw = False
            self.arrowFillShow[axis] = state
          else:
            if(self.arrowFillShow_resid[axis] == state):
              redraw = False
            self.arrowFillShow_resid[axis] = state

        if(redraw and self.arrowVisible[axis]):
          self.drawAxisArrow(axis=axis, redraw=redraw, target=target)

  def setAxisArrowColor(self, value=[0.0, 0.0, 0.0, 1.0], axis='x', item='fill', redraw=True):
    # changes color axis arrow
    if((axis in ['x', 'y']) and (item in ['line', 'fill'])):
      if(item == 'line'):
        checkItem = self.arrowEdgeShow[axis]
        if(self.arrowColor[axis] == value):
          redraw = False
        self.arrowColor[axis] = value
      else:
        checkItem = self.arrowFillShow[axis]
        if(self.arrowFill[axis] == value):
          redraw = False
        self.arrowFill[axis] = value
      
      if(redraw and self.arrowVisible[axis] and checkItem):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowLineWidth(self, value=0.1, axis='x', redraw=True):
    # changes edge width of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowEdge[axis] == value):
        redraw = False
      self.arrowEdge[axis] = value

      if(redraw and self.arrowVisible[axis] and self.arrowEdgeShow[axis]):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowHeadWidth(self, value=0.1, axis='x', redraw=True):
    # changes width of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowHeadWidth[axis] == value):
        redraw = False
      self.arrowHeadWidth[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowHeadLength(self, value=0.1, axis='x', redraw=True):
    # changes width of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowHeadLength[axis] == value):
        redraw = False
      self.arrowHeadLength[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowOverhang(self, value=0.1, axis='x', redraw=True):
    # changes overhang of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowOverhang[axis] == value):
        redraw = False
      self.arrowOverhang[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowOffset(self, value=0, axis='x', redraw=True):
    # changes offset of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowOffset[axis] == value):
        redraw = False
      self.arrowOffset[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowLocation(self, value='both', axis='x', redraw=True):
    # changes location of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowLocation[axis] == value):
        redraw = False
      self.arrowLocation[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def drawSplitYAxisDivider(self, redraw=True):
    # draws divider marks on split y axis
    plotobject, axisobject, axisobject2, handleDividerY = self.dataplotwidget, self.ax, self.ax_div, self.handleDividerY
    drawobject, drawobject2 = self.ax, self.ax2

    # delete old lines
    if(handleDividerY != None):
      for entry in handleDividerY:
        entry.remove()
    handleDividerY = None

    # draw new lines
    if(self.splitY and self.splitYDivider):
      # determine draw coordinates
      xcoord, ycoord, handleDividerY, axisList = [], [], [], []
      if(self.splitYDividerLocation == 'both'):
        useItems = ['left', 'right']
      else:
        useItems = [self.splitYDividerLocation]
      # account for shifted axis
      for item in useItems:
        # have to go via axisobject as drawobject throws an error
        useAxis, useAxisobject = drawobject, axisobject
        if(self.splitShow and (item == 'right')):
          useAxisobject, useAxis = axisobject2, self.ax_div
        if(item in useAxisobject.spines):
          try:
            axisPosition, axisPositionValue = useAxisobject.spines[item].get_position()
            if(axisPosition == 'data'):
              drawX = axisPositionValue
            elif(axisPosition == 'axes'):
              axis_to_data = useAxis.transAxes + useAxis.transData.inverted()
              transformedPoint = axis_to_data.transform((axisPositionValue, 0))
              drawX = transformedPoint[0]
            # passed => store coords for drawing
            xcoord.append(drawX)
            ycoord.append(self.minY)
            axisList.append(useAxis)
          except:
            pass
            
      # now copy coordinates to axisobject2
      if(self.splitYPad):
        for number, x in enumerate([i for i in xcoord]):
          xcoord.append(x)
          ycoord.append(self.maxY2)
          if(axisList[number] == drawobject):
            axisList.append(drawobject2)
          else:
            axisList.append(self.ax2_div)

      for x, y, useAxis in zip(xcoord, ycoord, axisList):
        # assign use-x values
        if(useAxis in [drawobject, drawobject2]):
          useMinX, useMaxX, useModeX = self.minX, self.maxX, self.modeX
        else:
          useMinX, useMaxX, useModeX = self.minX_div, self.maxX_div, self.modeX_div
          
        if(useAxis in [drawobject, self.ax_div]):
          useMinY, useMaxY, useModeY = self.minY, self.maxY, self.modeY
        else:
          useMinY, useMaxY, useModeY = self.minY2, self.maxY2, self.modeY2
          
        # draw some lines
        if(useModeY == 'linear'):
          dimY = (useMaxY - useMinY)
        else:
          dimY = np.log(np.abs(useMaxY / useMinY))
        if(useModeX == 'linear'):
          dimX = (useMaxX - useMinX)
        else:
          dimX = np.log(np.abs(useMaxX / useMinX))
        plotX, plotY = self.matplot.get_size_inches()
        # also take into account plot padding
        plotX *= (self.padSize['right'] - self.padSize['left'])
        plotY *= (self.padSize['top'] - self.padSize['bottom'])
        deltaX = (1 + self.splitFraction) * self.splitYDividerLength * np.cos(self.splitYDividerAngle * np.pi / 180.0) / plotX * np.max((plotX, plotY))
        if(not useAxis in [drawobject, drawobject2]):
          deltaX /= self.splitFraction
        if(not self.splitShow):
          deltaX /= 2
        deltaY = (1 + self.splitYFraction) * self.splitYDividerLength * np.sin(self.splitYDividerAngle * np.pi / 180.0) / plotY * np.max((plotX, plotY))
        if(not useAxis in [drawobject, self.ax_div]):
          deltaY /= self.splitYFraction

        if(useModeX == 'linear'):
          cx1, cx2 = x - 0.5 * deltaX * dimX, x + 0.5 * deltaX * dimX
        else:
          cx1, cx2 = x / np.exp(0.5 * deltaX * dimX), x * np.exp(0.5 * deltaX * dimX)
        if(useModeY == 'linear'):
          cy1, cy2 = y - 0.5 * deltaY * dimY, y + 0.5 * deltaY * dimY
        else:
          cy1, cy2 = y / np.exp(0.5 * deltaY * dimY), y * np.exp(0.5 * deltaY * dimY)

        # transform to axiscoordinates
        drawLine = matplotlib.lines.Line2D([cx1, cx2], [cy1, cy2])
        handleDividerY.append(useAxis.add_line(drawLine))

      # apply styles
      for entry in handleDividerY:
        entry.set_color(self.splitYDividerColor)
        entry.set_solid_capstyle(self.splitYDividerDashStyle)
        entry.set_linewidth(self.splitYDividerWidth)
        entry.set_clip_on(False)
        entry.set_zorder(999)
        
    # save handles
    self.handleDividerY = handleDividerY

    if(redraw):
      plotobject.myRefresh()

  def drawSplitAxisDivider(self, redraw=True, target='plot'):
    # draws divider marks on split axis
    if(target in ['plot', 'resid']):
      # assign handles
      if(target == 'plot'):
        plotobject, axisobject, axisobject2, handleDivider = self.dataplotwidget, self.ax2, self.ax2_div, self.handleDivider
        useMinY, useMaxY, useModeY = self.minY, self.maxY, self.modeY
        drawobject, drawobject2 = self.ax, self.ax_div
      else:
        plotobject, axisobject, axisobject2, handleDivider = self.residplotwidget, self.ax_resid, self.ax_resid_div, self.handleDividerResid
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; handleDivider = self.handleDividerResid
        useMinY, useMaxY, useModeY = self.minResidY, self.maxResidY, 'linear'
        drawobject, drawobject2 = axisobject, axisobject2

      # delete old lines
      if(handleDivider != None):
        for entry in handleDivider:
          entry.remove()
      handleDivider = None

      # draw new lines
      if(self.splitShow and self.splitDivider):
        # determine draw coordinates
        xcoord, ycoord, handleDivider, axisList = [], [], [], []
        if(self.splitDividerLocation == 'both'):
          useItems = ['bottom', 'top']
        else:
          useItems = [self.splitDividerLocation]
        # account for shifted axis
        for item in useItems:
          # have to go via axisobject as drawobject throws an error
          useAxis, useAxisobject = drawobject, axisobject
          if((target == 'plot') and self.splitY and (item == 'bottom')):
            useAxisobject, useAxis = axisobject2, self.ax2
          if(item in useAxisobject.spines):
            try:
              axisPosition, axisPositionValue = useAxisobject.spines[item].get_position()
              if(axisPosition == 'data'):
                drawY = axisPositionValue
              elif(axisPosition == 'axes'):
                axis_to_data = useAxis.transAxes + useAxis.transData.inverted()
                transformedPoint = axis_to_data.transform((0, axisPositionValue))
                drawY = transformedPoint[1]
              # passed => store coords for drawing
              xcoord.append(self.maxX)
              ycoord.append(drawY)
              axisList.append(useAxis)
            except:
              pass
            
        # now copy coordinates to axisobject2
        if(self.splitPad):
          for number, y in enumerate([i for i in ycoord]):
            xcoord.append(self.minX_div)
            ycoord.append(y)
            if(axisList[number] == drawobject):
              axisList.append(drawobject2)
            else:
              axisList.append(self.ax2_div)
          
        for x, y, useAxis in zip(xcoord, ycoord, axisList):
          # assign use-x values
          if(target == 'plot'):
            if(useAxis in [drawobject, self.ax_div]):
              useMinY, useMaxY, useModeY = self.minY, self.maxY, self.modeY
            else:
              useMinY, useMaxY, useModeY = self.minY2, self.maxY2, self.modeY2

          if(useAxis in [drawobject, self.ax2]):
            useMinX, useMaxX, useModeX = self.minX, self.maxX, self.modeX
          else:
            useMinX, useMaxX, useModeX = self.minX_div, self.maxX_div, self.modeX_div
            
          # draw some lines
          if(useModeX == 'linear'):
            dimX = (useMaxX - useMinX)
          else:
            dimX = np.log(np.abs(useMaxX / useMinX))
          if(useModeY == 'linear'):
            dimY = (useMaxY - useMinY)
          else:
            dimY = np.log(np.abs(useMaxY / useMinY))
          plotX, plotY = self.matplot.get_size_inches()
          # also take into account plot padding
          plotX *= (self.padSize['right'] - self.padSize['left'])
          plotY *= (self.padSize['top'] - self.padSize['bottom'])
          deltaX = (1 + self.splitFraction) * self.splitDividerLength * np.cos(self.splitDividerAngle * np.pi / 180.0) / plotX * np.max((plotX, plotY))
          if(useAxis in [drawobject2, self.ax2_div]):
            deltaX /= self.splitFraction
          deltaY = (1 + self.splitYFraction) * self.splitDividerLength * np.sin(self.splitDividerAngle * np.pi / 180.0) / plotY * np.max((plotX, plotY))
          if(target == 'plot'):
            if(self.splitY):
              if(not useAxis in [drawobject, self.ax_div]):
                deltaY /= self.splitYFraction
            else:
              deltaY /= 2.
          
          if(target == 'resid'):
            # account for size ratio plot/resid
            relativeSizes = self.masterwidget.sizes()
            sizeRatio = 1. * relativeSizes[0] / relativeSizes[1]
            deltaY *= sizeRatio / 2.
  
          if(useModeX == 'linear'):
            cx1, cx2 = x - 0.5 * deltaX * dimX, x + 0.5 * deltaX * dimX
          else:
            cx1, cx2 = x / np.exp(0.5 * deltaX * dimX), x * np.exp(0.5 * deltaX * dimX)
          if(useModeY == 'linear'):
            cy1, cy2 = y - 0.5 * deltaY * dimY, y + 0.5 * deltaY * dimY
          else:
            cy1, cy2 = y / np.exp(0.5 * deltaY * dimY), y * np.exp(0.5 * deltaY * dimY)

          # transform to axiscoordinates
          drawLine = matplotlib.lines.Line2D([cx1, cx2], [cy1, cy2])
          handleDivider.append(useAxis.add_line(drawLine))

        # apply styles
        for entry in handleDivider:
          entry.set_color(self.splitDividerColor)
          entry.set_solid_capstyle(self.splitDividerDashStyle)
          entry.set_linewidth(self.splitDividerWidth)
          entry.set_clip_on(False)
          entry.set_zorder(999)
          
      # save handles
      if(target == 'plot'):
        self.handleDivider = handleDivider
      else:
        self.handleDividerResid = handleDivider

      if(redraw):
        plotobject.myRefresh()

  def drawAxisArrow(self, axis='x', redraw=True, target='plot'):
    # draws arrowhead along axis
    drawOnDiv = self.splitShow and (axis == 'x')
    if((target in ['plot', 'resid']) and (axis in ['x', 'y'])):
      # assign handles
      if(target == 'plot'):
        plotobject, axisobject, axisobject2, arrowhandle, arrowhandle2 = self.dataplotwidget, self.ax, self.ax_div, self.handleArrow, self.handleArrow2
        if(drawOnDiv):
          axisobject = self.ax_div
      else:
        plotobject, axisobject, axisobject2, arrowhandle, arrowhandle2 = self.residplotwidget, self.ax_resid, self.ax_resid_div, self.handleArrowResid, self.handleArrowResid2
        if(drawOnDiv):
          axisobject = self.ax_resid_div

      # assign values
      if(self.arrowEdgeShow[axis]):
        drawCol = self.arrowColor[axis]
      else:
        drawCol = 'None'
      if(self.arrowFillShow[axis]):
        drawFill = self.arrowFill[axis]
      else:
        drawFill = 'None'
      drawOverhang = self.arrowOverhang[axis]
      drawOffset = self.arrowOffset[axis]
      drawHeadWidth = self.arrowHeadWidth[axis]
      drawHeadLength = self.arrowHeadLength[axis]
      drawZ = axisobject.spines['bottom'].get_zorder() + 0.1
      drawLw = self.arrowEdge[axis]
      
      # which axis to operate on?
      if(axis=='x'):
        # calculate drawWidth
        if(drawOnDiv):
          useModeX, useMinX, useMaxX = self.modeX_div, self.minX_div, self.maxX_div
        else:
          useModeX, useMinX, useMaxX = self.modeX, self.minX, self.maxX
          
        if(useModeX == 'linear'):
          drawWidth = np.abs(useMaxX - useMinX)
          logx = False
        else:
          drawWidth = np.abs(np.log(useMaxX) - np.log(useMinX))
          logx = True

        if(self.splitShow):
          drawHeadLength *= drawWidth * (1 + self.splitFraction) / self.splitFraction
        else:
          drawHeadLength *= drawWidth
  
        # calculate drawHeight
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawHeight = np.abs(self.maxY - self.minY)
            logy = False
          else:
            drawHeight = np.abs(np.log(self.maxY) - np.log(self.minY))
            logy = True
          if(self.modeY2 == 'linear'):
            drawHeight_2 = np.abs(self.maxY2 - self.minY2)
            logy_2 = False
          else:
            drawHeight_2 = np.abs(np.log(self.maxY2) - np.log(self.minY2))
            logy_2 = True

          if(self.splitY):
            drawHeadWidth_2 = drawHeadWidth * drawHeight_2  * (1 + self.splitYFraction) / self.splitYFraction
            drawHeadWidth *= drawHeight  * (1 + self.splitYFraction)
          else:
            drawHeadWidth_2 = drawHeadWidth * drawHeight_2
            drawHeadWidth *= drawHeight
        else:
          drawHeight = np.abs(self.maxResidY - self.minResidY)
          # resid plot is always linear in y; account for difference in window size
          relativeSizes = self.masterwidget.sizes()
          sizeRatio = 1. * relativeSizes[0] / relativeSizes[1]
          drawHeadWidth *= drawHeight * sizeRatio
          logy = False

        # assign line width and xy coordinates
        ###drawLw = self.axisWidth['bottom']
        drawCs = self.axisDashStyle['bottom']
        
        if(useModeX == 'linear'):
          drawX = np.max((useMinX, useMaxX))
        else:
          drawX = np.max((np.log(useMinX), np.log(useMaxX)))

        # check for axis boundaries
        if('bottom' in self.ax2.spines):
          bounds = self.ax2.spines['bottom'].get_bounds()
        elif('top' in self.ax2.spines):
          bounds = self.ax2.spines['top'].get_bounds()
        else:
          bounds = None
        
        if((bounds != None) and len(bounds)):
          boundedMax = np.max(bounds)
          if((boundedMax < drawX) and (boundedMax >= np.min((useMinX, useMaxX)))):
            if(useModeX == 'linear'):
              drawX = boundedMax
            else:
              drawX = np.log(boundedMax)

        # apply offset
        drawX -= drawOffset * drawHeadLength
        
        # determine drawY and drawY2
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawY, drawY2 = np.sort((self.minY, self.maxY))
          else:
            drawY, drawY2 = np.sort((np.log(self.minY), np.log(self.maxY)))
          if(self.modeY2 == 'linear'):
            drawY_2, drawY2_2 = np.sort((self.minY2, self.maxY2))
          else:
            drawY_2, drawY2_2 = np.sort((np.log(self.minY2), np.log(self.maxY2)))
        else:
          drawY, drawY2 = np.sort((self.minResidY, self.maxResidY))
        
        # account for shifted axis
        if(target == 'plot'):
          for item in ['bottom', 'top']:
            if(item in self.ax2.spines):
              if(self.splitY and (item == 'bottom')):
                useAxisObject, useAxisObject2, useModeY, useMinY, useMaxY = self.ax, self.ax2, self.modeY2, self.minY2, self.maxY2
              else:
                useAxisObject, useAxisObject2, useModeY, useMinY, useMaxY = self.ax2, self.ax, self.modeY, self.minY, self.maxY
              try:
                axisPosition, axisPositionValue = useAxisObject.spines[item].get_position()
                if(axisPosition == 'data'):
                  itemY = axisPositionValue
                  if(self.modeY == 'log'):
                    # have to test for zero/negative entry
                    if(itemY > 0):
                      itemY = np.log(itemY)
                    else:
                      if(item == 'bottom'):
                        itemY = np.log(np.min((useMinY, useMaxY)))
                      else:
                        itemY = np.log(np.min((useMinY, useMaxY)))
                elif(axisPosition in ['axes', 'outward']):
                  axis_to_data = useAxisObject2.transAxes + useAxisObject2.transData.inverted()
                  transformedPoint = axis_to_data.transform((0, axisPositionValue))
                  itemY = transformedPoint[1]
                  if(useModeY == 'log'):
                    itemY = np.log(itemY)
                if(axisPosition in ['data', 'axes', 'outward']):
                  if(item == 'bottom'):
                    if(self.splitY):
                      drawY_2 = itemY
                    else:
                      drawY = itemY
                  else:
                    drawY2 = itemY
              except:
                pass
        else:
          for item in ['bottom', 'top']:
            if(item in axisobject.spines):
              try:
                axisPosition, axisPositionValue = axisobject.spines[item].get_position()
                if(axisPosition == 'data'):
                  if(item == 'bottom'):
                    drawY = axisPositionValue
                  else:
                    drawY2 = axisPositionValue
                elif(axisPosition == 'axes'):
                  # in resid 
                  axis_to_data = axisobject.transAxes + axisobject.transData.inverted()
                  transformedPoint = axis_to_data.transform((0, axisPositionValue))
                  if(item == 'bottom'):
                    drawY = transformedPoint[1]
                  else:
                    drawY2 = transformedPoint[1]
              except:
                pass
      else:
        # this is the y arrows
        # calculate drawWidth
        if(self.modeX == 'linear'):
          drawHeight = np.abs(self.maxX - self.minX)
          logx = False
        else:
          drawHeight = np.abs(np.log(self.maxX) - np.log(self.minX))
          logx = True
        if(self.modeX_div == 'linear'):
          drawHeight_div = np.abs(self.maxX_div - self.minX_div)
          logx_div = False
        else:
          drawHeight_div = np.abs(np.log(self.maxX_div) - np.log(self.minX_div))
          logx_div = True

        if(self.splitShow):
          drawHeadWidth_div = drawHeadWidth * drawHeight_div * (1 + self.splitFraction) / self.splitFraction
          drawHeadWidth *= drawHeight * (1 + self.splitFraction)
        else:
          drawHeadWidth_div = drawHeadWidth * drawHeight_div
          drawHeadWidth *= drawHeight
  
        # calculate drawHeight
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawWidth = np.abs(self.maxY - self.minY)
            logy = False
          else:
            drawWidth = np.abs(np.log(self.maxY) - np.log(self.minY))
            logy = True
          if(self.splitY):
            drawHeadLength *= drawWidth * (1 + self.splitYFraction)
          else:
            drawHeadLength *= drawWidth
        else:
          drawWidth = np.abs(self.maxResidY - self.minResidY)
          # resid plot is always linear in y; account for difference in window size
          relativeSizes = self.masterwidget.sizes()
          sizeRatio = 1. * relativeSizes[0] / relativeSizes[1]
          drawHeadLength *= drawWidth * sizeRatio
          logy = False

        # assign line width and xy coordinates
        ###drawLw = self.axisWidth['left']
        drawCs = self.axisDashStyle['left']

        if(target == 'resid'):
          useMinY, drawY = np.sort((self.minResidY, self.maxResidY))
        elif (self.modeY == 'linear'):
          useMinY, drawY = np.sort((self.minY, self.maxY))
        else:
          useMinY, drawY = np.sort((np.log(self.minY), np.log(self.maxY)))

        # check for axis boundaries
        if('left' in axisobject.spines):
          bounds = axisobject.spines['left'].get_bounds()
        elif('right' in axisobject.spines):
          bounds = axisobject.spines['right'].get_bounds()
        else:
          bounds = None
        
        if((bounds != None) and len(bounds)):
          boundedMax = np.max(bounds)
          if((boundedMax < drawY) and (boundedMax >= useMinY)):
            if((target == 'resid') or (self.modeY == 'linear')):
              drawY = boundedMax
            else:
              drawY = np.log(boundedMax)

        # apply offset
        drawY -= drawOffset * drawHeadLength
        
        # determine drawX
        if(self.modeX == 'linear'):
          drawX, drawX2 = np.sort((self.minX, self.maxX))
        else:
          drawX, drawX2 = np.sort((np.log(self.minX), np.log(self.maxX)))
        if(self.modeX_div == 'linear'):
          drawX_div, drawX2_div = np.sort((self.minX_div, self.maxX_div))
        else:
          drawX_div, drawX2_div = np.sort((np.log(self.minX_div), np.log(self.maxX_div)))

        # account for shifted axis
        for item in ['left', 'right']:
          if(item in axisobject.spines):
            if(self.splitShow and (item == 'right')):
              useAxisObject, useModeX, useMinX, useMaxX = axisobject2, self.modeX_div, self.minX_div, self.maxX_div
            else:
              useAxisObject, useModeX, useMinX, useMaxX = axisobject, self.modeX, self.minX, self.maxX
            try:
              axisPosition, axisPositionValue = useAxisObject.spines[item].get_position()
              if(axisPosition == 'data'):
                itemX = axisPositionValue
                if(useModeX == 'log'):
                  # have to test for zero/negative entry
                  if(itemX > 0):
                    itemX = np.log(itemX)
                  else:
                    if(item == 'left'):
                      itemX = np.log(np.min((useMinX, useMaxX)))
                    else:
                      itemX = np.log(np.max((useMinX, useMaxX)))
              elif(axisPosition == 'axes'):
                axis_to_data = useAxisObject.transAxes + useAxisObject.transData.inverted()
                transformedPoint = axis_to_data.transform((axisPositionValue, self.minY))
                itemX = transformedPoint[0]
                if(useModeX == 'log'):
                  itemX = np.log(itemX)
                  
              if(item == 'left'):
                drawX = itemX
              else:
                drawX2 = itemX
            except:
              pass

      # remove previous arrows
      if(arrowhandle[axis] != None):
        arrowhandle[axis].remove()
        arrowhandle[axis] = None
      if(arrowhandle2[axis] != None):
        arrowhandle2[axis].remove()
        arrowhandle2[axis] = None

      # draw customized arrow
      if((axis == 'x') and (self.arrowLocation['x'] in ['both', 'bottom'])):
        if(self.splitY and (target == 'plot')):
          if(drawOnDiv):
            thisAxisObject = self.ax2_div
          else:
            thisAxisObject = self.ax2
          arrowhandle[axis] = self.drawMyArrow(axisobject=thisAxisObject, x=drawX, y=drawY_2, axis=axis,\
            head_width=drawHeadWidth_2, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
            linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy_2)
        else:
          arrowhandle[axis] = self.drawMyArrow(axisobject=axisobject, x=drawX, y=drawY, axis=axis,\
            head_width=drawHeadWidth, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
            linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy)
        arrowhandle[axis].set_clip_on(False)
      if((axis == 'y') and (self.arrowLocation['y'] in ['both', 'left'])):
        arrowhandle[axis] = self.drawMyArrow(axisobject=axisobject, x=drawX, y=drawY, axis=axis,\
          head_width=drawHeadWidth, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
          linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy)
        arrowhandle[axis].set_clip_on(False)
      if((axis == 'x') and (self.arrowLocation['x'] in ['both', 'top'])):
        arrowhandle2[axis] = self.drawMyArrow(axisobject=axisobject, x=drawX, y=drawY2, axis=axis,\
          head_width=drawHeadWidth, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
          linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy)
        arrowhandle2[axis].set_clip_on(False)
      if((axis == 'y') and (self.arrowLocation['y'] in ['both', 'right'])):
        if(self.splitShow):
          arrowhandle2[axis] = self.drawMyArrow(axisobject=axisobject2, x=drawX2_div, y=drawY, axis=axis,\
            head_width=drawHeadWidth_div, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
            linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx_div, logy=logy)
        else:
          arrowhandle2[axis] = self.drawMyArrow(axisobject=axisobject, x=drawX2, y=drawY, axis=axis,\
            head_width=drawHeadWidth, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
            linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy)
        arrowhandle2[axis].set_clip_on(False)

      if(redraw):
        plotobject.myRefresh()

  def drawMyArrow(self, axisobject, x, y, axis, head_width, head_length, overhang, linewidth, linecolor, fillcolor, capstyle, zorder, logx=False, logy=False):
    # draw customized arrow
    # calculate coordinates
    coords = np.array(4 * [[x, y]])
    if(axis=='x'):
      coords[0, 0] += head_length * overhang
      coords[2, 0] += head_length
      coords[1, 1] += head_width / 2.0
      coords[3, 1] -= head_width / 2.0
    else:
      coords[1, 0] += head_width / 2.0
      coords[3, 0] -= head_width / 2.0
      coords[0, 1] += head_length * overhang
      coords[2, 1] += head_length

    # transform to log scale?
    if(logx):
      coords[:, 0] = np.exp(coords[:,0])
    if(logy):
      coords[:, 1] = np.exp(coords[:,1])

    if(axisobject is self.ax):
      axisname = 'ax'
    else:
      axisname = 'ax_resid'
      
    if(overhang < 1):
      polyPatch = matplotlib.patches.Polygon(coords, closed=True, facecolor=fillcolor, fill=True,\
        edgecolor=linecolor, linestyle='solid', linewidth=linewidth, zorder=zorder, capstyle=capstyle)
      retv = axisobject.add_patch(polyPatch)
      self.rememberSetting[axisname + '_arrow' + axis] = 'coords = np.array(' + repr(coords.tolist()) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'polyPatch = matplotlib.patches.Polygon(coords, closed=True, facecolor='\
        + repr(fillcolor) + ', fill=True, edgecolor=' + repr(linecolor) + ', linestyle=\'solid\', linewidth='\
        + repr(linewidth) + ', zorder=' + repr(zorder) + ', capstyle=' + repr(capstyle) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle = ' + axisname + '.add_patch(polyPatch)\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle.set_clip_on(False)\n'
    else:
      polyPatch = matplotlib.patches.Polygon(coords[1:,:], closed=False, fill=False,\
        edgecolor=linecolor, linestyle='solid', linewidth=linewidth, zorder=zorder, capstyle=capstyle)
      retv = axisobject.add_patch(polyPatch)
      self.rememberSetting[axisname + '_arrow' + axis] = 'coords = np.array(' + repr(coords[1:,:].tolist()) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'polyPatch = matplotlib.patches.Polygon(coords, closed=False'\
        + ', fill=False, edgecolor=' + repr(linecolor) + ', linestyle=\'solid\', linewidth='\
        + repr(linewidth) + ', zorder=' + repr(zorder) + ', capstyle=' + repr(capstyle) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle = ' + axisname + '.add_patch(polyPatch)\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle.set_clip_on(False)\n'

    return retv

  def setCanvasGradientStyle(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientStyle == value):
          redraw = False
        else:
          self.canvasGradientStyle = value
      else:
        if(self.canvasGradientStyle_resid == value):
          redraw = False
        else:
          self.canvasGradientStyle_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientColor(self, value=0.0, redraw=True, target='plot', color=0):
    # sets angle of canvas gradient
    if((target in ['plot', 'resid']) and (color in [0, 1])):
      if(target == 'plot'):
        if(color):
          if(self.canvasGradientColor2 == value):
            redraw = False
          else:
            self.canvasGradientColor2 = value
        else:
          if(self.canvasGradientColor1 == value):
            redraw = False
          else:
            self.canvasGradientColor1 = value
      else:
        if(color):
          if(self.canvasGradientColor2_resid == value):
            redraw = False
          else:
            self.canvasGradientColor2_resid = value
        else:
          if(self.canvasGradientColor1_resid == value):
            redraw = False
          else:
            self.canvasGradientColor1_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientCenter(self, value=0.0, redraw=True, target='plot', axis='x'):
    # sets angle of canvas gradient
    if((target in ['plot', 'resid']) and (axis in ['x', 'y'])):
      if(axis == 'x'):
        index = 0
      else:
        index = 1
      if(target == 'plot'):
        if(self.canvasGradientCenter[index] == value):
          redraw = False
        else:
          self.canvasGradientCenter[index] = value
      else:
        if(self.canvasGradientCenter_resid[index] == value):
          redraw = False
        else:
          self.canvasGradientCenter_resid[index] = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'radial')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientWidth(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientWidth == value):
          redraw = False
        else:
          self.canvasGradientWidth = value
      else:
        if(self.canvasGradientWidth_resid == value):
          redraw = False
        else:
          self.canvasGradientWidth_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'radial')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientAngle(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientAngle == value):
          redraw = False
        else:
          self.canvasGradientAngle = value
      else:
        if(self.canvasGradientAngle_resid == value):
          redraw = False
        else:
          self.canvasGradientAngle_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'linear')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)
  
  def setCanvasGradient(self, state=True, redraw=True, target='plot', steps=50):
    # draws a color gradient on axis background
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; planeobject = self.colorPlane; handleContour = self.colorBackground
        axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; planeobject = self.colorPlane_resid; handleContour = self.colorBackground_resid
        axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
      
      # remove previous gradient (if present)
      if(handleContour != None):
        for entry in handleContour.collections:
          entry.remove()
        handleContour = None
  
      self.canvasGradientVisible = state
      if(state):
        # define new gradient
        gradientDict = {}
        for index, component in enumerate(['red', 'green', 'blue', 'alpha']):
          gradientDictTemp = {component: ((0.0, self.canvasGradientColor1[index], self.canvasGradientColor1[index]),
                                          (1.0, self.canvasGradientColor2[index], self.canvasGradientColor2[index]))}
          gradientDict.update(gradientDictTemp)
        gradientMap = matplotlib.colors.LinearSegmentedColormap('MyMap', gradientDict)
        x, y = np.linspace(0, 1, steps), np.linspace(0, 1, steps)
        X, Y = np.meshgrid(x, y)
        if(self.canvasGradientStyle == 'linear'):
          angle = self.canvasGradientAngle / 360.0 * 2 * np.pi
          Z = X * np.cos(angle) + Y * np.sin(angle)
        else:
          width = self.canvasGradientWidth
          Z = np.exp(-(((X - self.canvasGradientCenter[0]) / width) ** 2) - (((Y - self.canvasGradientCenter[1]) / width) ** 2))
        handleContour = planeobject.contourf(X, Y, Z, 128, cmap=gradientMap, vmax=1.0, vmin=0.0)
        # hide canvas background of top plots
        axisobject.patch.set_facecolor([1.0] * 3 + [0.0])
        axisobject2.patch.set_facecolor([1.0] * 3 + [0.0])
        if(self.splitY and (target == 'plot')):
          self.ax.patch.set_facecolor([1.0] * 3 + [0.0])
          self.ax_div.patch.set_facecolor([1.0] * 3 + [0.0])
      else:
        # restore canvas background of top plots
        if(self.canvasFill):
          axisobject.patch.set_facecolor(self.canvasColor)
          axisobject2.patch.set_facecolor(self.canvasColor)
          if(self.splitY and (target == 'plot')):
            self.ax.patch.set_facecolor(self.canvasColor)
            self.ax_div.patch.set_facecolor(self.canvasColor)
        else:
          axisobject.patch.set_facecolor('none')
          axisobject2.patch.set_facecolor('none')
          if(self.splitY and (target == 'plot')):
            self.ax.patch.set_facecolor('none')
            self.ax_div.patch.set_facecolor('none')
  
      if(redraw):
        plotobject.myRefresh()
  
      # assign handles
      if(target == 'plot'):
        self.colorBackground = handleContour
      else:
        self.colorBackground_resid = handleContour

  def setFigureColor(self, value=[0, 0, 0, 1], redraw=True, target='plot', silent=True):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; matobject = self.matplot; objectname = 'matplot'
      else:
        plotobject = self.residplotwidget; matobject = self.residplot; objectname = 'residplot'
      # sets figure background color
      if((self.figureColor == value) and (target == 'plot')):
        redraw = False
        
      self.figureColor = value
      # always change figure color on screen as we cannot assume which label and axis color etc. people are using
      if((not self.figureFill) and (not silent)):
        self.parent.statusbar.showMessage('Note that figure background of exported graphics is currently set to transparent.', self.parent.STATUS_TIME, color='blue')
      matobject.set_facecolor(self.figureColor)
      # remember settings
      self.rememberSetting[objectname + '_figureColor'] = objectname + '.set_facecolor(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleFigureFill(self, value=True, redraw=True, target='plot', silent=True):
    # toggles whether figure background is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget
      else:
        plotobject = self.residplotwidget

      # disable redraw and never change figure color on screen as we cannot assume which label and axis color etc. people are using
      redraw = False
      if((not value) and (not silent)):
        self.parent.statusbar.showMessage('Figure background of exported graphics set to transparent.', self.parent.STATUS_TIME, color='blue')
  
      self.figureFill = value
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleFrameDraw(self, value=True, redraw=True, target='plot'):
    # toggles whether figure frame is drawn or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot
        if(self.frameDraw == value):
          redraw = False
        self.frameDraw = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot
        if(self.frameDraw_resid == value):
          redraw = False
        self.frameDraw_resid = value

      # adjust value
      if(value):
        if(target == 'plot'):
          value = self.frameColor
        else:
          value = self.frameColor_resid
      else:
        value = 'none'
      # sets frame color
      figobject.patch.set_edgecolor(value)
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleCanvasFill(self, value=True, redraw=True, target='plot'):
    # toggles whether canvas is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
      # sets canvas color
      if((self.canvasFill == value) and (target == 'plot')):
        redraw = False

      self.canvasFill = value
      # adjust value
      if(value):
        value = self.canvasColor
      else:
        value = 'none'
      if(not self.canvasGradientVisible):
        axisobject.patch.set_facecolor(value)
        axisobject2.patch.set_facecolor(value)
        if(self.splitY and (target == 'plot')):
          self.ax.patch.set_facecolor(value)
          self.ax_div.patch.set_facecolor(value)

      # redraw?
      if(redraw):
        plotobject.myRefresh()
        
  def setCanvasColor(self, value=[0, 0, 0, 1], redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
      # sets canvas color
      if((self.canvasColor == value) and (target == 'plot')):
        redraw = False

      self.canvasColor = value
      if(self.canvasFill):
        if(not self.canvasGradientVisible):
          axisobject.patch.set_facecolor(self.canvasColor)
          axisobject2.patch.set_facecolor(self.canvasColor)
          if(self.splitY and (target == 'plot')):
            self.ax.patch.set_facecolor(self.canvasColor)
            self.ax_div.patch.set_facecolor(self.canvasColor)
        # remember settings
        self.rememberSetting[axisname + '_canvasColor'] = axisname + '.patch.set_facecolor(' + repr(value) + ')\n'
      else:
        redraw = False
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameWidth(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameWidth == value):
          redraw = False
        self.frameWidth = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameWidth_resid == value):
          redraw = False
        self.frameWidth_resid = value

      # sets frame width
      figobject.patch.set_linewidth(value)
      
      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameWidth'] = plotname + '.patch.set_linewidth(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameStyle(self, value='solid', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameStyle == value):
          redraw = False
        self.frameStyle = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameStyle_resid == value):
          redraw = False
        self.frameStyle_resid = value

      # sets frame line style
      figobject.patch.set_linestyle(value)

      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameStyle'] = plotname + '.patch.set_linestyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameDashStyle(self, value='solid', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameDashStyle == value):
          redraw = False
        self.frameDashStyle = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameDashStyle_resid == value):
          redraw = False
        self.frameDashStyle_resid = value

      # sets grid line style
      figobject.patch.set_capstyle(value)

      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameDashStyle'] = plotname + '.patch.set_capstyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameColor(self, value=[0, 0, 0, 1], redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameColor == value):
          redraw = False
        self.frameColor = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameColor_resid == value):
          redraw = False
        self.frameColor_resid = value

      # sets grid color
      if(self.frameDraw):
        figobject.patch.set_edgecolor(value)
      else:
        redraw = False

      # remember settings
      self.rememberSetting[axisname + '_frameColor'] = plotname + '.patch.set_edgecolor(' + repr(value) + ')\n'

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setGridOrder(self, value='back', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridOrder[axis] == value):
            redraw = False
          self.gridOrder[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridOrder_resid[axis] == value):
            redraw = False
          self.gridOrder_resid[axis] = value
          
        if(value == 'back'):
          useZ = 1
        else:
          useZ = 500
        # so here is the deal: set_axisbelow() toggles axis zorder between 0.5 and 2.5
        # however, due to z offset, all our objects are at higher z values than 2.5
        # hence draw custom lines
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_zorder(useZ)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_zorder(useZ)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridStyle(self, value='solid', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridStyle[axis] == value):
            redraw = False
          self.gridStyle[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridStyle_resid[axis] == value):
            redraw = False
          self.gridStyle_resid[axis] = value

        # sets grid line style
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_linestyle(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_linestyle(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridDashStyle(self, value='butt', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridDashStyle[axis] == value):
            redraw = False
          self.gridDashStyle[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridDashStyle_resid[axis] == value):
            redraw = False
          self.gridDashStyle_resid[axis] = value

        # sets grid line dash style
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_dash_capstyle(value)
            line.set_solid_capstyle(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_dash_capstyle(value)
            line.set_solid_capstyle(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridWidth(self, value=0.5, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridWidth[axis] == value):
            redraw = False
          self.gridWidth[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridWidth_resid[axis] == value):
            redraw = False
          self.gridWidth_resid[axis] = value

        # sets grid line width
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_linewidth(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_linewidth(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridColor[axis] == value):
            redraw = False
          self.gridColor[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridColor_resid[axis] == value):
            redraw = False
          self.gridColor_resid[axis] = value

        # sets grid line color
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_color(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_color(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridVisibility(self, value=True, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridVisible[axis] == value):
            redraw = False
          self.gridVisible[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridVisible_resid[axis] == value):
            redraw = False
          self.gridVisible_resid[axis] = value

        # sets visibility of grid lines
        self.drawAxisGrid(axis=axis, redraw=False, target=target)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setPadding(self, value=0.5, axis='bottom', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['bottom', 'top', 'left', 'right']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; matobject = self.matplot; objectname = 'matplot'
          if(matobject.subplotpars.__dict__[axis] == value):
            redraw = False
          self.padSize[axis] = value
        else:
          plotobject = self.residplotwidget; matobject = self.residplot; objectname = 'residplot'
          if(matobject.subplotpars.__dict__[axis] == value):
            redraw = False
          self.padSize_resid[axis] = value
        # sets padding
        matobject.subplots_adjust(left=self.padSize['left'], right=self.padSize['right'],\
          bottom=self.padSize['bottom'], top=self.padSize['top'])
        # account for split y axis
        if(self.splitY and (target == 'plot')):
          ybreak = (self.padSize['top'] - self.padSize['bottom'] - self.splitYPad) * self.splitYFraction / (1.0 + self.splitYFraction)
          self.ax.set_position(matplotlib.transforms.Bbox([[self.padSize['left'], self.padSize['bottom'] + ybreak + self.splitYPad], [self.padSize['right'], self.padSize['top']]]))
          self.ax2.set_position(matplotlib.transforms.Bbox([[self.padSize['left'], self.padSize['bottom']], [self.padSize['right'], self.padSize['bottom'] + ybreak]]))
        # remember settings
        self.rememberSetting[objectname + '_padding'] = objectname + '.subplots_adjust(left=' + repr(self.padSize['left'])
        self.rememberSetting[objectname + '_padding'] += ', right=' + repr(self.padSize['right']) + ', bottom=' + repr(self.padSize['bottom'])
        self.rememberSetting[objectname + '_padding'] += ', top=' + repr(self.padSize['top']) + ')\n'
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickOne4All(self, axis='x', redraw=True, target='plot'):
    # calls all tick label formatters successively to fix glitch when no. of tick labels change upon rescaling
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject,  axisobject, axisobject2 = self.dataplotwidget, self.ax2, self.ax2_div
        else:
          plotobject,  axisobject, axisobject2 = self.residplotwidget, self.ax_resid, self.ax_resid_div
        # which axis?  
        if(axis == 'x'):
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksXColor, self.ticksXSize, self.ticksXWeight, self.ticksXStyle, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksXAngle, self.ticksXAlignment, self.ticksXAlignmentVertical, self.ticksXPad, self.ticksXPad2
        elif(axis == 'y'):
          if(target == 'plot'):
            axisobject, axisobject2 = self.ax, self.ax_div
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksYColor, self.ticksYSize, self.ticksYWeight, self.ticksYStyle, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksYAngle, self.ticksYAlignment, self.ticksYAlignmentVertical, self.ticksYPad, self.ticksYPad2
        else:
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksY2Color, self.ticksY2Size, self.ticksY2Weight, self.ticksY2Style, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksY2Angle, self.ticksY2Alignment, self.ticksY2AlignmentVertical, self.ticksY2Pad, self.ticksY2Pad2
        
        if(axis == 'x'):
          tickLabels = axisobject.get_xticklabels(which='both')
          tickLabels.append(axisobject.xaxis.get_offset_text())
          tickLabels.extend(axisobject2.get_xticklabels(which='both'))
          tickLabels.append(axisobject2.xaxis.get_offset_text())
          ticks = axisobject.xaxis.get_major_ticks()
          ticks.extend(axisobject.xaxis.get_minor_ticks())
          ticks.extend(axisobject2.xaxis.get_major_ticks())
          ticks.extend(axisobject2.xaxis.get_minor_ticks())
          if(self.splitY and (target == 'plot')):
            tickLabels.extend(self.ax.get_xticklabels(which='both'))
            tickLabels.append(self.ax.xaxis.get_offset_text())
            ticks.extend(self.ax.xaxis.get_major_ticks())
            ticks.extend(self.ax.xaxis.get_minor_ticks())
            tickLabels.extend(self.ax_div.get_xticklabels(which='both'))
            tickLabels.append(self.ax_div.xaxis.get_offset_text())
            ticks.extend(self.ax_div.xaxis.get_major_ticks())
            ticks.extend(self.ax_div.xaxis.get_minor_ticks())
        else:
          tickLabels = axisobject.get_yticklabels(which='both')
          tickLabels.append(axisobject.yaxis.get_offset_text())
          tickLabels.extend(axisobject2.get_yticklabels(which='both'))
          tickLabels.append(axisobject2.yaxis.get_offset_text())
          ticks = axisobject.yaxis.get_major_ticks()
          ticks.extend(axisobject.yaxis.get_minor_ticks())
          ticks.extend(axisobject2.yaxis.get_major_ticks())
          ticks.extend(axisobject2.yaxis.get_minor_ticks())

        if((target == 'plot') or (axis != 'y2')):
          # don't call formatter functions as this is too slow
          safeFont = 'DejaVu Sans'
          useFont = tickLabelFont
          for entry in tickLabels:
            entry.set_color(tickLabelColor)
            entry.set_fontsize(tickLabelSize)
            entry.set_fontweight(tickLabelWeight)
            entry.set_fontstyle(tickLabelStyle)
            try:
              # we should be in the clear but there is a certain danger here
              entry.set_fontname(useFont)
              _, _, descent = entry._get_layout(self.matplot.canvas.renderer)
              if(not (descent > 0)):
                useFont = safeFont
                entry.set_fontname(useFont)
            except:
              useFont = safeFont
              entry.set_fontname(useFont)
            entry.set_rotation(tickLabelAngle)
            entry.set_horizontalalignment(tickLabelAlignment)
            entry.set_verticalalignment(tickLabelAlignmentVertical)

          for entry in ticks:
            entry.set_pad(tickLabelPad)
         
          # call formatter for pad2 as this is more complicated
          self.setTickLabelPad2(value=tickLabelPad2, axis=axis, redraw=False, target=target)
          
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickLabelColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets axis label color
          if(axis == 'x'):
            if((self.ticksXColor == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXColor = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
            if(self.splitY):
              tickLabels.extend(self.ax.get_xticklabels(which='both'))
              tickLabels.append(self.ax.xaxis.get_offset_text())
              tickLabels.extend(self.ax_div.get_xticklabels(which='both'))
              tickLabels.append(self.ax_div.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYColor == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYColor = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Color == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Color = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          # sets axis label color
          if(axis == 'x'):
            if((self.ticksXColor_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXColor_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          else:
            if((self.ticksYColor_resid == value) or (not self.ticksResidYShow)):
              redraw = False
            self.ticksYColor_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_color(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_color(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickColor' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickMarkLabelShow(self, value=True, axis='left', redraw=True, target='plot'):
    # sets where to display the axis labels
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
          if (axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div

        self.ticksLabelShow[axis] = value
        if(axis == 'bottom'):
          axisobject.xaxis.set_tick_params(which='both', labelbottom=value)
          axisobject2.xaxis.set_tick_params(which='both', labelbottom=value)
        elif(axis == 'top'):
          axisobject.xaxis.set_tick_params(which='both', labeltop=value)
          axisobject2.xaxis.set_tick_params(which='both', labeltop=value)
        elif(axis in ['left', 'left2']):
          axisobject.yaxis.set_tick_params(which='both', labelleft=value)
          axisobject2.yaxis.set_tick_params(which='both', labelleft=value)
        else:
          axisobject.yaxis.set_tick_params(which='both', labelright=value)
          axisobject2.yaxis.set_tick_params(which='both', labelright=value)

        # check general tick show dialog
        if(value):
          if(axis in ['bottom', 'top']):
            self.ticksXShow, self.ticksXShow_resid = True, True
            if(hasattr(self.parent, 'graphicsarea')):
              self.parent.graphicsarea.configTickXLabel.setChecked(True)
            # and activate TickOne4All()
            self.setTickOne4All(axis='x', redraw=False, target=target)
          elif(axis in ['left', 'right']):
            self.ticksYShow, self.ticksResidYShow  = True, True
            if(hasattr(self.parent, 'graphicsarea')):
              self.parent.graphicsarea.configTickYLabel.setChecked(True)
              self.parent.graphicsarea.configTickResidYLabel.setChecked(True)
              self.parent.graphicsarea.configInnerLabel.setChecked(True)
            self.setTickOne4All(axis='y', redraw=False, target=target)
          else:
            self.ticksY2Show  = True
            if(hasattr(self.parent, 'graphicsarea2')):
              self.parent.graphicsarea2.configTickYLabel.setChecked(True)
            self.setTickOne4All(axis='y2', redraw=False, target=target)
        
        # set visibility of inner items correctly
        self.updateInnerSituation()

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickMarkDirection(self, value='in', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksDirection[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksDirection['left'] = value
            self.ticksDirection['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksDirection['left2'] = value
            self.ticksDirection['right2'] = value
          else:
            axis = 'x'
            self.ticksDirection['top'] = value
            self.ticksDirection['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksDirection_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksDirection_resid['left'] = value
            self.ticksDirection_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksDirection_resid['top'] = value
            self.ticksDirection_resid['bottom'] = value

        # sets tick mark position
        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, direction=value, which='both')
          axisobject2.tick_params(axis=axis, direction=value, which='both')
          if(self.splitY and (axis == 'x') and (target == 'plot')):
            self.ax.tick_params(axis=axis, direction=value, which='both')
            self.ax_div.tick_params(axis=axis, direction=value, which='both')
          
          # remember settings
          self.rememberSetting[axisname + '_tickMarkDirection' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', direction=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()
          
  def setTickMarkVisibility(self, value=True, axis='left', redraw=True, target='plot', initMode=False):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.ticksVisible[axis] == value):
            redraw = False
          self.ticksVisible[axis] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksVisible_resid[axis] == value):
            redraw = False
          self.ticksVisible_resid[axis] = value

        if(axis in ['left', 'right']):
          # modify ticks along y axes
          # adjust axis labels
          if(not initMode):
            if(axis == 'left'):
              if(value or self.ticksLabelShow['right']):
                self.ticksLabelShow['left'] = value
                # ensure that graphicsarea has already been created (required during program start)
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['left'].setChecked(value)
            else:
              if(value and (not self.ticksVisible['left'])):
                self.ticksLabelShow['left'] = False
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['left'].setChecked(False)
              if(value == (not self.ticksLabelShow['left'])):
                self.ticksLabelShow['right'] = value
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['right'].setChecked(value)
          # then set ticks and tick labels
          if(target == 'plot'):
            useShow = self.ticksYShow
          else:
            useShow = self.ticksResidYShow
          axisobject.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], labelleft=self.ticksLabelShow['left'] and useShow, right=self.ticksVisible['right'], labelright=self.ticksLabelShow['right'] and useShow)
          axisobject2.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], labelleft=self.ticksLabelShow['left'] and useShow, right=self.ticksVisible['right'], labelright=self.ticksLabelShow['right'] and useShow)
          if(self.splitY and (target == 'plot')):
            self.ax.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], labelleft=self.ticksLabelShow['left'] and useShow, right=self.ticksVisible['right'], labelright=self.ticksLabelShow['right'] and useShow)
            self.ax_div.yaxis.set_tick_params(which='both', left=self.ticksVisible['left'], labelleft=self.ticksLabelShow['left'] and useShow, right=self.ticksVisible['right'], labelright=self.ticksLabelShow['right'] and useShow)
        elif (axis in ['left2', 'right2']):
          # adjust axis labels
          if(not initMode):
            if(axis == 'right2'):
              if(value or self.ticksLabelShow['left2']):
                self.ticksLabelShow['right2'] = value
                # ensure that graphicsarea has already been created (required during program start)
                if(hasattr(self.parent, 'graphicsarea2')):
                  self.parent.graphicsarea2.configTickMarkLabelShow['right2'].setChecked(value)
            else:
              if(value and (not self.ticksVisible['right2'])):
                self.ticksLabelShow['right2'] = False
                if(hasattr(self.parent, 'graphicsarea2')):
                  self.parent.graphicsarea2.configTickMarkLabelShow['right2'].setChecked(False)
              if(value == (not self.ticksLabelShow['right2'])):
                self.ticksLabelShow['left2'] = value
                if(hasattr(self.parent, 'graphicsarea2')):
                  self.parent.graphicsarea2.configTickMarkLabelShow['left2'].setChecked(value)
          # then set ticks and tick labels
          useShow = self.ticksY2Show
          axisobject.yaxis.set_tick_params(which='both', left=self.ticksVisible['left2'], labelleft=self.ticksLabelShow['left2'] and useShow, right=self.ticksVisible['right2'], labelright=self.ticksLabelShow['right2'] and useShow)
          axisobject2.yaxis.set_tick_params(which='both', left=self.ticksVisible['left2'], labelleft=self.ticksLabelShow['left2'] and useShow, right=self.ticksVisible['right2'], labelright=self.ticksLabelShow['right2'] and useShow)
        else:
          # modify ticks along x axes
          # adjust axis labels
          if(not initMode):
            if(axis == 'bottom'):
              if(value or self.ticksLabelShow['top']):
                self.ticksLabelShow['bottom'] = value
                # ensure that graphicsarea has already been created (required during program start)
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['bottom'].setChecked(value)
            else:
              if(value and (not self.ticksVisible['bottom'])):
                self.ticksLabelShow['bottom'] = False
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['bottom'].setChecked(False)
              if(value == (not self.ticksLabelShow['bottom'])):
                self.ticksLabelShow['top'] = value
                if(hasattr(self.parent, 'graphicsarea')):
                  self.parent.graphicsarea.configTickMarkLabelShow['top'].setChecked(value)
          # then set ticks and tick labels
          useShow, useShow2 = self.ticksXShow, self.ticksXShow_div
          axisobject.xaxis.set_tick_params(which='both', bottom=self.ticksVisible['bottom'], labelbottom=self.ticksLabelShow['bottom'] and useShow, top=self.ticksVisible['top'], labeltop=self.ticksLabelShow['top'] and useShow)
          axisobject2.xaxis.set_tick_params(which='both', bottom=self.ticksVisible['bottom'], labelbottom=self.ticksLabelShow['bottom'] and useShow2, top=self.ticksVisible['top'], labeltop=self.ticksLabelShow['top'] and useShow2)
              
        # remember settings
        if(axis in ['left', 'right']):
          axis = 'y'
        elif(axis in ['left2', 'right2']):
          if(target == 'plot'):
            axis = 'y'
          else:
            axis = 'abort'
        else:
          axis = 'x'
        
        if(axis != 'abort'):
          ###self.rememberSetting[axisname + '_tickMarkVisibility' + axis] = axisname + '.' + axis + 'axis.set_ticks_position(' + repr(toshow) + ')\n'

          # need to solve inner situation
          self.updateInnerSituation()
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickMarkColor(self, value=[0, 0, 0, 1], axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksColor[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksColor['left'] = value
            self.ticksColor['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksColor['left2'] = value
            self.ticksColor['right2'] = value
          else:
            axis = 'x'
            self.ticksColor['top'] = value
            self.ticksColor['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksColor_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksColor_resid['left'] = value
            self.ticksColor_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksColor_resid['top'] = value
            self.ticksColor_resid['bottom'] = value

        # sets axis label color
        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, color=value, which='both')
          axisobject2.tick_params(axis=axis, color=value, which='both')
          if(self.splitY and (axis == 'x') and (target == 'plot')):
            self.ax.tick_params(axis=axis, color=value, which='both')
            self.ax_div.tick_params(axis=axis, color=value, which='both')
    
          # remember settings
          self.rememberSetting[axisname + '_tickMarkColor' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', color=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickMarkWidth(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksWidth[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksWidth['left'] = value
            self.ticksWidth['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksWidth['left2'] = value
            self.ticksWidth['right2'] = value
          else:
            axis = 'x'
            self.ticksWidth['top'] = value
            self.ticksWidth['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksWidth_resid[axis] == value):
            redraw = False
          self.ticksWidth_resid[axis] = value
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksWidth_resid['left'] = value
            self.ticksWidth_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksWidth_resid['top'] = value
            self.ticksWidth_resid['bottom'] = value

        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, width=value, which='both')
          axisobject2.tick_params(axis=axis, width=value, which='both')
          if(self.splitY and (axis == 'x') and (target == 'plot')):
            self.ax.tick_params(axis=axis, width=value, which='both')
            self.ax_div.tick_params(axis=axis, width=value, which='both')
  
          # remember settings
          self.rememberSetting[axisname + '_tickMarkWidth' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', width=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setMinorTickRelativeLength(self, value, axis, redraw=True, target='plot'):
    # changes relative length of ticks
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          if(axis == 'y'):
            if(self.ticksYMinorRelativeLength == value):
              redraw = False
            self.ticksYMinorRelativeLength = value
            item = 'left'
          elif(axis == 'y2'):
            if(self.ticksY2MinorRelativeLength == value):
              redraw = False
            self.ticksY2MinorRelativeLength = value
            item = 'left2'
          else:
            if(self.ticksXMinorRelativeLength == value):
              redraw = False
            self.ticksXMinorRelativeLength = value
            item = 'top'
        else: 
          if(axis == 'y'):
            if(self.ticksResidYMinorRelativeLength == value):
              redraw = False
            self.ticksResidYMinorRelativeLength = value
            item = 'left'
          elif(axis == 'y'):
            axis = 'abort'
          else:
            if(self.ticksXMinorRelativeLength_resid == value):
              redraw = False
            self.ticksXMinorRelativeLength_resid = value
            item = 'top'
            
        # update tick marks
        if(axis != 'abort'):
          self.setTickMarkLength(value=self.ticksLength[item], axis=item, redraw=redraw, target=target, forceRedraw=redraw)
      
  def setTickMarkLength(self, value=1.0, axis='left', redraw=True, target='plot', forceRedraw=False):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksLength[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksLength['left'] = value
            self.ticksLength['right'] = value
            ticksMinorRelativeLength = self.ticksYMinorRelativeLength
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksLength['left2'] = value
            self.ticksLength['right2'] = value
            ticksMinorRelativeLength = self.ticksY2MinorRelativeLength
          else:
            axis = 'x'
            self.ticksLength['top'] = value
            self.ticksLength['bottom'] = value
            ticksMinorRelativeLength = self.ticksXMinorRelativeLength
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksLength_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksLength_resid['left'] = value
            self.ticksLength_resid['right'] = value
            ticksMinorRelativeLength = self.ticksResidYMinorRelativeLength
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksLength_resid['top'] = value
            self.ticksLength_resid['bottom'] = value
            ticksMinorRelativeLength = self.ticksXMinorRelativeLength

        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, length=value, which='major')
          axisobject.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
          axisobject2.tick_params(axis=axis, length=value, which='major')
          axisobject2.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
          if(self.splitY and (axis == 'x') and (target == 'plot')):
            self.ax.tick_params(axis=axis, length=value, which='major')
            self.ax.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
            self.ax_div.tick_params(axis=axis, length=value, which='major')
            self.ax_div.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
          # remember settings
          self.rememberSetting[axisname + '_tickMarkLength' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', length=' + repr(value) + ', which=\'major\')\n'
          self.rememberSetting[axisname + '_tickMarkLength' + axis] += axisname + '.tick_params(axis=' + repr(axis) +', length=' + repr(value/2.0) + ', which=\'minor\')\n'
          # redraw?
          if(redraw or forceRedraw):
            plotobject.myRefresh()

  def setAxisLabelColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXColor == value) or (not self.labelXShow)):
            redraw = False
          self.labelXColor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXColor_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXColor_resid = value

        handleAxis = axisobject.xaxis.label
        handleAxis.set_color(value)
        handleAxis = axisobject2.xaxis.label
        handleAxis.set_color(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYColor == value) or (not self.labelYShow)):
            redraw = False
          self.labelYColor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYColor_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYColor_resid = value

        handleAxis = axisobject.yaxis.label
        handleAxis.set_color(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_color(value)
      elif(axis == 'y2'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelY2Color == value) or (not self.labelY2Show)):
            redraw = False
          self.labelY2Color = value
          handleAxis = axisobject.yaxis.label
          handleAxis.set_color(value)
          handleAxis = axisobject2.yaxis.label
          handleAxis.set_color(value)
        else:
          axis = 'abort'

      # remember settings
      if(axis != 'abort'):
        self.rememberSetting[axisname + '_axisLabelColor' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_color(' + repr(value) + ')\n'
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setAxisLabel(self, labeltext=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      # updates axis label
      if(labeltext == None):
        labeltext = axis

      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; figobject = self.matplot; axisname = 'ax2'
          if((self.labelX == labeltext) or (not self.labelXShow)):
            redraw = False
          self.labelX = labeltext
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; figobject = self.residplot; axisname = 'ax_resid'
          if((self.labelX_resid == labeltext) or (not self.labelXShow_resid)):
            redraw = False
          self.labelX_resid = labeltext
        # manually process escape characters
        labeltext = labeltext.replace('\n', '\\n')
        labeltext = labeltext.replace('\t', '\\t')
        labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
        labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
        # check for potential Mathtext errors
        prevLabel = axisobject.xaxis.get_label_text()
        axisobject.xaxis.set_label_text(labeltext)
        try:
          axisobject.xaxis.label._get_layout(figobject.canvas.renderer)
        except:
          # revert to previous label
          self.parent.statusbar.showMessage('Cannot set axis label to ' + labeltext, self.parent.STATUS_TIME)
          
          axisobject.xaxis.set_label_text(prevLabel)
          labeltext = prevLabel
          redraw = False
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; figobject = self.matplot; axisname = 'ax'
          if((self.labelY == labeltext) or (not self.labelYShow)):
            redraw = False
          self.labelY = labeltext
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; figobject = self.residplot; axisname = 'ax_resid'
          if((self.labelY_resid == labeltext) or (not self.labelYShow_resid)):
            redraw = False
          self.labelY_resid = labeltext
        # manually process escape characters
        labeltext = labeltext.replace('\n', '\\n')
        labeltext = labeltext.replace('\t', '\\t')
        labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
        labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
        if((target == 'resid') and (labeltext != '')):
          labeltext = u'\N{GREEK CAPITAL LETTER DELTA}' + labeltext
        # check for potential Mathtext errors
        prevLabel = axisobject.yaxis.get_label_text()
        axisobject.yaxis.set_label_text(labeltext)
        try:
          axisobject.yaxis.label._get_layout(figobject.canvas.renderer)
        except:
          # revert to previous label
          self.parent.statusbar.showMessage('Cannot set axis label to ' + labeltext, self.parent.STATUS_TIME)
          axisobject.yaxis.set_label_text(prevLabel)
          labeltext = prevLabel
          redraw = False
      elif(axis == 'y2'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; figobject = self.matplot; axisname = 'ax2'
          if((self.labelY2 == labeltext) or (not self.labelY2Show)):
            redraw = False
          self.labelY2 = labeltext
          # manually process escape characters
          labeltext = labeltext.replace('\n', '\\n')
          labeltext = labeltext.replace('\t', '\\t')
          labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
          labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
          # check for potential Mathtext errors
          prevLabel = axisobject.yaxis.get_label_text()
          axisobject.yaxis.set_label_text(labeltext)
          try:
            axisobject.yaxis.label._get_layout(figobject.canvas.renderer)
            axisobject2.yaxis.set_label_text(labeltext)
          except:
            # revert to previous label
            self.parent.statusbar.showMessage('Cannot set axis label to' + labeltext, self.parent.STATUS_TIME)
            axisobject.yaxis.set_label_text(prevLabel)
            axisobject2.yaxis.set_label_text(prevLabel)
            labeltext = prevLabel
            redraw = False
        else:
          axis = 'abort'
                        
      # remember settings
      if(axis != 'abort'):
        self.rememberSetting[axisname + '_axisLabel' + axis] = axisname + '.' + axis[:1] + 'axis.set_label_text(' + repr(labeltext) + ')\n'
  
        # capture errors with bad fonts (can occur when switching back from all-Mathtext label)
        try:
          if(redraw):
            plotobject.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Experiencing problems with font ' + self.axisFont[axis] + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.axisFont[axis] = safeFont
          if(axis == 'x'):
            axisobject.xaxis.label.set_fontname(safeFont)
          else:
            axisobject.yaxis.label.set_fontname(safeFont)
            if(axis == 'y2'):
              axisobject2.yaxis.label.set_fontname(safeFont)
  
          # adjust remember settings 
          self.rememberSetting[axisname + '_axisFont' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontname(' + repr(safeFont) + ')\n'
  
          if(redraw):
            plotobject.myRefresh()

  def setAxisVisibility(self, value=True, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisVisible[axis] == value):
            redraw = False
          self.axisVisible[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisVisible_resid[axis] == value):
              redraw = False
            self.axisVisible_resid[axis] = value

        # sets axis visibility
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_visible(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_visible(value)
  
          # need to solve inner situation
          self.updateInnerSituation()

          # remember settings
          self.rememberSetting[axisname + '_axisVisibility' + axis] = axisname + '.spines[' + repr(axis) + '].set_visible(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisColor(self, value=True, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisColor[axis] == value):
            redraw = False
          self.axisColor[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisColor_resid[axis] == value):
              redraw = False
            self.axisColor_resid[axis] = value

        # set axis color
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_color(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_color(value)
          
          # remember settings
          self.rememberSetting[axisname + '_axisColor' + axis] = axisname + '.spines[' + repr(axis) + '].set_color(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisWidth(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisWidth[axis] == value):
            redraw = False
          self.axisWidth[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisWidth_resid[axis] == value):
              redraw = False
            self.axisWidth_resid[axis] = value

        # updates axis width
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_linewidth(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_linewidth(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisWidth' + axis] = axisname + '.spines[' + repr(axis) + '].set_linewidth(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisFont(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether font exists
    safeFont = 'DejaVu Sans'
    if(not (value in self.parent.fontNames)):
      value = safeFont
    if(value in self.parent.fontNames):
      # check whether to operate on data or resid plot
      if(target in ['plot', 'resid']):
        if(axis in ['x', 'y', 'y2']):
          if(target == 'plot'):
            prevFont = self.axisFont[axis]
            plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
            if(axis == 'y'):
              axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if(self.axisFont[axis] == value):
              redraw = False
            self.axisFont[axis] = value
          else:
            if(axis == 'y2'):
              axis = 'abort'
            else:
              prevFont = self.axisFont_resid[axis]
              plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
              if(self.axisFont_resid[axis] == value):
                redraw = False
              self.axisFont_resid[axis] = value

          if(axis != 'abort'):
            useFont = value
            # try setting font value
            if(axis == 'x'):
              for useObject in [axisobject, axisobject2]:
                useObject.xaxis.label.set_fontname(useFont)
                _, _, descent = useObject.xaxis.label._get_layout(self.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + useFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
                  useFont = prevFont
                  useObject.xaxis.label.set_fontname(useFont)
                  _, _, descent =useObject.xaxis.label._get_layout(self.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Also experiencing problems setting font ' + useFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    useFont = safeFont
                    useObject.xaxis.label.set_fontname(useFont)
            else:
              for useObject in [axisobject, axisobject2]:
                useObject.yaxis.label.set_fontname(useFont)
                _, _, descent = useObject.yaxis.label._get_layout(self.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + useFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
                  useFont = prevFont
                  useObject.yaxis.label.set_fontname(useFont)
                  _, _, descent =useObject.yaxis.label._get_layout(self.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Also experiencing problems setting font ' + useFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    useFont = safeFont
                    useObject.yaxis.label.set_fontname(useFont)
  
            # save actual font value
            if(target == 'plot'):
              self.axisFont[axis] = useFont
            else:
              self.axisFont_resid[axis] = useFont
            
            # have to capture errors in case a strange font is set
            # retain this as 2nd-layer contro
            try:
              if(redraw):
                plotobject.myRefresh()
            except:
              self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
              
              # revert to previous font
              value = prevFont
              if(target == 'plot'):
                self.axisFont[axis] = prevFont
              else:
                self.axisFont_resid[axis] = prevFont
  
              if(axis == 'x'):
                axisobject.xaxis.label.set_fontname(prevFont)
                axisobject2.xaxis.label.set_fontname(prevFont)
              else:
                axisobject.yaxis.label.set_fontname(prevFont)
                axisobject2.yaxis.label.set_fontname(prevFont)
  
              # also capture errors with previous font (can happen if selecting two bad fonts in a row)
              try:
                if(redraw):
                  plotobject.myRefresh()
              except:
                self.parent.statusbar.showMessage('Also experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
  
                # revert to previous font
                value = safeFont
                if(target == 'plot'):
                  self.axisFont[axis] = safeFont
                else:
                  self.axisFont_resid[axis] = safeFont
    
                if(axis == 'x'):
                  axisobject.xaxis.label.set_fontname(safeFont)
                  axisobject2.xaxis.label.set_fontname(safeFont)
                else:
                  axisobject.yaxis.label.set_fontname(safeFont)
                  axisobject2.yaxis.label.set_fontname(safeFont)
  
            # remember settings
            self.rememberSetting[axisname + '_axisFont' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontname(' + repr(value) + ')\n'

  def setAxisLabelAlignment(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'

        if(axis == 'x'):
          axisobject.xaxis.label.set_horizontalalignment(value)
          axisobject2.xaxis.label.set_horizontalalignment(value)
          direction = 'horizontal'
          if(target == 'plot'):
            if((self.labelXAlignment == value) or (not self.labelXShow)):
              redraw = False
            self.labelXAlignment = value
          else:
            if((self.labelXAlignment_resid == value) or (not self.labelXShow_resid)):
              redraw = False
            self.labelXAlignment_resid = value
        elif(axis == 'y'):
          if(target == 'plot'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.labelYAlignment == value) or (not self.labelYShow)):
              redraw = False
            self.labelYAlignment = value
          else:
            if((self.labelYAlignment_resid == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelYAlignment_resid = value
          axisobject.yaxis.label.set_horizontalalignment(value)
          axisobject2.yaxis.label.set_horizontalalignment(value)
          direction = 'horizontal'
        elif(axis == 'y2'):
          if(target == 'plot'):
            axisobject.yaxis.label.set_horizontalalignment(value)
            axisobject2.yaxis.label.set_horizontalalignment(value)
            direction = 'horizontal'
            if((self.labelY2Alignment == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelY2Alignment = value
          else:
            axis = 'abort'

        # remember settings
        if(axis != 'abort'):
          self.rememberSetting[axisname + '_axisAlignment' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + direction + 'alignment(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisLabelAlignmentVertical(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'

        if(axis == 'x'):
          axisobject.xaxis.label.set_verticalalignment(value)
          axisobject2.xaxis.label.set_verticalalignment(value)
          direction = 'vertical'
          if(target == 'plot'):
            if((self.labelXAlignmentVertical == value) or (not self.labelXShow)):
              redraw = False
            self.labelXAlignmentVertical = value
          else:
            if((self.labelXAlignmentVertical_resid == value) or (not self.labelXShow_resid)):
              redraw = False
            self.labelXAlignmentVertical_resid = value
        elif(axis == 'y'):
          if(target == 'plot'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.labelYAlignmentVertical == value) or (not self.labelYShow)):
              redraw = False
            self.labelYAlignmentVertical = value
          else:
            if((self.labelYAlignmentVertical_resid == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelYAlignmentVertical_resid = value
          axisobject.yaxis.label.set_verticalalignment(value)
          axisobject2.yaxis.label.set_verticalalignment(value)
          direction = 'vertical'
        elif(axis == 'y2'):
          if(target == 'plot'):
            axisobject.yaxis.label.set_verticalalignment(value)
            axisobject2.yaxis.label.set_verticalalignment(value)
            direction = 'vertical'
            if((self.labelY2AlignmentVertical == value) or (not self.labelY2Show)):
              redraw = False
            self.labelY2AlignmentVertical = value
          else:
            axis = 'abort'

        # remember settings
        if(axis != 'abort'):
          self.rememberSetting[axisname + '_axisAlignmentVertical' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + direction + 'alignment(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()
          
  def setTickFont(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether font exists
    safeFont = 'DejaVu Sans'
    if(not (value in self.parent.fontNames)):
      value = safeFont
    if(value in self.parent.fontNames):
      # check whether to operate on data or resid plot
      if(target in ['plot', 'resid']):
        if(axis in ['x', 'y', 'y2']):
          if(target == 'plot'):
            prevFont = self.tickFont[axis]
            plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
            if(axis == 'y'):
              axisobject = self.ax; axisname = 'ax'
            if(self.tickFont[axis] == value):
              redraw = False
            self.tickFont[axis] = value
          else:
            prevFont = self.tickFont_resid[axis]
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.tickFont_resid[axis] == value):
              redraw = False
            self.tickFont_resid[axis] = value
        
          # updates tick font
          if(axis == 'x'):
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if(target == 'plot'):
              tickLabels = axisobject.get_yticklabels(which='both')
              tickLabels.append(axisobject.yaxis.get_offset_text())
              tickLabels.extend(axisobject2.get_yticklabels(which='both'))
              tickLabels.append(axisobject2.yaxis.get_offset_text())
            else:
              axis = 'abort'
          
          if(axis != 'abort'):
            useFont = value
            # try setting font value
            for entry in tickLabels:
              entry.set_fontname(useFont)
              _, _, descent = entry._get_layout(self.matplot.canvas.renderer)
              if(not (descent > 0)):
                self.parent.statusbar.showMessage('Experiencing problems setting font ' + useFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
                useFont = prevFont
                entry.set_fontname(useFont)
                _, _, descent = entry._get_layout(self.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Also experiencing problems setting font ' + useFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                  useFont = safeFont
                  entry.set_fontname(useFont)
  
            # save actual font value
            if(target == 'plot'):
              self.tickFont[axis] = useFont
            else:
              self.tickFont_resid[axis] = useFont
            
            # have to capture errors in case a strange font is set
            # retain this as 2nd-layer control
            try:
              if(redraw):
                plotobject.myRefresh()
            except:
              self.parent.statusbar.showMessage('Experiencing problems setting font ' + useFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
              
              # revert to previous font
              useFont = prevFont
              if(target == 'plot'):
                self.tickFont[axis] = prevFont
              else:
                self.tickFont_resid[axis] = prevFont
                
              for entry in tickLabels:
                entry.set_fontname(prevFont)
  
              # also capture errors with previous font (can happen if selecting two bad fonts in a row)
              try:
                if(redraw):
                  plotobject.myRefresh()
              except:
                self.parent.statusbar.showMessage('Also experiencing problems setting font ' + useFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
  
                # revert to previous font
                value = safeFont
                if(target == 'plot'):
                  self.tickFont[axis] = safeFont
                else:
                  self.tickFont_resid[axis] = safeFont
  
                for entry in tickLabels:
                  entry.set_fontname(safeFont)
  
            # remember settings
            self.rememberSetting[axisname + '_axisTickFont' + axis] = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels()\n'
            self.rememberSetting[axisname + '_axisTickFont' + axis] += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
            self.rememberSetting[axisname + '_axisTickFont' + axis] += 'for entry in tickLabels:\n\tentry.set_fontname(' + repr(value) + ')\n'

  def setMinorTick(self, value=2, axis='x', redraw=True, target='plot'):
    # changes number of minor tick marks (on linear axes)
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2', 'x2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisname = 'ax2'
          if(axis == 'x'):
            if(self.ticksXMinor == value):
              redraw = False
            self.ticksXMinor = value
          elif(axis == 'x2'):
            axisobject = self.ax2_div
            if(self.ticksXMinor_div == value):
              redraw = False
            self.ticksXMinor_div = value
          elif(axis == 'y'):
            axisobject = self.ax; axisname = 'ax'
            if(self.ticksYMinor == value):
              redraw = False
            self.ticksYMinor = value
          else:
            if(self.ticksY2Minor == value):
              redraw = False
            self.ticksY2Minor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisname = 'ax_resid'
          if(axis == 'y'):
            if(self.ticksResidYMinor == value):
              redraw = False
            self.ticksResidYMinor = value
          elif(axis == 'x2'):
            axisobject = self.ax_resid_div
            
        # remember settings
        if(axis != 'abort'):
          minorAutoticks = MyAutoMinorLocator(value)
          if(axis in ['x', 'x2']):
            axisobject.xaxis.set_minor_locator(minorAutoticks)
            axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            axisobject.yaxis.set_minor_locator(minorAutoticks)
            axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          if(axis != 'x2'):
            self.rememberSetting[axisname + '_minorTicks' + axis] = 'minorAutoticks = matplotlib.ticker.AutoMinorLocator(' + repr(value) + ')\n'
            self.rememberSetting[axisname + '_minorTicks' + axis] += axisname + '.' + axis[:1] + 'axis.set_minor_locator(minorAutoticks)\n'
        elif(axis != 'x2'):
          # undo setting if log axes
          self.rememberSetting[axisname + '_minorTicks' + axis] = ''

        # redraw?
        if(axis != 'abort') :
          if(redraw):
            plotobject.myRefresh()

  def setAxisStyle(self, value='solid', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisStyle[axis] == value):
            redraw = False
          self.axisStyle[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisStyle_resid[axis] == value):
              redraw = False
            self.axisStyle_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_linestyle(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_linestyle(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisStyle' + axis] = axisname + '.spines[' + repr(axis) + '].set_linestyle(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisDashStyle(self, value='solid', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisDashStyle[axis] == value):
            redraw = False
          self.axisDashStyle[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisDashStyle_resid[axis] == value):
              redraw = False
            self.axisDashStyle_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_capstyle(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_capstyle(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisDashStyle' + axis] = axisname + '.spines[' + repr(axis) + '].set_capstyle(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def resetAxisPosition(self, axis='left', redraw=True):
    # resets axis position to original values
    originalPosition = {'left':('axes', 0), 'right':('axes', 1.0), 'bottom':('axes', 0), 'top':('axes', 1.0), 'left2':('axes', 0), 'right2':('axes', 1.0)}
    if(axis in originalPosition):
      # check whether to do anything
      if((originalPosition[axis][0] != self.axisPosition[axis]) or (originalPosition[axis][1] != self.axisPositionValue[axis])):
        for target in ['plot', 'resid']:
          self.setAxisPosition(value=originalPosition[axis][0], axis=axis, redraw=False, target=target)
          self.setAxisPositionValue(value=originalPosition[axis][1], axis=axis, redraw=False, target=target)
        # refresh plots
        if(redraw):
          self.dataplotwidget.myRefresh()
          self.residplotwidget.myRefresh()

  def setAxisBoundaryValue(self, value=0.0, lower=True, axis='left', redraw=True, target='plot'):
    # changes limits on the axes
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(lower):
          index = 0
        else:
          index = 1
        if(target == 'plot'):
          if(self.axisBoundary[axis][index] == value):
            redraw = False
          self.axisBoundary[axis][index] = value
        else:
          if(self.axisBoundary_resid[axis][index] == value):
            redraw = False
          self.axisBoundary_resid[axis][index] = value
        
        self.setAxisBoundaryHelper(axis=axis, redraw=redraw, target=target)

  def setAxisBoundary(self, value=False, axis='left', redraw=True, target='plot'):
    # sets limits on the axes
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          if(self.axisBoundaryCheck[axis] == value):
            redraw = False
          self.axisBoundaryCheck[axis] = value
        else:
          if(self.axisBoundaryCheck_resid[axis] == value):
            redraw = False
          self.axisBoundaryCheck_resid[axis] = value
        
        self.setAxisBoundaryHelper(axis=axis, redraw=redraw, target=target)

  def setAxisBoundaryHelper(self, axis='left', redraw=True, target='plot'):
    # helper function for setting axis boundaries
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        secondAxes = False
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
            secondAxes = True
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
        
        if(axis != 'abort'):
          if(secondAxes):
            useAxis = axis + '2'
          else:
            useAxis = axis
          if(self.axisBoundaryCheck[useAxis]):
            lower, upper = self.axisBoundary[useAxis]
            for useobject in [axisobject, axisobject2]:
              if(axis in useobject.spines):
                useobject.spines[axis].set_bounds(lower, upper)
          else:
            for useobject in [axisobject, axisobject2]:
              if(axis in useobject.spines):
                useobject.spines[axis]._bounds = None

          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisPosition(self, value='axes', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        secondAxes = False
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisPosition[axis] == value):
            redraw = False
          self.axisPosition[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
            secondAxes = True
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisPosition_resid[axis] == value):
              redraw = False
            self.axisPosition_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            value = self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=secondAxes)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=secondAxes, splitX=True)
            # remember settings
            self.rememberSetting[axisname + '_axisPosition' + axis] = axisname + '.spines[' + repr(axis) + '].set_position(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisPositionValue(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        secondAxes = False
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisPositionValue[axis] == value):
            redraw = False
          self.axisPositionValue[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
            secondAxes = True
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisPositionValue_resid[axis] == value):
              redraw = False
            self.axisPositionValue_resid[axis] = value

        # updates axis width
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            value = self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=secondAxes)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=secondAxes, splitX=True)
            # remember settings
            self.rememberSetting[axisname + '_axisPosition' + axis] = axisname + '.spines[' + repr(axis) + '].set_position(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisPositionHelper(self, axis, plotobject, axisobject, target, secondAxes=False, splitX=False, splitY=False):
    # called by setAxisPosition
    # duh, this is ugly!
    # the following call breaks the connection b/w spine and axis and thus disables detrimental updates to ticks and labels
    saveAxis = axisobject.spines[axis].axis
    axisobject.spines[axis].axis = None
    # assign useModeX and transAxisobject1/2
    if(splitX):
      useModeX, useMinX, transAxisobject1, transAxisobject2  = self.modeX_div, self.minX_div, self.ax_div, self.ax2_div
      ##useModeX, useMinX, transAxisobject1, transAxisobject2  = self.modeX_div, self.minX_div, self.ax, self.ax2
      transAxisobjectResid = self.ax_resid_div
    else:
      useModeX, useMinX, transAxisobject1, transAxisobject2 = self.modeX, self.minX, self.ax, self.ax2
      transAxisobjectResid = self.ax_resid
    #
    if(secondAxes):
      if((self.axisPosition[axis + '2'] == 'data') and (useModeX == 'log')):
        # matplotlib somehow screws up for log data (a bug I discovered!) => map to plot axes
        try:
          # have to do this b/c matplotlib.scale on Linux is buggy
          axis_to_data = transAxisobject1.transAxes + transAxisobject1.transData.inverted()
          point_on_data = (self.axisPositionValue[axis + '2'], self.minY)
          point_on_axes = axis_to_data.inverted().transform(point_on_data)
          assembledValue = ('axes', point_on_axes[0])
        except:
          assembledValue = ('outward', 0.0)
      else:
        assembledValue = (self.axisPosition[axis + '2'], self.axisPositionValue[axis + '2'])
    elif(target == 'plot'):
      if(axis in ['top', 'bottom']):
        # argh -- top and bottom are on self.ax2, meaning they are linked to the second axes
        # => we hence need to convert data values from one axis to the other
        if(self.axisPosition[axis] == 'data'):
          if(self.splitY):
            assembledValue = ('data', self.axisPositionValue[axis])
          else:
            try:
              # have to do this b/c matplotlib.scale on Linux is buggy
              axis_to_data1 = transAxisobject1.transAxes + transAxisobject1.transData.inverted()
              axis_to_data2 = transAxisobject2.transAxes + transAxisobject2.transData.inverted()
              point_on_data1 = (useMinX, self.axisPositionValue[axis])
              # map to axes
              point_on_axes = axis_to_data1.inverted().transform(point_on_data1)
              assembledValue = ('axes', point_on_axes[1])
            except:
              assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      else:
        if((self.axisPosition[axis] == 'data') and (useModeX == 'log')):
          # matplotlib somehow screws up for log data (a bug I discovered!) => map to plot axes
          try:
            # have to do this b/c matplotlib.scale on Linux is buggy
            axis_to_data2 = transAxisobject2.transAxes + transAxisobject2.transData.inverted()
            point_on_data2 = (self.axisPositionValue[axis], self.minY2)
            point_on_axes = axis_to_data2.inverted().transform(point_on_data2)
            assembledValue = ('axes', point_on_axes[0])
          except:
            assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
    else:
      # the resid plot
      if(axis in ['left', 'right']):
        if((self.axisPosition[axis] == 'data') and (useModeX == 'log')):
          # deal with matplotlib error => map to plot axes
          try:
            # have to do this b/c matplotlib.scale on Linux is buggy
            axis_to_data = transAxisobjectResid.transAxes + transAxisobjectResid.transData.inverted()
            point_on_data = (self.axisPositionValue[axis], self.minResidY)
            point_on_axes = axis_to_data.inverted().transform(point_on_data)
            assembledValue = ('axes', point_on_axes[0])
          except:
            assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      else:
        assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      
    # set the new axis mode and value
    axisobject.spines[axis].set_position(assembledValue)

    # for good measure restore axis setting
    axisobject.spines[axis].axis = saveAxis
    
    # now we have to manually update the position of the tick labels and ticks
    if(axis in ['left', 'right']):
      ticks = axisobject.yaxis.get_major_ticks()
      ticks.extend(axisobject.yaxis.get_minor_ticks())
      if(axis == 'left'):
        useTransform = axisobject.get_yaxis_transform(which='tick1')
        tick1 = True
      else:
        useTransform = axisobject.get_yaxis_transform(which='tick2')
        tick1 = False
    else:
      ticks = axisobject.xaxis.get_major_ticks()
      ticks.extend(axisobject.xaxis.get_minor_ticks())
      if(axis == 'bottom'):
        useTransform = axisobject.get_xaxis_transform(which='tick1')
        tick1 = True
      else:
        useTransform = axisobject.get_xaxis_transform(which='tick2')
        tick1 = False

    horizontal = True        
    if(target == 'plot'):
      plotobject = self.matplot
      if(axis in ['left', 'right']):
        usePad = self.ticksYPad2
        horizontal = False
        if(secondAxes):
          usePad = self.ticksY2Pad2
      elif(axis in ['bottom', 'top']):
        usePad = self.ticksXPad2
    else:
      plotobject = self.residplot
      if(axis in ['left', 'right']):
        usePad = self.ticksYPad2_resid
        horizontal = False
      else:
        usePad = self.ticksXPad2_resid

    for entry in ticks:
      if(tick1):
        entry.tick1line.set_transform(useTransform)
        trans, vert, horiz = entry._get_text1_transform()
        # also have to apply pad2 padding - phew!
        if(horizontal):
          offset = matplotlib.transforms.ScaledTranslation(usePad / 72.0, 0.0, plotobject.dpi_scale_trans)
        else:
          offset = matplotlib.transforms.ScaledTranslation(0.0, usePad / 72.0, plotobject.dpi_scale_trans)
        trans += offset
        entry.label1.set_transform(trans)
      else:
        entry.tick2line.set_transform(useTransform)
        trans, vert, horiz = entry._get_text2_transform()
        # also have to apply pad2 padding - phew!
        if(horizontal):
          offset = matplotlib.transforms.ScaledTranslation(usePad / 72.0, 0, plotobject.dpi_scale_trans)
        else:
          offset = matplotlib.transforms.ScaledTranslation(0, usePad / 72.0, plotobject.dpi_scale_trans)
        trans += offset
        entry.label2.set_transform(trans)

    return repr(assembledValue)

  def setAutoScale(self, axis='x'):
    # updates autoscale options for axes
    if(axis in ['x', 'y', 'y2', 'x2']):
      if(axis == 'x'):
        state = self.autoScaleCheckX.isChecked()
        self.autoScaleX = state
      elif(axis == 'x2'):
        state = self.xSplitAutoScaleCheckX.isChecked()
        self.autoScaleX_div = state
      elif(axis == 'y'):
        state = self.autoScaleCheckY.isChecked()
        self.autoScaleY = state
      else:
        state = self.secondAutoScaleCheckY.isChecked()
        self.autoScaleY2 = state
        
      # rescale contents on setting auto to True
      if(state):
        self.doAutoScale(axis=axis, redraw=True)
        
  def doAutoScale(self, axis='x', redraw=True):
    # performs autoscale on axis
    if(axis in ['x', 'y', 'y2', 'x2', 'resid']):
      currData, currRoles = self.parent.data[self.parent.activeData].getData_n_Fit()
      # we have some data that we could zoom to
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useModeX = self.modeX
        else:
          useModeX = self.modeX_div
        if(('x' in currRoles) and (len(list(currData[:, currRoles.index('x')])))):
          xval = list(currData[:, currRoles.index('x')])
          if('xerr' in currRoles):
            xerr = list(currData[:, currRoles.index('xerr')])
            temp_xmin = np.min([i - j for i, j in zip(xval, xerr)])
            temp_xmax = np.max([i + j for i, j in zip(xval, xerr)])
          else:
            temp_xmin = np.min(xval)
            temp_xmax = np.max(xval)

          # check for split x axis
          if(self.splitShow):
            if(axis == 'x'):
              temp_xmax = np.min((temp_xmax, self.maxX_div, self.minX_div))
            else:
              temp_xmin = np.max((temp_xmin, self.maxX, self.minX))
            
          # ensure minimum limit
          if(temp_xmax - temp_xmin < self.EPSILON):
            temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useModeX == 'linear'):
              difference = temp_xmax - temp_xmin
              if((not self.splitShow) or (axis == 'x2')):
                temp_xmax += difference * self.data_spacer
              if((not self.splitShow) or (axis == 'x')):
                temp_xmin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_x = np.array(xval)
              pos_x = pos_x[pos_x > 0]
              pos_x = np.array([i for i in pos_x if ((not np.isnan(i)) and (not np.isinf(i)))])
              if(len(pos_x > 1)):
                # recalc. xmin to address error when restoring state
                temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                if(self.splitShow and (axis == 'x2') and (np.max((self.minX, self.maxX)) > 0)):
                  posLimits = [i for i  in [self.minX, self.maxX] if (i > 0)]
                  temp_xmin = np.max((temp_xmin, np.max(posLimits)))
                if(self.splitShow and (axis == 'x') and (np.max((self.minX_div, self.maxX_div)) > 0)):
                  posLimits = [i for i  in [self.minX_div, self.maxX_div] if (i > 0)]
                  temp_xmax = np.min((temp_xmax, np.min(posLimits)))
                difference = np.log(pos_x[-1] / pos_x[0])
                if((not self.splitShow) or (axis == 'x')):
                  temp_xmin = np.exp(np.log(temp_xmin) - self.data_spacer * difference)
                if((not self.splitShow) or (axis == 'x2')):
                  temp_xmax = np.exp(np.log(temp_xmax) + self.data_spacer * difference)
          
          if(axis == 'x'):
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            # plot current function over new x-range
            self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
              redraw=False)
            # copy in case split axes are shown
            curve = self.parent.fit[self.parent.activeFit]
            if(self.parent.plotArea.splitY and curve.onBothAxes):
              curve.duplicateForSplit()
            self.parent.plotArea.dataplotwidget.myRefresh()
            # plot zeroResid line over new x-range
            self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(\
              handleResidZero=self.parent.plotArea.handleResidZero, redraw=redraw)
          else:
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            # plot current function over new x-range
            self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
              redraw=False, splitX=True)
            # copy in case split axes are shown
            curve = self.parent.fit[self.parent.activeFit]
            if(self.parent.plotArea.splitY and curve.onBothAxes):
              curve.duplicateForSplit()
            self.parent.plotArea.dataplotwidget.myRefresh()
            # plot zeroResid line over new x-range
            self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(\
              handleResidZero=self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=True)
          # update tick entry fields
          self.updateTickEntryField(axis=axis)
      elif(axis in ['y', 'y2']):
        dataAxesFlag = self.parent.data[self.parent.activeData].onSecondAxes or self.parent.data[self.parent.activeData].onBothAxes
        # only consider active function and data if on current y axis
        if(axis == 'y'):
          if(self.splitShow):
            funcY = np.hstack((self.y, self.y_div))
          else:
            funcY = self.y
          dataAxesFlag = (not self.parent.data[self.parent.activeData].onSecondAxes) or self.parent.data[self.parent.activeData].onBothAxes
        else:
          if(self.splitShow):
            funcY = np.hstack((self.y2, self.y2_div))
          else:
            funcY = self.y2
        if(self.splitY and self.parent.fit[self.parent.activeFit].onBothAxes):
          if(self.splitShow):
            funcY = np.hstack((self.y, self.y_div, self.y2, self.y2_div))
          else:
            funcY = np.hstack((self.y, self.y2))
        # check whether curve is visible at all
        if(not self.parent.fit[self.parent.activeFit].visibility):
          funcY = []
        # consider data (and only if it is visible)
        if(('y' in currRoles) and (len(list(currData[:, currRoles.index('y')]))) and dataAxesFlag and self.parent.data[self.parent.activeData].visibility):
          yval = list(currData[:, currRoles.index('y')])
          if(len(yval)):
            if('yerr' in currRoles):
              yerr = list(currData[:, currRoles.index('yerr')])
              temp_y = np.array([i - j for i, j in zip(yval, yerr)])
              temp_y = np.hstack((temp_y, np.array([i + j for i, j in zip(yval, yerr)])))
            else:
              temp_y = yval
            temp_y = np.hstack((funcY, temp_y))
          else:
            temp_y = funcY
        else:
          temp_y = funcY
          
        temp_y = np.array([i for i in temp_y if ((not np.isnan(i)) and (not np.isinf(i)))])
        # ensure that temp_y is at least one element long
        if(temp_y.size):
          temp_ymin = np.min(temp_y)
          temp_ymax = np.max(temp_y)
          
          # check for split y axis
          if(self.splitY):
            if(axis == 'y'):
              temp_ymin = np.max((temp_ymin, self.maxY2, self.minY2))
            else:
              temp_ymax = np.min((temp_ymax, self.maxY, self.minY))
  
          # ensure minimum limit
          if (temp_ymax - temp_ymin < self.EPSILON):
            temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(axis == 'y'):
              useMode = self.modeY
            else:
              useMode = self.modeY2
            if(useMode == 'linear'):
              difference = temp_ymax - temp_ymin
              if((not self.splitY) or (axis == 'y')):
                temp_ymax += difference * self.data_spacer
              if((not self.splitY) or (axis == 'y2')):
                temp_ymin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_y = np.array(temp_y)
              pos_y = pos_y[pos_y > 0]
              if(len(pos_y > 1)):
                temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                if(self.splitY and (axis == 'y') and (np.max((self.minY2, self.maxY2)) > 0)):
                  posLimits = [i for i  in [self.minY2, self.maxY2] if (i > 0)]
                  temp_ymin = np.max((temp_ymin, np.max(posLimits)))
                if(self.splitY and (axis == 'y2') and (np.max((self.minY, self.maxY)) > 0)):
                  posLimits = [i for i  in [self.minY, self.maxY] if (i > 0)]
                  temp_ymax = np.min((temp_ymax, np.min(posLimits)))
                difference = np.log(temp_ymax / temp_ymin)
                if((not self.splitY) or (axis == 'y2')):
                  temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
                if((not self.splitY) or (axis == 'y')):
                  temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)
          
          self.setAxisLimits(lower = temp_ymin, upper = temp_ymax, axis = axis, updateLabel = True, target='plot', redraw=redraw, updateGrid=True)
          # update tick entry fields
          self.updateTickEntryField(axis=axis)
      else:
        # consider data (and only if it is visible)
        if(('resid' in currRoles) and (len(list(currData[:, currRoles.index('resid')]))) and self.parent.data[self.parent.activeData].visibilityResid):
          resid = list(currData[:, currRoles.index('resid')])
          if(len(resid)):
            resid = np.array([i for i in resid if ((not np.isnan(i)) and (not np.isinf(i)))])
            # ensure that temp_y is at least one element long
            if(resid.size):
              temp_residmin = np.min(resid)
              temp_residmax = np.max(resid)
      
              # ensure minimum limit
              if (temp_residmax - temp_residmin < self.EPSILON):
                temp_residmax += self.EPSILON; temp_residmin -= self.EPSILON
              else:
                # this needs to correspond to the setting in doFit()
                usespacer = 1.2
                temp_residmax *= usespacer
                temp_residmin *= usespacer
              # ensure symmetric limits
              uselimit = np.max((np.abs(temp_residmax), np.abs(temp_residmin)))
              temp_residmin, temp_residmax = -1. * uselimit, 1. * uselimit
              
              self.setAxisLimits(lower=temp_residmin, upper=temp_residmax, axis='y', updateLabel=True, target='resid', redraw=redraw, updateGrid=True)
              # update tick entry fields
              self.updateTickEntryField(axis='resid')

  def flipAxis(self, axis='x', redraw=True):
    # swaps upper and lower limit of axis
    if(axis in ['x', 'x2', 'y', 'y2']):
      if(axis == 'x'):
        self.minX, self.maxX = self.maxX, self.minX
        # better to swap actual text and thus avoid reformatting of entered text (avoids rounding issues)
        lowerText, upperText = self.lowerLimitx.text(), self.upperLimitx.text()
        self.upperLimitx.setText(lowerText)
        self.lowerLimitx.setText(upperText)
        # update axis
        self.ax2.set_xlim([self.minX, self.maxX])
        self.ax_resid.set_xlim([self.minX, self.maxX])
        updateResid = True
      elif(axis == 'x2'):
        self.minX_div, self.maxX_div = self.maxX_div, self.minX_div
        # better to swap actual text and thus avoid reformatting of entered text (avoids rounding issues)
        lowerText, upperText = self.xSplitLowerLimitx.text(), self.xSplitUpperLimitx.text()
        self.xSplitUpperLimitx.setText(lowerText)
        self.xSplitLowerLimitx.setText(upperText)
        # update axis
        self.ax2_div.set_xlim([self.minX_div, self.maxX_div])
        self.ax_div.set_xlim([self.minX_div, self.maxX_div])
        self.ax_resid_div.set_xlim([self.minX_div, self.maxX_div])
        updateResid = True
      elif(axis == 'y'):
        self.minY, self.maxY = self.maxY, self.minY
        # better to swap actual text and thus avoid reformatting of entered text (avoids rounding issues)
        lowerText, upperText = self.lowerLimity.text(), self.upperLimity.text()
        self.upperLimity.setText(lowerText)
        self.lowerLimity.setText(upperText)
        # update axis
        self.ax.set_ylim([self.minY, self.maxY])
        updateResid = False
      else:
        self.minY2, self.maxY2 = self.maxY2, self.minY2
        # better to swap actual text and thus avoid reformatting of entered text (avoids rounding issues)
        lowerText, upperText = self.secondLowerLimit.text(), self.secondUpperLimit.text()
        self.secondUpperLimit.setText(lowerText)
        self.secondLowerLimit.setText(upperText)
        # update axis
        self.ax2.set_ylim([self.minY2, self.maxY2])
        updateResid = False
        
      # refresh the plot(s)
      if(redraw):
        self.dataplotwidget.myRefresh()
        if(updateResid):
          self.residplotwidget.myRefresh()

  def lassoSelectorCallback(self, vertices):
    # call back for lasso selector function
    if(self.pick2Freehand or (self.pickedMode == 3)):
      self.pick2Freehand = False
      # this indicates that we want to draw a freehand shape
      if(self.thisLasso != None):
        self.thisLasso.line.set_color([0.2, 0.15, 0.9, 1.0])
        self.thisLasso = None
      # generate a new extras object
      self.parent.extras.append(ExtrasObject(self.parent))
      valueDict = {'labeltext': 'Freehand', 'extrasType': 'shape', 'shape__type': 'freehand', 'shape__vertices': vertices, 'shape__doFill': False}
      self.parent.extras[-1].setValues(valueDict, redraw=True)
      # deal with duplication and update of menus
      if(self.splitY):
        self.parent.extras[-1].onBothAxes = True
        self.parent.extras[-1].duplicateForSplit()
      # update extras table
      self.parent.objectsarea.refreshExtrasTable()
      self.parent.objectsarea.refreshCurvesTable()
      self.parent.objectsarea.refreshDataTable()
    else:
      modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
      if(modifiers & QtCore.Qt.ShiftModifier):
        lassoPath = matplotlib.path.Path(vertices)
        values, roles = self.parent.data[self.parent.activeData].getData_n_Fit()
        if(('x' in roles) and ('y' in roles) and len(values[roles.index('x')])):
          xyData = [(x, y) for x, y in zip(values[:, roles.index('x')], values[:, roles.index('y')])]
          if(len(xyData)):
            selectData = lassoPath.contains_points(xyData)
            self.parent.selectedData.mouseSelectIndices(selectData)
          
      # hide the lasso(s)
      for lasso in [self.lassoSelector, self.lassoSelector_div, self.lassoSelector2, self.lassoSelector2_div]:
        lasso.line.set_visible(False)
        if(hasattr(lasso, 'update')):
          lasso.update()

  def rectSelectorCallback(self, event_click, event_release):
    # handles interactive zoom in plot
    MIN_SELECTION_BOX = 5
    flag, restore = False, False
    # determine which axis we are on
    inaxes = event_click.inaxes
    if(inaxes == self.ax):
      divAxis, useSelector = False, self.rectSelector
    elif(inaxes == self.ax_div):
      divAxis, useSelector = True, self.rectSelector_div
    elif(inaxes == self.ax2):
      divAxis, useSelector = False, self.rectSelector2
    else:
      divAxis, useSelector = True, self.rectSelector2_div
    # handle button reactions
    if(event_click.button == 1):
      # check whether rectangle selector is active at all
      if(useSelector.visible):
        # check wether selection box is at least minimum size
        if((np.abs(event_click.x - event_release.x) >= MIN_SELECTION_BOX) and (np.abs(event_click.y - event_release.y) >= MIN_SELECTION_BOX)):
          # left mouse button => zoom
          # only proceed if at least one coord changed since last click (this is to prevent rectangle selector from misbehainvg)
          if((event_click.x != self.previousClick[0]) or (event_click.y != self.previousClick[1]) or (event_release.x != self.previousClick[2]) or (event_release.y != self.previousClick[3])):
            x1, y1 = event_click.xdata, event_click.ydata
            x2, y2 = event_release.xdata, event_release.ydata
            if(divAxis):
              xmin_div = np.min((x1, x2)); xmax_div = np.max((x1, x2))
            else:
              xmin = np.min((x1, x2)); xmax = np.max((x1, x2))
            ymin = np.min((y1, y2)); ymax = np.max((y1, y2))
            
            # transform coordinates to second y axis
            # as main and split plot share y axis, we don't need to discriminate here
            if(self.splitY and (inaxes in [self.ax, self.ax_div])):
              secondYmin, secondYmax = self.minY2, self.maxY2
            else:
              secondY1 = self.ax2.transData.inverted().transform((event_click.x, event_click.y))
              secondY2 = self.ax2.transData.inverted().transform((event_release.x, event_release.y))
              secondYmin = np.min((secondY1[1], secondY2[1])); secondYmax = np.max((secondY1[1], secondY2[1]))
              if(self.splitY):
                ymin, ymax = self.minY, self.maxY
            
            # store current axis limits
            self.storeCoord.extend((self.minX, self.maxX, self.minY, self.maxY, self.minX_div, self.maxX_div, self.minY2, self.maxY2))
            flag = True
            
            # update self.previousClick
            self.previousClick = [event_click.x, event_click.y, event_release.x, event_release.y]
    elif(event_click.button == 3):
      # update self.previousClick
      self.previousClick = [event_click.x, event_click.y, event_release.x, event_release.y]
      # right mouse button => unzoom
      if(len(self.storeCoord) > 0):
        [xmin, xmax, ymin, ymax, xmin_div, xmax_div, secondYmin, secondYmax] = self.storeCoord[-8:]
        self.storeCoord = self.storeCoord[:-8]
        flag, restore = True, True
        
    # set axes limits if required
    if(flag):
      if(divAxis or restore):
        # only change the x axis when really required
        if((xmin_div != self.minX_div) or (xmax_div != self.maxX_div)):
          self.setAxisLimits(lower=xmin_div, upper=xmax_div, axis='x2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
          self.setAxisLimits(lower=xmin_div, upper=xmax_div, axis='x2', updateLabel=False, target='resid', redraw=False, updateGrid=True)
          self.updateTickEntryField(axis='x2')
      if(not divAxis or restore):
        # only change the x axis when really required
        if((xmin != self.minX) or (xmax != self.maxX)):
          self.setAxisLimits(lower=xmin, upper=xmax, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
          self.setAxisLimits(lower=xmin, upper=xmax, axis='x', updateLabel=False, target='resid', redraw=False, updateGrid=True)
          self.updateTickEntryField(axis='x')
      # trigger redrawing of fit function with new axis limits
      if(divAxis or restore):
        self.parent.fit[self.parent.activeFit].handlePlot_div = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                       handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True, doAutoZoom=False)
        # copy in case split axes are shown
        curve = self.parent.fit[self.parent.activeFit]
        if(self.parent.plotArea.splitY and curve.onBothAxes):
          curve.duplicateForSplit()
        self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, redraw=not restore, splitX=True)
      if(not divAxis or restore):
        self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                       handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=False, doAutoZoom=False)
        # copy in case split axes are shown
        curve = self.parent.fit[self.parent.activeFit]
        if(self.parent.plotArea.splitY and curve.onBothAxes):
          curve.duplicateForSplit()
        self.handleResidZero = self.plotResidZero(self.handleResidZero, redraw=True)

      # hide rectangle selector prior to redraw
      useSelector.eventpress = None
      useSelector.eventrelease = None
      useSelector.to_draw.set_visible(False)
 
      # reset y axis
      self.setAxisLimits(lower=secondYmin, upper=secondYmax, axis='y2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower=ymin, upper=ymax, axis='y', updateLabel=True, target='plot', redraw=True, updateGrid=True)
      self.updateTickEntryField(axis='y')
      self.updateTickEntryField(axis='y2')

  def setPathStroke(self, state=True, redraw=True):
    # applies path stroke
    self.applyPathStroke = state
    self.setPathEffects(redraw=redraw)

  def setPathStrokeColor(self, value=4*[0.0], redraw=True):
    # changes color of path stroke
    self.pathStrokeColor = value
    # do the path setting draw?
    if((redraw) and (self.applyPathStroke)):
      self.setPathEffects(redraw=redraw)

  def setPathStrokeWidth(self, value=1.0, redraw=True):
    # changes witdth of path stroke
    self.pathStrokeWidth = value
    # do the path setting draw?
    if((redraw) and (self.applyPathStroke)):
      self.setPathEffects(redraw=redraw)

  def setPathShadow(self, state=True, redraw=True):
    # applies path shadow
    self.applyPathShadow = state
    self.setPathEffects(redraw=redraw)

  def setPathShadowColor(self, value=4*[0.0], redraw=True):
    # changes color of path shadow
    self.pathShadowColor = value
    self.pathShadowAlpha = value[-1]
    # do the path setting draw?
    if((redraw) and (self.applyPathShadow)):
      self.setPathEffects(redraw=redraw)

  def setPathShadowOffset(self, value=1.0, direction='x', redraw=True):
    # changes offset of path shadow
    if(direction in ['x', 'y']):
      if(direction == 'x'):
        self.pathShadowX = value
      else:
        self.pathShadowY = value
      # do the path setting draw?
      if((redraw) and (self.applyPathShadow)):
        self.setPathEffects(redraw=redraw)

  def setPathEffects(self, redraw=True):
    # applies path effects
    if(self.applyPathStroke):
      baseEffect = []
      tempRememberSetting = ''
    else:
      baseEffect = [PathEffects.Normal()]
      tempRememberSetting = 'PathEffects.Normal()'

    if(self.applyPathShadow):
      pathShadowX = self.pathShadowX
      pathShadowY = self.pathShadowY
      pathShadowColor = self.pathShadowColor
      pathShadowAlpha = self.pathShadowAlpha
      baseEffect = [PathEffects.SimpleLineShadow(offset=(pathShadowX, pathShadowY), shadow_color=pathShadowColor,\
        alpha=pathShadowAlpha)] + baseEffect
      tempRememberSetting2 = 'PathEffects.SimpleLineShadow(offset=(' + repr(pathShadowX) + ',' + repr(pathShadowY) + '), shadow_color=' +\
        repr(pathShadowColor) + ', alpha=' + repr(pathShadowAlpha) +')'
      baseEffectText = [PathEffects.SimplePatchShadow(offset=(pathShadowX, pathShadowY), shadow_rgbFace=pathShadowColor,\
        alpha=pathShadowAlpha)] + baseEffect

      if(len(tempRememberSetting)):
        tempRememberSetting += ',\n\t' + tempRememberSetting2
      else:
        tempRememberSetting = tempRememberSetting2
    else:
      baseEffectText = baseEffect
    
    # deal with existing objects
    if(self.applyPathStroke):
      pathStrokeWidth = self.pathStrokeWidth
      pathStrokeColor = self.pathStrokeColor

      # modify existing extras
      for entry in self.parent.extras:
        relevantHandles = [entry.handle, entry.handle_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handle', 'handle_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleExtra in relevantHandles:
          if(handleExtra != None):
            if(hasattr(handleExtra, 'get_lw')):
              curr_linewidth = 2 * pathStrokeWidth + handleExtra.get_lw()
            else:
              curr_linewidth = 2 * pathStrokeWidth + 1
            # check whether we have a label here
            if(hasattr(handleExtra, 'get_text')):
              handleExtra.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            else:
              handleExtra.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            # set bbox if present
            if(hasattr(handleExtra, 'get_bbox_patch')):
              handle = handleExtra.get_bbox_patch()
              if(handle != None):
                curr_linewidth = 2 * pathStrokeWidth + handle.get_lw()
                handle.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            # set arrow patch if present
            if(hasattr(handleExtra, 'arrow_patch')):
              handle = handleExtra.arrow_patch
              if(handle != None):
                curr_linewidth = 2 * pathStrokeWidth + handle.get_lw()
                handle.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # modify existing curves
      for entry in self.parent.fit:
        relevantHandles = [entry.handlePlot, entry.handlePlot_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handlePlot', 'handlePlot_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handlePlot in relevantHandles:
          if(handlePlot != None):
            curr_linewidth = 2 * pathStrokeWidth + handlePlot.get_lw()
            handlePlot.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
  
      # modify existing data sets
      for entry in self.parent.data:
        relevantHandles = [entry.handleData, entry.handleData_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleData', 'handleData_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleData in relevantHandles:
          if(handleData != None):
            curr_linewidth = 2 * pathStrokeWidth + handleData.get_lw()
            handleData.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            
        for handleResid in [entry.handleResid, entry.handleResid_div]:
          if(handleResid != None):
            curr_linewidth = 2 * pathStrokeWidth + handleResid.get_lw()
            handleResid.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

        relevantHandles = [entry.handleBar, entry.handleBar_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleBar', 'handleBar_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleBar in relevantHandles:
          if(handleBar != None):
            children = handleBar.get_children()
            for entry2 in children:
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_lw()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # don't apply to stack style, throws strange error
        #if(entry.handleStack != None):
          #entry.handleStack.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

        for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
          if(handleResidBar != None):
            children = handleResidBar.get_children()
            for entry2 in children:
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_lw()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # don't apply to stack style, throws strange error
        #if(entry.handleStack != None):
          #entry.handleStack.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

        relevantHandles = [entry.handleErr, entry.handleErr_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleErr', 'handleErr_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleErr in relevantHandles:
          if(handleErr != None):
            curr_linewidth = 2 * pathStrokeWidth + handleErr[0].get_lw()
            handleErr[0].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            for entry2 in handleErr[1]:
              # remember caps are drawn as markers not lines
              if(entry2.get_markeredgewidth() > 0):
                curr_linewidth = 2 * pathStrokeWidth + entry2.get_markeredgewidth()
                entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
              else:
                # don't draw effects for zero width markers
                #entry2.set_path_effects(baseEffect)
                # in this case don't do anything since setting path effects would cause drawing of caps (w/ currently set path effects)
                pass
            for entry2 in handleErr[2]:
              # have to use get_linewidth() here as get_lw() not implemented?!
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_linewidth()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

        # now handle violin and box plots
        relevantHandles = [entry.handleViolin, entry.handleViolin_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleViolin', 'handleViolin_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleViolin in relevantHandles:
          if(handleViolin != None):
            # bodies throws a crash when applying path effects
            validItems = ['cmins', 'cmaxes', 'cmeans', 'cmedians', 'cbars', 'boxes', 'medians', 'whiskers', 'caps', 'fliers']
            for subtarget in [i for i in handleViolin if i in validItems]:
              if(type(handleViolin[subtarget]) == type([])):
                itemList = handleViolin[subtarget]
              else:
                itemList = [handleViolin[subtarget]]
              # cycle through all items
              for item in itemList:
                if(hasattr(item, 'get_linewidth')):
                  curr_linewidth = 2 * pathStrokeWidth + item.get_linewidth()
                else:
                  curr_linewidth = 2 * pathStrokeWidth + 1.0
                if(hasattr(item, 'set_path_effects')):
                  item.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

        # now handle the text labels
        relevantHandles = [entry.handleText, entry.handleText_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleText', 'handleText_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleText in relevantHandles:
          if(handleText != None):
            for item in handleText:
              if(hasattr(item, 'get_linewidth')):
                curr_linewidth = 2 * pathStrokeWidth + item.get_linewidth()
              else:
                curr_linewidth = 2 * pathStrokeWidth + 1.0
              if(hasattr(item, 'set_path_effects')):
                item.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
       
      # modify axes
      for entry in self.ax.spines:
        if(entry in ['left', 'right']):
          curr_linewidth = 2 * pathStrokeWidth + self.ax.spines[entry].get_lw()
          self.ax.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax2.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax2.spines[entry].get_lw()
        self.ax2.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_resid.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax_resid.spines[entry].get_lw()
        self.ax_resid.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_div.spines:
        if(entry in ['left', 'right']):
          curr_linewidth = 2 * pathStrokeWidth + self.ax_div.spines[entry].get_lw()
          self.ax_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax2_div.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax2_div.spines[entry].get_lw()
        self.ax2_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_resid_div.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax_resid_div.spines[entry].get_lw()
        self.ax_resid_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # modify grid lines
      for key in self.gridLinesStore:
        if(self.gridVisible[key]):
          for entry in self.gridLinesStore[key]:
            curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        if(key in self.gridLinesStore_resid):
          for entry in self.gridLinesStore_resid[key]:
            curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            
      # modify tick lines
      #for entry in self.ax.xaxis.get_ticklines():
      #  curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
      #  entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
  
      # zero line
      for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
        if(handleResidZero != None):
          curr_linewidth = 2 * pathStrokeWidth + handleResidZero.get_lw()
          handleResidZero.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the cursor
      for cursor in [self.cursor, self.cursor_div, self.cursor2, self.cursor2_div]:
        if(cursor != None):
          handles = cursor.getHandles()
          for entry in handles:
            if(hasattr(entry, 'get_lw')):
              curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            else:
              curr_linewidth = 2 * pathStrokeWidth + 1
            # check for text
            if(hasattr(entry, 'get_text')):
              entry.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            else:
              entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the axes labels
      curr_linewidth = 2 * pathStrokeWidth + 1
      for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
        entry.xaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        entry.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      self.ax.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      self.ax_div.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the tick labels
      curr_linewidth = 2 * pathStrokeWidth + 1
      tickLabels = []
      for entry in [self.ax, self.ax_resid, self.ax2, self.ax_div, self.ax_resid_div, self.ax2_div]:
        tickLabels.extend(entry.get_xticklabels(which='both'))
        tickLabels.extend(entry.get_yticklabels(which='both'))
        tickLabels.append(entry.xaxis.get_offset_text())
        tickLabels.append(entry.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # update baseEffect for new plot items
      curr_linewidth = 2 * pathStrokeWidth + 1.0
      baseEffect.append(PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor))
      tempRememberSetting2 = 'PathEffects.withStroke(linewidth=' + repr(curr_linewidth) + ', foreground=' + repr(pathStrokeColor) +')'
      if(len(tempRememberSetting)):
        tempRememberSetting += ',\n\t' + tempRememberSetting2
      else:
        tempRememberSetting = tempRememberSetting2
    else:
      # check for complete turnoff of pathEffects for text labels
      if((not self.applyPathStroke) and (not self.applyPathShadow)):
        baseEffectText = []

      # modify existing extras
      for entry in self.parent.extras:
        relevantHandles = [entry.handle, entry.handle_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handle', 'handle_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleExtra in relevantHandles:
          if(handleExtra != None):
            # check whether we have a label here
            if(hasattr(handleExtra, 'get_text')):
              handleExtra.set_path_effects(baseEffectText)
            else:
              handleExtra.set_path_effects(baseEffect)
            # set bbox if present
            if(hasattr(handleExtra, 'get_bbox_patch')):
              handle = handleExtra.get_bbox_patch()
              if(handle != None):
                handle.set_path_effects(baseEffect)
            # set arrow patch if present
            if(hasattr(handleExtra, 'arrow_patch')):
              handle = handleExtra.arrow_patch
              if(handle != None):
                handle.set_path_effects(baseEffect)

      # modify existing curves
      for entry in self.parent.fit:
        relevantHandles = [entry.handlePlot, entry.handlePlot_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handlePlot', 'handlePlot_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handlePlot in relevantHandles:
          if(handlePlot != None):
            handlePlot.set_path_effects(baseEffect)
  
      # modify existing data sets
      for entry in self.parent.data:
        relevantHandles = [entry.handleData, entry.handleData_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleData', 'handleData_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleData in relevantHandles:
          if(handleData != None):
            handleData.set_path_effects(baseEffect)
            
        for handleResid in [entry.handleResid, entry.handleResid_div]:
          if(handleResid != None):
            handleResid.set_path_effects(baseEffect)
            
        relevantHandles = [entry.handleBar, entry.handleBar_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleBar', 'handleBar_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleBar in relevantHandles:
          if(handleBar != None):
            children = handleBar.get_children()
            for entry2 in children:
              entry2.set_path_effects(baseEffect)

        # don't apply to stack style, throws strange error
        for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
          if(handleResidBar != None):
            children = handleResidBar.get_children()
            for entry2 in children:
              entry2.set_path_effects(baseEffect)

        # don't apply to stack style, throws strange error
        relevantHandles = [entry.handleErr, entry.handleErr_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleErr', 'handleErr_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleErr in relevantHandles:
          if(handleErr != None):
            handleErr[0].set_path_effects(baseEffect)
            for entry2 in handleErr[1]:
              entry2.set_path_effects(baseEffect)
            for entry2 in handleErr[2]:
              entry2.set_path_effects(baseEffect)

        # now handle violin and box plots
        relevantHandles = [entry.handleViolin, entry.handleViolin_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleViolin', 'handleViolin_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleViolin in relevantHandles:
          if(handleViolin != None):
            # bodies throws a crash when applying path effects
            validItems = ['cmins', 'cmaxes', 'cmeans', 'cmedians', 'cbars', 'boxes', 'medians', 'whiskers', 'caps', 'fliers']
            for subtarget in [i for i in handleViolin if i in validItems]:
              if(type(handleViolin[subtarget]) == type([])):
                itemList = handleViolin[subtarget]
              else:
                itemList = [handleViolin[subtarget]]
              # cycle through all items
              for item in itemList:
                if(hasattr(item, 'set_path_effects')):
                  item.set_path_effects(baseEffect)

        # now handle the text labels
        relevantHandles = [entry.handleText, entry.handleText_div]
        if(self.splitY):
          relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleText', 'handleText_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
        for handleText in relevantHandles:
          if(handleText != None):
            for item in handleText:
              if(hasattr(item, 'set_path_effects')):
                item.set_path_effects(baseEffectText)
       
      # modify axes
      for entry in self.ax.spines:
        if(entry in ['left', 'right']):
          self.ax.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax2.spines:
        self.ax2.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_resid.spines:
        self.ax_resid.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_div.spines:
        if(entry in ['left', 'right']):
          self.ax_div.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax2_div.spines:
        self.ax2_div.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_resid_div.spines:
        self.ax_resid_div.spines[entry].set_path_effects(baseEffect)

      # modify grid lines
      for key in self.gridLinesStore:
        if(self.gridVisible[key]):
          for entry in self.gridLinesStore[key]:
            entry.set_path_effects(baseEffect)
        if(key in self.gridLinesStore_resid):
          for entry in self.gridLinesStore_resid[key]:
            entry.set_path_effects(baseEffect)

      # modify tick lines
      for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)

      # zero line
      for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
        if(handleResidZero != None):
          handleResidZero.set_path_effects(baseEffect)
        
      # and the axes labels
      for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
        entry.xaxis.label.set_path_effects(baseEffectText)
        entry.yaxis.label.set_path_effects(baseEffectText)
      self.ax.yaxis.label.set_path_effects(baseEffectText)
      self.ax_div.yaxis.label.set_path_effects(baseEffectText)

      # and the tick labels
      tickLabels = []
      for entry in [self.ax, self.ax_resid, self.ax2, self.ax_div, self.ax_resid_div, self.ax2_div]:
        tickLabels.extend(entry.get_xticklabels(which='both'))
        tickLabels.extend(entry.get_yticklabels(which='both'))
        tickLabels.append(entry.xaxis.get_offset_text())
        tickLabels.append(entry.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_path_effects(baseEffectText)

      # and the cursor
      for cursor in [self.cursor, self.cursor_div, self.cursor2, self.cursor2_div]:
        if(cursor != None):
          handles = cursor.getHandles()
          for entry in handles:
            # check for text
            if(hasattr(entry, 'get_text')):
              entry.set_path_effects(baseEffectText)
            else:
              entry.set_path_effects(baseEffect)

    # introduces path effects for new plot items
    tempDict = {}
    tempDict['path.effects'] = baseEffect
    matplotlib.rcParams.update(tempDict)

    self.rememberSetting['pathEffects'] = 'tempDict = {\'path.effects\': [' + tempRememberSetting + ']}\n'
    self.rememberSetting['pathEffects'] += 'matplotlib.rcParams.update(tempDict)\n'

    # update plot
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()
    
  def setXkcdSetting(self, value=1.0, item='scale', redraw=True):
    # update xckd setttings
    if(item in ['scale', 'length', 'random']):
      if(item == 'scale'):
        if(self.xkcdScale == value):
          redraw = False
        else:
          self.xkcdScale = value
      elif(item == 'length'):
        if(self.xkcdLength == value):
          redraw = False
        else:
          self.xkcdLength = value
      elif(item == 'random'):
        if(self.xkcdRandomness == value):
          redraw = False
        else:
          self.xkcdRandomness = value
          
      # do the xkcdify?
      if((redraw) and (self.xkcd)):
        self.xkcdify(state=self.xkcd, redraw=redraw)

  def xkcdify(self, state=True, redraw=True):
    # set xkcd-like parameters
    # store previous parameters
    if((not self.xkcd) and (state)):
      if ('font.sans-serif' in matplotlib.rcParams):
        self.xkcdStoreFonts = matplotlib.rcParams['font.sans-serif']
      else:
        self.xkcdStoreFonts = ['DejaVu Sans']
    
    # set new parameters
    self.xkcd = state
    tempDict = {}
    if(self.xkcd):
      xkcdScale = self.xkcdScale
      xkcdLength = self.xkcdLength
      xkcdRandomness = self.xkcdRandomness

      # check for presence of funny fonts
      addFonts = []
      fontCandidates = 'Humor Sans,Comic Sans MS'.split(',')
      for entry in fontCandidates:
        if entry in self.parent.fontNames:
          addFonts.append(entry)
          
      if(len(addFonts)):
        tempDict['font.sans-serif'] = addFonts
        tempDict['font.sans-serif'].extend(self.xkcdStoreFonts)
    else:
      xkcdScale = 0
      xkcdLength = 0
      xkcdRandomness = 0
      
      # restore original fonts
      tempDict['font.sans-serif'] = self.xkcdStoreFonts

    # introduces xkcd-type style for new plot items
    tempDict['path.sketch'] = (xkcdScale, xkcdLength, xkcdRandomness)
    matplotlib.rcParams.update(tempDict)
    self.rememberSetting['xkcd'] = 'tempDict = ' + repr(tempDict) + '\n'
    self.rememberSetting['xkcd'] += 'matplotlib.rcParams.update(tempDict)\n'
    
    # modify existing extras
    for entry in self.parent.extras:
      relevantHandles = [entry.handle, entry.handle_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handle', 'handle_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleExtra in relevantHandles:
        if(handleExtra != None):
          # modify object directly (for line)
          if(hasattr(handleExtra, 'set_sketch_params')):
            handleExtra.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          # set bbox if present
          if(hasattr(handleExtra, 'get_bbox_patch')):
            handle = handleExtra.get_bbox_patch()
            if(handle != None):
              handle.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          # set arrow patch if present
          if(hasattr(handleExtra, 'arrow_patch')):
            handle = handleExtra.arrow_patch
            if(handle != None):
              handle.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    
    # modify existing curves
    for entry in self.parent.fit:
      relevantHandles = [entry.handlePlot, entry.handlePlot_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handlePlot', 'handlePlot_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handlePlot in relevantHandles:
        if(handlePlot != None):
          handlePlot.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    
    # modify existing data sets
    for entry in self.parent.data:
      relevantHandles = [entry.handleData, entry.handleData_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleData', 'handleData_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleData in relevantHandles:
        if(handleData != None):
          handleData.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      for handleResid in [entry.handleResid, entry.handleResid_div]:
        if(handleResid != None):
          handleResid.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      relevantHandles = [entry.handleBar, entry.handleBar_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleBar', 'handleBar_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleBar in relevantHandles:
        if(handleBar != None):
          children = handleBar.get_children()
          for entry2 in children:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      relevantHandles = [entry.handleStack, entry.handleStack_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleStack', 'handleStack_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleStack in relevantHandles:
        if(handleStack != None):
          handleStack.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      relevantHandles = [entry.handleStackNeg, entry.handleStackNeg_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleStackNeg', 'handleStackNeg_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleStackNeg in relevantHandles:
        if(handleStackNeg != None):
          handleStackNeg.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
        if(handleResidBar != None):
          children = handleResidBar.get_children()
          for entry2 in children:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      for handleResidStack in [entry.handleResidStack, entry.handleResidStack_div]:
        if(handleResidStack != None):
          handleResidStack.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      for handleResidStackNeg in [entry.handleResidStackNeg, entry.handleResidStackNeg_div]:
        if(handleResidStackNeg != None):
          handleResidStackNeg.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      relevantHandles = [entry.handleErr, entry.handleErr_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleErr', 'handleErr_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleErr in relevantHandles:
        if(handleErr != None):
          handleErr[0].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          for entry2 in handleErr[1]:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          for entry2 in handleErr[2]:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

      relevantHandles = [entry.handleViolin, entry.handleViolin_div]
      if(self.splitY):
        relevantHandles += [entry.handlesBothAxes[handle] for handle in ['handleViolin', 'handleViolin_div'] if ((handle in entry.handlesBothAxes) and (entry.handlesBothAxes != None))]
      for handleViolin in relevantHandles:
        if(handleViolin != None):
          for subtarget in handleViolin:
            if(type(handleViolin[subtarget]) == type([])):
              itemList = handleViolin[subtarget]
            else:
              itemList = [handleViolin[subtarget]]
            # cycle through all items
            for item in itemList:
              if(hasattr(item, 'set_sketch_params')):
                item.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify axes and background
    for entry in self.ax.spines:
      if(entry in ['left', 'right']):
        self.ax.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_resid.spines:
      self.ax_resid.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax2.spines:
      self.ax2.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax2.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_resid.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_div.spines:
      if(entry in ['left', 'right']):
        self.ax_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_resid_div.spines:
      self.ax_resid_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax2_div.spines:
      self.ax2_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax2_div.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_resid_div.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify grid lines
    for key in self.gridLinesStore:
      if(self.gridVisible[key]):
        for entry in self.gridLinesStore[key]:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      if(key in self.gridLinesStore_resid):
        for entry in self.gridLinesStore_resid[key]:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify tick lines (somehow not heeded by matplotlib?!)
    for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # zero line
    for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
      if(handleResidZero != None):
        handleResidZero.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      
    # and the cursor
    for cursor in [self.cursor, self.cursor_div, self.cursor2, self.cursor2_div]:
      if(cursor != None):
        handles = cursor.getHandles()
        for entry in handles:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # and the axes labels
    for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
      entry.xaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      entry.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_div.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # and the tick labels
    tickLabels = []
    for entry in [self.ax, self.ax2, self.ax_resid, self.ax_div, self.ax2_div, self.ax_resid_div]:
      tickLabels.extend(entry.get_xticklabels(which='both'))
      tickLabels.extend(entry.get_yticklabels(which='both'))
    for entry in tickLabels:
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # update plot
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()
    
  def initPlot(self, initialize=True):
    if(initialize):
      plt.ioff()
      # initialize data plot
      self.ax2 = self.matplot.add_subplot(111)
      self.ax2.autoscale(enable=False, axis='both')
      self.ax2.xaxis.set_label_text('x')
      self.ax2.yaxis.set_label_text('y')
      self.ax2.yaxis.set_label_position('right')
      self.ax2.yaxis.set_ticks_position('right')
      self.ax2.grid(False, which='both')
      self.ax2.patch.set_facecolor('none')
      
      # now for some fun with make_axes_locatable
      self.divider_ax2 = make_axes_locatable(self.ax2)
      self.ax2_div = self.divider_ax2.append_axes('right', size='100%', pad=0.2, sharey=self.ax2)
      self.ax2_div.set_xscale(self.modeX_div)
      self.ax2_div.set_xlim((self.minX_div, self.maxX_div))
      # hide the extra axis
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax2))))
      self.ax2_div.grid(False, which='both')
      self.ax2_div.set_visible(False)
      self.ax2_div.yaxis.set_label_position('right')

      # we cannot set entire axis invisible as this also removes canvas etc.
      ###self.ax2.set_visible(False)
      self.toggleSecondAxesItems(state=False)
      
      # ax object should be twinned to ax2 (not vice versa), such that it ends on top
      self.ax = self.ax2.twinx()
      # untwin axes dimensions
      if(hasattr(self.ax2, '_twinned_axes')):
        # for good measure, also except this
        try:
          self.ax2._twinned_axes.remove(self.ax)
        except:
          pass
      self.ax.autoscale(enable=False, axis='both')
      self.ax.xaxis.set_visible(False)
      self.ax.yaxis.set_label_position('left')
      self.ax.yaxis.set_ticks_position('left')
      self.ax.grid(False, which='both')
      # for good measure, reset ticks position on ax2
      self.ax2.yaxis.set_ticks_position('right')
      for entry in ['top', 'bottom']:
        self.ax.spines[entry].set_visible(False)
      self.matplot.patch.set_facecolor(self.canvasColor)

      # now for some fun with make_axes_locatable
      self.divider_ax = make_axes_locatable(self.ax)
      self.ax_div = self.divider_ax.append_axes('right', size='100%', pad=0.2, sharey=self.ax)
      self.ax_div.set_xscale(self.modeX_div)
      self.ax_div.set_xlim((self.minX_div, self.maxX_div))
      # hide diverse elements
      for entry in ['top', 'bottom', 'left', 'right']:
        self.ax_div.spines[entry].set_visible(False)
      self.ax_div.patch.set_facecolor('none')
      self.ax_div.grid(False, which='both')
      self.ax_div.xaxis.set_ticks_position('none')
      self.ax_div.yaxis.set_ticks_position('none')
      tickLabels = self.ax_div.get_xticklabels(which='both')
      tickLabels.append(self.ax_div.xaxis.get_offset_text())
      tickLabels.extend(self.ax_div.get_yticklabels(which='both'))
      tickLabels.append(self.ax_div.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_visible(False)
      # hide the extra axis
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax))))
      self.ax_div.set_visible(False)

      # adjust z-order to make original axes appear in front (important for mouse cursor)
      self.ax.set_zorder(self.ax_div.get_zorder() + 1)
      self.ax2.set_zorder(self.ax2_div.get_zorder() + 1)
      
      # generate additional plot object for colored background
      self.colorPlane = self.matplot.add_subplot(111, label='tilt')
      self.colorPlane.autoscale(enable=False, axis='both')
      # hide essentially all elements of this new plot
      self.colorPlane.xaxis.set_visible(False)
      self.colorPlane.yaxis.set_ticks_position('none')
      for entry in ['top', 'bottom', 'left', 'right']:
        self.colorPlane.spines[entry].set_visible(False)
      self.colorPlane.xaxis.set_label_text('')
      self.colorPlane.yaxis.set_label_text('')
      self.colorPlane.xaxis.label.set_visible(False)
      self.colorPlane.yaxis.label.set_visible(False)
      self.colorPlane.set_xlim(0, 1)
      self.colorPlane.set_ylim(0, 1)
      self.colorPlane.set_xticks([])
      self.colorPlane.set_yticks([])
      self.colorPlane.patch.set_facecolor([0.0] * 4)
      self.colorPlane.grid(False, which='both')
      # initialize handle for colored background
      if(self.canvasGradientVisible):
        self.setCanvasGradient(redraw=False)
      else:
        self.colorBackground = None
      self.colorPlane.set_zorder(self.ax_div.get_zorder() - 1)
        
      # initalize some values
      self.handleData = None
      self.handlePlot = None
      self.handleErr = None
      self.handleErrShady = None
    
      # initialize resid plot
      self.ax_resid = self.residplot.add_subplot(111)
      self.ax_resid.autoscale(enable=False, axis='both')
      self.ax_resid.grid(False, which='both')
      self.residplot.patch.set_facecolor(self.canvasColor)
      
      # now for some fun with make_axes_locatable
      self.divider_resid = make_axes_locatable(self.ax_resid)
      self.ax_resid_div = self.divider_resid.append_axes('right', size='100%', pad=0.2, sharey=self.ax_resid)
      self.ax_resid_div.set_xscale(self.modeX_div)
      self.ax_resid_div.set_xlim((self.minX_div, self.maxX_div))
      self.ax_resid_div.grid(False, which='both')
      tickLabels = self.ax_resid_div.get_yticklabels(which='both')
      tickLabels.append(self.ax_resid_div.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_visible(False)
      # hide the extra axis
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax_resid))))
      self.ax_resid_div.set_visible(False)

      # adjust z-order to make original axes appear in front
      self.ax_resid.set_zorder(self.ax_resid_div.get_zorder() + 1)

      # refresh plots
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()

      # generate additional plot object for colored background
      self.colorPlane_resid = self.residplot.add_subplot(111, label='tilt_resid')
      self.colorPlane_resid.autoscale(enable=False, axis='both')
      # hide essentially all elements of this new plot
      self.colorPlane_resid.xaxis.set_visible(False)
      self.colorPlane_resid.yaxis.set_ticks_position('none')
      for entry in ['top', 'bottom', 'left', 'right']:
        self.colorPlane_resid.spines[entry].set_visible(False)
      self.colorPlane_resid.xaxis.set_label_text('')
      self.colorPlane_resid.yaxis.set_label_text('')
      self.colorPlane_resid.xaxis.label.set_visible(False)
      self.colorPlane_resid.yaxis.label.set_visible(False)
      self.colorPlane_resid.set_xlim(0, 1)
      self.colorPlane_resid.set_ylim(0, 1)
      self.colorPlane_resid.set_xticks([])
      self.colorPlane_resid.set_yticks([])
      self.colorPlane_resid.patch.set_facecolor([0.0] * 4)
      self.colorPlane_resid.grid(False, which='both')
      # initialize handle for colored background
      if(self.canvasGradientVisible):
        self.setCanvasGradient(redraw=False, target='resid')
      else:
        self.colorBackground_resid = None
      self.colorPlane_resid.set_zorder(self.ax_resid_div.get_zorder() - 1)

      # initalize some values
      self.handleResid = None
      self.handleResidZero = None
      self.handleResidZero_div = None
      self.handlesAbout = []
      
      # initialize the plot rectangle selector
      rectprops = dict(fill=True, linewidth=1, facecolor=[0, 0, 1, 0.4], edgecolor='black', linestyle='solid')
      self.rectSelector = MyRectangli(self.ax, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                button=[1, 3], minspanx=0, minspany=0, spancoords='pixels')#, interactive=False)

      # initialize lasso selector
      self.lassoSelector = MyLassoli(self.ax, self.lassoSelectorCallback, 1)

      # fudge to prevent rectangle selector from firing same event twice
      self.previousClick = [0.0] * 4
      
      # rectangle and lasso selectors for split x axis
      self.rectSelector_div = MyRectangli(self.ax_div, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                button=[1, 3], minspanx=0, minspany=0, spancoords='pixels')
      self.lassoSelector_div = MyLassoli(self.ax_div, self.lassoSelectorCallback, 1)

      # set up rectangle selector for split y axis
      self.rectSelector2 = MyRectangli(self.ax2, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                button=[1, 3], minspanx=0, minspany=0, spancoords='pixels')
      self.rectSelector2.set_active(False)
      self.lassoSelector2 = MyLassoli(self.ax2, self.lassoSelectorCallback, 1)
      
      self.rectSelector2_div = MyRectangli(self.ax2_div, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                button=[1, 3], minspanx=0, minspany=0, spancoords='pixels')
      self.rectSelector2.set_active(False)
      self.lassoSelector2_div = MyLassoli(self.ax2_div, self.lassoSelectorCallback, 1)

      # set up cursor
      self.matplot.canvas.mpl_connect('button_press_event', self.toggleCrossHairEncore)
      self.matplot.canvas.mpl_connect('scroll_event', self.mouseScrolled)
      self.matplot.canvas.mpl_connect('motion_notify_event', self.moveHandler)
      self.matplot.canvas.mpl_connect('button_release_event', self.releaseHandler)
      
      # set up click handler in residplot
      self.residplot.canvas.mpl_connect('button_press_event', self.pickHandlerResid)

    for target in ['plot', 'resid']:
      # labels etc.
      self.toggleAxisLabel(self.labelXShow, axis='x', redraw=False, target=target)
      self.setAxisLabel(self.labelX, axis='x', redraw=False, target=target)
      self.setAxisLabelColor(value = self.labelXColor, axis = 'x', redraw = False, target=target)
      self.setAxisLabelSize(value = self.labelXSize, axis = 'x', redraw = False, target=target)
      self.setAxisLabelBold(value = self.labelXWeight, axis = 'x', redraw = False, target=target)
      self.setAxisLabelItalic(value = self.labelXStyle, axis = 'x', redraw = False, target=target)
      self.setAxisLabelVariant(value = self.labelXVariant, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAlignment(value = self.labelXAlignment, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAlignmentVertical(value = self.labelXAlignmentVertical, axis = 'x', redraw = False, target=target)
      self.setAxisLabelPad(value = self.labelXPad, axis = 'x', redraw = False, target=target)
      self.setAxisLabelPos(value = self.labelXPos, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAngle(value = self.labelXAngle, axis = 'x', redraw = False, target=target)
      self.setAxisFont(value = self.axisFont['x'], axis = 'x', redraw = False, target=target)
      self.toggleAxisLabel(self.labelYShow, axis='y', redraw=False, target=target)
      self.setAxisLabel(labeltext=self.labelY, axis='y', redraw=False, target=target)
      if(target == 'plot'):
        self.setAxisLabel(labeltext=self.labelY2, axis='y2', redraw=False, target=target)
        self.toggleAxisLabel(self.labelY2Show, axis='y2', redraw=False, target=target)
      self.setAxisLabelColor(value = self.labelYColor, axis = 'y', redraw = False, target=target)
      self.setAxisLabelSize(value = self.labelYSize, axis = 'y', redraw = False, target=target)
      self.setAxisLabelBold(value = self.labelYWeight, axis = 'y', redraw = False, target=target)
      self.setAxisLabelItalic(value = self.labelYStyle, axis = 'y', redraw = False, target=target)
      self.setAxisLabelVariant(value = self.labelYVariant, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAlignment(value = self.labelYAlignment, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAlignmentVertical(value = self.labelYAlignmentVertical, axis = 'y', redraw = False, target=target)
      self.setAxisLabelPad(value = self.labelYPad, axis = 'y', redraw = False, target=target)
      self.setAxisLabelPos(value = self.labelYPos, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAngle(value = self.labelYAngle, axis = 'y', redraw = False, target=target)
      self.setAxisFont(value = self.axisFont['y'], axis = 'y', redraw = False, target=target)
      if(target == 'plot'):
        self.setAxisLabelColor(value = self.labelY2Color, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelSize(value = self.labelY2Size, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelBold(value = self.labelY2Weight, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelItalic(value = self.labelY2Style, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelVariant(value = self.labelY2Variant, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAlignment(value = self.labelY2Alignment, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAlignmentVertical(value = self.labelY2AlignmentVertical, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelPad(value = self.labelY2Pad, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelPos(value = self.labelY2Pos, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAngle(value = self.labelY2Angle, axis = 'y2', redraw = False, target=target)
        self.setAxisFont(value = self.axisFont['y2'], axis = 'y2', redraw = False, target=target)
      
      # set axes properties
      for key in self.axisVisible:
        self.setAxisVisibility(value = self.axisVisible[key], axis = key, redraw = False, target=target)
      for key in self.axisWidth:
        self.setAxisWidth(value = self.axisWidth[key], axis = key, redraw = False, target=target)
      for key in self.axisStyle:
        self.setAxisStyle(value = self.axisStyle[key], axis = key, redraw = False, target=target)
      for key in self.axisDashStyle:
        self.setAxisDashStyle(value = self.axisDashStyle[key], axis = key, redraw = False, target=target)
      for key in self.axisColor:
        self.setAxisColor(value = self.axisColor[key], axis = key, redraw = False, target=target)

      if(target == 'plot'):
        useKeys = ['left', 'right', 'bottom', 'top', 'left2', 'right2']
      else:
        useKeys = ['left', 'right', 'bottom', 'top']
      if(not initialize):
        for key in useKeys:
          self.setAxisPosition(value=self.axisPosition[key], axis=key, redraw=False, target=target)
          self.setAxisPositionValue(value=self.axisPositionValue[key], axis=key, redraw=False, target=target)
      for key in useKeys:
        self.setAxisBoundaryValue(value=self.axisBoundary[key][0], lower=True, axis=key, redraw=False, target=target)
        self.setAxisBoundaryValue(value=self.axisBoundary[key][1], lower=False, axis=key, redraw=False, target=target)
        self.setAxisBoundary(value=self.axisBoundaryCheck[key], axis=key, redraw=False, target=target)
        
      # set axes arrows
      for axis in ['x', 'y']:
        self.setAxisArrowColor(value=self.arrowColor[axis], axis=axis, item='line', redraw=False)
        self.setAxisArrowColor(value=self.arrowFill[axis], axis=axis, item='fill', redraw=False)
        self.setAxisArrowHeadWidth(value=self.arrowHeadWidth[axis], axis=axis, redraw=False)
        self.setAxisArrowHeadLength(value=self.arrowHeadLength[axis], axis=axis, redraw=False)
        self.setAxisArrowOverhang(value=self.arrowOverhang[axis], axis=axis, redraw=False)
        self.setAxisArrow(state=self.arrowVisible[axis], axis=axis, item='all', redraw=False, target=target)
        self.setAxisArrow(state=self.arrowEdgeShow[axis], axis=axis, item='edge', redraw=False, target=target)
        self.setAxisArrow(state=self.arrowFillShow[axis], axis=axis, item='fill', redraw=False, target=target)
  
      # set color and size of ticks
      self.toggleTicksLabel(value=self.ticksXShow, axis='x', redraw=False, target=target)
      self.setTickLabelColor(value = self.ticksXColor, axis = 'x', redraw = False, target=target)
      self.setTickLabelSize(value = self.ticksXSize, axis = 'x', redraw = False, target=target)
      self.setTickLabelBold(value = self.ticksXWeight, axis = 'x', redraw = False, target=target)
      self.setTickLabelItalic(value = self.ticksXStyle, axis = 'x', redraw = False, target=target)
      self.setTickLabelAngle(value = self.ticksXAngle, axis = 'x', redraw = False, target=target)
      self.setTickLabelAlignment(value = self.ticksXAlignment, axis = 'x', redraw = False, target=target)
      self.setTickLabelAlignmentVertical(value = self.ticksXAlignmentVertical, axis = 'x', redraw = False, target=target)
      self.setTickLabelPad(value = self.ticksXPad, axis = 'x', redraw = False, target=target)
      self.setTickLabelPad2(value = self.ticksXPad2, axis = 'x', redraw = False, target=target)
      self.setTickFont(value = self.tickFont['x'], axis = 'x', redraw = False, target=target)
      ###self.setTickFormat(axis='x', value=self.ticksXFormat, redraw=False, target=target)
      ### do we need to call tick formatting at all? (will be updated on draw time)

      if(target == 'plot'):
        self.toggleTicksLabel(value=self.ticksYShow, axis='y', redraw=False, target=target)
      else:
        self.toggleTicksLabel(value=self.ticksResidYShow, axis='y', redraw=False, target=target)
      self.setTickLabelColor(value = self.ticksYColor, axis = 'y', redraw = False, target=target)
      self.setTickLabelSize(value = self.ticksYSize, axis = 'y', redraw = False, target=target)
      self.setTickLabelBold(value = self.ticksYWeight, axis = 'y', redraw = False, target=target)
      self.setTickLabelItalic(value = self.ticksYStyle, axis = 'y', redraw = False, target=target)
      self.setTickLabelAngle(value = self.ticksYAngle, axis = 'y', redraw = False, target=target)
      self.setTickLabelAlignment(value = self.ticksYAlignment, axis = 'y', redraw = False, target=target)
      self.setTickLabelAlignmentVertical(value = self.ticksYAlignmentVertical, axis = 'y', redraw = False, target=target)
      self.setTickLabelPad(value = self.ticksYPad, axis = 'y', redraw = False, target=target)
      self.setTickLabelPad2(value = self.ticksYPad2, axis = 'y', redraw = False, target=target)
      self.setTickFont(value = self.tickFont['y'], axis = 'y', redraw = False, target=target)
      if(target == 'plot'):
        self.toggleTicksLabel(value=self.ticksY2Show, axis='y2', redraw=False, target=target)
        self.setTickLabelColor(value = self.ticksY2Color, axis = 'y2', redraw = False, target=target)
        self.setTickLabelSize(value = self.ticksY2Size, axis = 'y2', redraw = False, target=target)
        self.setTickLabelBold(value = self.ticksY2Weight, axis = 'y2', redraw = False, target=target)
        self.setTickLabelItalic(value = self.ticksY2Style, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAngle(value = self.ticksY2Angle, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAlignment(value = self.ticksY2Alignment, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAlignmentVertical(value = self.ticksY2AlignmentVertical, axis = 'y2', redraw = False, target=target)
        self.setTickLabelPad(value = self.ticksY2Pad, axis = 'y2', redraw = False, target=target)
        self.setTickLabelPad2(value = self.ticksY2Pad2, axis = 'y2', redraw = False, target=target)
        self.setTickFont(value = self.tickFont['y2'], axis = 'y2', redraw = False, target=target)
  
      # set tick properties
      if(target == 'plot'):
        validItems = ['left', 'right', 'top', 'bottom', 'left2', 'right2']
      else:
        validItems = ['left', 'right', 'top', 'bottom']
      for key in self.ticksVisible:
        if(key in validItems):
         self.setTickMarkVisibility(value = self.ticksVisible[key], axis = key, redraw = False, target=target, initMode=True)
      for key in self.ticksWidth:
        if(key in validItems):
          self.setTickMarkWidth(value = self.ticksWidth[key], axis = key, redraw = False, target=target)
      for key in self.ticksLength:
        if(key in validItems):
          self.setTickMarkLength(value = self.ticksLength[key], axis = key, redraw = False, target=target, forceRedraw=False)
      for key in self.ticksColor:
        if(key in validItems):
          self.setTickMarkColor(value = self.ticksColor[key], axis = key, redraw = False, target=target)
      for key in self.ticksDirection:
        if(key in validItems):
          self.setTickMarkDirection(value = self.ticksDirection[key], axis = key, redraw = False, target=target)
      for key in self.ticksLabelShow:
        if(key in validItems):
          self.setTickMarkLabelShow(value = self.ticksLabelShow[key], axis = key, redraw = False, target=target)

      # set grid properties
      for key in self.gridVisible:
         self.setGridVisibility(value = self.gridVisible[key], axis = key, redraw = False, target=target)
      for key in self.gridWidth:
        self.setGridWidth(value = self.gridWidth[key], axis = key, redraw = False, target=target)
      for key in self.gridStyle:
        self.setGridStyle(value = self.gridStyle[key], axis = key, redraw = False, target=target)
      for key in self.gridDashStyle:
        self.setGridDashStyle(value = self.gridDashStyle[key], axis = key, redraw = False, target=target)
      for key in self.gridColor:
        self.setGridColor(value = self.gridColor[key], axis = key, redraw = False, target=target)
      for key in self.gridOrder:
        self.setGridOrder(value = self.gridOrder[key], axis = key, redraw = False, target=target)

      # canvas color etc.
      if(self.splitY):
        # activate patch background
        self.ax.patch.set_visible(True)
        self.ax_div.patch.set_visible(True)
      else:
        self.ax.patch.set_visible(False)
        self.ax_div.patch.set_visible(False)
        
      # deal with the innner situation
      self.updateInnerYSituation()
      self.setCanvasColor(value=self.canvasColor, redraw=False, target=target)
      self.toggleCanvasFill(value=self.canvasFill, redraw=False, target=target)
      self.toggleFigureFill(value=self.figureFill, redraw=False, target=target, silent=True)
      self.toggleFrameDraw(value=self.frameDraw, redraw=False, target=target)
      self.setFigureColor(value=self.figureColor, redraw=False, target=target, silent=True)
      self.setCanvasGradientStyle(value=self.canvasGradientStyle, redraw=False, target=target)
      self.setCanvasGradientColor(value=self.canvasGradientColor1, redraw=False, target=target, color=0)
      self.setCanvasGradientColor(value=self.canvasGradientColor2, redraw=False, target=target, color=1)
      self.setCanvasGradientCenter(value=self.canvasGradientCenter[0], redraw=False, target=target, axis='x')
      self.setCanvasGradientCenter(value=self.canvasGradientCenter[1], redraw=False, target=target, axis='y')
      self.setCanvasGradientWidth(value=self.canvasGradientWidth, redraw=False, target=target)
      self.setCanvasGradientAngle(value=self.canvasGradientAngle, redraw=False, target=target)
      self.setCanvasGradient(state=self.canvasGradientVisible, redraw=False, target=target)
      
      # set padding
      self.setPadding(value=self.padSize['bottom'], axis='bottom', redraw=False, target=target)
      
      # frame
      self.setFrameColor(value=self.frameColor, redraw=False, target=target)
      self.setFrameWidth(value=self.frameWidth, redraw=False, target=target)
      self.setFrameStyle(value=self.frameStyle, redraw=False, target=target)
      self.setFrameDashStyle(value=self.frameDashStyle, redraw=False, target=target)

    # the inner situation
    self.changeSplitFraction(value=self.splitFraction, redraw=False)
    self.changeSplitPad(value=self.splitPad, redraw=False)
    self.setInnerParameter(param='axes', state=self.innerAxes, redraw=False)
    self.setInnerParameter(param='ticks', state=self.innerTicks, redraw=False)
    for target in ['plot', 'resid']:
      self.toggleTicksLabel(value=self.ticksXShow_div, axis='x2', redraw=False, target=target)

    # xkcd etc.
    self.xkcdify(state=self.xkcd, redraw=False)
    self.setPathEffects(redraw=False)
    
    # deal with axis ticks
    if(self.ticksXAuto):
      self.setAutoTicks(axis='x', redraw=False, target='plot')
      self.setAutoTicks(axis='x', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel = ticksXLabel
      if(len(self.ticksXLabel)):
        for axisobject in [self.ax, self.ax_resid]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel)
    if(self.ticksXAuto_div):
      self.setAutoTicks(axis='x2', redraw=False, target='plot')
      self.setAutoTicks(axis='x2', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel_div
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel_div = ticksXLabel
      if(len(self.ticksXLabel_div)):
        for axisobject in [self.ax2_div, self.ax_resid_div]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel_div)
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='y', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY, axis='y', redraw=False, target='plot')
      
    if(self.ticksY2Auto):
      self.setAutoTicks(axis='y2', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY2, axis='y2', redraw=False, target='plot')
      
    if(self.ticksResidYAuto):
      self.setAutoTicks(axis='resid', redraw=False, target='resid')
    else:
      self.setAxisTicks(value=self.ticksResidY, axis='resid', redraw=False, target='resid')

    # retrieve axis ticks
    self.ticksX = self.getAxisTicks(axis = 'x')
    self.ticksY = self.getAxisTicks(axis = 'y')
    self.ticksY2 = self.getAxisTicks(axis = 'y2')
    self.ticksResidY = self.getAxisTicks(axis = 'resid')

    # issue plot redraw
    # the follwing call not needed as we will draw a curve afterwards
    self.handleResidZero = self.plotResidZero(self.handleResidZero, redraw=False)
    self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, redraw=False, splitX=True)
    self.setAxisLimits(lower=self.minResidY, upper=self.maxResidY, axis='y', updateLabel=False, target='resid', redraw=initialize, updateGrid=True)
    self.updateTickEntryField(axis='y')

  def pickHandlerResid(self, event):
    # handles click events in resid plot
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if((event.button == 1) and (modifiers & QtCore.Qt.ControlModifier or event.dblclick)):
      # compile list of z-ordered items
      zOrderedItems = {}
      for index, entry in enumerate(self.parent.data):
        if((hasattr(entry, 'visibilityResid')) and entry.visibilityResid):
          zOrderedItems[entry.zorderResid] = ['resid', index]
      if(self.visibilityResidLine):
        zOrderedItems[self.zorderResidLine] = ['residLine', 0]
      # now check for click in descending z order
      zKeys = sorted(list(zOrderedItems.keys()))
      currIndex = len(zKeys) - 1
      while(currIndex >= 0):
        currKey = zKeys[currIndex]
        currItem = zOrderedItems[currKey]
        if(currItem[0] == 'resid'):
          relevantHandles = ['handleResid', 'handleResidStack', 'handleResidStackNeg', 'handleResid_div', 'handleResidStack_div', 'handleResidStackNeg_div']
          for handle in relevantHandles:
            if((self.parent.data[currItem[1]].__dict__[handle] != None) and (self.parent.data[currItem[1]].__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on
              currIndex = -1
          # handle bars extra
          for handle in ['handleResidBar', 'handleResidBar_div']:
            if(self.parent.data[currItem[1]].__dict__[handle] != None):
              for patch in self.parent.data[currItem[1]].__dict__[handle].patches:
                if(patch.contains(event)[0]):
                  # found an item that has been clicked on
                  currIndex = -1
          # did we hit the item?
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.data[currItem[1]], False, True, callButton=None)
        elif(currItem[0] == 'residLine'):
          for handle in ['handleResidZero', 'handleResidZero_div']:
            if((self.__dict__[handle] != None) and (self.__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on
              currIndex = -1
              
          if(currIndex == -1):
            self.parent.objectsarea.changeResidZeroStyle(callButton=None)
          
        # advance item
        currIndex -= 1

  def releaseHandler(self, event):
    # called to turn off extra picking
    if(self.pickedExtra != None):
      if(event.inaxes == self.inAxes):
        # map to correct axis
        xdata, ydata = self.pickedAxes.transData.inverted().transform((event.x, event.y))
        xdata, ydata = xdata - self.startX, ydata - self.startY
      else:
        xdata, ydata = 0.0, 0.0
      self.parent.extras[self.pickedExtra].updateMe(xdata, ydata, pickedAxes=self.pickedAxes,\
                        pickedBackground=self.pickedBackground, pickedMode=self.pickedMode, transient=False)
      if(self.splitY and self.parent.extras[self.pickedExtra].onBothAxes):
        self.parent.extras[self.pickedExtra].duplicateForSplit()
      self.parent.extras[self.pickedExtra].drawMe(redraw=True)
    self.pickedExtra, self.pickedAxes, self.pickedBackground, self.pickedMode, self.inAxes = None, None, None, 0, None

  def moveHandler(self, event):
    # called to allow moving and resizing of extras
    if(self.pickedExtra != None):
      if(event.inaxes == self.inAxes):
        # map to correct axis
        xdata, ydata = self.pickedAxes.transData.inverted().transform((event.x, event.y))
        xdata, ydata = xdata - self.startX, ydata - self.startY
        self.parent.extras[self.pickedExtra].updateMe(xdata, ydata, pickedAxes=self.pickedAxes,\
                          pickedBackground=self.pickedBackground, pickedMode=self.pickedMode, transient=True)

  def toggleCrossHairEncore(self, event):
    # combined handler for all click events
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    # determine which axis we are on
    inaxes = event.inaxes
    if(inaxes == self.ax):
      lassoSelector, rectSelector = self.lassoSelector, self.rectSelector
    elif(inaxes == self.ax_div):
      lassoSelector, rectSelector = self.lassoSelector_div, self.rectSelector_div
    elif(inaxes == self.ax2):
      lassoSelector, rectSelector = self.lassoSelector2, self.rectSelector2
    else:
      lassoSelector, rectSelector = self.lassoSelector2_div, self.rectSelector2_div
    # first deal with lasso selector
    if((modifiers & QtCore.Qt.ShiftModifier or self.drawFreehand) and (event.button == 1)):
      lassoSelector.line.set_visible(True)
      lassoSelector.drawMe = True
      if(self.drawFreehand):
        lassoSelector.line.set_color([0.2, 0.9, 0.15, 1.0])
        self.thisLasso = lassoSelector
    else:
      lassoSelector.line.set_visible(False)
      lassoSelector.drawMe = False
    # and then with all the rest
    fallThrough, hideRectSel = False, False
    if(((modifiers & QtCore.Qt.ControlModifier) or (modifiers & QtCore.Qt.ShiftModifier) or self.drawFreehand) and (event.button == 1)):
      hideRectSel = True
      # determine mode
      if(self.drawFreehand):
        # for myterious reasons, older Python version under Linux does not correctly assign pickedMode (it reverts to zero!)
        # => go via extra flag pick2Freehand
        # => potentially could be b/c releaseHandler() is called before lassoSelectorCallback()??
        self.pickedMode, self.pick2Freehand = 3, True
      else:
        if((modifiers & QtCore.Qt.ControlModifier) and (modifiers & QtCore.Qt.ShiftModifier)):
          # Ctrl/shift for rotation
          self.pickedMode = 2
        elif(modifiers & QtCore.Qt.ControlModifier):
          # Ctrl for resizing
          self.pickedMode = 1
        else:
          # shift for moving
          self.pickedMode = 0
        # compile list of z-ordered extras
        zOrderedExtras = {}
        for index, entry in enumerate(self.parent.extras):
          if((hasattr(entry, 'visibility')) and entry.visibility):
            zOrderedExtras[entry.zorder] = index
        # now check for click in descending z order
        zKeys = sorted(list(zOrderedExtras.keys()))
        currIndex = len(zKeys) - 1
        while(currIndex >= 0):
          currKey = zKeys[currIndex]
          currItem = zOrderedExtras[currKey]          
  
          relevantHandles = ['handle', 'handle_div']
          # check for items on splitY
          if(self.splitY):
            # determine whether the event originated from the same axis as the object is on
            flag = False
            if((inaxes in [self.ax, self.ax_div]) and (not self.parent.extras[currItem].onSecondAxes)):
              flag = True
            if((inaxes in [self.ax2, self.ax2_div]) and self.parent.extras[currItem].onSecondAxes):
              flag = True
          else:
            flag = True
  
          check = False
          for handle in relevantHandles:
            if(flag):
              if((self.parent.extras[currItem].__dict__[handle] != None) and (self.parent.extras[currItem].__dict__[handle].contains(event)[0]) and (currIndex != -1)):
                # found an item that has been clicked on - break out of loop
                currIndex = -1
                self.pickedExtra = currItem
            elif((handle in self.parent.extras[currItem].handlesBothAxes) and (self.parent.extras[currItem].handlesBothAxes[handle] != None) and (self.parent.extras[currItem].handlesBothAxes[handle].contains(event)[0]) and (currIndex != -1)):
              # found an item that has been clicked on - break out of loop
              currIndex = -1
              self.pickedExtra = currItem
                
            if((currIndex == -1) and (not check)):
              check = True
              # determine which axes to draw on
              self.pickedAxes = inaxes
              self.inAxes = inaxes
                
              # save canvas for blitting
              self.pickedBackground = self.pickedAxes.figure.canvas.copy_from_bbox(self.pickedAxes.bbox)
  
              # map to correct axis
              self.startX, self.startY = self.pickedAxes.transData.inverted().transform((event.x, event.y))
              
              # disable lasso selector
              lassoSelector.line.set_visible(False)
              lassoSelector.drawMe = False
  
          # advance item
          currIndex -= 1
    elif((event.button == 1) and event.dblclick):
      hideRectSel = True
      if(event.dblclick):
        fallThrough = True
      # compile list of z-ordered items
      zOrderedItems = {}
      for index, entry in enumerate(self.parent.fit):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['fit', index]
      for index, entry in enumerate(self.parent.data):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['data', index]
      for index, entry in enumerate(self.parent.extras):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['extra', index]
      # now check for click in descending z order
      zKeys = sorted(list(zOrderedItems.keys()))
      currIndex = len(zKeys) - 1
      while(currIndex >= 0):
        currKey = zKeys[currIndex]
        currItem = zOrderedItems[currKey]
        if(currItem[0] == 'fit'):
          relevantHandles = ['handlePlot', 'handlePlot_div']
          # check for items on splitY
          if(self.splitY):
            # determine whether the event originated from the same axis as the object is on
            flag = False
            if((inaxes in [self.ax, self.ax_div]) and (not self.parent.fit[currItem[1]].onSecondAxes)):
              flag = True
            if((inaxes in [self.ax2, self.ax2_div]) and self.parent.fit[currItem[1]].onSecondAxes):
              flag = True
            # check whether we have item on both axes
            if(self.parent.fit[currItem[1]].onBothAxes and (not flag)):
              for handle in relevantHandles:
                if((handle in self.parent.fit[currItem[1]].handlesBothAxes) and (self.parent.fit[currItem[1]].handlesBothAxes[handle] != None) and (self.parent.fit[currItem[1]].handlesBothAxes[handle].contains(event)[0])):
                  # found an item that has been clicked on - break out of loop
                  currIndex = -1
          else:
            flag = True
          # normal click handling
          if(flag):
            for handle in relevantHandles:
              if((self.parent.fit[currItem[1]].__dict__[handle] != None) and (self.parent.fit[currItem[1]].__dict__[handle].contains(event)[0])):
                # found an item that has been clicked on - break out of loop
                currIndex = -1
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.fit[currItem[1]], False, False, callButton=None)
        elif(currItem[0] == 'data'):
          relevantHandles = ['handleData', 'handleStack', 'handleStackNeg', 'handleData_div', 'handleStack_div', 'handleStackNeg_div']
          # check for items on splitY
          if(self.splitY):
            # determine whether the event originated from the same axis as the object is on
            flag = False
            if((inaxes in [self.ax, self.ax_div]) and (not self.parent.data[currItem[1]].onSecondAxes)):
              flag = True
            if((inaxes in [self.ax2, self.ax2_div]) and self.parent.data[currItem[1]].onSecondAxes):
              flag = True
            flag2 = (not flag) and self.parent.data[currItem[1]].onBothAxes
          else:
            flag, flag2 = True, False
          # cycle through items
          for handle in relevantHandles:
            if(flag):
              if((self.parent.data[currItem[1]].__dict__[handle] != None) and (self.parent.data[currItem[1]].__dict__[handle].contains(event)[0])):
                # found an item that has been clicked on
                currIndex = -1
            if(flag2):
              if((handle in self.parent.data[currItem[1]].handlesBothAxes) and (self.parent.data[currItem[1]].handlesBothAxes[handle] != None) and (self.parent.data[currItem[1]].handlesBothAxes[handle].contains(event)[0])):
                # found an item that has been clicked on - break out of loop
                currIndex = -1
          # handle bars extra
          for handle in ['handleBar', 'handleBar_div']:
            if(flag):
              if(self.parent.data[currItem[1]].__dict__[handle] != None):
                for patch in self.parent.data[currItem[1]].__dict__[handle].patches:
                  if(patch.contains(event)[0]):
                    # found an item that has been clicked on
                    currIndex = -1
            if(flag2):
              if((handle in self.parent.data[currItem[1]].handlesBothAxes) and (self.parent.data[currItem[1]].handlesBothAxes[handle] != None)):
                for patch in self.parent.data[currItem[1]].handlesBothAxes[handle].patches:
                  if(patch.contains(event)[0]):
                    # found an item that has been clicked on
                    currIndex = -1
          # handle violins extra
          for handle in ['handleViolin', 'handleViolin_div']:
            if(flag):
              if(self.parent.data[currItem[1]].__dict__[handle] != None):
                for entry in self.parent.data[currItem[1]].__dict__[handle]:
                  if(type(self.parent.data[currItem[1]].__dict__[handle][entry]) == type([])):
                    for item in self.parent.data[currItem[1]].__dict__[handle][entry]:
                      if(item.contains(event)[0]):
                        # found an item that has been clicked on
                        currIndex = -1
                  else:
                    if(self.parent.data[currItem[1]].__dict__[handle][entry].contains(event)[0]):
                      # found an item that has been clicked on
                      currIndex = -1
            if(flag2):
              if((handle in self.parent.data[currItem[1]].handlesBothAxes) and (self.parent.data[currItem[1]].handlesBothAxes[handle] != None)):
                for entry in self.parent.data[currItem[1]].handlesBothAxes[handle]:
                  if(type(self.parent.data[currItem[1]].handlesBothAxes[handle][entry]) == type([])):
                    for item in self.parent.data[currItem[1]].handlesBothAxes[handle][entry]:
                      if(item.contains(event)[0]):
                        # found an item that has been clicked on
                        currIndex = -1
                  else:
                    if(self.parent.data[currItem[1]].handlesBothAxes[handle][entry].contains(event)[0]):
                      # found an item that has been clicked on
                      currIndex = -1
                    
          # did we hit the item?
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.data[currItem[1]], True, False, callButton=None)
        elif(currItem[0] == 'extra'):
          relevantHandles = ['handle', 'handle_div']
          # check for items on splitY
          if(self.splitY):
            # determine whether the event originated from the same axis as the object is on
            flag = False
            if((inaxes in [self.ax, self.ax_div]) and (not self.parent.extras[currItem[1]].onSecondAxes)):
              flag = True
            if((inaxes in [self.ax2, self.ax2_div]) and self.parent.extras[currItem[1]].onSecondAxes):
              flag = True
            # check whether we have item on both axes
            if(self.parent.extras[currItem[1]].onBothAxes and (not flag)):
              for handle in relevantHandles:
                if((handle in self.parent.extras[currItem[1]].handlesBothAxes) and (self.parent.extras[currItem[1]].handlesBothAxes[handle] != None) and (self.parent.extras[currItem[1]].handlesBothAxes[handle].contains(event)[0])):
                  # found an item that has been clicked on - break out of loop
                  currIndex = -1
          else:
            flag = True
          # normal click handling
          if(flag):
            for handle in relevantHandles:
              if((self.parent.extras[currItem[1]].__dict__[handle] != None) and (self.parent.extras[currItem[1]].__dict__[handle].contains(event)[0])):
                # found an item that has been clicked on - break out of loop
                currIndex = -1
          if(currIndex == -1):
            self.parent.objectsarea.changeStyleExtra(currItem[1], callButton=None)

        if(currIndex == -1):
          # we hit an item, so don't fall through
          fallThrough = False

        # advance item
        currIndex -= 1
      
    if((event.button == 2) or fallThrough):
      hideRectSel = True
      # toggle cross hair on middle mouse button -- cannot use QtCore.Qt.MidButton as this equates to 4?!
      self.cursorVisible = not self.cursorVisible
      # check whether cursor already exists
      if(self.cursor == None):
        self.cursor = MyCursor(self.ax, useblit=True, color='black', linewidth=1)
        self.cursor.setParent(self)
        self.cursor.setAx2(self.ax2)
      if(self.cursor_div == None):
        if(self.splitShow):
          self.cursor_div = MyCursor(self.ax_div, useblit=True, color='black', linewidth=1)
          self.cursor_div.setParent(self)
          self.cursor_div.setAx2(self.ax2_div)
          
      # link cursors
      # as of matplotlib 3.1.2. we have to make sure that split axes are displayed before we can initialize the div cursor
      if(self.cursor_div != None):
        self.cursor.setTwin(self.cursor_div)
        self.cursor_div.setTwin(self.cursor)
      
      # deal with splity cursors
      if((self.cursor2 == None) and self.splitY):
        self.cursor2 = MyCursor(self.ax2, useblit=True, color='black', linewidth=1)
        self.cursor2.setParent(self)
        self.cursor2.setAx2(self.ax2)
      if((self.cursor2_div == None) and self.splitY and self.splitShow):
        self.cursor2_div = MyCursor(self.ax2_div, useblit=True, color='black', linewidth=1)
        self.cursor2_div.setParent(self)
        self.cursor2_div.setAx2(self.ax2_div)
    
      # link cursors
      if(self.cursor2 != None):
        self.cursor.setTwinVertical(self.cursor2)
        self.cursor2.setTwinVertical(self.cursor)
        self.cursor2.setTwin(self.cursor2_div)

      if(self.cursor2_div != None):
        self.cursor_div.setTwinVertical(self.cursor2_div)
        self.cursor2_div.setTwinVertical(self.cursor_div)
        self.cursor2_div.setTwin(self.cursor2)

      # toggle visibility (in correct order to get display of twins right)
      if(event.inaxes == self.ax):
        order = [self.cursor2_div, self.cursor2, self.cursor_div, self.cursor]
      elif(event.inaxes == self.ax_div):
        order = [self.cursor2, self.cursor2_div, self.cursor, self.cursor_div]
      elif(event.inaxes == self.ax2):
        order = [self.cursor_div, self.cursor2_div, self.cursor, self.cursor2]
      else:
        order = [self.cursor, self.cursor2, self.cursor_div, self.cursor2_div]
        
      if(self.splitY):
        for cursor in order:
          if(cursor != None):
            cursor.toggleVisibility(self.cursorVisible, event)
            
        # extra call to turn off surplus vertical lines
        if(order[0] != None):
          order[0].linev.set_visible(False)
          order[0].lineh.set_visible(False)
          order[0]._update()
      else:
        for cursor in order[-2:]:
          if(cursor != None):
            cursor.toggleVisibility(self.cursorVisible, event)
        
    # do this to remove superfluous rectSel box    
    if(hideRectSel):
      rectSelector.ignore(event)
      rectSelector.eventpress = None
      rectSelector.eventrelease = None
      rectSelector.to_draw.set_visible(False)
      rectSelector.visible = False
    else:
      rectSelector.to_draw.set_visible(True)
      rectSelector.visible = True
      
    # reset freehand toggle
    if(self.drawFreehand):
      self.drawFreehand = False
      self.parent.objectsarea.extrasCreateFreehandButton.setChecked(False)

  def mouseScrolled(self, event):
    # adjusts zoom level when Ctrl is pressed also
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if((modifiers & QtCore.Qt.ControlModifier) and (event.button in ['down', 'up'])):
      if(event.button == 'down'):
        self.incZoomLevel(1)
      else:
        self.incZoomLevel(-1)

  def destructAboutLogo(self):
    # destroys about logo
    counter = self.dataplotwidget.getDestructionCounter()
    if(counter >= 0):
      counter -= 1
      self.dataplotwidget.setDestructionCounter(np.max((counter, 0)))
      if((counter <= 0) and (len(self.handlesAbout))):
        for entry in self.handlesAbout:
          if(hasattr(entry, 'remove')):
            entry.remove()
        self.handlesAbout = []

  def drawAboutLogo(self, aspect=0, destructCounter=1):
    # draws program info on canvas
    # helper function that transforms coordinates according to axis settings
    def processCoordSet(coords, minX, maxX, modeX, minY, maxY, modeY, relWidth, relHeight, relOffsetX, relOffsetY):
      coords /= 100.0
      # process X coords
      if(modeX == 'linear'):
        coords[:,0] *= (maxX - minX) * relWidth
        coords[:,0] += minX + (maxX - minX) * relOffsetX
      else:
        minX, maxX = np.log(minX), np.log(maxX)
        coords[:,0] *= (maxX - minX) * relWidth
        coords[:,0] += minX + (maxX - minX) * relOffsetX
        coords[:,0] = np.exp(coords[:,0])
      # process Y coords
      if(modeY == 'linear'):
        coords[:,1] *= (maxY - minY) * relHeight
        coords[:,1] += minY + (maxY - minY) * relOffsetY
      else:
        minY, maxY = np.log(minY), np.log(maxY)
        coords[:,1] *= (maxY - minY) * relHeight
        coords[:,1] += minY + (maxY - minY) * relOffsetY
        coords[:,1] = np.exp(coords[:,1])
      return coords

    # helper function that transforms coordinates according to axis settings
    def processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, relOffsetX, relOffsetY):
      # process X coords
      if(modeX == 'linear'):
        x = minX + (maxX - minX) * relOffsetX
      else:
        minX, maxX = np.log(minX), np.log(maxX)
        x = minX + (maxX - minX) * relOffsetX
        x = np.exp(x)
      # process Y coords
      if(modeY == 'linear'):
        y = minY + (maxY - minY) * relOffsetY
      else:
        minY, maxY = np.log(minY), np.log(maxY)
        y = minY + (maxY - minY) * relOffsetY
        y = np.exp(y)
      return [x, y]
    
    # check whether a previous logo is still displayed?
    if(not len(self.handlesAbout)):
      # settings
      zOffset = 2001 # should be in front of selectedData which are at 2000
      ubtCol = [0.011, 0.541, 0.384, 1.0]
      greyCol = [0.3, 0.3, 0.3, 1.0]
      blackCol = [0.0, 0.0, 0.0, 1.0]
      
      # retrieve axis info
      targetAxis = self.ax
      minX, maxX = self.minX, self.maxX
      minY, maxY = self.minY, self.maxY
      modeX, modeY = self.modeX, self.modeY

      # check which axes are available to draw on
      if(self.splitShow):
        if(self.splitFraction > 1.0):
          targetAxis = self.ax_div
          minX, maxX = self.minX_div, self.maxX_div
          modeX = self.modeX_div
          
      # no aspect ratio specified, calculate own (don't do on first call since widgets have not resized properly yet)      
      currWidth, currHeight = self.matplot.get_size_inches()
      if(not aspect):
        aspect = currWidth / currHeight
        # adjust for split axes
        if(self.splitShow):
          if(self.splitFraction > 1.0):
            aspect *= self.splitFraction / (self.splitFraction + 1.0)
          else:
            aspect *= 1.0 / (self.splitFraction + 1.0)
      scaleFont = 100.0 / self.matplot.get_dpi()
        
      # define coordinate sets for graphics ...
      coords0 = np.array([[0.0, 0.0], [0.0, 100.0], [100.0, 100.0], [100.0, 0.0]])
      coords1 = np.array([[4.72, 4.11], [4.72, 95.13], [35.00, 95.13], [35.00, 34.76]])
      coords2 = np.array([[4.72, 4.11], [72.58, 72.14], [95.03, 72.14], [95.03, 49.53], [49.61, 4.11]])
      coords3 = np.array([[0.0, 0.0], [0.0, 100.0], [100.0, 100.0], [100.0, 0.0]])
      # ... and process them
      scaleWidth = 1
      scaleHeight = 1 / aspect
      scaleMin = np.min((scaleWidth, scaleHeight))
      scaleHeight = np.min((2.5, scaleHeight))
      scaleHeight = np.max((1.0, scaleHeight))
      widthBox = 0.8 * scaleWidth
      heightBox = 0.5 * scaleHeight
      coords0 = processCoordSet(coords0, minX, maxX, modeX, minY, maxY, modeY, widthBox, heightBox, 0.1, (1 - heightBox) / 2.0)
      coords1 = processCoordSet(coords1, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
      coords2 = processCoordSet(coords2, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
      coords3 = processCoordSet(coords3, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
  
      # calculate coords for text labels
      text0 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.64)
      text1 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.45)
      text2 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.35)
  
      # draw the background
      polyPatch0 = matplotlib.patches.Polygon(coords0, closed=True, facecolor=[1.0, 1.0, 1.0, 0.7],\
        edgecolor = greyCol, linestyle='solid', linewidth=0.7, zorder=zOffset)
      retv = targetAxis.add_patch(polyPatch0)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      # draw UBT logo
      polyPatch1 = matplotlib.patches.Polygon(coords1, closed=True, facecolor=[1.0]*4,\
        edgecolor = blackCol, linestyle='solid', linewidth=0.5, zorder=zOffset)
      retv = targetAxis.add_patch(polyPatch1)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      polyPatch2 = matplotlib.patches.Polygon(coords2, closed=True, facecolor=ubtCol,\
        edgecolor = 'None', linestyle='solid', linewidth=0.0, zorder=zOffset)
      retv = targetAxis.add_patch(polyPatch2)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      polyPatch3 = matplotlib.patches.Polygon(coords3, closed=True, facecolor='None',\
        edgecolor = blackCol, linestyle='solid', linewidth=0.5, zorder=zOffset)
      retv = targetAxis.add_patch(polyPatch3)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      # print some information
      # according to docu, positional argument would be 'text' but Matplotlib wants 's' => better don't use positional arguments
      #retv = self.ax.text(x=self.minX + 0.5 * width, y=self.minY + 0.5 * height, s='Fit-o-mat',\
      #  horizontalalignment='center', zorder=zOffset)
      retv = targetAxis.text(text0[0], text0[1], 'Fit-o-mat',\
        horizontalalignment='center', zorder=zOffset, style='normal', fontsize=scaleFont * scaledDPI(12), fontweight='bold', color=ubtCol)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      retv = targetAxis.text(text1[0], text1[1],\
        '\u00A9' + ' by A.M. 2017-2021 @MoeglichLab\nandreas.moeglich@uni-bayreuth.de\nGNU General Public License v3.0',\
        horizontalalignment='center', zorder=zOffset, style='normal', fontsize=scaleFont * scaledDPI(10), fontweight='normal', color=greyCol)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      retv = targetAxis.text(text2[0], text2[1], 'version '+ VERSION, horizontalalignment='center', zorder=zOffset,\
        style='italic', fontsize=scaleFont * scaledDPI(8), fontweight='normal', color=greyCol)
      self.handlesAbout.append(retv)
      zOffset += 1
    else:
      self.dataplotwidget.setDestructionCounter(1)
      self.destructAboutLogo()
      destructCounter = 0
      
    # refresh the plot to draw everything
    self.dataplotwidget.myRefresh()
    
    # set us up for ready destruction
    self.dataplotwidget.setDestructionCounter(destructCounter)

  def initLegend(self):
    # initializes legend (has to occur after function is drawn)
    self.setLegend(value=self.legendVisible, redraw=False, target='plot')
    self.setLegendPlacement(value=self.legendPlacement, redraw=False, target='plot')
    for prop in ['face', 'edge']:
      self.setLegendColor(value=self.legendColor[prop], prop=prop, redraw=False, target='plot')
    self.setLegendEdgeWidth(value=self.legendEdgeWidth, redraw=False, target='plot')
    self.setLegendShadow(value=self.legendShadow, redraw=False, target='plot')
    self.setLegendLabelColor(value=self.legendLabelColor, redraw=False, target='plot')
    self.setLegendLabelSize(value=self.legendLabelSize, redraw=False, target='plot')
    self.setLegendLabelBold(value=self.legendLabelWeight, redraw=False, target='plot')
    self.setLegendLabelItalic(value=self.legendLabelStyle, redraw=False, target='plot')
    self.setLegendLabelFont(value=self.legendLabelFont, redraw=False, target='plot')
    self.setLegendMarkerFirst(value=self.legendMarkerFirst, redraw=False, target='plot')
    self.setLegendMarkerScale(value=self.legendMarkerScale, redraw=False, target='plot')
    self.setLegendNCol(value=self.legendNumCol, redraw=False, target='plot')
    self.toggleLegendFill(value=self.legendFill, redraw=False, target='plot')
    self.toggleLegendEdge(value=self.legendEdge, redraw=False, target='plot')
    self.setLegendMarkerNumPoints(value=self.legendNumPoints, redraw=False, target='plot')
    self.setLegendPadBorder(value=self.legendBorderPad, redraw=False, target='plot')
    self.setLegendPadRow(value=self.legendLabelSpacing, redraw=False, target='plot')
    self.setLegendPadCol(value=self.legendColumnSpacing, redraw=False, target='plot')
   
  def changeAxisLimits(self, axis='x', target='plot', redraw=True):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      # changes limits of axis
      if(axis == 'x'):
        # retrieve values from field
        upperx = self.upperLimitx.text()
        try:
          upperx = float(upperx)
        except:
          upperx = 0.0
  
        lowerx = self.lowerLimitx.text()
        try:
          lowerx = float(lowerx)
        except:
          lowerx = 0.0
        # check whether any value changed
        if((upperx != self.maxX) or (lowerx != self.minX)):
          # do some checks and update axis (don't redraw, plot functions will take care of)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x', updateLabel = False, target='plot', redraw=False, updateGrid=True, preserveInverted=False)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True, preserveInverted=False)
          self.updateTickEntryField(axis='x')
          # replot function over current x-interval
          self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                         handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
          # copy in case split axes are shown
          curve = self.parent.fit[self.parent.activeFit]
          if(self.parent.plotArea.splitY and curve.onBothAxes):
            curve.duplicateForSplit()
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
          self.handleResidZero = self.plotResidZero(handleResidZero=self.handleResidZero, redraw=redraw)
      elif(axis == 'x2'):
        # retrieve values from field
        upperx = self.xSplitUpperLimitx.text()
        try:
          upperx = float(upperx)
        except:
          upperx = 0.0
  
        lowerx = self.xSplitLowerLimitx.text()
        try:
          lowerx = float(lowerx)
        except:
          lowerx = 0.0
        # check whether any value changed
        if((upperx != self.maxX_div) or (lowerx != self.minX_div)):
          # do some checks and update axis (don't redraw, plot functions will take care of)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x2', updateLabel = False, target='plot', redraw=False, updateGrid=True, preserveInverted=False)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x2', updateLabel = False, target='resid', redraw=False, updateGrid=True, preserveInverted=False)
          self.updateTickEntryField(axis='x2')
          # replot function over current x-interval
          self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                         handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,redraw=False, splitX=True)
          # copy in case split axes are shown
          curve = self.parent.fit[self.parent.activeFit]
          if(self.parent.plotArea.splitY and curve.onBothAxes):
            curve.duplicateForSplit()
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
          self.handleResidZero_div = self.plotResidZero(handleResidZero=self.handleResidZero_div, redraw=redraw, splitX=True)
      elif(axis == 'y'):
        # retrieve values from field
        if(target == 'plot'):
          uppery = self.upperLimity.text()
          lowery = self.lowerLimity.text()
        else:
          uppery = self.upperLimitResidy.text()
          lowery = self.lowerLimitResidy.text()

        try:
          uppery = float(uppery)
        except:
          uppery = 0.0
  
        try:
          lowery = float(lowery)
        except:
          lowery = 0.0
        
        # check whether any value changed
        if(target == 'plot'):
          if((uppery != self.maxY) or (lowery != self.minY)):
            # do some checks and update axis
            self.setAxisLimits(lower=lowery, upper=uppery, axis='y', updateLabel=False, target=target, redraw=redraw, updateGrid=True, preserveInverted=False)
            self.updateTickEntryField(axis='y')
        else:
          if((uppery != self.maxResidY) or (lowery != self.minResidY)):
            # do some checks and update axis
            self.setAxisLimits(lower=lowery, upper=uppery, axis='y', updateLabel=False, target=target, redraw=redraw, updateGrid=True, preserveInverted=False)
            self.updateTickEntryField(axis='resid')
      elif(axis == 'y2'):
        # modify second y axis
        uppery = self.secondUpperLimit.text()
        lowery = self.secondLowerLimit.text()

        try:
          uppery = float(uppery)
        except:
          uppery = 0.0
  
        try:
          lowery = float(lowery)
        except:
          lowery = 0.0
        
        # check whether any value changed
        if((uppery != self.maxY2) or (lowery != self.minY2)):
          # do some checks and update axis
          self.setAxisLimits(lower=lowery, upper=uppery, axis='y2', updateLabel=False, target=target, redraw=redraw, updateGrid=True, preserveInverted=False)
          self.updateTickEntryField(axis='y2')
      
  def setAxisLimits(self, lower=0, upper=1, axis='x', updateLabel=False, target='plot', redraw=True, updateTicks=True, updateGrid=True, preserveInverted=True):
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
        if(axis == 'x2'):
          axisobject = [self.ax_div, self.ax2_div]
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
        if(axis == 'x2'):
          axisobject = [self.ax_resid_div]
    else:
      axis='abort'
    # ensure safe distance from largest positive/negative number
    # => otherwise matplotlib will crash when calculating tick locations
    MONSTER_FLOAT = 1.0e300
    lower, upper  = min(lower, MONSTER_FLOAT), min(upper, MONSTER_FLOAT)
    lower, upper  = max(lower, -MONSTER_FLOAT), max(upper, -MONSTER_FLOAT)
    # performs checks and then sets axis limits
    if(axis == 'x'):
      # check for inverted axis limits
      if(preserveInverted and (self.minX > self.maxX)):
        invertMe = True
      else:
        invertMe = False
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minX = lower
      if(np.isfinite(upper)):
        self.maxX = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.modeSelectorx.currentText())
      if (axis_mode == 'log'):
        if ((self.minX <= 0) or (self.maxX <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('x' in data):
            xdata = np.array(data['x'])
            xdata = xdata[xdata > 0]
            if(len(xdata)):
              min_xdata = np.min(xdata); max_xdata = np.max(xdata)
              if((self.data_spacer > 0) and (len(xdata) > 1)):
                difference = np.log(max_xdata / min_xdata)
                min_xdata = np.exp(np.log(min_xdata) - self.data_spacer * difference)
                max_xdata = np.exp(np.log(max_xdata) + self.data_spacer * difference)
            else:
              min_xdata, max_xdata = 0, 0
            self.minX = np.max((self.EPSILON, self.minX, min_xdata))
            self.maxX = np.max((self.EPSILON, self.maxX, max_xdata))
          else:
            # ensure that min and max values are positive
            self.minX = np.max((self.EPSILON, self.minX))
            self.maxX = np.max((self.EPSILON, self.maxX))
          updateLabel = True

      if(invertMe):
        self.minX, self.maxX = np.max((self.minX, self.maxX)), np.min((self.minX, self.maxX))
      # update labels?
      if(updateLabel):
        lowerText, upperText = self.parent.formatPairedNumbers(self.minX, self.maxX)
        self.upperLimitx.setText(upperText)
        self.lowerLimitx.setText(lowerText)
        
      # update axis
      if(self.minX == self.maxX):
        if(axis_mode == 'log'):
          self.minX, self.maxX = self.minX / 1.1, self.maxX * 1.1
        else:
          self.minX, self.maxX = self.minX - self.EPSILON, self.maxX + self.EPSILON
        lowerText, upperText = self.parent.formatPairedNumbers(self.minX, self.maxX)
        self.upperLimitx.setText(upperText)
        self.lowerLimitx.setText(lowerText)
      axisobject.set_xlim([self.minX, self.maxX])
      # update push button
      self.flipAxisButtonX.setChecked(self.maxX < self.minX)
      if(updateTicks):
        self.setTickOne4All(axis=axis, redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      for axis in ['left', 'right']:
        if((axis_mode == 'log') and (self.axisPosition[axis] == 'data')):
          # only required for log plots which we had to cast to axes coords
          if(target == 'plot'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_div, target=target, secondAxes=False, splitX=True)
          else:
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid_div, target=target, secondAxes=False, splitX=True)

      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=True)
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)

      if(redraw):
        plotobject.myRefresh()
    elif(axis == 'x2'):
      # check for inverted axis limits
      if(preserveInverted and (self.minX_div > self.maxX_div)):
        invertMe = True
      else:
        invertMe = False
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minX_div = lower
      if(np.isfinite(upper)):
        self.maxX_div = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.xSplitModeSelectorx.currentText())
      if (axis_mode == 'log'):
        if ((self.minX_div <= 0) or (self.maxX_div <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('x' in data):
            xdata = np.array(data['x'])
            xdata = xdata[xdata > 0]
            if(len(xdata)):
              min_xdata = np.min(xdata); max_xdata = np.max(xdata)
              if((self.data_spacer > 0) and (len(xdata) > 1)):
                difference = np.log(max_xdata / min_xdata)
                min_xdata = np.exp(np.log(min_xdata) - self.data_spacer * difference)
                max_xdata = np.exp(np.log(max_xdata) + self.data_spacer * difference)
            else:
              min_xdata, max_xdata = 0, 0
            self.minX_div = np.max((self.EPSILON, self.minX_div, min_xdata))
            self.maxX_div = np.max((self.EPSILON, self.maxX_div, max_xdata))
          else:
            # ensure that min and max values are positive
            self.minX_div = np.max((self.EPSILON, self.minX_div))
            self.maxX_div = np.max((self.EPSILON, self.maxX_div))
          updateLabel = True
      
      if(invertMe):
        self.minX_div, self.maxX_div = np.max((self.minX_div, self.maxX_div)), np.min((self.minX_div, self.maxX_div))
      # update labels?
      if(updateLabel):
        lowerText, upperText = self.parent.formatPairedNumbers(self.minX_div, self.maxX_div)
        self.xSplitUpperLimitx.setText(upperText)
        self.xSplitLowerLimitx.setText(lowerText)
        
      # update axis
      if(self.minX_div == self.maxX_div):
        if(axis_mode == 'log'):
          self.minX_div, self.maxX_div = self.minX_div / 1.1, self.maxX_div * 1.1
        else:
          self.minX_div, self.maxX_div = self.minX_div - self.EPSILON, self.maxX_div + self.EPSILON
        lowerText, upperText = self.parent.formatPairedNumbers(self.minX_div, self.maxX_div)
        self.xSplitUpperLimitx.setText(upperText)
        self.xSplitLowerLimitx.setText(lowerText)
      for entry in axisobject:
        entry.set_xlim([self.minX_div, self.maxX_div])
      # update push button
      self.flipAxisButtonX2.setChecked(self.maxX_div < self.minX_div)
      # should be able to use the same call which updates both regular x axis and divided one
      if(updateTicks):
        self.setTickOne4All(axis='x2', redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x2', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      '''
      for axis in ['left', 'right']:
        if((axis_mode == 'log') and (self.axisPosition[axis] == 'data')):
          # only required for log plots which we had to cast to axes coords
          if(target == 'plot'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_div, target=target, secondAxes=False, splitX=True)
          else:
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid_div, target=target, secondAxes=False, splitX=True)

      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)
      '''
      
      if(redraw):
        plotobject.myRefresh()
    elif(axis == 'y'):
      if(target == 'plot'):
        # check for inverted axis limits
        if(preserveInverted and (self.minY > self.maxY)):
          invertMe = True
        else:
          invertMe = False
        # have to prevent nan and inf here
        if(np.isfinite(lower)):
          self.minY = lower
        if(np.isfinite(upper)):
          self.maxY = upper
        # check current axis mode and take care of log values
        axis_mode = str(self.modeSelectory.currentText())
        if ((axis_mode == 'log') and (target == 'plot')):
          if ((self.minY <= 0) or (self.maxY <= 0)):
            # look whether data are loaded
            data = self.parent.data[self.parent.activeData].value()
            if ('y' in data):
              ydata = np.array(data['y'])
              ydata = ydata[ydata > 0]
              if(len(ydata)):
                min_ydata = np.min(ydata); max_ydata = np.max(ydata)
                if((self.data_spacer > 0) and (len(ydata) > 1)):
                  difference = np.log(max_ydata / min_ydata)
                  min_ydata = np.exp(np.log(min_ydata) - self.data_spacer * difference)
                  max_ydata = np.exp(np.log(max_ydata) + self.data_spacer * difference)
              else:
                min_ydata, max_ydata = 0, 0
              self.minY = np.max((self.EPSILON, self.minY, min_ydata))
              self.maxY = np.max((self.EPSILON, self.maxY, max_ydata))
            else:
              # ensure that min and max values are positive
              self.minY = np.max((self.EPSILON, self.minY))
              self.maxY = np.max((self.EPSILON, self.maxY))
            updateLabel = True
        
        if(invertMe):
          self.minY, self.maxY = np.max((self.minY, self.maxY)), np.min((self.minY, self.maxY))
        # update labels?
        if(updateLabel):
          lowerText, upperText = self.parent.formatPairedNumbers(self.minY, self.maxY)
          self.upperLimity.setText(upperText)
          self.lowerLimity.setText(lowerText)

        # update axis
        if(self.minY == self.maxY):
          if(axis_mode == 'log'):
            self.minY, self.maxY = self.minY / 1.1, self.maxY * 1.1
          else:
            self.minY, self.maxY = self.minY - self.EPSILON, self.maxY + self.EPSILON
          lowerText, upperText = self.parent.formatPairedNumbers(self.minY, self.maxY)
          self.upperLimity.setText(upperText)
          self.lowerLimity.setText(lowerText)
        axisobject.set_ylim([self.minY, self.maxY])
        # update push button
        self.flipAxisButtonY.setChecked(self.maxY < self.minY)
        if(updateTicks):
          self.setTickOne4All(axis=axis, redraw=False, target=target)

        # do we have a grid to draw?
        if(updateGrid):
          for item in ('x', 'x2', 'y'):
            if(self.gridVisible[item]):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
  
        # adjust spine lines if needed
        for axis in ['top', 'bottom']:
          if(self.axisPosition[axis] == 'data'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2_div, target=target, secondAxes=False, splitX=True)

        if(redraw):
          plotobject.myRefresh()
      else:
        # don't check for inverted as this should not be possible for resid plot
        # have to prevent nan and inf here
        if(np.isfinite(lower)):
          self.minResidY = lower
        if(np.isfinite(upper)):
          self.maxResidY = upper

        # update labels?
        if(updateLabel):
          lowerText, upperText = self.parent.formatPairedNumbers(self.minResidY, self.maxResidY)
          self.upperLimitResidy.setText(upperText)
          self.lowerLimitResidy.setText(lowerText)
        
        # update axis
        if(self.minResidY == self.maxResidY):
          self.minResidY, self.maxResidY = self.minResidY - self.EPSILON, self.maxResidY + self.EPSILON
          lowerText, upperText = self.parent.formatPairedNumbers(self.minResidY, self.maxResidY)
          self.upperLimitResidy.setText(upperText)
          self.lowerLimitResidy.setText(lowerText)
        axisobject.set_ylim([self.minResidY, self.maxResidY])
        if(updateTicks):
          self.setTickOne4All(axis=axis, redraw=False, target=target)

        # do we have a grid to draw?
        if(updateGrid):
          for item in ('x', 'x2', 'y'):
            if(self.gridVisible[item]):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

        if(redraw):
          plotobject.myRefresh()
    elif(axis == 'y2'):
      axisobject = self.ax2
      # check for inverted axis limits
      if(preserveInverted and (self.minY2 > self.maxY2)):
        invertMe = True
      else:
        invertMe = False
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minY2 = lower
      if(np.isfinite(upper)):
        self.maxY2 = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.secondModeSelector.currentText())
      if(axis_mode == 'log'):
        if ((self.minY2 <= 0) or (self.maxY2 <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('y' in data):
            ydata = np.array(data['y'])
            ydata = ydata[ydata > 0]
            if(len(ydata)):
              min_ydata = np.min(ydata); max_ydata = np.max(ydata)
              if((self.data_spacer > 0) and (len(ydata) > 1)):
                difference = np.log(max_ydata / min_ydata)
                min_ydata = np.exp(np.log(min_ydata) - self.data_spacer * difference)
                max_ydata = np.exp(np.log(max_ydata) + self.data_spacer * difference)
            else:
              min_ydata, max_ydata = 0, 0
            self.minY2 = np.max((self.EPSILON, self.minY2, min_ydata))
            self.maxY2 = np.max((self.EPSILON, self.maxY2, max_ydata))
          else:
            # ensure that min and max values are positive
            self.minY2 = np.max((self.EPSILON, self.minY2))
            self.maxY2 = np.max((self.EPSILON, self.maxY2))
          updateLabel = True
      
      if(invertMe):
        self.minY2, self.maxY2 = np.max((self.minY2, self.maxY2)), np.min((self.minY2, self.maxY2))
      # update labels?
      if(updateLabel):
        lowerText, upperText = self.parent.formatPairedNumbers(self.minY2, self.maxY2)
        self.secondUpperLimit.setText(upperText)
        self.secondLowerLimit.setText(lowerText)

      # update axis
      if(self.minY2 == self.maxY2):
        if(axis_mode == 'log'):
          self.minY2, self.maxY2 = self.minY2 / 1.1, self.maxY2 * 1.1
        else:
          self.minY2, self.maxY2 = self.minY2 - self.EPSILON, self.maxY2 + self.EPSILON
        lowerText, upperText = self.parent.formatPairedNumbers(self.minY2, self.maxY2)
        self.secondUpperLimit.setText(upperText)
        self.secondLowerLimit.setText(lowerText)
      axisobject.set_ylim([self.minY2, self.maxY2])
      # update push button
      self.flipAxisButtonY2.setChecked(self.maxY2 < self.minY2)
      if(updateTicks):
        self.setTickOne4All(axis=axis, redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x', 'x2', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      # adjust spine lines if needed
      for axis in ['top', 'bottom']:
        if(self.axisPosition[axis] == 'data'):
          self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2, target=target, secondAxes=False)
          self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2_div, target=target, secondAxes=False, splitX=True)

      if(redraw):
        plotobject.myRefresh()

  def drawAxisGrid(self, axis='x', target='plot', redraw=False):
    # draws custom grid lines
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        # draw grid on 1st set of axes
        plotobject = self.dataplotwidget; axisobject = [self.ax, self.ax_div]
        if(axis == 'x'):
          axisobject = [self.ax]
          if(self.splitY):
            axisobject += [self.ax2]
        elif(axis == 'x2'):
          axisobject =[self.ax2_div]
          if(self.splitY):
            axisobject += [self.ax_div]
        elif(axis == 'y2'):
          axisobject = [self.ax2, self.ax2_div]
        useVisible, useColor, useWidth, useStyle, useDashStyle, useGridOrder = self.gridVisible[axis], self.gridColor[axis], self.gridWidth[axis], self.gridStyle[axis], self.gridDashStyle[axis], self.gridOrder[axis]
      else:
        plotobject = self.residplotwidget; axisobject = [self.ax_resid, self.ax_resid_div]
        if(axis == 'x'):
          axisobject = [self.ax_resid]
        elif(axis == 'x2'):
          axisobject =[self.ax_resid_div]
        useVisible, useColor, useWidth, useStyle, useDashStyle, useGridOrder = self.gridVisible_resid[axis], self.gridColor_resid[axis], self.gridWidth_resid[axis], self.gridStyle_resid[axis], self.gridDashStyle_resid[axis], self.gridOrder_resid[axis]
      
      if(useGridOrder == 'back'):
        useZ = 1
      else:
        useZ = 500
        
      # remove previous lines for this axis
      if(target == 'plot'):
        for entry in self.gridLinesStore[axis]:
          entry.remove()
        self.gridLinesStore[axis] = []
      else:
        for entry in self.gridLinesStore_resid[axis]:
          entry.remove()
        self.gridLinesStore_resid[axis] = []

      # replace grid lines by custom lines
      allLineHandles = []
      if(useVisible):
        for targetAxis in axisobject:
          lines = []
          # determine positions for drawing new ones
          if(axis in ['x', 'x2']):
            ticks = np.array(targetAxis.xaxis.get_majorticklocs())
            if(axis == 'x2'):
              ticks = np.array(targetAxis.xaxis.get_majorticklocs())
            if(axis == 'x'):
              vmin, vmax = min(self.minX, self.maxX), max(self.minX, self.maxX)
            else:
              vmin, vmax = min(self.minX_div, self.maxX_div), max(self.minX_div, self.maxX_div)
            # filter for visible ticks
            cond1 = ticks >= vmin
            cond2 = ticks <= vmax
            cond3 = ~np.isclose(ticks, vmin)
            cond4 = ~np.isclose(ticks, vmax)
            ticks = ticks.compress(cond1 & cond2 & cond3 & cond4)
            # create plot coordinates
            if(target == 'resid'):
              minY, maxY = min(self.minResidY, self.maxResidY), max(self.minResidY, self.maxResidY)
            elif(targetAxis in [self.ax, self.ax_div]):
              minY, maxY = min(self.minY, self.maxY), max(self.minY, self.maxY)
            else:
              minY, maxY = min(self.minY2, self.maxY2), max(self.minY2, self.maxY2)
            for entry in ticks:
              lines.append([[entry, entry], [minY, maxY]])
          else:
            # don't draw axis lines for non-displayed second axes
            if((axis != 'y2') or self.isSecondAxesActive()):
              ticks = targetAxis.yaxis.get_majorticklocs()
              if(target == 'resid'):
                vmin, vmax = min(self.minResidY, self.maxResidY), max(self.minResidY, self.maxResidY)
              elif(axis == 'y'):
                vmin, vmax = min(self.minY, self.maxY), max(self.minY, self.maxY)
              else:
                vmin, vmax = min(self.minY2, self.maxY2), max(self.minY2, self.maxY2)
              cond1 = ticks >= vmin
              cond2 = ticks <= vmax
              cond3 = ~np.isclose(ticks, vmin)
              cond4 = ~np.isclose(ticks, vmax)
              ticks = ticks.compress(cond1 & cond2 & cond3 & cond4)
              # create plot coordinates
              if(targetAxis in [self.ax, self.ax2, self.ax_resid]):
                minX, maxX = min(self.minX, self.maxX), max(self.minX, self.maxX)
              else:
                minX, maxX = min(self.minX_div, self.maxX_div), max(self.minX_div, self.maxX_div)
              for entry in ticks:
                lines.append([[minX, maxX], [entry, entry]])
  
          # draw these lines
          for entry in lines:
            drawLine = matplotlib.lines.Line2D(entry[0], entry[1])
            allLineHandles.append(targetAxis.add_line(drawLine))
            # apply styles
            drawLine.set_color(useColor)
            drawLine.set_linewidth(useWidth)
            drawLine.set_linestyle(useStyle)
            drawLine.set_dash_capstyle(useDashStyle)
            drawLine.set_solid_capstyle(useDashStyle)
            drawLine.set_zorder(useZ)
          
        # store them for future manipulation
        if(target == 'plot'):
          self.gridLinesStore[axis].extend(allLineHandles)
        else:
          self.gridLinesStore_resid[axis].extend(allLineHandles)

      # redraw
      if(redraw):
        plotobject.myRefresh()

  def updateTickEntryField(self, axis='x'):
    # updates tick entry field in graphics area when auto is selected
    if(axis in ['x', 'x2', 'y', 'y2', 'resid']):
      # check for existence of graphics tab (during initialization)
      if(axis == 'y2'):
        graphicsarea = 'graphicsarea2'
      else:
        graphicsarea = 'graphicsarea'
      if(hasattr(self.parent, graphicsarea)):
        if(axis == 'x'):
          tickAuto, tickEntry = self.parent.graphicsarea.configTickXAuto, self.parent.graphicsarea.configTickXEntry
        elif(axis == 'x2'):
          tickAuto, tickEntry = self.parent.graphicsarea.configInnerTickXAuto, self.parent.graphicsarea.configInnerTickXEntry
        elif(axis in ['y', 'y2']):
          tickAuto, tickEntry = self.parent.__dict__[graphicsarea].configTickYAuto, self.parent.__dict__[graphicsarea].configTickYEntry
        else:
          tickAuto, tickEntry = self.parent.graphicsarea.configTickResidYAuto, self.parent.graphicsarea.configTickResidYEntry
  
        if(tickAuto.isChecked()):
          nuTicks = self.getAxisTicks(axis)
          tickstr = self.parent.__dict__[graphicsarea].magicTickstring(nuTicks)
          tickEntry.setText(tickstr)

  def changeAxisMode(self, axis='x', redraw=True):
    # changes scale mode of axis
    if(axis == 'x'):
      # adjust axis
      axis_mode = str(self.modeSelectorx.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax.set_xscale(axis_mode)
        self.ax_resid.set_xscale(axis_mode)
      self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax.set_xscale(axis_mode)
        self.ax_resid.set_xscale(axis_mode)
      self.modeX = axis_mode
      # trigger redrawing of fit function with new axis limits and minor ticks
      if(self.modeX == 'linear'):
        # reset minor ticks to 1 when changing to log scale
        if(self.ticksXMinor > 1):
          self.ticksXMinor, targetField = 2, self.parent.graphicsarea.configMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(1)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(1)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksXMinor)
        self.ax.xaxis.set_minor_locator(minorAutoticks)
        self.ax_resid.xaxis.set_minor_locator(minorAutoticks)
        self.ax.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      elif(self.modeX == 'log'):
        # reset minor ticks to 8 when changing to log scale
        if(self.ticksXMinor > 1):
          self.ticksXMinor, targetField = 8, self.parent.graphicsarea.configMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksXMinor + 1)
        self.ax.xaxis.set_minor_locator(minorAutoticks)
        self.ax_resid.xaxis.set_minor_locator(minorAutoticks)
        self.ax.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        
      self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                     handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
      # copy in case split axes are shown
      curve = self.parent.fit[self.parent.activeFit]
      if(self.parent.plotArea.splitY and curve.onBothAxes):
        curve.duplicateForSplit()
      self.handleResidZero = self.plotResidZero(handleResidZero=self.handleResidZero, redraw=False)
      # adjust spine lines if needed
      for spine in ['left', 'right']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.residplot, axisobject=self.ax_resid, target='resid', secondAxes=False)
      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=True)
      
      # update axis grid
      for target in ('plot', 'resid'):
        for item in ('x', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # update tick entry field
      self.updateTickEntryField(axis=axis)
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()
    elif(axis == 'x2'):
      # adjust axis
      axis_mode = str(self.xSplitModeSelectorx.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax_div.set_xscale(axis_mode)
        self.ax2_div.set_xscale(axis_mode)
        self.ax_resid_div.set_xscale(axis_mode)
      self.setAxisLimits(lower = self.minX_div, upper = self.maxX_div, axis = 'x2', updateLabel = False, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower = self.minX_div, upper = self.maxX_div, axis = 'x2', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax_div.set_xscale(axis_mode)
        self.ax2_div.set_xscale(axis_mode)
        self.ax_resid_div.set_xscale(axis_mode)
      self.modeX_div = axis_mode
      # trigger redrawing of fit function with new axis limits and minor ticks
      if(self.modeX_div == 'linear'):
        # reset minor ticks to 1 when changing to log scale
        if(self.ticksXMinor_div > 1):
          self.ticksXMinor_div, targetField = 2, self.parent.graphicsarea.configInnerMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(1)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(1)))
          targetField.blockSignals(False)
        minorAutoticks2 = MyAutoMinorLocator(self.ticksXMinor_div)
        self.ax2_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax_resid_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax2_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      elif(self.modeX_div == 'log'):
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksXMinor_div > 1):
          self.ticksXMinor_div, targetField = 8, self.parent.graphicsarea.configInnerMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks2 = MyAutoMinorLocator(self.ticksXMinor_div + 1)
        self.ax2_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax_resid_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax2_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # need to also call null formatter on overlaid axis to prevent minor labels from showing
        self.ax_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        
      self.parent.fit[self.parent.activeFit].handlePlot_div = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                     handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True)
      # copy in case split axes are shown
      curve = self.parent.fit[self.parent.activeFit]
      if(self.parent.plotArea.splitY and curve.onBothAxes):
        curve.duplicateForSplit()
      self.handleResidZero_div = self.plotResidZero(handleResidZero=self.handleResidZero_div, redraw=False, splitX=True)

      # adjust spine lines if needed
      for spine in ['left', 'right']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax_div, target='plot', secondAxes=False, splitX=True)
          self.setAxisPositionHelper(axis=spine, plotobject=self.residplot, axisobject=self.ax_resid_div, target='resid', secondAxes=False, splitX=True)
      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)

      # update axis grid
      for target in ('plot', 'resid'):
        for item in ('x2', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # update tick entry field
      self.updateTickEntryField(axis=axis)
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()
    elif(axis == 'y'):
      # adjust axis
      axis_mode = str(self.modeSelectory.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax.set_yscale(axis_mode)
      self.setAxisLimits(lower = self.minY, upper = self.maxY, axis = 'y', updateLabel = False, redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax.set_yscale(axis_mode)
      self.modeY = axis_mode
      if(self.modeY == 'linear'):
        # reset minor ticks to 1 when changing to log scale
        if(self.ticksYMinor > 1):
          self.ticksYMinor, targetField = 2, self.parent.graphicsarea.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(1)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(1)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      else:
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksYMinor > 1):
          self.ticksYMinor, targetField = 8, self.parent.graphicsarea.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksYMinor + 1)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      # adjust spine lines if needed
      for spine in ['bottom', 'top']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax_div, target='plot', secondAxes=False, splitX=True)

      # update axis grid
      target = 'plot'
      for item in ('x', 'x2', 'y'):
        if(self.gridVisible[item]):
          self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # update tick entry field
      self.updateTickEntryField(axis=axis)
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
    elif(axis == 'y2'):
      # adjust axis
      axis_mode = str(self.secondModeSelector.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax2.set_yscale(axis_mode)
      self.setAxisLimits(lower = self.minY2, upper = self.maxY2, axis = 'y2', updateLabel = False, redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax2.set_yscale(axis_mode)
      self.modeY2 = axis_mode
      if(self.modeY2 == 'linear'):
        # reset minor ticks to 1 when changing to log scale
        if(self.ticksY2Minor > 1):
          self.ticksY2Minor, targetField = 2, self.parent.graphicsarea2.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(1)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(1)))
          targetField.blockSignals(False)        
        minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
        self.ax2.yaxis.set_minor_locator(minorAutoticks)
        self.ax2.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      else:
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksY2Minor > 1):
          self.ticksY2Minor, targetField = 8, self.parent.graphicsarea2.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)        
        minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor + 1)
        self.ax2.yaxis.set_minor_locator(minorAutoticks)
        self.ax2.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      # adjust spine lines if needed
      for spine in ['bottom', 'top']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=False, splitX=True)

      # update axis grid
      target = 'plot'
      for item in ('x', 'x2', 'y2'):
        if(self.gridVisible[item]):
          if((item != 'y2') or self.isSecondAxesActive()):
            self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # update tick entry field
      self.updateTickEntryField(axis=axis)
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()

  def plotResidZero(self, handleResidZero=None, redraw=False, splitX=False):
    # plots zero line in residuals plot
    if(splitX):
      self.handleResidZero_div = handleResidZero
      # set up data
      xval = [self.minX_div, self.maxX_div]
      yval = [0, 0]
      # do the actual plot
      if(self.handleResidZero_div != None):
        #self.handleData.remove()
        self.handleResidZero_div.set_xdata(xval)
        self.handleResidZero_div.set_ydata(yval)
      else:
        self.handleResidZero_div, = self.ax_resid_div.plot(xval, yval, 'ko', zorder = 0.5  + self.parent.zOffset)
      handleResidZero = self.handleResidZero_div
    else:
      self.handleResidZero = handleResidZero
      # set up data
      xval = [self.minX, self.maxX]
      yval = [0, 0]
      # do the actual plot
      if(self.handleResidZero != None):
        #self.handleData.remove()
        self.handleResidZero.set_xdata(xval)
        self.handleResidZero.set_ydata(yval)
      else:
        self.handleResidZero, = self.ax_resid.plot(xval, yval, 'ko', zorder = 0.5  + self.parent.zOffset)
      handleResidZero = self.handleResidZero
    self.rememberSettingResidLine['init'] = 'ax_resid.plot(' + repr(xval) + ', ' + repr(yval) + ', zorder=' + repr(0.5  + self.parent.zOffset) + ')'
      
    # apply style of fit curve to zero line
    style = self.parent.data[self.parent.activeData].getResidLineStyle()
    for key in style:
      method = 'set_'+key
      if (hasattr(handleResidZero, method)):
        method2call = getattr(handleResidZero, method)
        method2call(style[key])
        self.rememberSettingResidLine[key] = 'set_' + key + '(' + repr(style[key]) + ')'
    # ensure only line is visible but not markers
    if (hasattr(handleResidZero, 'set_linestyle')):
        method2call = getattr(handleResidZero, 'set_linestyle')
        method2call('solid')        
        self.rememberSettingResidLine['linestyle'] = 'set_linestyle(\'solid\')'
    if (hasattr(handleResidZero, 'set_marker')):
        method2call = getattr(handleResidZero, 'set_marker')
        method2call('None')
        self.rememberSettingResidLine['marker'] = 'set_marker(\'None\')'
        
    # do redraw?
    if(redraw):
      self.residplotwidget.myRefresh()
    
    return handleResidZero

  def plotResid(self, dataobject=None, handleResid=None, handleResidZero=None, handleResidBar=None, handleResidStack=None, handleResidStackNeg=None, handleResidText=None, redraw=True, splitX=False, rescale=True):
    # was dataobject specified?
    if(dataobject == None):
      dataobject = self.parent.data[self.parent.activeData]

    if(splitX):
      useAxes = self.ax_resid_div
    else:
      useAxes = self.ax_resid
      
    # analyze data
    xval = dataobject.x
    yval = dataobject.resid
    if(yval.size > 0):
      # plot residuals
      if(handleResid != None):
        handleResid.set_xdata(xval)
        handleResid.set_ydata(yval)
      else:
        handleResid, = useAxes.plot(xval, yval, 'ko', zorder = dataobject.zorder + self.parent.zOffset)
        if(not splitX):
          handleResid.set_pickradius(PICK_TOLERANCE)
        
      # draw bar?
      if(handleResidBar != None):
        handleResidBar.remove()

      if((dataobject.ResidBarstyle['showBar']) and (dataobject.ResidBarstyle['offset'] != 0)):
        # also use this for error bars
        useOffset = dataobject.ResidBarstyle['offset']
      else:
        useOffset = 0
  
      if(dataobject.ResidBarstyle['showBar']):
        barstyle = dataobject.getResidBarStyle()
        if('width' in barstyle):
          usewidth = barstyle['width']
        else:
          usewidth = 0.5

        handleResidBar = useAxes.bar(xval + useOffset, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, align='center', width=usewidth)
      else:
        handleResidBar = None

      # draw stack?
      if(handleResidStack != None):
        handleResidStack.remove()
      if(handleResidStackNeg != None):
        handleResidStackNeg.remove()

      if(dataobject.ResidStackstyle['showStack']):
        posVals = (yval >= 0)
        posCount = [i for i in posVals if i]
        negCount = [i for i in posVals if (not i)]
        if(len(posCount)):
          handleResidStack, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval >= 0), interpolate=True)
          if(not splitX):
            handleResidStack.set_pickradius(PICK_TOLERANCE)
        else:
          handleResidStack = None
        if(len(negCount)):
          handleResidStackNeg, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval < 0), interpolate=True)
          if(not splitX):
            handleResidStackNeg.set_pickradius(PICK_TOLERANCE)
        else:
          handleResidStackNeg = None
      else:
        handleResidStack = None
        handleResidStackNeg = None

      # apply styles
      style = dataobject.getResidStyle()
      for key in style:
        method = 'set_' + key
        if (hasattr(handleResid, method)):
          method2call = getattr(handleResid, method)
          if((key == 'marker') and (style[key] in CUSTOM_MARKERS)):
            method2call(CUSTOM_MARKERS[style[key]])
          elif((key == 'marker') and (not (style[key] in matplotlib.lines.Line2D.markers))):
            # this is to ensure compatibility with future versions that may introduce markers we don't know yet
            method2call('o')
          else:
            method2call(style[key])
      if(not style['doFill']):
        handleResid.set_markerfacecolor('none')

      # draw text labels?
      if(handleResidText != None):
        for entry in handleResidText:
          entry.remove()
        handleResidText = None
          
      if(dataobject.ResidTextstyle['showText']):
        textstyle = dataobject.getResidTextStyle()
        # prepare list of data points
        labels = [''] * len(xval); useYFlag = False
        if(('type' in textstyle) and (textstyle['type'] == 'labels')):
          labels = dataobject.getLabels()
          if(len(labels) != len(xval)):
            labels = [''] * len(xval)
            self.parent.statusbar.showMessage('Cannot use label information, will use y values instead.', self.parent.STATUS_TIME, color='blue')
            useYFlag = True
        comboList = [[i, j, k] for i, j, k  in zip(xval, yval, labels)]
        if(textstyle['skip']):
          comboList = comboList[::textstyle['skip'] + 1]

        if(len(comboList)):
          handleResidText = []
          if(('padX' in textstyle) and ('padY' in textstyle)):
            padX, padY = textstyle['padX'], textstyle['padY']
          else:
            padX, padY = 0.0, 0.0
          for entry in comboList:
            x, y, label = entry
            if(textstyle['type'] == 'x'):
              output = self.parent.formatNumber(x)
            elif((textstyle['type'] == 'y') or useYFlag):
              output = self.parent.formatNumber(y)
            else:
              output = label
            if(len(output)):
              handleResidText.append(useAxes.text(x + padX + useOffset, y + padY, output, horizontalalignment='center', verticalalignment='bottom', zorder=dataobject.zorder + dataobject.relativeZOrderText + self.parent.zOffset))
              handleResidText[-1].set_clip_on(True)

      # plot zero line
      if(splitX):
        self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, False, splitX=True)
        handleResidZero = self.handleResidZero_div
      else:
        self.handleResidZero = self.plotResidZero(self.handleResidZero, False)
        self.handleResidZero.set_pickradius(PICK_TOLERANCE)
        handleResidZero = self.handleResidZero
          
      # adjust x-axis limits to those of main plot
      if((not splitX) and rescale):
        self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      
        # auto adjust y limits
        # need to take care of potential nan and inf values
        procval = [i for i in yval if ((not np.isnan(i)) and (not np.isinf(i)))]
        # do we have selectedData active?
        if(self.parent.selectedData.isLive):
          values, roles = self.parent.selectedData.getData_n_Fit()
          if('resid' in roles):
            residVal = values[:, roles.index('resid')]
            residVal = [i for i in residVal if ((not np.isnan(i)) and (not np.isinf(i)))]
            if(len(residVal) > 1):
              # require at least two data points here
              procval = residVal
        if(len(procval)):
          temp_ylimit = np.max([np.abs(i) for i in procval])
          # ensure minimum limit
          if (temp_ylimit == 0):
            self.maxResidY = self.EPSILON; self.minResidY = -self.EPSILON
          else:
            self.maxResidY = 1.2 * temp_ylimit; self.minResidY = -1.2 * temp_ylimit
          self.setAxisLimits(lower = self.minResidY, upper = self.maxResidY, axis = 'y', updateLabel = True, target='resid', redraw=False, updateGrid=True)
          self.updateTickEntryField(axis='resid')
          
      # apply bar styles
      if(dataobject.ResidBarstyle['showBar']):
        barstyle = dataobject.getResidBarStyle()
        for entry in handleResidBar.patches:
          for key in barstyle:
            method = 'set_' + key
            # treat width differently to avoid recentering of bars upon width change (does not heed center position)
            if ((key != 'width') and (hasattr(entry, method))):
              method2call = getattr(entry, method)
              # extra check b/c of hatchMultiply
              if((key == 'hatch') and ('hatchMultiply' in barstyle)):
                method2call(barstyle[key] * barstyle['hatchMultiply'])
              else:
                method2call(barstyle[key])
            # set alternate color?
            if((entry.get_height() < 0) and ('facecolorAlt' in barstyle)):
              entry.set_facecolor(barstyle['facecolorAlt'])
        # check visibility of entire object
        if(not dataobject.visibilityResid):
          for entry in handleResidBar.patches:
            entry.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.ResidBarstyle['doFill']):
          for entry in handleResidBar.patches:
            entry.set_facecolor('none')
 
      # apply stack styles
      if(dataobject.ResidStackstyle['showStack']):
        stackstyle = dataobject.getResidStackStyle()
        for handle in [handleResidStack, handleResidStackNeg]:
          if(handle != None):
            for key in stackstyle:
              method = 'set_' + key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                # extra check b/c of hatchMultiply
                if((key == 'hatch') and ('hatchMultiply' in stackstyle)):
                  method2call(stackstyle[key] * stackstyle['hatchMultiply'])
                else:
                  method2call(stackstyle[key])
            # set alternate color?
            if((handle == handleResidStackNeg) and ('facecolorAlt' in stackstyle)):
              handle.set_facecolor(stackstyle['facecolorAlt'])
            else:
              handle.set_facecolor(stackstyle['facecolor'])
        # check visibility of entire object
        if(not dataobject.visibilityResid):
          handleResidStack.set_visible(False)
          handleResidStackNeg.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.ResidStackstyle['doFill']):
          for entry in [handleResidStack, handleResidStackNeg]:
            entry.set_facecolor('none')

      # apply text styles
      if(dataobject.ResidTextstyle['showText']):
        textstyle = dataobject.getResidTextStyle()
        if((handleResidText != None) and (len(handleResidText))):
          # apply styles
          for key in textstyle:
            method = 'set_' + key
            if(hasattr(handleResidText[0], method)):
              value = textstyle[key]; safeFont = 'DejaVu Sans'
              for item in handleResidText:
                method2call = getattr(item, method)
                method2call(value)
                if(key == 'fontname'):
                  # test last element descent, should be larger than zero
                  _, _, descent = item._get_layout(self.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    value = safeFont
                    method2call(value)
          # check visibility of entire object
          if(not dataobject.visibilityResid):
            for item in handleResidText:
              if(hasattr(item, 'set_visible')):
                item.set_visible(False)

      # probably not really needed
      if(1):
        if(splitX):
          # assign handles
          self.handleResid_div = handleResid
          self.handleResidZero_div = handleResidZero
          self.handleResidBar_div = handleResidBar
          self.handleResidStack_div = handleResidStack
          self.handleResidStackNeg_div = handleResidStackNeg
          self.handleResidText_div = handleResidText
        else:
          # assign handles
          self.handleResid = handleResid
          self.handleResidZero = handleResidZero
          self.handleResidBar = handleResidBar
          self.handleResidStack = handleResidStack
          self.handleResidStackNeg = handleResidStackNeg
          self.handleResidText = handleResidText

      # draw everything
      if(redraw):
        self.residplotwidget.myRefresh()

      return handleResid, handleResidZero, handleResidBar, handleResidStack, handleResidStackNeg, handleResidText
    else:
      if(handleResid != None):
        handleResid.remove()
      if(handleResidBar != None):
        handleResidBar.remove()
      if(handleResidStack != None):
        handleResidStack.remove()
      if(handleResidStackNeg != None):
        handleResidStackNeg.remove()
      if(handleResidText != None):
        for entry in handleResidText:
          entry.remove()

      return None, handleResidZero, None, None, None, None
    
  def plotData(self, data, dataobject=None, handleData=None, handleErr=None, handleErrShady=None, handleBar=None, handleStack=None, handleStackNeg=None, handleText=None, handleViolin=None, redraw=True, rescale=True, splitX=False, autoIgnoreCurrentY=False):
    # was dataobject specified?
    if(dataobject == None):
      dataobject = self.parent.data[self.parent.activeData]
    
    # analyze data
    xerr, yerr = np.array([]), np.array([])
    if (('x' in data) and ('y' in data)):
      # okay found valid data, now assign values
      xval = data['x']
      yval = data['y']
      
      if ('xerr' in data):
        xerr = data['xerr']
        
      if ('yerr' in data):
        yerr = data['yerr']
        
      # determine which axes to draw on
      if(dataobject.onSecondAxes):
        useAxes = self.ax2
        if(splitX):
          useAxes = self.ax2_div
      else:
        useAxes = self.ax
        if(splitX):
          useAxes = self.ax_div
        
      # can do some plotting
      if((handleData != None) and (handleData.axes == useAxes)):
        handleData.set_xdata(xval)
        handleData.set_ydata(yval)
      else:
        if((handleData != None) and (handleData.axes != useAxes)):
          handleData.remove()
        handleData, = useAxes.plot(xval, yval, 'ko', zorder = dataobject.zorder  + self.parent.zOffset)
      if(not splitX):
        handleData.set_pickradius(PICK_TOLERANCE)
      
      # draw bar?
      if(handleBar != None):
        handleBar.remove()

      if((dataobject.Barstyle['showBar']) and (dataobject.Barstyle['offset'] != 0)):
        # also use this for error bars
        useOffset = dataobject.Barstyle['offset']
      else:
        useOffset = 0
  
      if(dataobject.Barstyle['showBar']):
        barstyle = dataobject.getBarStyle()
        if('width' in barstyle):
          usewidth = barstyle['width']
        else:
          usewidth = 0.5

        handleBar = useAxes.bar(xval + useOffset, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, align='center', width=usewidth)
      else:
        handleBar = None

      # draw stack?
      if(handleStack != None):
        handleStack.remove()
      if(handleStackNeg != None):
        handleStackNeg.remove()

      if(dataobject.Stackstyle['showStack']):
        posVals = (yval >= 0)
        posCount = [i for i in posVals if i]
        negCount = [i for i in posVals if (not i)]
        if(len(posCount)):
          handleStack, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval >= 0), interpolate=True)
          if(not splitX):
            handleStack.set_pickradius(PICK_TOLERANCE)
        else:
          handleStack = None
        if(len(negCount)):
          handleStackNeg, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval < 0), interpolate=True)
          if(not splitX):
            handleStackNeg.set_pickradius(PICK_TOLERANCE)
        else:
          handleStackNeg = None
      else:
        handleStack = None
        handleStackNeg = None

      # draw error bars?
      if (handleErr != None):
        handleErr[0].remove()
        for entry in handleErr[1]:
          entry.remove()
        for entry in handleErr[2]:
          entry.remove()
          
      # prepare errors for drawing them in two direction
      drawXerr, drawYerr = xerr, yerr
      if(dataobject.Errorstyle['direction'] != 'both'):
        if(dataobject.Errorstyle['direction'] == 'negative'):
          if(xerr.size):
            drawXerr = [xerr, 0.0 * xerr]
          if(yerr.size):
            drawYerr = [yerr, 0.0 * yerr]
        else:
          if(xerr.size):
            drawXerr = [0.0 * xerr, xerr]
          if(yerr.size):
            drawYerr = [0.0 * yerr, yerr]
          
      if(xerr.size):
        if(yerr.size):
          handleErr = useAxes.errorbar(xval + useOffset, yval, xerr = drawXerr, yerr = drawYerr, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset, capsize = 1)#, fmt = 'o')
        else:
          handleErr = useAxes.errorbar(xval + useOffset, yval, xerr = drawXerr, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset, capsize = 1)#, fmt = 'o')
      elif(yerr.size):
        handleErr = useAxes.errorbar(xval + useOffset, yval, yerr = drawYerr, zorder = dataobject.zorder + dataobject.relativeZOrderError  + self.parent.zOffset, capsize = 1)#, fmt = 'o')
      else:
        handleErr = None
        
      if(handleErr != None):
        # don't draw the error curve
        handleErr[0].set_linestyle('None')
        handleErr[0].set_marker('None')
        
      # should we draw the error intervals as shaded region?
      if(handleErrShady != None):
        handleErrShady.remove()
        handleErrShady = None
      if((dataobject.ErrorShadystyle['visible']) and (yerr.size)):
        useYerrPos, useYerrNeg = 0.0 * yerr, 0.0 * yerr
        
        if(dataobject.Errorstyle['direction'] in ['both', 'positive']):
          useYerrPos = yerr
        if(dataobject.Errorstyle['direction'] in ['both', 'negative']):
          useYerrNeg = yerr
        handleErrShady = useAxes.fill_between(xval + useOffset, yval - useYerrNeg, yval + useYerrPos, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset - 0.05)
            
      # draw text labels?
      if(handleText != None):
        for entry in handleText:
          entry.remove()
        handleText = None
          
      if(dataobject.Textstyle['showText']):
        textstyle = dataobject.getTextStyle()
        # prepare list of data points
        labels = [''] * len(xval); useYFlag = False
        if(('type' in textstyle) and (textstyle['type'] == 'labels')):
          labels = dataobject.getLabels()
          if(len(labels) != len(xval)):
            labels = [''] * len(xval)
            self.parent.statusbar.showMessage('Cannot use label information, will use y values instead.', self.parent.STATUS_TIME, color='blue')
            useYFlag = True
        comboList = [[i, j, k] for i, j, k  in zip(xval, yval, labels)]
        if(textstyle['skip']):
          comboList = comboList[::textstyle['skip'] + 1]

        if(len(comboList)):
          handleText = []
          if(('padX' in textstyle) and ('padY' in textstyle)):
            padX, padY = textstyle['padX'], textstyle['padY']
          else:
            padX, padY = 0.0, 0.0
          for entry in comboList:
            x, y, label = entry
            if(textstyle['type'] == 'x'):
              output = self.parent.formatNumber(x)
            elif((textstyle['type'] == 'y') or useYFlag):
              output = self.parent.formatNumber(y)
            elif(type(label) in [str, np.str_]):
              output = label
            else:
              output = str(label)
            if(len(output)):
              handleText.append(useAxes.text(x + padX + useOffset, y + padY, output, horizontalalignment='center', verticalalignment='bottom', zorder=dataobject.zorder + dataobject.relativeZOrderText + self.parent.zOffset))
              handleText[-1].set_clip_on(True)
     
      # draw violin plot
      if(handleViolin != None):
        for entry in handleViolin:
          if(type(handleViolin[entry]) == type([])):
            for entry2 in handleViolin[entry]:
              if(hasattr(entry2, 'remove')):
                entry2.remove()
          elif(hasattr(handleViolin[entry], 'remove')):
            handleViolin[entry].remove()
        handleViolin = None
          
      if(dataobject.Violinstyle['mode']):
        # get data organized into vectors
        xvector, yvector = dataobject.collateViolinData()
        if(len(xvector) * len(yvector)):
          if(dataobject.Violinstyle['mode'] == 1):
            if(('bodies' in dataobject.Violinstyle) and ('width' in dataobject.Violinstyle['bodies'])):
              useWidth = dataobject.Violinstyle['bodies']['width']
            else:
              useWidth = 0.5
            handleViolin = useAxes.violinplot(yvector, xvector, vert=True, showmeans=True, showextrema=True, showmedians=True, widths=useWidth)
          else:
            if(('boxes' in dataobject.Violinstyle) and ('width' in dataobject.Violinstyle['boxes'])):
              useWidth = dataobject.Violinstyle['boxes']['width']
            else:
              useWidth = 0.5
            if(('boxes' in dataobject.Violinstyle) and ('boxFill' in dataobject.Violinstyle['boxes'])):
              useFill = dataobject.Violinstyle['boxes']['boxFill']
            else:
              useFill = False
            # check matplotlib version
            version = matplotlib.__version__.split('.')
            if((len(version) > 1) and ((int(version[0]) > 3) or ((int(version[0]) == 3) and (int(version[1]))))):
              handleViolin = useAxes.boxplot(yvector, positions=xvector, manage_ticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})
            else:
              handleViolin = useAxes.boxplot(yvector, positions=xvector, manage_xticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})

      # adjust axis limits
      if(rescale):
        if(splitX):
          useModeX, useAxis, useAutoScale = self.modeX_div, 'x2', self.autoScaleX_div
        else:
          useModeX, useAxis, useAutoScale = self.modeX, 'x', self.autoScaleX
        if(useAutoScale):
          if(xerr.size):
            temp_xmin = np.min([i - j for i, j in zip(xval, xerr)])
            temp_xmax = np.max([i + j for i, j in zip(xval, xerr)])
          else:
            temp_xmin = np.min(xval)
            temp_xmax = np.max(xval)
            
          # check for split x axis
          if(self.splitShow):
            if(splitX):
              temp_xmin = np.max((temp_xmin, self.maxX, self.minX))
            else:
              temp_xmax = np.min((temp_xmax, self.maxX_div, self.minX_div))

          # ensure minimum limit
          if (temp_xmax - temp_xmin < self.EPSILON):
            temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useModeX == 'linear'):
              difference = temp_xmax - temp_xmin

              if((not self.splitShow) or splitX):
                temp_xmax += difference * self.data_spacer
              if((not self.splitShow) or (not splitX)):
                temp_xmin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_x = np.array(xval)
              pos_x = pos_x[pos_x > 0]
              # recalc. xmin to address error when restoring state
              if(len(pos_x > 1)):
                temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                if(self.splitShow and splitX and (np.max((self.minX, self.maxX)) > 0)):
                  posLimits = [i for i  in [self.minX, self.maxX] if (i > 0)]
                  temp_xmin = np.max((temp_xmin, np.max(posLimits)))
                if(self.splitShow and (not splitX) and (np.max((self.minX_div, self.maxX_div)) > 0)):
                  posLimits = [i for i  in [self.minX_div, self.maxX_div] if (i > 0)]
                  temp_xmax = np.min((temp_xmax, np.min(posLimits)))
                difference = np.log(temp_xmax / temp_xmin)
                if((not self.splitShow) or (not splitX)):
                  temp_xmin = np.exp(np.log(temp_xmin) - self.data_spacer * difference)
                if((not self.splitShow) or splitX):
                  temp_xmax = np.exp(np.log(temp_xmax) + self.data_spacer * difference)
                
          self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis=useAxis, updateLabel=True, redraw=False, updateGrid=True)
          self.updateTickEntryField(axis=useAxis)
        
      # determine axis data is plotted on
      if(dataobject.onSecondAxes):
        axis = 'y2'; useMode = self.modeY2; autoCheck = self.autoScaleY2; temp_y = self.y2
      else:
        axis = 'y'; useMode = self.modeY; autoCheck = self.autoScaleY; temp_y = self.y
      # should we ignore the current scale when autozooming?
      if(autoIgnoreCurrentY or (not self.parent.fit[self.parent.activeFit].visibility)):
        temp_y = []

      # it is sufficient to do this for main axes as split axes will follow suit
      if((not splitX) and (autoCheck) and (rescale)):
        if(yerr.size):
          temp_y = np.hstack((temp_y, [i - j for i, j in zip(yval, yerr)], [i + j for i, j in zip(yval, yerr)]))
        else:
          temp_y = np.hstack((temp_y, yval))
        temp_ymin, temp_ymax = np.min(temp_y), np.max(temp_y)
          
        # check for split y axis
        if(self.splitY):
          temp_ymin = np.max((temp_ymin, self.maxY2, self.minY2))
  
        # ensure minimum limit
        if (temp_ymax - temp_ymin < self.EPSILON):
          temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
        elif(self.data_spacer > 0):
          if(useMode == 'linear'):
            difference = temp_ymax - temp_ymin
            temp_ymax += difference * self.data_spacer
            if(not self.splitY):
              temp_ymin -= difference * self.data_spacer
          else:
            # log scale -- isolate positive data
            pos_y = np.array(yval)
            pos_y = pos_y[pos_y > 0]
            if(len(pos_y > 1)):
              temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
              if(self.splitY and (np.max((self.minY2, self.maxY2)) > 0)):
                posLimits = [i for i  in [self.minY2, self.maxY2] if (i > 0)]
                temp_ymin = np.max((temp_ymin, np.max(posLimits)))
              difference = np.log(temp_ymax / temp_ymin)
              if(not self.splitY):
                temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
              temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)

        self.setAxisLimits(lower=temp_ymin, upper=temp_ymax, axis=axis, updateLabel=True, redraw=False, updateGrid=True)
        self.updateTickEntryField(axis=axis)
      
      # apply styles
      dataobject.styleMe(handleData=handleData, handleErr=handleErr, handleErrShady=handleErrShady, handleBar=handleBar,
                         handleStack=handleStack, handleText=handleText, handleViolin=handleViolin)

      # deal with split y axis
      if(self.splitY and dataobject.onBothAxes):
        dataobject.duplicateForSplit(xval=xval, yval=yval, xerr=xerr, yerr=yerr)
        
      # draw everything
      if(redraw):
        self.dataplotwidget.myRefresh()

    # do we need this at all?
    if(1):
      # assign handles
      if(splitX):
        self.handleData_div = handleData
        self.handleErr_div = handleErr
        self.handleErrShady_div = handleErrShady
        self.handleBar_div = handleBar
        self.handleStack_div = handleStack
        self.handleStackNeg_div = handleStackNeg
        self.handleText_div = handleText
        self.handleViolin_div = handleViolin
      else:
        self.handleData = handleData
        self.handleErr = handleErr
        self.handleErrShady = handleErrShady
        self.handleBar = handleBar
        self.handleStack = handleStack
        self.handleStackNeg = handleStackNeg
        self.handleText = handleText
        self.handleViolin = handleViolin
      
    # return handles to graphics objects
    return handleData, handleErr, handleErrShady, handleBar, handleStack, handleStackNeg, handleText, handleViolin
      
  def plotFunction(self, fitobject=None, x=[], handlePlot=None, redraw=True, splitX=False, doAutoZoom=True):
    # was fitobject specified?
    if(fitobject == None):
      fitobject = self.parent.fit[self.parent.activeFit]

    if(splitX):
      # retrieve plot handle
      self.handlePlot_div = handlePlot
      
      # determine which axes to draw on
      if(fitobject.onSecondAxes):
        useAxes = self.ax2_div
      else:
        useAxes = self.ax_div
    else:
      # retrieve plot handle
      self.handlePlot = handlePlot
      
      # determine which axes to draw on
      if(fitobject.onSecondAxes):
        useAxes = self.ax2
      else:
        useAxes = self.ax

    # retrieve restriction information
    restrictMeLow, restrictMeHigh, restrictLow_orig, restrictHigh_orig = fitobject.getRestricted()
    restrictLow, restrictHigh = np.min((restrictLow_orig, restrictHigh_orig)), np.max((restrictLow_orig, restrictHigh_orig))
    
    # was target plot interval specified?
    if(splitX):
      if (len(x)):
        self.x_div = np.array(x)
      else:
        # determine x interval of plot
        xmin, xmax = self.minX_div, self.maxX_div
        if(xmin > xmax):
          restrictMeLow, restrictMeHigh = restrictMeHigh, restrictMeLow
          restrictLow, restrictHigh = restrictHigh, restrictLow
        if(restrictMeLow):
          if(xmin < xmax):
            xmin = np.max((xmin, restrictLow))
          else:
            xmin = np.min((xmin, restrictLow))
        if(restrictMeHigh):
          if(xmin < xmax):
            xmax = np.min((xmax, restrictHigh))
          else:
            xmax = np.max((xmax, restrictHigh))
        if(self.modeX_div == 'linear'):
          self.x_div = np.linspace(xmin, xmax, self.DATAPOINTS_SIMULATION)
        elif(self.modeX_div == 'log'):
          self.x_div = np.linspace(np.log(xmin), np.log(xmax), self.DATAPOINTS_SIMULATION)
          self.x_div = np.exp(self.x_div)
      x = self.x_div

      # calculate function values
      self.x_div, funcY = fitobject.simulateFunc(self.x_div, splitX=True)
      if(fitobject.onSecondAxes):
        self.y_div, self.y2_div = np.array([]), funcY
      else:
        self.y_div, self.y2_div = funcY, np.array([])

      # can do some plotting
      if((self.handlePlot_div != None) and (self.handlePlot_div.axes == useAxes)):
        self.handlePlot_div.set_xdata(self.x_div)
        self.handlePlot_div.set_ydata(funcY)
      else:
        if((self.handlePlot_div != None) and (self.handlePlot_div.axes != useAxes)):
          self.handlePlot_div.remove()
        self.handlePlot_div, = useAxes.plot(self.x_div, funcY, zorder = fitobject.zorder + self.parent.zOffset)
      handlePlot = self.handlePlot_div
    else:
      if (len(x)):
        self.x = np.array(x)
      else:
        # determine x interval of plot
        xmin, xmax = self.minX, self.maxX
        if(xmin > xmax):
          restrictMeLow, restrictMeHigh = restrictMeHigh, restrictMeLow
          restrictLow, restrictHigh = restrictHigh, restrictLow
        if(restrictMeLow):
          if(xmin < xmax):
            xmin = np.max((xmin, restrictLow))
          else:
            xmin = np.min((xmin, restrictLow))
        if(restrictMeHigh):
          if(xmin < xmax):
            xmax = np.min((xmax, restrictHigh))
          else:
            xmax = np.max((xmax, restrictHigh))
        if(self.modeX == 'linear'):
          self.x = np.linspace(xmin, xmax, self.DATAPOINTS_SIMULATION)
        elif(self.modeX == 'log'):
          self.x = np.linspace(np.log(xmin), np.log(xmax), self.DATAPOINTS_SIMULATION)
          self.x = np.exp(self.x)
      x = self.x
      ###print('limits', xmin, xmax, '\nrestrictMe', restrictMeLow, restrictMeHigh, '\nrestrictions', restrictLow, restrictHigh, '\n\n')
    
      # calculate function values
      self.x, funcY = fitobject.simulateFunc(self.x)
      if(fitobject.onSecondAxes):
        self.y, self.y2 = np.array([]), funcY
      else:
        self.y, self.y2 = funcY, np.array([])

      # can do some plotting
      if((self.handlePlot != None) and (self.handlePlot.axes == useAxes)):
        self.handlePlot.set_xdata(self.x)
        self.handlePlot.set_ydata(funcY)
      else:
        if((self.handlePlot != None) and (self.handlePlot.axes != useAxes)):
          self.handlePlot.remove()
        self.handlePlot, = useAxes.plot(self.x, funcY, zorder = fitobject.zorder + self.parent.zOffset)
      handlePlot = self.handlePlot
      self.handlePlot.set_pickradius(PICK_TOLERANCE)
  
      # determine axis data is plotted on
      if(fitobject.onSecondAxes):
        axis = 'y2'; useMode = self.modeY2; autoCheck = self.autoScaleY2
      else:
        axis = 'y'; useMode = self.modeY; autoCheck = self.autoScaleY

      # adjust y limits
      if(autoCheck and doAutoZoom):
        # check whether currently plotted curve is visible
        if(fitobject.visibility):
          zoomY = funcY
        else:
          # if invisible, don't consider for autoscaling
          zoomY = np.array([])
        # check if data is loaded
        if(('y' in self.parent.data[self.parent.activeData].value()) and (fitobject.onSecondAxes == self.parent.data[self.parent.activeData].onSecondAxes)):
          temp_data = self.parent.data[self.parent.activeData].value()
          if(('yerr' in temp_data) and (len(temp_data['yerr']))):
            temp_data1 = [i - j for i, j in zip(temp_data['y'], temp_data['yerr'])]
            temp_data2 = [i + j for i, j in zip(temp_data['y'], temp_data['yerr'])]
            temp_y = np.hstack((zoomY, temp_data1, temp_data2))
          else:
            temp_y = np.hstack((zoomY, temp_data['y']))
        else:
          temp_y = zoomY
  
        temp_y = temp_y[np.isfinite(temp_y)]
        
        # check to account for inf/nan only curves
        if(len(temp_y)):
          temp_ymin = np.min(temp_y)
          temp_ymax = np.max(temp_y)
            
          # check for split y axis
          if(self.splitY):
            if(axis == 'y'):
              temp_ymin = np.max((temp_ymin, self.maxY2, self.minY2))
            else:
              temp_ymax = np.min((temp_ymax, self.maxY, self.minY))
  
          # ensure minimum limit
          if(temp_ymax - temp_ymin < self.EPSILON):
            temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useMode == 'linear'):
              difference = temp_ymax - temp_ymin
              if((not self.splitY) or (axis == 'y')):
                temp_ymax += difference * self.data_spacer
              if((not self.splitY) or (axis == 'y2')):
                temp_ymin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_y = np.array(temp_y)
              pos_y = pos_y[pos_y > 0]
              if(len(pos_y > 1)):
                #difference = np.log(pos_y[-1] / pos_y[0])
                temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                if(self.splitY and (axis == 'y') and (np.max((self.minY2, self.maxY2)) > 0)):
                  posLimits = [i for i  in [self.minY2, self.maxY2] if (i > 0)]
                  temp_ymin = np.max((temp_ymin, np.max(posLimits)))
                if(self.splitY and (axis == 'y2') and (np.max((self.minY, self.maxY)) > 0)):
                  posLimits = [i for i  in [self.minY, self.maxY] if (i > 0)]
                  temp_ymax = np.min((temp_ymax, np.min(posLimits)))
                difference = np.log(temp_ymax / temp_ymin)
                if((not self.splitY) or (axis == 'y2')):
                  temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
                if((not self.splitY) or (axis == 'y')):
                  temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)
        else:
          if(fitobject.onSecondAxes):
            temp_ymin, temp_ymax = self.minY2, self.maxY2
          else:
            temp_ymin, temp_ymax = self.minY, self.maxY
  
        self.setAxisLimits(lower=temp_ymin, upper=temp_ymax, axis=axis, updateLabel=True, redraw=False, updateGrid=True)
        self.updateTickEntryField(axis=axis)
    
    # apply styles
    fitobject.styleMe(handlePlot=handlePlot)
      
    # and finally draw everything
    if(redraw):
      self.dataplotwidget.myRefresh()

    # return handles to graphics
    return handlePlot

class BruteWindow(QtWidgets.QMainWindow):
  def __init__(self, parent=None, title=' '):
    super(BruteWindow, self).__init__()
    self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
    self.parent = parent
    self.title = title
    self.setWindowTitle(self.title)
    
    self.centralwidget = QWidgetMac(self)
    self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(250), scaledDPI(100)))
    self.centralwidget.setMaximumSize(QtCore.QSize(scaledDPI(250), scaledDPI(100)))
    self.setCentralWidget(self.centralwidget)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.messageLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel)

    self.messageLabel2 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel2)

    self.messageLabel3 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel3)

    self.messageLabel4 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel4)

    self.buttonContainer = QtWidgets.QWidget()
    self.hLayout = QtWidgets.QHBoxLayout(self.buttonContainer)
    self.hLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.buttonContainer)
    
    self.closeButton = QPushButtonMac()
    self.closeButton.setText('Stop')
    self.closeButton.setToolTip('Terminate random parameter search.')
    self.closeButton.clicked.connect(self.close)
    self.hLayout.addWidget(self.closeButton)
    
    self.resetButton = QPushButtonMac()
    self.resetButton.setText('Restart')
    self.resetButton.setToolTip('Restart this cycle.')
    self.resetButton.clicked.connect(self.restartCycle)
    self.hLayout.addWidget(self.resetButton)
    
  def closeEvent(self, event):
    # stop fit procedure in parent window
    self.parent.runFlag = False
    
  def restartCycle(self):
    # restarts the current random search cycle
    self.parent.restartFlag = True

class MinWindow(QtWidgets.QMainWindow):
  def __init__(self, parent=None, title=' '):
    super(MinWindow, self).__init__()
    self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
    self.parent = parent
    self.title = title
    self.setWindowTitle(self.title)
    
    self.centralwidget = QWidgetMac(self)
    self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(250), scaledDPI(90)))
    self.centralwidget.setMaximumSize(QtCore.QSize(scaledDPI(250), scaledDPI(90)))
    self.setCentralWidget(self.centralwidget)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.messageLabel = QtWidgets.QLabel(self.title)
    self.vLayout.addWidget(self.messageLabel)

    self.iterLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.iterLabel)

    self.minLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.minLabel)

    self.closeButton = QPushButtonMac()
    self.closeButton.setText('Stop')
    self.closeButton.setToolTip('Terminate numerical minimization.')
    self.closeButton.clicked.connect(self.close)
    self.vLayout.addWidget(self.closeButton)
    
  def closeEvent(self,event):
    # stop fit procedure in parent window
    self.parent.runFlag = False
    self.parent.daughterWindow = None

# a custom QTextEdit
class myQTextEditBase(QtWidgets.QTextEdit):
  def __init__(self, parent = None):
    super(myQTextEditBase, self).__init__(parent)
    self.parent = parent

    self.parent = parent
    # for some reason need to explicitly set QSTYLE again -- could be due to nested widgets?! unclear
    if(QSTYLE != None):
      self.setStyle(QSTYLE)

    self.installEventFilter(self)

  def eventFilter(self, source, event):
    # filters events to allow dynamic display of tooltips
    if(self.toolTip()):
      # this button has a tooltip alright
      if((event.type() == QtCore.QEvent.ToolTip) and (not myapp.toolTipsShow)):
        # ignore this one
        return True

    return QtWidgets.QWidget.eventFilter(self, source, event)

class myQTextEdit(myQTextEditBase):
  def __init__(self, parent = None):
    super(myQTextEdit, self).__init__(parent)
    self.parent = parent
    self._originalFocusInEvent = QtWidgets.QTextEdit.focusInEvent
    # stuff for updating line numbers
    self.lineNumbersField = None
    self.textChanged.connect(self.textChangedCallback)
    self.currLineCount = 0
    self.verticalScrollBar().valueChanged.connect(self.scrollCallback)
    self.setAcceptRichText(False)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    # don't use palettes as these are incompatible with style sheets
    self.setStyleSheet('myQTextEdit {background-color: white; border-left-style: none;}')
    
  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Save):
      if(self.parent != None):
        self.parent.saveFit()
    elif(event.matches(QtGui.QKeySequence.ZoomIn)):
      self.zoomli(1)
      event.accept()
    elif(event.matches(QtGui.QKeySequence.ZoomOut)):
      self.zoomli(-1)
      event.accept()
    elif(event.matches(QtGui.QKeySequence.Open) or event.matches(QtGui.QKeySequence.HelpContents)\
      or event.matches(QtGui.QKeySequence.Print) or event.matches(QtGui.QKeySequence.Quit) or event.matches(QtGui.QKeySequence.Italic)\
      or event.matches(QtGui.QKeySequence.Find)\
      or event.matches(QtGui.QKeySequence.New) or event.matches(QtGui.QKeySequence.Refresh) or event.matches(QtGui.QKeySequence.FindNext)):
      # pass through event
      event.ignore()
    else:
      QtWidgets.QTextEdit.keyPressEvent(self, event)
      # prevent event from triggering main ui as well
      event.accept()
      
  def textChangedCallback(self):
    # check whether this altered the number of lines
    lineCount = self.document().lineCount()
    if(lineCount != self.currLineCount):
      self.currLineCount = lineCount
      if(self.lineNumbersField != None):
        lineText = '\n'.join([str(i + 1) for i in range(lineCount)])
        self.lineNumbersField.setText(lineText)
        useWidth = self.lineNumbersField.fontMetrics().width(str(lineCount)) + scaledDPI(8)
        self.lineNumbersField.setMinimumWidth(useWidth)
        self.lineNumbersField.setMaximumWidth(useWidth)
        # issue scroll update (required to keep track during editing)
        self.scrollCallback()
        
  def scrollCallback(self):
    # check whether text edit has been scrolled
    value = self.verticalScrollBar().value()
    if(self.lineNumbersField != None):
      self.lineNumbersField.verticalScrollBar().setValue(value)

  def wheelEvent(self, event):
    # adjusts zoom level when Ctrl is pressed also
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if(modifiers & QtCore.Qt.ControlModifier):
      if(event.angleDelta().y() > 0):
        self.zoomli(1)
      else:
        self.zoomli(-1)
    else:
      # normal event handling
      QtWidgets.QTextEdit.wheelEvent(self, event)
    
  def zoomli(self, direction):
    if(direction == 1):
      self.zoomIn()
      if(self.lineNumbersField != None):
        self.lineNumbersField.zoomIn()
    else:
      self.zoomOut()
      if(self.lineNumbersField != None):
        self.lineNumbersField.zoomOut()

    # adjust width of line numbers field
    if(self.lineNumbersField != None):
      useWidth = self.lineNumbersField.fontMetrics().width(str(self.document().lineCount())) + scaledDPI(8)
      self.lineNumbersField.setMinimumWidth(useWidth)
      self.lineNumbersField.setMaximumWidth(useWidth)

# class for display of line numbers
class myQTextEditLineNumbers(myQTextEditBase):
  def __init__(self, parent = None):
    super(myQTextEditLineNumbers, self).__init__(parent)
    self.parent = parent
    # initialize settings
    self.setText('1')
    self.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.setReadOnly(True)
    self.setEnabled(False)
    self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.setStyleSheet('myQTextEditLineNumbers {background-color: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0, stop: 0 #b0aae8, stop: 0.3 #9288e8, stop: 0.8 #9288e8, stop: 1.0 #8077e8); color: white; font-weight: bold; text-align: right; border-right-style: none;}')

class GlobalArea(QWidgetMac):
  def __init__(self, parent=None):
    super(GlobalArea, self).__init__()
    self.parent = parent
    self.validFloat = MyValidFloat()
    self.globalParamsCollate = {}
    self.globalParam_active = []
    self.globalParamNames = []
    self.globalParamValues = []
    self.globalParamFlag = []
    self.globalConfidence = []
    self.globalConfidence_apriori = []
    self.globalParam_lower, self.globalParam_upper =  [], []
    self.chisquare, self.red_chisquare = 0, 0
    self.storeGlobalParam = []
    self.fitGlobalResultsHeader = '<h3>Latest global fit results</h3><br>'
    self.globalOutstring = self.fitGlobalResultsHeader
    self.globalCovar, self.globalCovarParameters = [], []
    
    # use epsilon as minimum error value and for calculating derivatives
    self.EPSILON = 1e-9
    # define amplitude threshold for random variation of parameters
    self.MIN_AMPLITUDE = 0.5

    # advanced export settings
    self.advancedMinimization = {'algorithm': 'Nelder-Mead', 'xtol': 1e-8, 'maxfev': 1e5}
    self.advancedRandomSearch = {'cycles': 5, 'escalate': 1.5, 'maxfev': 5e3}

    # locally import numpy again
    import numpy as np
    # import common functions from numpy for ease of access (and for consistency with local fitting)
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Vertical)
    self.vLayout.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)

    # specify data sets and associated curves
    self.dataSetContainer = QWidgetMac()
    self.masterwidget.addWidget(self.dataSetContainer)
    self.LayoutDataSetContainer = QtWidgets.QVBoxLayout(self.dataSetContainer)
    self.LayoutDataSetContainer.setContentsMargins(0, scaledDPI(5), 0, 0)

    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data sets and curves')
    self.dataSetLabel
    self.LayoutDataSetContainer.addWidget(self.dataSetLabel)

    self.dataSetTable = QtWidgets.QTableWidget()
    self.dataSetTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.dataSetTable.setEnabled(True)
    self.dataSetTable.setColumnCount(4)
    self.dataSetTable.setRowCount(1)
    self.dataSetTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Use?'))
    self.dataSetTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Item'))
    self.dataSetTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Curve'))
    self.dataSetTable.setHorizontalHeaderItem(3, QtWidgets.QTableWidgetItem('Params'))
    self.LayoutDataSetContainer.addWidget(self.dataSetTable)

    blah = self.HLine()
    self.LayoutDataSetContainer.addWidget(blah)
    
    # global parameter table
    self.parameterTableContainer = QWidgetMac()
    self.masterwidget.addWidget(self.parameterTableContainer)
    self.LayoutParameterTableContainer = QtWidgets.QVBoxLayout(self.parameterTableContainer)
    self.LayoutParameterTableContainer.setContentsMargins(0, 0, 0, 0)

    self.parameterLabelContainer = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.parameterLabelContainer)
    self.LayoutParameterLabelContainer = QtWidgets.QHBoxLayout(self.parameterLabelContainer)
    self.LayoutParameterLabelContainer.setContentsMargins(0, 0, 0, 0)

    self.parameterLabel = QtWidgets.QLabel()
    useFont = self.parameterLabel.font()
    useFont.setBold(True)
    self.parameterLabel.setFont(useFont)
    self.parameterLabel.setText('Parameters Local /')
    self.LayoutParameterLabelContainer.addWidget(self.parameterLabel)
    self.parameterLabel2 = QtWidgets.QLabel()
    useFont = self.parameterLabel2.font()
    useFont.setBold(True)
    self.parameterLabel2.setFont(useFont)
    self.parameterLabel2.setText('Global')
    self.parameterLabel2.setStyleSheet('color: blue;')
    self.LayoutParameterLabelContainer.addWidget(self.parameterLabel2)
    self.LayoutParameterLabelContainer.addStretch()

    self.globalParamTable = QtWidgets.QTableWidget()
    self.globalParamTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.globalParamTable.setEnabled(True)
    self.globalParamTable.setColumnCount(5)
    self.globalParamTable.setRowCount(1)
    self.globalParamTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Fit'))
    self.globalParamTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Value'))
    self.globalParamTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Error'))
    item3 = QtWidgets.QTableWidgetItem('a priori')
    useFont = item3.font()
    useFont.setItalic(True)
    item3.setFont(useFont)
    self.globalParamTable.setHorizontalHeaderItem(3, item3)
    self.globalParamTable.setHorizontalHeaderItem(4, QtWidgets.QTableWidgetItem('Boundaries'))
    self.LayoutParameterTableContainer.addWidget(self.globalParamTable)

    # set fit controls
    self.ButtonContainer = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.ButtonContainer)
    self.LayoutButtonContainer = QtWidgets.QHBoxLayout(self.ButtonContainer)
    self.LayoutButtonContainer.setContentsMargins(0, 0, 0, 0)

    # set up Fit button
    self.doGlobalFitButton = QPushButtonMac()
    self.doGlobalFitButton.setText('Global Fit')
    self.doGlobalFitButton.setToolTip('Perform global least-squares fit')
    self.doGlobalFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalFitButton.clicked.connect(self.doGlobalFit)
    self.LayoutButtonContainer.addWidget(self.doGlobalFitButton)

    # set up minimize button
    self.doGlobalMinButton = QPushButtonMac()
    self.doGlobalMinButton.setText('Global ' + self.advancedMinimization['algorithm'] + ' Min.')
    self.doGlobalMinButton.setToolTip('Perform global numerical minimization')
    self.doGlobalMinButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalMinButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalMinButton.clicked.connect(self.doGlobalMin)
    self.LayoutButtonContainer.addWidget(self.doGlobalMinButton)

    # set up random fit button
    self.doGlobalBruteButton = QPushButtonMac()
    self.doGlobalBruteButton.setToolTip('Perform global random search of parameters')
    self.doGlobalBruteButton.setText('Random Search')
    self.doGlobalBruteButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalBruteButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalBruteButton.clicked.connect(self.doBruteGlobalFit)
    self.LayoutButtonContainer.addWidget(self.doGlobalBruteButton)

    # set up Reset button
    self.resetGlobalButton = QPushButtonMac()
    self.resetGlobalButton.setText('Reset Parameters')
    self.resetGlobalButton.setToolTip('Reset global function parameters to previous values')
    self.resetGlobalButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.resetGlobalButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resetGlobalButton.clicked.connect(self.resetGlobalParam)
    self.LayoutButtonContainer.addWidget(self.resetGlobalButton)

    # global fit results
    self.globalFitResultsContainer = QWidgetMac()
    self.masterwidget.addWidget(self.globalFitResultsContainer)
    self.LayoutGlobalFitResultsContainer = QtWidgets.QVBoxLayout(self.globalFitResultsContainer)
    self.LayoutGlobalFitResultsContainer.setContentsMargins(0, 0, 0, 0)
    
    # set up text edit field for displaying fit results
    blah = self.HLine()
    self.LayoutGlobalFitResultsContainer.addWidget(blah)
    self.globalFitResults = myQTextEditBase()
    self.globalFitResults.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.globalFitResults.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutGlobalFitResultsContainer.addWidget(self.globalFitResults)
    self.globalFitResults.setReadOnly(True)
    self.globalFitResults.setText(self.fitGlobalResultsHeader)
    self.globalFitResults.setToolTip('Results from previous global least-squares fit')
    
    # set up button for display of covariances
    self.globalCovarButton = QPushButtonMac(self.globalFitResults)
    self.globalCovarButton.setText('Covariances')
    self.globalCovarButton.setToolTip('Display covariances from previous global least-squares fit')
    self.globalCovarButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.globalCovarButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.globalCovarButton.clicked.connect(self.displayGlobalCovar)
    self.globalFitResults.resizeEvent = self.customResize
    self.repositionGlobalCovarButton()
    self.globalCovarButton.hide()

    # update
    self.updateDataSetTable()

  def reportState(self):
    # reports contents for saveState function
    return self.globalFitResults.toHtml() + '\n'

  def restoreState(self, data):
    # restores contents from loadState function
    if(type(data) == type([])):
      self.globalFitResults.setText('\n'.join(data))

  def customResize(self, event):
    # hijack resize event to allow repositioning of covariance button
    myQTextEditBase.resizeEvent(self.globalFitResults, event)
    if(hasattr(self, 'globalCovarButton')):
      self.repositionGlobalCovarButton()

  def repositionGlobalCovarButton(self):
    # dynamically adjusts position of covariance button
    topRight = self.globalFitResults.rect().topRight()
    width = self.globalCovarButton.geometry().width()
    scrollbar = self.globalFitResults.verticalScrollBar().sizeHint().width()
    self.globalCovarButton.move(QtCore.QPoint(topRight.x() - width - scrollbar, topRight.y()))

  def displayGlobalCovar(self):
    # opens new window for display of covariances
    if(len(self.globalCovar)):
      if(not (hasattr(self.parent, 'covarWindow'))):
        self.parent.covarWindow = CovarWindow()
        self.parent.covarWindow.setWindowTitle('Global Covariances')
      self.parent.covarWindow.covarLabel.setText('Normalized Global Covariances')
      self.parent.covarWindow.move(QtGui.QCursor.pos())

      # populate covariance table
      self.parent.covarWindow.populateCovariances(names=self.globalCovarParameters, covar=self.globalCovar)
      
      # apply styles and show
      if(QSTYLE != None):
        self.parent.covarWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.parent.covarWindow.setStyleSheet(QSTYLESHEET)
      self.parent.covarWindow.show()
      self.parent.covarWindow.activateWindow()
      self.parent.covarWindow.focusNextChild()

  def updateBruteGlobalParam(self, culledDataSets=[], nop=[], updateResid=False):
    # update global fit parameters once found better resid
    counter = 0
    for index, entry in enumerate(self.globalParam_active):
      if (entry == 1):
        self.globalParamValues[index] = self.globalParam_active_list[counter]
        counter += 1

    # update parameter tables
    # updateGlobalParamTable() too brutal at this point, find a more benign way
    ###self.updateGlobalParamTable(fitted=True)
    self.changeGlobalParamTable()
    # update parameter table for current curve
    self.parent.fitarea.changeParamTable()

    # update individual curves
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    selectedCurves = [self.parent.data[index].globalFitCurve for index in selectedDataSets]
    selectedCurves = list(set(selectedCurves))
    for index in selectedCurves:
      # update params as needed
      paramUpdateNames, paramUpdateValues = [], []
      for entry in self.parent.fit[index].paramNames:
        if(entry in self.globalParamNames):
          paramUpdateNames.append(entry)
          paramUpdateValues.append(self.globalParamValues[self.globalParamNames.index(entry)])
      self.parent.fit[index].updateParamSelect(paramUpdateNames, paramUpdateValues)

      if(index != self.parent.activeFit):
        self.updateNonActiveCurve(index, redefine=False)
      else:
        self.updateActiveCurve()
      # plot function
      self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
      self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)
      # copy in case split axes are shown
      curve = self.parent.fit[index]
      if(self.parent.plotArea.splitY and curve.onBothAxes):
        curve.duplicateForSplit()

    # update residuals in data sets
    if(updateResid):
      for index, dataSetNumber in enumerate(culledDataSets):
        if(not index):
          self.parent.data[dataSetNumber].setFval(self.globalFval[:nop[index]])
        elif(index < len(culledDataSets) - 1):
          self.parent.data[dataSetNumber].setFval(self.globalFval[sum(nop[:index]):sum(nop[:index + 1])])
        else:
          self.parent.data[dataSetNumber].setFval(self.globalFval[sum(nop[:index]):])
  
        # do the actual plot
        curveIndex = self.parent.data[index].globalFitCurve
        # generate resid style on the fly
        self.parent.data[index].Residstyle.update(self.parent.data[index].style)
        self.parent.data[index].ResidBarstyle.update(self.parent.data[index].Barstyle)
        self.parent.data[index].ResidStackstyle.update(self.parent.data[index].Stackstyle)
        self.parent.data[index].ResidTextstyle.update(self.parent.data[index].Textstyle)
        for item in ['linewidth', 'linestyle', 'color']:
          self.parent.data[index].ResidLinestyle[item] = deepcopy(self.parent.fit[curveIndex].style[item])
        # ensure line is visible to connect dots
        if(self.parent.data[index].Residstyle['linestyle'] == 'None'):
          self.parent.data[index].Residstyle['linestyle'] = 'solid'
        # plot residuals
        self.parent.data[index].handleResid, self.parent.plotArea.handleResidZero,\
          self.parent.data[index].handleResidBar, self.parent.data[index].handleResidStack, self.parent.data[index].handleResidStackNeg, self.parent.data[index].handleResidText = self.parent.plotArea.plotResid(\
          dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid,\
          handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[index].handleResidBar,\
          handleResidStack = self.parent.data[index].handleResidStack, handleResidStackNeg = self.parent.data[index].handleResidStackNeg,\
          handleResidText = self.parent.data[index].handleResidText, redraw=False)
        self.parent.data[index].handleResid_div, self.parent.plotArea.handleResidZero_div,\
          self.parent.data[index].handleResidBar_div, self.parent.data[index].handleResidStack_div, self.parent.data[index].handleResidStackNeg_div, self.parent.data[index].handleResidText_div = self.parent.plotArea.plotResid(\
          dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid_div,\
          handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[index].handleResidBar_div,\
          handleResidStack = self.parent.data[index].handleResidStack_div, handleResidStackNeg = self.parent.data[index].handleResidStackNeg_div,\
          handleResidText = self.parent.data[index].handleResidText_div, redraw=False, splitX=True)

      # issue plot updates
      self.parent.plotArea.residplotwidget.myRefresh()

    # issue plot updates
    self.parent.plotArea.dataplotwidget.myRefresh()

  def getGlobalRelativeDerivatives(self):
    # determine derivatives of fit parameters
    # define helper function to calc. square deviations
    def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
      self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
      globalResid = (self.globalY - self.globalFval) / self.globalYerr
      globalResid = globalResid ** 2
      self.currGlobalResid = np.sum(globalResid)
      return self.currGlobalResid
        
    # probe sensitivity of parameters
    globalParam = [i for i in self.globalParam_active_list]
    self.globalStartVal = self.XX__monster_Ffunc_(self.globalX, *globalParam)
    self.globalStartResid = XX_monster_minWrapper(globalParam)

    # cycle through parameters and calc. derivatives
    for index, entry in enumerate(self.globalParam_active_list):
      globalWorkParam = [i for i in self.globalParam_active_list]
      globalWorkParam[index] *= (1.0 + self.EPSILON)
      globalPerturbResid = XX_monster_minWrapper(globalWorkParam)
      # calc. change in chi square when varying a certain parameter
      self.globalDerivatives[index] = (globalPerturbResid - self.globalStartResid)

    # now also assign amplitudes for random parameter variation
    self.globalRandomAmplitudes = np.array([1.0/i if i != 0 else 0 for i in self.globalDerivatives])
          
    # calc. relative amplitudes
    divisor = np.max(np.abs(self.globalRandomAmplitudes))
    divisor = np.max((divisor, self.EPSILON))
    self.globalRandomAmplitudes = self.globalRandomAmplitudes / divisor / 2.0

  def doBruteGlobalFit(self):
    if(self.doGlobalHelper(modus='random search')):
      # if selected dataset exists, clear it
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.clearMe(redraw=False)

      # and we are ready to gogog!
      self.globalParam_active_list = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
      self.globalParam_lower_list = [self.globalParam_lower[i] for i, j in enumerate(self.globalParam_active) if j]
      self.globalParam_upper_list = [self.globalParam_upper[i] for i, j in enumerate(self.globalParam_active) if j]
      # ensure that we start within bounds
      self.globalParam_active_list = [min(max(init, lower), upper) for init, lower, upper in \
                                zip(self.globalParam_active_list, self.globalParam_lower_list, self.globalParam_upper_list)]
      self.globalOrigParam = [i for i in self.globalParam_active_list]
      self.daughterWindow = None
      self.runFlag = True
      self.restartFlag = False
      try:
        # define helper function to calc. square deviations
        def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
          self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
          globalResid = (self.globalY - self.globalFval) / self.globalYerr
          globalResid = globalResid ** 2
          self.currGlobalResid = np.sum(globalResid)
          return self.currGlobalResid
        
        # display busy pointer
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))

        # open an extra window to interact with procedure
        self.daughterWindow = BruteWindow(self, 'Global Random Search')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
  
        # now do the minimization
        # cycle until daughter window closed
        movingCursor = '|,/,-,\\'.split(',')
        cursorCount = 0
        repeatCycleLimit, escalate, lastSuccessLimit = self.advancedRandomSearch['cycles'],\
          self.advancedRandomSearch['escalate'], self.advancedRandomSearch['maxfev']
        escalate = [escalate ** i for i in range(repeatCycleLimit)]
        residstr = ''
        repeatCycleCount = 0
        while repeatCycleCount < repeatCycleLimit:
          # update message label
          self.daughterWindow.messageLabel.setText('Repeat cycle ' + str(repeatCycleCount + 1) + '/' + str(repeatCycleLimit))
          
          # parameter derivatives
          self.globalDerivatives = np.zeros(len(self.globalParam_active_list))
          self.getGlobalRelativeDerivatives()
          self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.globalStartResid) + residstr)
        
          lastSuccessCount = 0
          while ((lastSuccessCount < lastSuccessLimit) and (self.runFlag) and (not self.restartFlag)):
            # randomly vary parameters
            for trial in range(100):
              if(not self.restartFlag):
                lastSuccessCount += 1
                # randomly vary parameters -- add epsilon to get rid of zero parameters
                globalWorkamplitude = [i if (np.abs(i) > self.MIN_AMPLITUDE) else (np.sign(i + 1.1 * self.EPSILON) * self.MIN_AMPLITUDE) for i in self.globalParam_active_list]
                globalWorkamplitude = escalate[repeatCycleCount] * np.array(globalWorkamplitude)
                globalWorkParam = self.globalParam_active_list  + (globalWorkamplitude * (0.33 - np.random.random(len(self.globalParam_active_list))))
                # ensure that we start within bounds
                globalWorkParam = [min(max(init, lower), upper) for init, lower, upper in \
                                   zip(globalWorkParam, self.globalParam_lower_list, self.globalParam_upper_list)]
                globalPerturbResid = XX_monster_minWrapper(globalWorkParam)
                
                if(globalPerturbResid < self.globalStartResid):
                  # improvement, yeah!
                  # update params
                  self.globalParam_active_list = [i for i in globalWorkParam]
                  self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=False)
                  # prepare new round of random search
                  self.getGlobalRelativeDerivatives()
                  self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.globalStartResid) + residstr)
                  lastSuccessCount = 0
                  self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
                    lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            
            # periodically update label in daughter window
            cursorCount += 1
            if(cursorCount >= len(movingCursor)):
              cursorCount = 0
            self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
              lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            self.daughterWindow.messageLabel4.setText('Working ' + movingCursor[cursorCount])
            # need to still process events
            QtCore.QCoreApplication.processEvents()

          if((residstr == '') or (self.globalStartResid < self.globalBestResid)):
            # first cycle or improvement
            self.globalBestParam = [i for i in self.globalParam_active_list]
            self.globalBestVal = 1.0 * self.globalStartVal
            self.globalBestResid = 1.0 * self.globalStartResid
            residstr = '; best ' + self.parent.formatNumber(self.globalBestResid)

          # reset original parameters for next cycle
          self.globalParam_active_list = [i for i in self.globalOrigParam]

          # advance cycle counter
          if(self.restartFlag):
            self.restartFlag = False
          else:
            repeatCycleCount += 1

        # finished
        success = True
      except:
        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()
        self.parent.statusbar.showMessage('Encountered some problem when conducting random search!', self.parent.STATUS_TIME)
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        success = False
        return False

      # restore pointer
      QtWidgets.QApplication.restoreOverrideCursor()

      if(success):
        # finished all repeat cycles
        self.daughterWindow.close()
        self.daughterWindow = None
        
        # restore best results from previous cycle
        if(repeatCycleCount > 0):
          self.globalParam_active_list = [i for i in self.globalBestParam]
        
        # calc. residuals even if no improvement
        globalPerturbResid = XX_monster_minWrapper(self.globalBestParam)
        # after procedure, set new parameters and update curve
        self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=True)
        # success
        return True

  def doGlobalHelper(self, modus=''):
    # combines preparatory calls needed by both global minimization and random search
    # determine number of selected data sets
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    if(len(selectedDataSets) < 2):
      self.parent.statusbar.showMessage('Select at least two datasets for global ' + modus + '!', self.parent.STATUS_TIME)
    elif(sum([1 if i else 0 for i in self.globalParam_active]) == 0):
      self.parent.statusbar.showMessage('Select at least one parameter for global ' + modus + '!', self.parent.STATUS_TIME)
    else:
      # check for no. of global parameters and display warning if equals zero
      noGlobalParams = True
      for index, entry in enumerate(self.globalParamNames):
        if(len(self.globalParamsCollate[entry]) > 1):
          noGlobalParams = False
      if(noGlobalParams):
        self.parent.statusbar.showMessage('No global parameters found! Will minimize but there is no gain by global minimization.', self.parent.STATUS_TIME, color='blue')

      # collate and organize data
      self.culledDataSets = []
      checkYerr = False
      self.globalX, self.globalY, self.globalYerr, self.nop = [], [], [], []
      globalYSecond = []
      for index in selectedDataSets:
        # read and organize data
        indivData, indivRoles = self.parent.data[index].getData_n_Fit()
        currDataOnSecond = self.parent.data[index].onSecondAxes
        if(('x' in indivRoles) and ('y' in indivRoles)):
          self.culledDataSets.append(index)
          colX, colY = indivRoles.index('x'), indivRoles.index('y')
          # get y errors
          if('yerr' in indivRoles):
            colYerr = indivRoles.index('yerr')
          else:
            colYerr = -1
            checkYerr = True
          for line in indivData:
            self.globalX.append(line[colX])
            self.globalY.append(line[colY])
            if(colYerr + 1):
              self.globalYerr.append(line[colYerr])
            else:
              self.globalYerr.append(1)
            globalYSecond.append(currDataOnSecond)
          # count data points
          self.nop.append(len(indivData))
      
      if(checkYerr):
        self.parent.statusbar.showMessage('Warning -- y error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')

      # replace zero entries by self.EPSILON
      self.globalX, self.globalY, self.globalYerr = np.array(self.globalX), np.array(self.globalY), np.array(self.globalYerr)
      zerosigma = self.globalYerr[self.globalYerr <= 0]
      if(len(zerosigma) > 0):
        self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
        self.globalYerr = np.array([i if(i>0) else self.EPSILON for i in self.globalYerr])
      
      # determine curves to use
      selectedCurves = [self.parent.data[index].globalFitCurve for index in self.culledDataSets]
      selectedCurves = list(set(selectedCurves))
      
      # cycle over all and define the individual fits in the current scope
      noProblem = self.functionInScope(selectedCurves)
      
      # only proceed if success with setting individual fit functions
      if(noProblem):
        # prepare the monster fit function
        globalFitFunc = 'def XX__monster_Ffunc_(self, x, '
        freeParam = [i for i, j in zip(self.globalParamNames, self.globalParam_active) if j]
        globalFitFunc += ', '.join(freeParam) + '):\n'
        globalFitFunc += '\t# fixed parameters\n'
        for index, entry in enumerate(self.globalParamNames):
          if(not(self.globalParam_active[index])):
            globalFitFunc += '\t' + entry + ' = ' + str(self.globalParamValues[index]) + '\n'
  
        # now call individual fit functions
        globalFitFunc += '\n\t# now call functions for individual curves'
        globalFitFunc += '\n\t__globalFval_ = np.array([])\n'
        for index, dataSetNumber in enumerate(self.culledDataSets):
          # localX
          if(not index):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[:' + str(self.nop[index]) + ']'
          elif(index < len(self.culledDataSets) - 1):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(self.nop[:index])) + ':' + str(sum(self.nop[:index + 1])) + ']'
          else:
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(self.nop[:index])) + ':]'
          # call function w/ localX
          useCurve = self.parent.data[dataSetNumber].globalFitCurve
          globalFitFunc += '\n\t__localFval_' + str(dataSetNumber) + ' = self.__globFfunc_' + str(useCurve) + '(__localX_' + str(dataSetNumber) + ', '
          globalFitFunc += ', '.join(self.parent.fit[useCurve].paramNames) + ')'
          # and np-stack results
          globalFitFunc += '\n\t__globalFval_ = np.hstack((__globalFval_, __localFval_' + str(dataSetNumber) + '))\n'
          
        # and wrap up the monster fit function
        globalFitFunc += '\n\treturn __globalFval_\n'
  
        # now test the monster fit function
        try:
          # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
          namespace = self.mySpace
          exec(globalFitFunc, namespace)
          # we need to do some initial test to see whether the function can be called
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          retv = namespace['XX__monster_Ffunc_'](self, self.globalX, *initpa)
          # check for dimension mismatch
          if(retv.shape != self.globalX.shape):
            # we found some mismatch b/w x and y -- raise error to prevent program crash
            raise ValueError
        except:
          self.parent.statusbar.showMessage('Error collating global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)
        else:
          # now define the new function in the object scope
          setattr(GlobalArea, 'XX__monster_Ffunc_', namespace['XX__monster_Ffunc_'])
          return True
        # some kind of error
        return False
          
  def doGlobalMin(self):
    if(self.doGlobalHelper(modus='minimization')):
      # if selected dataset exists, clear it
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.clearMe(redraw=False)

      # and we are ready to gogog!
      initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
      self.fitpa = [i for i in initpa]
      xtol, maxfev = self.advancedMinimization['xtol'], self.advancedMinimization['maxfev']
      self.fev, self.currGlobalResid = 0, 0
      self.globalFval = 0 * self.globalX
      success = False
      self.daughterWindow = None
      self.runFlag = True
      try:
        # define callback and wrapper functions
        def minimizeCallback(args=0):
          self.fev += 1
          self.fitpa = args
          if((self.fev > maxfev) or (not self.runFlag)):
            # have to raise a warning to terminate
            raise ValueError('exceeded')
          # process events once in a while
          if(not (self.fev % 100)):
            if(self.daughterWindow != None):
              self.daughterWindow.iterLabel.setText('iter ' + str(int(self.fev)) + ' / ' + str(int(maxfev)))
              self.daughterWindow.minLabel.setText('resid ' + self.formatNumber(self.currGlobalResid))
            QtCore.QCoreApplication.processEvents()
      
        # generate wrapper function to calculate square deviation
        def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
          self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
          globalResid = (self.globalY - self.globalFval) / self.globalYerr
          globalResid = globalResid ** 2
          self.currGlobalResid = np.sum(globalResid)
          return self.currGlobalResid

        # deal w/ boundaries
        usedAlgorithm = self.advancedMinimization['algorithm']
        boundaryLow = np.array([i for i, j in zip(self.globalParam_lower, self.globalParam_active) if j])
        boundaryHigh = np.array([i for i, j in zip(self.globalParam_upper, self.globalParam_active) if j])
        boundaryLowCheck = len(boundaryLow[boundaryLow != -np.inf])
        boundaryHighCheck = len(boundaryHigh[boundaryHigh != np.inf])
        boundaryCheck = boundaryLowCheck or boundaryHighCheck
        if(boundaryCheck):
          # adjust algorithm to use?
          if(usedAlgorithm in ['Powell', 'BFGS']):
            # algorithms that support bounds
            if(usedAlgorithm == 'BFGS'):
              usedAlgorithm = 'L-BFGS-B'
          else:
            self.parent.statusbar.showMessage('As at least some parameters were bounded, global fit was done by L-BFGS-B.', self.parent.STATUS_TIME, color='blue')
            usedAlgorithm = 'L-BFGS-B'
      
          # prepare boundaries
          boundsLow = [None if(i == -np.inf) else i for i in boundaryLow]
          boundsHigh = [None if(i == np.inf) else i for i in boundaryHigh]
          bounds = [(i, j) for i, j in zip(boundsLow, boundsHigh)]

        # display busy pointer
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))

        # open an extra window to interact with procedure
        self.daughterWindow = MinWindow(self, 'Global ' + self.advancedMinimization['algorithm'] + ' Minimization')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
  
        # now do the minimization
        options = {'disp': False}
        if(usedAlgorithm in ['Nelder-Mead', 'Powell']):
          options.update({'xtol': xtol})
        if(boundaryCheck):
          res = optim.minimize(XX_monster_minWrapper, initpa, method=usedAlgorithm, options=options, callback=minimizeCallback, bounds=bounds)
        else:
          res = optim.minimize(XX_monster_minWrapper, initpa, method=usedAlgorithm, options=options, callback=minimizeCallback)

        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()
        success = True
      except ValueError as err:
        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()
        if((len(err.args)) and (err.args[0] == 'exceeded')):
          success = True
        else:
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          success = False
          return False
      except:
        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()
        self.parent.statusbar.showMessage('Encountered some problem when searching minimum!', self.parent.STATUS_TIME)
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        success = False
        return False
    
      if(success):
        # finish, close window if still visible
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        # now update plot and parameter table
        self.globalParam_active_list = [i for i in self.fitpa]
        # after procedure, set new parameters and update curve
        self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=True)
        # success
        return True

  def doGlobalFit(self):
    # determine number of selected data sets
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    if(len(selectedDataSets) < 2):
      self.parent.statusbar.showMessage('Select at least two datasets for global fit!', self.parent.STATUS_TIME)
    elif(sum([1 if i else 0 for i in self.globalParam_active]) == 0):
      self.parent.statusbar.showMessage('Select at least one parameter for global fit!', self.parent.STATUS_TIME)
    else:
      # if selected dataset exists, clear it
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.clearMe(redraw=False)

      # check for no. of global parameters and display warning if equals zero
      noGlobalParams = True
      for index, entry in enumerate(self.globalParamNames):
        if(len(self.globalParamsCollate[entry]) > 1):
          noGlobalParams = False
      if(noGlobalParams):
        self.parent.statusbar.showMessage('No global parameters found! Will fit but there is no gain by global fitting.', self.parent.STATUS_TIME, color='blue')
      
      # collate and organize data
      culledDataSets = []
      checkXerr, checkYerr = False, False
      flagXerr, flagYerr = False, False
      globalX, globalY, globalYerr, globalXerr, globalXerrOriginal, nop = [], [], [], [], [], []
      globalYSecond = []
      for index in selectedDataSets:
        # read and organize data
        indivData, indivRoles = self.parent.data[index].getData_n_Fit()
        currDataOnSecond = self.parent.data[index].onSecondAxes
        if(('x' in indivRoles) and ('y' in indivRoles)):
          culledDataSets.append(index)
          colX, colY = indivRoles.index('x'), indivRoles.index('y')
          # get y errors
          if('yerr' in indivRoles):
            colYerr = indivRoles.index('yerr')
            flagYerr = True
          else:
            colYerr = -1
            checkYerr = True
          # get x errors
          if('xerr' in indivRoles):
            colXerr = indivRoles.index('xerr')
            flagXerr = True
          else:
            colXerr = -1
            checkXerr = True
          for line in indivData:
            globalX.append(line[colX])
            globalY.append(line[colY])
            if(colYerr + 1):
              globalYerr.append(line[colYerr])
            else:
              globalYerr.append(1)
            if(colXerr + 1):
              globalXerr.append(line[colXerr])
              globalXerrOriginal.append(line[colXerr])
            else:
              globalXerr.append(1)
              globalXerrOriginal.append(0)
            globalYSecond.append(currDataOnSecond)
          # count data points
          nop.append(len(indivData))
      
      if(checkYerr and flagYerr):
        self.parent.statusbar.showMessage('Warning -- y error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')
      if(checkXerr and flagXerr):
        self.parent.statusbar.showMessage('Warning -- x error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')
          
      # replace zero entries by self.EPSILON
      globalX, globalY, globalYerr = np.array(globalX), np.array(globalY), np.array(globalYerr)
      zerosigma = globalYerr[globalYerr <= 0]
      if(len(zerosigma) > 0):
        self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
        globalYerr = np.array([i if(i>0) else self.EPSILON for i in globalYerr])
      # deal with x errors?
      if(flagXerr):
        globalXerr = np.array(globalXerr)
        globalXerrOriginal = np.array(globalXerrOriginal)
        zerosigmaX = globalXerr[globalXerr <= 0]
        if(len(zerosigmaX) > 0):
          self.parent.statusbar.showMessage('Encountered zero/negative sigmaX values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
          globalXerr = np.array([i if(i>0) else self.EPSILON for i in globalXerr])
          globalXerrOriginal = np.array([i if(i>0) else 0 for i in globalXerrOriginal])
      
      # determine curves to use
      selectedCurves = [self.parent.data[index].globalFitCurve for index in culledDataSets]
      selectedCurves = list(set(selectedCurves))
      selectedCurvesSecond = [self.parent.fit[index].onSecondAxes for index in selectedCurves]
      
      # cycle over all and define the individual fits in the current scope
      noProblem = self.functionInScope(selectedCurves)
      
      # only proceed if success with setting individual fit functions
      if(noProblem):
        # prepare the monster fit function
        globalFitFunc = 'def XX__monster_Ffunc_(self, x, '
        freeParam = [i for i, j in zip(self.globalParamNames, self.globalParam_active) if j]
        globalFitFunc += ', '.join(freeParam) + '):\n'
        globalFitFunc += '\t# fixed parameters\n'
        for index, entry in enumerate(self.globalParamNames):
          if(not(self.globalParam_active[index])):
            globalFitFunc += '\t' + entry + ' = ' + str(self.globalParamValues[index]) + '\n'
  
        # now call individual fit functions
        globalFitFunc += '\n\t# now call functions for individual curves'
        globalFitFunc += '\n\t__globalFval_ = np.array([])\n'
        for index, dataSetNumber in enumerate(culledDataSets):
          # localX
          if(not index):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[:' + str(nop[index]) + ']'
          elif(index < len(culledDataSets) - 1):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(nop[:index])) + ':' + str(sum(nop[:index + 1])) + ']'
          else:
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(nop[:index])) + ':]'
          # call function w/ localX
          useCurve = self.parent.data[dataSetNumber].globalFitCurve
          globalFitFunc += '\n\t__localFval_' + str(dataSetNumber) + ' = self.__globFfunc_' + str(useCurve) + '(__localX_' + str(dataSetNumber) + ', '
          globalFitFunc += ', '.join(self.parent.fit[useCurve].paramNames) + ')'
          # and np-stack results
          globalFitFunc += '\n\t__globalFval_ = np.hstack((__globalFval_, __localFval_' + str(dataSetNumber) + '))\n'
          
        # and wrap up the monster fit function
        globalFitFunc += '\n\treturn __globalFval_\n'
  
        # now test the monster fit function
        try:
          # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
          namespace = self.mySpace
          exec(globalFitFunc, namespace)
          # we need to do some initial test to see whether the function can be called
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          retv = namespace['XX__monster_Ffunc_'](self, globalX, *initpa)
          # check for dimension mismatch
          if(retv.shape != globalX.shape):
            # we found some mismatch b/w x and y -- raise error to prevent program crash
            raise ValueError
        except:
          self.parent.statusbar.showMessage('Error collating global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)
        else:
          # display busy pointer
          QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))

          # now define the new function in the object scope
          setattr(GlobalArea, 'XX__monster_Ffunc_', namespace['XX__monster_Ffunc_'])
          
          # prepare boundary values and determine algorithm to use
          boundaryLow = np.array([i for i, j in zip(self.globalParam_lower, self.globalParam_active) if j])
          boundaryHigh = np.array([i for i, j in zip(self.globalParam_upper, self.globalParam_active) if j])
          
          # and we are ready to gogog!
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          sigma = globalYerr
          maxfev = 100000
          success = False
          if(flagXerr):
            usedAlgorithm = 'odr'
            try:
              # generate wrapper function to refactor x and param vectors
              def XX_monster_odrWrapper(globalParam, x):
                return self.XX__monster_Ffunc_(x, *globalParam)
              # populate x errors
              sigmaX = globalXerr
              sigmaX = [i if(i>0) else self.EPSILON for i in sigmaX]
              # call odr
              odrData = odr.RealData(globalX, globalY, sigmaX, sigma)
              odrModel = odr.Model(XX_monster_odrWrapper)
              odrODR = odr.ODR(odrData, odrModel, beta0=initpa)
              odrODR.set_job(fit_type=2)
              odrOut = odrODR.run()
              fitpa, covar = odrOut.beta, odrOut.cov_beta
              success = True
            except:
              # catch all kind of fit problems
              fitpa = initpa
              covar = np.zeros((len(fitpa), len(fitpa)))
          else:
            # determine whether we have boundaries
            usedAlgorithm = 'lm'
            if(len(boundaryLow) or len(boundaryHigh)):
              if(len(boundaryLow[boundaryLow != -np.inf]) or len(boundaryHigh[boundaryHigh != np.inf])):
                # careful -- we need to check whether trf is supported
                try:
                  # fake fit call
                  optim.curve_fit(lambda y, p: y + 3 + p, [1, 2, 3], [0, -1, 2], [2], method='trf', bounds=(-10, 10))
                  usedAlgorithm = 'trf'
                except:
                  self.parent.statusbar.showMessage('Trf fitting not supported on your platform, will switch to lm!', self.parent.STATUS_TIME)

            # do appropriate fit
            if(usedAlgorithm == 'trf'):
              # we do have boundaries here
              # ensure that we start within bounds
              initpa = [min(max(init, lower), upper) for init, lower, upper in zip(initpa, boundaryLow, boundaryHigh)]
              try:
                fitpa, covar = optim.curve_fit(self.XX__monster_Ffunc_, globalX, globalY, initpa, sigma, maxfev=maxfev,\
                                               method=usedAlgorithm, bounds=(boundaryLow, boundaryHigh))
                success = True
              except:
                # catch all kind of fit problems
                fitpa = initpa
                covar = np.zeros((len(fitpa), len(fitpa)))
            else:
              # no boundaries, use Levenberg Marquardt
              try:
                # careful -- we need to check whether method argument is supported
                try:
                  optim.curve_fit(lambda y, p: y + 3 + p, [1, 2, 3], [0, -1, 2], [2], method='lm')
                  fitpa, covar = optim.curve_fit(self.XX__monster_Ffunc_, globalX, globalY, initpa, sigma, maxfev=maxfev, method=usedAlgorithm)
                  success = True
                except:
                  fitpa, covar = optim.curve_fit(self.XX__monster_Ffunc_, globalX, globalY, initpa, sigma, maxfev=maxfev)
                  success = True
              except:
                # catch all kind of fit problems
                fitpa = initpa
                covar = np.zeros((len(fitpa), len(fitpa)))

          # continue if fit successful
          if(success):
            # fit success! -- this is awesome
            # calculate variances etc.
            # evaluate fitted function at x values and store in data object
            globalFval = self.XX__monster_Ffunc_(globalX, *fitpa)

            # calculate confidences
            normcovar = deepcopy(covar)
            try:
              confidence = np.power(covar.diagonal(), 0.5)
              nanList = confidence[np.isnan(confidence)]
              if(nanList.size):
                normcovar = np.ones((len(confidence), len(confidence)))
              else:
                try:
                  for index, value in enumerate(confidence):
                    if(value != 0):
                      normcovar[:, index] /= value
                      normcovar[index, :] /= value
                except:
                  normcovar = np.ones((len(confidence), len(confidence)))
            except:
              # takes care of NaN and similar errors
              confidence = ['--'] * len(fitpa)
              normcovar = np.ones((len(confidence), len(confidence)))
            
            # check for 'nan' in confidence
            if(type(confidence) == type(np.array([]))):
              nanCheck = np.isnan(confidence)
              nanList = confidence[nanCheck]
              if(nanList.size):
                confidence = ['--'] * len(fitpa)

            # check for 'nan' in covar
            if(type(normcovar) == type(np.array([]))):
              nanCheck = np.isnan(normcovar)
              nanList = normcovar[nanCheck]
              if(nanList.size):
                normcovar = np.ones((len(confidence), len(confidence)))

            # calculate chi_square and reduced chi_square
            resid = globalY - globalFval
            self.chisquare = (globalY - globalFval) ** 2 / globalYerr ** 2
            self.chisquare = np.sum(self.chisquare)
            dof = len(globalX) - sum([1 if i else 0 for i in self.globalParam_active])
            if(dof > 0):
              self.red_chisquare = self.chisquare / dof
            else:
              self.red_chisquare = 'inf'
            # and now calculate a priori errors
            if((self.red_chisquare != 'inf') and flagYerr):
              covar_apriori = covar / self.red_chisquare
              confidence_apriori = np.power(covar_apriori.diagonal(), 0.5)
            else:
              confidence_apriori = ['--'] * len(fitpa)
  
            # did we use x errors or boundaries?
            if(usedAlgorithm == 'odr'):
              self.parent.statusbar.showMessage('As data contained x errors, global fit was done by orthogonal distance regression (odr).', self.parent.STATUS_TIME, color='blue')
            elif(usedAlgorithm == 'trf'):
              self.parent.statusbar.showMessage('As at least some parameters were bounded, global fit was done by trust region reflective (trf).', self.parent.STATUS_TIME, color='blue')
          
            # update parameters in list and table
            counter = 0
            for index, entry in enumerate(self.globalParam_active):
              if (entry):
                self.globalParamValues[index] = fitpa[counter]
                self.globalConfidence[index] = confidence[counter]
                self.globalConfidence_apriori[index] = confidence_apriori[counter]
                counter += 1
              else:
                self.globalConfidence[index] = '--'
                self.globalConfidence_apriori[index] = '--'
  
            # adjust x-axes limits according to all data sets and curves
            if(self.parent.plotArea.autoScaleX):
              if(len(globalXerrOriginal)):
                temp_xmin = np.min([i - j for i, j in zip(globalX, globalXerrOriginal)])
                temp_xmax = np.max([i + j for i, j in zip(globalX, globalXerrOriginal)])
              else:
                temp_xmin, temp_xmax = np.min(globalX), np.max(globalX)
              # check for split x axis
              if(self.parent.plotArea.splitShow):
                temp_xmax = np.min((temp_xmax, self.parent.plotArea.maxX_div, self.parent.plotArea.minX_div))
              # ensure minimum limit
              if (temp_xmax - temp_xmin < self.EPSILON):
                temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
              elif(self.parent.plotArea.data_spacer > 0):
                data_spacer = self.parent.plotArea.data_spacer
                if(self.parent.plotArea.modeX == 'linear'):
                  difference = temp_xmax - temp_xmin
                  if(not self.parent.plotArea.splitShow):
                    temp_xmax += difference * data_spacer
                  temp_xmin -= difference * data_spacer
                else:
                  # log scale -- isolate positive data
                  pos_x = np.array(globalX)
                  pos_x = pos_x[pos_x > 0]
                  # recalc. xmin to address error when restoring state
                  if(len(pos_x > 1)):
                    temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                    if(self.parent.plotArea.splitShow and (np.max((self.parent.plotArea.minX_div, self.parent.plotArea.maxX_div)) > 0)):
                      posLimits = [i for i  in [self.parent.plotArea.minX_div, self.parent.plotArea.maxX_div] if (i > 0)]
                      temp_xmax = np.min((temp_xmax, np.min(posLimits)))
                    difference = np.log(temp_xmax / temp_xmin)
                    if(not self.parent.plotArea.splitShow):
                      temp_xmin = np.exp(np.log(temp_xmin) - data_spacer * difference)
                    temp_xmax = np.exp(np.log(temp_xmax) + data_spacer * difference)

              self.parent.plotArea.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
              self.parent.plotArea.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='resid', redraw=False, updateGrid=True)
              self.parent.plotArea.updateTickEntryField(axis='x')

            if(self.parent.plotArea.autoScaleX_div):
              if(len(globalXerrOriginal)):
                temp_xmin = np.min([i - j for i, j in zip(globalX, globalXerrOriginal)])
                temp_xmax = np.max([i + j for i, j in zip(globalX, globalXerrOriginal)])
              else:
                temp_xmin, temp_xmax = np.min(globalX), np.max(globalX)
              # check for split x axis
              if(self.parent.plotArea.splitShow):
                temp_xmin = np.max((temp_xmin, self.parent.plotArea.maxX, self.parent.plotArea.minX))
              # ensure minimum limit
              if (temp_xmax - temp_xmin < self.EPSILON):
                temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
              elif(self.parent.plotArea.data_spacer > 0):
                data_spacer = self.parent.plotArea.data_spacer
                if(self.parent.plotArea.modeX == 'linear'):
                  difference = temp_xmax - temp_xmin
                  temp_xmax += difference * data_spacer
                  if(not self.parent.plotArea.splitShow):
                    temp_xmin -= difference * data_spacer
                else:
                  # log scale -- isolate positive data
                  pos_x = np.array(globalX)
                  pos_x = pos_x[pos_x > 0]
                  # recalc. xmin to address error when restoring state
                  if(len(pos_x > 1)):
                    temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                    if(self.parent.plotArea.splitShow and (np.max((self.parent.plotArea.minX, self.parent.plotArea.maxX)) > 0)):
                      posLimits = [i for i  in [self.parent.plotArea.minX, self.parent.plotArea.maxX] if (i > 0)]
                      temp_xmin = np.max((temp_xmin, np.max(posLimits)))
                    difference = np.log(temp_xmax / temp_xmin)
                    temp_xmin = np.exp(np.log(temp_xmin) - data_spacer * difference)
                    if(not self.parent.plotArea.splitShow):
                      temp_xmax = np.exp(np.log(temp_xmax) + data_spacer * difference)

              self.parent.plotArea.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
              self.parent.plotArea.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='resid', redraw=False, updateGrid=True)
              self.parent.plotArea.updateTickEntryField(axis='x2')
 
            # cycle through individual curves and plot them
            # determine x interval over which to plot
            for index in selectedCurves:
              # update parameters
              self.parent.fit[index].updateParamSelect(names=self.globalParamNames, values=self.globalParamValues)
              # for non-active functions, calculate xy values => do that in this scope as we already defined the functions here
              if(index != self.parent.activeFit):
                self.updateNonActiveCurve(index, redefine=False)
              else:
                self.updateActiveCurve()
              # plot function
              self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
              self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)
              # copy in case split axes are shown
              curve = self.parent.fit[index]
              if(self.parent.plotArea.splitY and curve.onBothAxes):
                curve.duplicateForSplit()
  
            # update parameter table for current curve
            self.parent.fitarea.changeParamTable()
  
            # in case of 'odr', check whether we had boundaries that would need to be expanded to new value
            if(usedAlgorithm == 'odr'):
              self.changeGlobalParamTableBoundaries()

            # update residuals in data sets
            for index, dataSetNumber in enumerate(culledDataSets):
              if(not index):
                self.parent.data[dataSetNumber].setFval(globalFval[:nop[index]])
              elif(index < len(culledDataSets) - 1):
                self.parent.data[dataSetNumber].setFval(globalFval[sum(nop[:index]):sum(nop[:index + 1])])
              else:
                self.parent.data[dataSetNumber].setFval(globalFval[sum(nop[:index]):])
              
            # and we should update the results table
            self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)
                
            # cycle through all data sets and plot residuals
            for index in culledDataSets:
              curveIndex = self.parent.data[index].globalFitCurve
              # generate resid style on the fly
              self.parent.data[index].Residstyle.update(self.parent.data[index].style)
              self.parent.data[index].ResidBarstyle.update(self.parent.data[index].Barstyle)
              self.parent.data[index].ResidStackstyle.update(self.parent.data[index].Stackstyle)
              self.parent.data[index].ResidTextstyle.update(self.parent.data[index].Textstyle)
              for item in ['linewidth', 'linestyle', 'color']:
                self.parent.data[index].ResidLinestyle[item] = deepcopy(self.parent.fit[curveIndex].style[item])
              # ensure line is visible to connect dots
              if(self.parent.data[index].Residstyle['linestyle'] == 'None'):
                self.parent.data[index].Residstyle['linestyle'] = 'solid'
              # plot residuals
              self.parent.data[index].handleResid, self.parent.plotArea.handleResidZero,\
                self.parent.data[index].handleResidBar, self.parent.data[index].handleResidStack, self.parent.data[index].handleResidStackNeg, self.parent.data[index].handleResidText = self.parent.plotArea.plotResid(\
                dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid,\
                handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[index].handleResidBar,\
                handleResidStack = self.parent.data[index].handleResidStack, handleResidStackNeg = self.parent.data[index].handleResidStackNeg,\
                handleResidText = self.parent.data[index].handleResidText, redraw=False)
              self.parent.data[index].handleResid_div, self.parent.plotArea.handleResidZero_div,\
                self.parent.data[index].handleResidBar_div, self.parent.data[index].handleResidStack_div, self.parent.data[index].handleResidStackNeg_div, self.parent.data[index].handleResidText_div  = self.parent.plotArea.plotResid(\
                dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid_div,\
                handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[index].handleResidBar_div,\
                handleResidStack = self.parent.data[index].handleResidStack_div, handleResidStackNeg = self.parent.data[index].handleResidStackNeg_div,\
                handleResidText = self.parent.data[index].handleResidText_div, redraw=False, splitX=True)
                
            # adjust y-axes limits according to all data sets and curves
            axes = [i for i, j in zip(['y', 'y2'], [self.parent.plotArea.autoScaleY, self.parent.plotArea.autoScaleY2]) if j]
            condition = {'y': False, 'y2': True}
            mode = {}; mode['y'] = self.parent.plotArea.modeY; mode['y2'] = self.parent.plotArea.modeY2
            for axis in axes:
              # filter for data that is on current y axis
              filter_y = np.array([i for i, j in zip(globalY, globalYSecond) if (j == condition[axis])])
              if(not checkYerr):
                filter_yerr = np.array([i for i, j in zip(globalYerr, globalYSecond) if (j == condition[axis])])
              # prepare temp_y -- data
              if(not checkYerr):
                temp_y = np.array([i - j for i, j in zip(filter_y, filter_yerr)])
                temp_y = np.hstack((temp_y, np.array([i + j for i, j in zip(filter_y, filter_yerr)])))
              else:
                temp_y = filter_y
              # prepare temp_y -- fit
              temp_fval = []
              for index, currFitOnSecond in zip(selectedCurves, selectedCurvesSecond):
                if(currFitOnSecond == condition[axis]):
                  dump_x, curr_y = self.parent.fit[index].simulateFunc()
                  temp_fval = np.hstack((temp_fval, curr_y))
              temp_y = np.hstack((temp_fval, temp_y))
              temp_y = np.array([i for i in temp_y if ((not np.isnan(i)) and (not np.isinf(i)))])
              # if any points available do the auto fit
              if(temp_y.size):
                temp_ymin = np.min(temp_y)
                temp_ymax = np.max(temp_y)
                # check for split y axis
                if(self.parent.plotArea.splitY):
                  if(axis == 'y'):
                    temp_ymin = np.max((temp_ymin, self.parent.plotArea.maxY2, self.parent.plotArea.minY2))
                  else:
                    temp_ymax = np.min((temp_ymax, self.parent.plotArea.maxY, self.parent.plotArea.minY))
                # ensure minimum limit
                if (temp_ymax - temp_ymin < self.EPSILON):
                  temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
                elif(self.parent.plotArea.data_spacer > 0):
                  data_spacer = self.parent.plotArea.data_spacer
                  if(mode[axis] == 'linear'):
                    difference = temp_ymax - temp_ymin
                    if((not self.parent.plotArea.splitY) or (axis == 'y')):
                      temp_ymax += difference * data_spacer
                    if((not self.parent.plotArea.splitY) or (axis == 'y2')):
                      temp_ymin -= difference * data_spacer
                  else:
                    # log scale -- isolate positive data
                    pos_y = np.array(temp_y)
                    pos_y = pos_y[pos_y > 0]
                    if(len(pos_y > 1)):
                      # recalc. xmin to address error when restoring state
                      temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                      if(self.parent.plotArea.splitY and (axis == 'y') and (np.max((self.parent.plotArea.minY2, self.parent.plotArea.maxY2)) > 0)):
                        posLimits = [i for i  in [self.parent.plotArea.minY2, self.parent.plotArea.maxY2] if (i > 0)]
                        temp_ymin = np.max((temp_ymin, np.max(posLimits)))
                      if(self.parent.plotArea.splitY and (axis == 'y2') and (np.max((self.parent.plotArea.minY, self.parent.plotArea.maxY)) > 0)):
                        posLimits = [i for i  in [self.parent.plotArea.minY, self.parent.plotArea.maxY] if (i > 0)]
                        temp_ymax = np.min((temp_ymax, np.min(posLimits)))
                      difference = np.log(temp_ymax / temp_ymin)
                      if((not self.parent.plotArea.splitY) or (axis == 'y2')):
                        temp_ymin = np.exp(np.log(temp_ymin) - data_spacer * difference)
                      if((not self.parent.plotArea.splitY) or (axis == 'y')):
                        temp_ymax = np.exp(np.log(temp_ymax) + data_spacer * difference)
                
                self.parent.plotArea.setAxisLimits(lower=temp_ymin, upper=temp_ymax, axis=axis, updateLabel=True, target='plot', redraw=False, updateGrid=True)
                self.parent.plotArea.updateTickEntryField(axis=axis)

            # adjust zoom of residuals plot to encompass all global datasets
            procval = [i for i in resid if ((not np.isnan(i)) and (not np.isinf(i)))]
            if(len(procval)):
              temp_ylimit = np.max([np.abs(i) for i in procval])
              # ensure minimum limit
              if (temp_ylimit == 0):
                maxResidY, minResidY = self.EPSILON, -self.EPSILON
              else:
                maxResidY, minResidY = 1.2 * temp_ylimit, -1.2 * temp_ylimit
              self.parent.plotArea.setAxisLimits(lower = minResidY, upper = maxResidY, axis = 'y', updateLabel = True, target='resid', redraw=False, updateGrid=True)
              self.parent.plotArea.updateTickEntryField(axis='resid')

            # and we should update the fit information
            freeparameters = []; fixedparameters = []
            for index, entry in enumerate(self.globalParam_active):
              if(entry):
                if(self.globalConfidence_apriori[index] != '--'):
                  freeparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index])\
                    + ' &plusmn; ' + self.parent.formatNumber(self.globalConfidence[index]) + ' (' + self.parent.formatNumber(self.globalConfidence_apriori[index]) + ')')
                else:
                  freeparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index]) + ' &plusmn; ' + self.parent.formatNumber(self.globalConfidence[index]))
              else:
                fixedparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index]))
            freestring = '  ' + '\n  '.join(freeparameters)
            fixedstring = '  ' + '\n  '.join(fixedparameters)
            self.globalOutstring = self.fitGlobalResultsHeader
            self.globalOutstring += 'algorithm: ' + usedAlgorithm + '\n'
            self.globalOutstring += 'degrees of freedom: ' + str(dof) + '\n'
            self.globalOutstring += u'<i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(self.chisquare) + '\n'
            self.globalOutstring += u'red. <i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(self.red_chisquare) + '\n\n'

            self.globalOutstring += '<u>used datasets / functions</u>\n<span style="white-space: pre;">'
            for index in culledDataSets:
              curveIndex = self.parent.data[index].globalFitCurve
              self.globalOutstring += '  ' + self.parent.data[index].name + ' / ' + self.parent.fit[curveIndex].name + '\n'
            self.globalOutstring += '\n</span>\n'

            self.globalOutstring += '<u>free parameters</u>\n<span style="white-space: pre;">' + freestring + '\n\n</span>\n\n'

            if(usedAlgorithm == 'trf'):
              self.globalOutstring += '<u>parameter bounds</u>\n<span style="white-space: pre;">'
              for index, entry in enumerate(self.globalParam_active):
                if(entry and ((self.globalParam_lower[index] != -np.inf) or (self.globalParam_upper[index] != np.inf))):
                  self.globalOutstring += '  ' + self.parent.formatNumber(self.globalParam_lower[index]) + ' &le; ' + self.parent.formatNumber(self.globalParamNames[index])
                  self.globalOutstring += ' &le; ' + self.parent.formatNumber(self.globalParam_upper[index]) + '\n'
              self.globalOutstring += '\n</span>\n'

            if(len(fixedparameters)):
              self.globalOutstring += '<u>fixed parameters</u>\n<span style="white-space: pre;">' + fixedstring + '\n</span>\n'
            self.globalOutstring = self.globalOutstring.replace('\n', '<br>')
            self.globalFitResults.setText(self.globalOutstring)

            # remember that last fit was global
            self.parent.lastFitType = 'global'
            self.parent.lastFitGlobalDataSets = culledDataSets
            self.parent.lastFitGlobalCurves = selectedCurves

            # issue plot updates
            self.parent.plotArea.dataplotwidget.myRefresh()
            self.parent.plotArea.residplotwidget.myRefresh()
                
            # update parameter tables
            self.updateGlobalParamTable(fitted=True)

            # remember covariances and parameter names
            self.globalCovar = normcovar
            self.globalCovarParameters = [i for index, i in enumerate(self.globalParamNames) if self.globalParam_active[index]]
            self.globalCovarButton.show()
          else:
            # some kind of fit problem
            self.parent.statusbar.showMessage('Error doing global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)

          # restore pointer
          QtWidgets.QApplication.restoreOverrideCursor()

  def functionInScope(self, selectedCurves=[]):
    # defines a list of functions in current object scope
    # => needed for plotting and fitting
    noProblem = True
    for index in selectedCurves:
      indivFitFunc = 'def __globFfunc_' + str(index) + '(self, x, ' + ', '.join(self.parent.fit[index].paramNames) + '):\n\t'
      indivFitFunc += '\n\t'.join(self.parent.fit[index].ffuncstr_base.split('\n'))
      indivFitFunc += '\n\treturn y'
      try:
        namespace = self.mySpace
        # remove previous definition
        if(hasattr(GlobalArea, '__globFfunc_' + str(index))):
          delattr(GlobalArea, '__globFfunc_' + str(index))
        exec(indivFitFunc, namespace)
        setattr(GlobalArea, '__globFfunc_' + str(index), namespace['__globFfunc_' + str(index)])
      except:
        self.parent.statusbar.showMessage('Error setting fit function no. ' + str(index) + '!', self.parent.STATUS_TIME)
        noProblem = False
        
    # successful?
    return noProblem

  def updateActiveCurve(self):
    # here we update the active curve parameters
    # udpate fit function
    fitpa = [i for i, j in zip(self.parent.fit[self.parent.activeFit].paramAll, self.parent.fit[self.parent.activeFit].active) if j]
    self.parent.fit[self.parent.activeFit].updateParam(fitpa)
    self.parent.fitarea.param = [i for i in self.parent.fit[self.parent.activeFit].paramAll]
    self.parent.fitarea.setFfunc(redraw=False)

    # update fit area
    self.parent.fitarea.changeParamTable()

  def updateNonActiveCurve(self, index=0, redefine=True):
    # helper function to update curves that are currently not active
    # check whether we should redefine the function (this is to prevent errors when function changed)
    success = True
    if(redefine):
      success = self.functionInScope([index])
    if(success and (hasattr(self, '__globFfunc_' + str(index)))):
      # get plot limiations
      restrictMeLow, restrictMeHigh, restrictLow, restrictHigh = self.parent.fit[index].getRestricted()
      restrictLow, restrictHigh = np.min((restrictLow, restrictHigh)), np.max((restrictLow, restrictHigh))
      # plot over interval
      for splitX in [False, True]:
        if(splitX):
          xmin, xmax, useModeX = self.parent.plotArea.minX_div, self.parent.plotArea.maxX_div, self.parent.plotArea.modeX_div
        else:
          xmin, xmax, useModeX = self.parent.plotArea.minX, self.parent.plotArea.maxX, self.parent.plotArea.modeX
        # heed plot limitations
        if(xmin > xmax):
          restrictMeLow, restrictMeHigh = restrictMeHigh, restrictMeLow
        if(restrictMeLow):
          if(xmin < xmax):
            xmin = np.max((xmin, restrictLow))
          else:
            xmin = np.min((xmin, restrictHigh))
        if(restrictMeHigh):
          if(xmin < xmax):
            xmax = np.min((xmax, restrictHigh))
          else:
            xmax = np.max((xmax, restrictLow))
        # calculate new x vector
        if(useModeX == 'linear'):
          plotX = np.linspace(xmin, xmax, self.parent.plotArea.DATAPOINTS_SIMULATION)
        else:
          plotX = np.linspace(np.log(xmin), np.log(xmax), self.parent.plotArea.DATAPOINTS_SIMULATION)
          plotX = np.exp(plotX)
    
        usepa = []
        for entry in self.parent.fit[index].paramNames:
          index2 = self.globalParamNames.index(entry)
          usepa.append(self.globalParamValues[index2])
        method2call = getattr(self, '__globFfunc_' + str(index))
        indivFval = method2call(plotX, *usepa)
        self.parent.fit[index].updateXY(plotX, indivFval, splitX=splitX)
  
  def reportGlobalParam(self):
    # returns current parameters
    return self.globalParamNames, self.globalParam_active, self.globalParamValues, self.globalConfidence, self.globalConfidence_apriori, self.chisquare, self.red_chisquare, self.globalParamFlag

  def resetGlobalParam(self):
    # restores global params
    flag = False
    for index, entry in enumerate(self.storeGlobalParam):
      if(entry != self.globalParamValues[index]):
        flag = True
        
    if(flag):
      # update global values and table
      self.globalParamValues = [i for i in self.storeGlobalParam]
      self.globalConfidence = ['--'] * len(self.globalParamValues)
      self.globalConfidence_apriori = ['--'] * len(self.globalParamValues)
      # deal w/ parameter boundaries
      self.globalParam_lower = [min(i, j) for i, j in zip(self.globalParam_lower, self.globalParamValues)]
      self.globalParam_upper = [max(i, j) for i, j in zip(self.globalParam_upper, self.globalParamValues)]

      self.updateGlobalParamTable(fitted=True)
      
      # update individual curves
      selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
      selectedCurves = [self.parent.data[index].globalFitCurve for index in selectedDataSets]
      selectedCurves = list(set(selectedCurves))
      for index in selectedCurves:
        # update params as needed
        paramUpdateNames, paramUpdateValues = [], []
        for entry in self.parent.fit[index].paramNames:
          if(entry in self.globalParamNames):
            paramUpdateNames.append(entry)
            paramUpdateValues.append(self.globalParamValues[self.globalParamNames.index(entry)])
        self.parent.fit[index].updateParamSelect(paramUpdateNames, paramUpdateValues)

        if(index != self.parent.activeFit):
          self.updateNonActiveCurve(index, redefine=False)
        else:
          self.updateActiveCurve()
        # plot function
        self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
        self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)
        # copy in case split axes are shown
        curve = self.parent.fit[index]
        if(self.parent.plotArea.splitY and curve.onBothAxes):
          curve.duplicateForSplit()
  
      # update parameter table for current curve
      self.parent.fitarea.changeParamTable()

      # issue plot update
      self.parent.plotArea.dataplotwidget.myRefresh()

  def changeGlobalParamTable(self):
    # fills in values into the parameter table
    for index, entry in enumerate(self.globalParamNames):
      self.globalParamTable.cellWidget(index, 1).setText(self.parent.formatNumber(self.globalParamValues[index]))

  def updateGlobalParamTable(self, fitted=False):
    # updates global param table
    if(not fitted):
      # first collate all parameters from all entries
      self.globalParamsCollate = {}
      self.globalParamNames = []
      self.globalParamValues = []
      self.globalParam_active = []
      for index, entry in enumerate(self.parent.data):
        if(self.dataSetTable.cellWidget(index, 0).isChecked()):
          # sanity check for globalFitCurve
          self.parent.data[index].globalFitCurve = min(self.parent.data[index].globalFitCurve, len(self.parent.fit) - 1)
          indexCurve = self.parent.data[index].globalFitCurve
          indivParam, indivParamNames, indivParamActive = self.parent.fit[indexCurve].paramAll, self.parent.fit[indexCurve].paramNames, self.parent.fit[indexCurve].active
          
          for param, paramName, paramActive in zip(indivParam, indivParamNames, indivParamActive):
            if(paramName in self.globalParamsCollate):
              self.globalParamsCollate[paramName].append(param)
            else:
              self.globalParamsCollate[paramName] = [param]
              self.globalParam_active.append(paramActive)
              self.globalParamNames.append(paramName)
              self.globalParamValues.append(param)
      
      # reset confidences and active parameters        
      self.globalConfidence = ['--'] * len(self.globalParamsCollate)
      self.globalConfidence_apriori = ['--'] * len(self.globalParamsCollate)
      
      # store parameters for later resetting
      self.storeGlobalParam = [i for i in self.globalParamValues]
      
      # update global param boundaries
      self.globalParam_lower = [-np.inf] * len(self.globalParamsCollate)
      self.globalParam_upper = [np.inf] * len(self.globalParamsCollate)

    # prepare table
    self.globalParamTable.setRowCount(len(self.globalParamsCollate))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.globalParamTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.globalParamTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    # initialize boundary fields
    self.boundaryLowCheck, self.boundaryLowEntry, self.boundaryHighCheck, self.boundaryHighEntry = [], [], [], []

    # set up new param entries
    self.globalParamFlag = []
    for index, entry in enumerate(self.globalParamNames):
      item = QtWidgets.QTableWidgetItem(entry)
      if(len(self.globalParamsCollate[entry]) > 1):
        item.setForeground(QtCore.Qt.blue)
        useFont = item.font()
        useFont.setBold(True)
        item.setFont(useFont)
        self.globalParamFlag.append(True)
      else:
        self.globalParamFlag.append(False)
      self.globalParamTable.setVerticalHeaderItem(index, item)

      qchkbox_item = QPushButtonCheckable()
      if(self.globalParam_active[index]):
        qchkbox_item.setChecked(True)
      else:
        qchkbox_item.setChecked(False)
      qchkbox_item.setText('')
      qchkbox_item.setPadMe(scaledDPI(2))
      qchkbox_item.setToolTip('Vary parameter ' + str(index) + ' during global fit/minimization')
      qchkbox_item.setCheckMe(True)
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickGlobalParam, index))
      self.globalParamTable.setCellWidget(index, 0, qchkbox_item)

      qline_item = QLineEditClick(self.parent.formatNumber(self.globalParamValues[index]))
      qline_item.setToolTip('Value of global parameter ' + str(index))
      qline_item.setValidator(self.validFloat)
      qline_item.setAlignment(QtCore.Qt.AlignRight)
      qline_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qline_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qline_item.editingFinished.connect(partial(self.editGlobalParam, index, False))
      self.globalParamTable.setCellWidget(index, 1, qline_item)

      qlabel_item = QLabelToolTip(self.parent.formatNumber(self.globalConfidence[index]))
      qlabel_item.setToolTip('A posteriori error of global parameter ' + str(index))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.globalParamTable.setCellWidget(index, 2, qlabel_item)
      
      qlabel_item = QLabelToolTip(self.parent.formatNumber(self.globalConfidence_apriori[index]))
      qlabel_item.setToolTip('A priori error of global parameter ' + str(index))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.globalParamTable.setCellWidget(index, 3, qlabel_item)

      # set up boundary area
      qitem = QtWidgets.QWidget()
      qitem.setMinimumWidth(scaledDPI(132))
      qitem.setMaximumWidth(scaledDPI(132))
      self.globalParamTable.setCellWidget(index, 4, qitem)
      qitem_Layout = QtWidgets.QGridLayout(qitem)
      qitem_Layout.setContentsMargins(0, 0, 0, 0)
      qitem_Layout.setSpacing(scaledDPI(1))
      
      self.boundaryLowCheck.append(QPushButtonCheckable())
      self.boundaryLowCheck[-1].setText('lower')
      self.boundaryLowCheck[-1].setToolTip('Activate lower fit boundary for global parameter ' + str(index))
      self.boundaryLowCheck[-1].setChecked(self.globalParam_lower[index] != -np.inf)
      self.boundaryLowCheck[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowCheck[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowCheck[-1].clicked.connect(partial(self.clickBoundary, index, True))
      qitem_Layout.addWidget(self.boundaryLowCheck[-1], 0, 0, 1, 1)
      
      self.boundaryLowEntry.append(QLineEditClick())
      self.boundaryLowEntry[-1].setToolTip('Lower fit boundary for global parameter ' + str(index))
      self.boundaryLowEntry[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowEntry[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowEntry[-1].editingFinished.connect(partial(self.editBoundary, index, True))
      self.boundaryLowEntry[-1].setValidator(self.validFloat)
      qitem_Layout.addWidget(self.boundaryLowEntry[-1], 1, 0, 1, 1)
      if(self.boundaryLowCheck[-1].isChecked()):
        self.boundaryLowEntry[-1].setText(self.parent.formatNumber(self.globalParam_lower[index]))
        # explicitly set row height as PyQt layout does not update correctly
        self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.boundaryLowEntry[-1].hide()
      
      self.boundaryHighCheck.append(QPushButtonCheckable())
      self.boundaryHighCheck[-1].setText('upper')
      self.boundaryHighCheck[-1].setToolTip('Activate upper fit boundary for global parameter ' + str(index))
      self.boundaryHighCheck[-1].setChecked(self.globalParam_upper[index] != np.inf)
      self.boundaryHighCheck[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighCheck[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighCheck[-1].clicked.connect(partial(self.clickBoundary, index, False))
      qitem_Layout.addWidget(self.boundaryHighCheck[-1], 0, 1, 1, 1)
      
      self.boundaryHighEntry.append(QLineEditClick())
      self.boundaryHighEntry[-1].setToolTip('Upper fit boundary for global parameter ' + str(index))
      self.boundaryHighEntry[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighEntry[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighEntry[-1].editingFinished.connect(partial(self.editBoundary, index, False))
      self.boundaryHighEntry[-1].setValidator(self.validFloat)
      qitem_Layout.addWidget(self.boundaryHighEntry[-1], 1, 1, 1, 1)
      if(self.boundaryHighCheck[-1].isChecked()):
        self.boundaryHighEntry[-1].setText(self.parent.formatNumber(self.globalParam_upper[index]))
        # explicitly set row height as PyQt layout does not update correctly
        self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.boundaryHighEntry[-1].hide()
      
    # set automatic column size
    self.globalParamTable.resizeColumnsToContents()

  def clickBoundary(self, index, lower=True):
    # toggle lower/upper boundary fields
    if(lower):
      value = self.boundaryLowCheck[index].isChecked()
      if(value):
        if(self.globalParam_lower[index] == -np.inf):
          self.globalParam_lower[index] = min(0, 10 * self.globalParamValues[index])
        else:
          self.globalParam_lower[index] = min(self.globalParam_lower[index], 0, 10 * self.globalParamValues[index])
        self.boundaryLowEntry[index].show()
        self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.globalParam_lower[index]))
        self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.globalParam_lower[index] = -np.inf
        self.boundaryLowEntry[index].setText('')
        self.boundaryLowEntry[index].hide()
        if(self.boundaryHighCheck[index].isChecked()):
          self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
        else:
          self.globalParamTable.setRowHeight(index, self.rowHeight)
    else:
      value = self.boundaryHighCheck[index].isChecked()
      if(value):
        if(self.globalParam_upper[index] == np.inf):
          self.globalParam_upper[index] = max(0, 10 * self.globalParamValues[index])
        else:
          self.globalParam_upper[index] = max(self.globalParam_upper[index], 0, 10 * self.globalParamValues[index])
        self.boundaryHighEntry[index].show()
        self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.globalParam_upper[index]))
        self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.globalParam_upper[index] = np.inf
        self.boundaryHighEntry[index].setText('')
        self.boundaryHighEntry[index].hide()
        if(self.boundaryLowCheck[index].isChecked()):
          self.globalParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
        else:
          self.globalParamTable.setRowHeight(index, self.rowHeight)
    
  def editBoundary(self, index, lower=True):
    # edit boundary value
    if(lower):
      try:
        self.globalParam_lower[index] = float(self.boundaryLowEntry[index].text())
      except:
        self.globalParam_lower[index] = 0
    else:
      try:
        self.globalParam_upper[index] = float(self.boundaryHighEntry[index].text())
      except:
        self.globalParam_upper[index] = 0

    # check other boundary and parameter value
    flag = False
    if(self.globalParam_lower[index] > self.globalParam_upper[index]):
      self.globalParam_lower[index], self.globalParam_upper[index] = self.globalParam_upper[index], self.globalParam_lower[index]
      self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.globalParam_lower[index]))
      self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.globalParam_upper[index]))
    if(self.globalParamValues[index] < self.globalParam_lower[index]):
      self.globalParamValues[index] = self.globalParam_lower[index]
      flag = True
    if(self.globalParamValues[index] > self.globalParam_upper[index]):
      self.globalParamValues[index] = self.globalParam_upper[index]
      flag = True
    if(flag):
      # update fit function
      self.editGlobalParam(index, force=True)

  def changeGlobalParamTableBoundaries(self):
    # function called by odr optimization to ensure that afterwards lower and upper limits are adjusted if needed
    for index, entry in enumerate(self.globalParamNames):
      if(self.boundaryLowCheck[index].isChecked()):
        if(self.globalParamValues[index] < self.globalParam_lower[index]):
          self.globalParam_lower[index] = self.globalParamValues[index]
          self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.globalParam_lower[index]))
      if(self.boundaryHighCheck[index].isChecked()):
        if(self.globalParamValues[index] > self.globalParam_upper[index]):
          self.globalParam_upper[index] = self.globalParamValues[index]
          self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.globalParam_upper[index]))

  def updateDataSetTable(self):
    # prepare table
    self.dataSetTable.setRowCount(len(self.parent.data))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.dataSetTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.dataSetTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    # populate table
    for index, entry in enumerate(self.parent.data):
      self.dataSetTable.setVerticalHeaderItem(index, QtWidgets.QTableWidgetItem(str(index + 1)))

      qchkbox_item = QPushButtonCheckable()
      qchkbox_item.setChecked(entry.globalFitCheck)
      qchkbox_item.setText('')
      qchkbox_item.setPadMe(scaledDPI(2))
      qchkbox_item.setToolTip('Include data set ' + str(index) + ' in global fit/minimization')
      qchkbox_item.setCheckMe(True)
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickDataSet, index))
      self.dataSetTable.setCellWidget(index, 0, qchkbox_item)

      qlabel_item = QLabelToolTip(entry.name)
      qlabel_item.setToolTip('Name of data set ' + str(index))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
      self.dataSetTable.setCellWidget(index, 1, qlabel_item)
      
      qcombobox_item = QComboBoxMac()
      qcombobox_item.setToolTip('Associate data set ' + str(index) + ' with fit function')
      qcombobox_item.setMinimumHeight(scaledDPI(BASE_SIZE))
      qcombobox_item.setMaximumHeight(scaledDPI(BASE_SIZE))
      for index2, entry2 in enumerate(self.parent.fit):
        qcombobox_item.addItem(str(index2 + 1) + ' - ' + entry2.name)
      if(self.parent.data[index].globalFitCurve < len(self.parent.fit)):
        qcombobox_item.setCurrentIndex(self.parent.data[index].globalFitCurve)
      else:
        qcombobox_item.setCurrentIndex(0)
      qcombobox_item.activated.connect(partial(self.selectGlobalFfunc, index))
      self.dataSetTable.setCellWidget(index, 2, qcombobox_item)
      
      qlabel_item = QLabelToolTip()
      indexCurve = min(self.parent.data[index].globalFitCurve, (len(self.parent.fit) - 1))
      curr_param = ', '.join(self.parent.fit[indexCurve].paramNames)
      qlabel_item.setText(curr_param)
      qlabel_item.setToolTip('Parameters featuring in selected function')
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(190), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(190), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
      self.dataSetTable.setCellWidget(index, 3, qlabel_item)
      
    # set automatic column size
    self.dataSetTable.resizeColumnsToContents()
    
    # trigger update of global param table
    self.updateGlobalParamTable()

  def selectGlobalFfunc(self, index=0):
    # need to update data object
    indexCurve = self.dataSetTable.cellWidget(index, 2).currentIndex()
    self.parent.data[index].globalFitCurve = indexCurve
    
    # update parameters
    curr_param = ', '.join(self.parent.fit[indexCurve].paramNames)
    self.dataSetTable.cellWidget(index, 3).setText(curr_param)

    # trigger update of global param table
    self.updateGlobalParamTable()

  def clickDataSet(self, index=0):
    # processes click on data set
    state = self.dataSetTable.cellWidget(index, 0).isChecked()
    if(index < len(self.parent.data)):
      self.parent.data[index].globalFitCheck = state

    # trigger update of global param table
    self.updateGlobalParamTable()

  def clickGlobalParam(self, index=0):
    # check/uncheck global param
    state = self.globalParamTable.cellWidget(index, 0).isChecked()
    self.globalParam_active[index] = state

  def editGlobalParam(self, index=0, force=False):
    # edits global param
    try:
      value = float(self.globalParamTable.cellWidget(index, 1).text())
    except:
      value = 0
    
    if((self.globalParamValues[index] != value) or force):
      if(force):
        # force equals True means called b/c of boundary change
        self.globalParamTable.cellWidget(index, 1).setText(self.parent.formatNumber(self.globalParamValues[index]))
      else:
        self.globalParamValues[index] = value
      paramName = self.globalParamNames[index]
      # update parameters in curves
      redraw = False
      selectedDataSets = [index2 for index2, entry in enumerate(self.parent.data) if entry.globalFitCheck]
      selectedCurves = [self.parent.data[index2].globalFitCurve for index2 in selectedDataSets]
      selectedCurves = list(set(selectedCurves))
      for index2 in selectedCurves:
        if(paramName in self.parent.fit[index2].paramNames):
          if(index2 == self.parent.activeFit):
            # update parameter in active curve (go via fitarea to update parameters there as well)
            if(paramName in self.parent.fitarea.paramList):
              index3 = self.parent.fitarea.paramList.index(paramName)
              self.parent.fitarea.param[index3] = value
            fitpa = [i for i, j in zip(self.parent.fit[index2].paramAll, self.parent.fit[index2].active) if j]
            self.parent.fit[index2].updateParam(fitpa)
            self.parent.fitarea.setFfunc(redraw=False)
            # update parameter table for current curve
            self.parent.fitarea.changeParamTable()
          else:
            self.updateNonActiveCurve(index2)        
            
          self.parent.fit[index2].updateParamSelect([paramName], [self.globalParamValues[index]])
          # plot function
          self.parent.fit[index2].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index2], handlePlot = self.parent.fit[index2].handlePlot, redraw=False)
          self.parent.fit[index2].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index2], handlePlot = self.parent.fit[index2].handlePlot_div, redraw=False, splitX=True)
          # copy in case split axes are shown
          curve = self.parent.fit[index2]
          if(self.parent.plotArea.splitY and curve.onBothAxes):
            curve.duplicateForSplit()
          if(self.parent.fit[index2].visibility):
            redraw = True

      # update parameter boundaries if required
      if(self.globalParamValues[index] < self.globalParam_lower[index]):
        self.globalParam_lower[index] = self.globalParamValues[index]
        self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.globalParam_lower[index]))
      if(self.globalParamValues[index] > self.globalParam_upper[index]):
        self.globalParam_upper[index] = self.globalParamValues[index]
        self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.globalParam_upper[index]))
  
      # issue plot updates
      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()

  def setAdvancedRandomSearch(self, key=None, value=None):
    # updates advanced random search settings
    if(key in self.advancedRandomSearch):
      self.advancedRandomSearch[key] = value

  def setAdvancedMinimization(self, key=None, value=None):
    # updates advanced minmization settings
    if(key in self.advancedMinimization):
      self.advancedMinimization[key] = value
      
    if(key == 'algorithm'):
      self.doGlobalMinButton.setText('Global ' + self.advancedMinimization['algorithm'] + ' Min.')

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline
      
  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.3f}'
    FORMAT_SCIENTIFIC = '{:.3e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

class CovarWindow(QtWidgets.QMainWindow):
  def __init__(self, *args, **kwargs):
    super(CovarWindow, self).__init__(*args, **kwargs)
    self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
    self.covar = []
    self.names = []
    self.setMinimumSize(QtCore.QSize(scaledDPI(240), scaledDPI(100)))

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    self.centralwidget = QWidgetMac(self)
    self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(320), scaledDPI(240)))
    self.setCentralWidget(self.centralwidget)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setSpacing(scaledDPI(2))
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    
    self.covarLabel = QtWidgets.QLabel()
    useFont = self.covarLabel.font()
    useFont.setBold(True)
    useFont.setPointSize(useFont.pointSize() * 1.25)
    self.covarLabel.setFont(useFont)
    self.covarLabel.setText('Normalized Covariances')
    self.vLayout.addWidget(self.covarLabel)

    # initialize data table
    self.tableView = QtWidgets.QTableView()
    self.vLayout.addWidget(self.tableView)
    self.tableView.setSelectionMode(self.tableView.ContiguousSelection)
    self.tableView.setEditTriggers(self.tableView.NoEditTriggers)
    # set delegate
    self.tableView.setItemDelegate(CovarDelegate())

    # close button
    self.closeButton = QPushButtonMac()
    self.vLayout.addWidget(self.closeButton)
    self.closeButton.setText('Close')
    self.closeButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.closeButton.clicked.connect(self.close)
    self.vLayout.addStretch()
    
    # copy button
    # actually don't put in for now as clipboard copying appears buggy due to Qt bug, see below

  def populateCovariances(self, names=[], covar=[]):
    # populates covariance table
    if(len(covar) and (type(covar) == type(np.array([])))):
      self.names, self.covar = names, covar
      
      # prepare table model
      shape = self.covar.shape
      self.model = QtGui.QStandardItemModel(shape[0], shape[1])
      
      # poulate model
      for row in range(shape[0]):
        for col in range(shape[1]):
          item = QtGui.QStandardItem('%4.3f' % self.covar[row, col])
          item.setTextAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
          self.model.setItem(row, col, item)
      self.model.setHorizontalHeaderLabels(self.names)
      self.model.setVerticalHeaderLabels(self.names)
      self.model.layoutChanged.emit()

      # assign to table
      self.tableView.setModel(self.model)
      [self.tableView.verticalHeader().setSectionResizeMode(vheader, QtWidgets.QHeaderView.Fixed) for vheader in range(shape[0])]
      [self.tableView.horizontalHeader().setSectionResizeMode(hheader, QtWidgets.QHeaderView.Fixed) for hheader in range(shape[1])]
      self.tableView.resizeColumnsToContents()

      # now correctly size the QWindow -- seriously effing bugger this
      width, height = self.tableView.viewportSizeHint().width(), self.tableView.viewportSizeHint().height()
      # need to add some extra pixels b/c on repeat calls viewportSizeHint() screws up :( 
      # => what an ugly fudge
      self.tableView.setFixedSize(QtCore.QSize(width + scaledDPI(4), height + scaledDPI(4)))
      self.centralwidget.adjustSize()
      self.centralwidget.update()
      # explicitly update windows size but check for viewport size
      requiredSize = self.vLayout.sizeHint()
      screenSize = QtWidgets.QDesktopWidget().screenGeometry(0)
      useWidth = min(requiredSize.width(), screenSize.width())
      useWidth = max(useWidth, scaledDPI(240))
      useHeight = min(requiredSize.height(), screenSize.height())
      self.setMaximumSize(QtCore.QSize(useWidth, useHeight))
      self.resize(useWidth, useHeight)
    
  def keyPressEvent(self, event):
    # catches escape key
    if(event.key() == QtCore.Qt.Key_Escape):
      self.close()
    elif(event.matches(QtGui.QKeySequence.Copy)):
      # prepare output
      selind = self.tableView.selectionModel().selectedIndexes()
      selrow = list(set([index.row() for index in selind]))
      selcol = list(set([index.column() for index in selind]))
      output = [' \t' + '\t'.join([self.names[col] for col in selcol])]
      for row in selrow:
        output.append(self.names[row] + '\t' + '\t'.join(['%4.3f' % self.covar[row, col] for col in selcol]))
      output = '\n'.join(output)
      # for reasons beyond me, clipboard copying fails -- seems to be a Windows Qt bug
      # neither setText() nor setMimeData() appear to do the job :(
      data = QtCore.QMimeData()
      data.setText(output)
      QtWidgets.QApplication.clipboard().setMimeData(data)
    else:
      # activate normal event handling
      QtWidgets.QMainWindow.keyPressEvent(self, event)

# define item delegate for coloring of specific cells
class CovarDelegate(QtWidgets.QStyledItemDelegate):
  def __init__(self):
    super(CovarDelegate, self).__init__()

  def paint(self, painter, option, index):
    if(index.row() == index.column()):
      # regular draw event
      QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
      brushColor = QtGui.QColor('#aaaaaa')
      painter.save()
      painter.setBrush(QtGui.QBrush(brushColor))
      painter.setOpacity(0.5)
      painter.setPen(QtCore.Qt.NoPen)
      r = QtCore.QRect(option.rect)
      painter.drawRect(r)
      painter.restore()
    else:
      try:
        # highlight covariances larger than 0.9
        if(abs(float(index.data())) > 0.9):
          brushColor = QtGui.QColor('#ffaabb')
          painter.save()
          painter.setBrush(QtGui.QBrush(brushColor))
          painter.setOpacity(1.0)
          painter.setPen(QtCore.Qt.NoPen)
          r = QtCore.QRect(option.rect)
          painter.drawRect(r)
          painter.restore()
      except:
        pass
      # regular draw event
      QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
 
class FitArea(QWidgetMac):
  def __init__(self, parent=None):
    super(FitArea, self).__init__()
    self.parent = parent
    self.validFloat = MyValidFloat()
    self.param = []
    self.storeParam = []
    self.confidence = []
    self.confidence_apriori = []
    self.param_active = []
    self.param_lower, self.param_upper = [], []
    self.chisquare, self.red_chisquare = 0, 0
    self.ffuncList = self.initFfunc(path=WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR)
    self.fitResultsHeader = '<h3>Latest fit results</h3><br>'
    self.outstring = self.fitResultsHeader
    self.covar, self.covarParameters = [], []
    # use epsilon as minimum error value and for calculating derivatives
    self.EPSILON = 1e-9
    # define amplitude threshold for random variation of parameters
    self.MIN_AMPLITUDE = 0.5
    
    # advanced export settings
    self.advancedMinimization = {'algorithm': 'Nelder-Mead', 'xtol': 1e-8, 'maxfev': 1e5}
    self.advancedRandomSearch = {'cycles': 5, 'escalate': 1.5, 'maxfev': 1e4}

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setSpacing(scaledDPI(2))

    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Vertical)
    self.vLayout.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)
    
    # set up container for fit formula
    self.fitFunctionContainer = QWidgetMac()
    self.masterwidget.addWidget(self.fitFunctionContainer)
    self.LayoutFitFunctionContainer = QtWidgets.QVBoxLayout(self.fitFunctionContainer)
    self.LayoutFitFunctionContainer.setContentsMargins(0, 0, 0, 0)

    self.functionBox = QWidgetMac()
    self.hLayout00 = QtWidgets.QHBoxLayout(self.functionBox)
    self.hLayout00.setContentsMargins(0, 0, 0, 0)
    self.LayoutFitFunctionContainer.addWidget(self.functionBox)
    self.functionLabel = QtWidgets.QLabel()
    useFont = self.functionLabel.font()
    useFont.setBold(True)
    self.functionLabel.setFont(useFont)
    self.functionLabel.setText('Function')
    self.functionLabel.setMinimumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.functionLabel.setMaximumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.hLayout00.addWidget(self.functionLabel)

    # set up selector for fit functions
    self.comboBox = QComboBoxMac()
    self.comboBox.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.comboBox.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.hLayout00.addWidget(self.comboBox)
    self.populateFfuncSelector()
    self.comboBox.activated.connect(self.selectFfunc)
    self.comboBox.setToolTip('Choose fit formula')

    # set up field that declares parameters
    self.declareParamBox = QWidgetMac()
    self.hLayout = QtWidgets.QHBoxLayout(self.declareParamBox)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.declareParamLabel = QtWidgets.QLabel()
    useFont = self.declareParamLabel.font()
    useFont.setBold(True)
    self.declareParamLabel.setFont(useFont)
    self.declareParamLabel.setText('Parameters')
    self.declareParamLabel.setMinimumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.declareParamLabel.setMaximumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.hLayout.addWidget(self.declareParamLabel)
    self.declareParamEntry = QLineEditClick()
    self.declareParamEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.declareParamEntry.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.declareParamEntry.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.declareParamEntry.setToolTip('Declare parameters as comma-separated list')
    self.hLayout.addWidget(self.declareParamEntry)
    
    self.LayoutFitFunctionContainer.addWidget(self.declareParamBox)
    
    # set up edit field for fit function
    self.fitFormulaBox = QWidgetMac()
    self.LayoutFitFormulaBox = QtWidgets.QHBoxLayout(self.fitFormulaBox)
    self.LayoutFitFormulaBox.setContentsMargins(0, 0, 0, 0)
    self.LayoutFitFormulaBox.setSpacing(0)
    self.LayoutFitFunctionContainer.addWidget(self.fitFormulaBox)

    self.fitFormulaLineNumbers = myQTextEditLineNumbers(self)
    self.LayoutFitFormulaBox.addWidget(self.fitFormulaLineNumbers, stretch=0)

    self.fitFormula = myQTextEdit(self)
    self.fitFormula.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.fitFormula.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutFitFormulaBox.addWidget(self.fitFormula, stretch=1)
    # tool tip kind of disturbs when editing the formula
    ###self.fitFormula.setToolTip('Edit the fit formula')
    self.fitFormula.lineNumbersField = self.fitFormulaLineNumbers

    # read all available fit functions
    if (len(self.ffuncList)):
      defaultFunction = 'binding_isotherm.ffunc'
      functionNo = 0
      for index, entry in enumerate(self.ffuncList):
        if(defaultFunction in entry):
          functionNo = index
      success, parameters, formula, values, active = self.loadFfunc(self.ffuncList[functionNo])
      self.comboBox.blockSignals(True)
      self.comboBox.setCurrentIndex(functionNo)
      self.comboBox.blockSignals(False)
      self.paramList = parameters
      parameters = ', '.join(parameters)
    else:
      parameters = 'A0, A1, KD'
      self.paramList = ['A0', 'A1', 'KD']
      formula = '# a binding isotherm\ny = A0 + A1 * x / (x + KD)'
      values = [1, 1, 1]
      active = [True] * 3

    self.declareParamEntry.setText(parameters)
    self.fitFormula.setText(formula)
    self.param = values
    self.storeParam = [i for i in self.param]
    self.confidence = ['--'] * len(values)
    self.confidence_apriori = ['--'] * len(values)
    self.param_active = [1 if i else 0 for i in active]
    
    # set up buttons
    self.buttonContainer = QWidgetMac()
    self.buttonContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutFitFunctionContainer.addWidget(self.buttonContainer)
    self.LayoutButtonContainer = QtWidgets.QHBoxLayout(self.buttonContainer)
    self.LayoutButtonContainer.setContentsMargins(0, 0, 0, 0)
    
    self.saveFitButton = QPushButtonMac()
    self.saveFitButton.setText('Save Fit Function')
    self.saveFitButton.setToolTip('Save formula to file')
    self.saveFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.saveFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.saveFitButton.clicked.connect(self.saveFit)
    self.LayoutButtonContainer.addWidget(self.saveFitButton)
    self.useFitButton = QPushButtonMac()
    self.useFitButton.setText('Apply Fit Function')
    self.useFitButton.setToolTip('Update formula in curve')
    self.useFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.useFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.useFitButton.clicked.connect(partial(self.useFit, True))
    self.LayoutButtonContainer.addWidget(self.useFitButton)

    # set up container for parameter table
    self.parameterTableContainer = QWidgetMac()
    self.masterwidget.addWidget(self.parameterTableContainer)
    self.LayoutParameterTableContainer = QtWidgets.QVBoxLayout(self.parameterTableContainer)
    self.LayoutParameterTableContainer.setContentsMargins(0, 0, 0, 0)

    # set up parameter table
    blah = self.HLine()
    self.LayoutParameterTableContainer.addWidget(blah)
    self.ParamTable = QtWidgets.QTableWidget()
    self.ParamTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.ParamTable.setEnabled(True)
    self.ParamTable.setColumnCount(5)
    self.ParamTable.setRowCount(1)
    self.ParamTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Fit'))
    self.ParamTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Value'))
    self.ParamTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Error'))
    item3 = QtWidgets.QTableWidgetItem('a priori')
    useFont = item3.font()
    useFont.setItalic(True)
    item3.setFont(useFont)
    self.ParamTable.setHorizontalHeaderItem(3, item3)
    self.ParamTable.setHorizontalHeaderItem(4, QtWidgets.QTableWidgetItem('Boundaries'))
    self.LayoutParameterTableContainer.addWidget(self.ParamTable)
    self.updateParamTable()
    self.useFit(redraw=False)
   
    # set fit controls 2
    self.ButtonContainer2 = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.ButtonContainer2)
    self.LayoutButtonContainer2 = QtWidgets.QHBoxLayout(self.ButtonContainer2)
    self.LayoutButtonContainer2.setContentsMargins(0, 0, 0, 0)

    # set up Fit button
    self.doFitButton = QPushButtonMac()
    self.doFitButton.setText('Fit Data')
    self.doFitButton.setToolTip('Perform least-squares fit\n(Ctrl-F)')
    self.doFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doFitButton.clicked.connect(self.doFit)
    self.LayoutButtonContainer2.addWidget(self.doFitButton)

    # set up minimize button
    self.doMinButton = QPushButtonMac()
    self.doMinButton.setText(self.advancedMinimization['algorithm'] + ' Min.')
    self.doMinButton.setToolTip('Perform numerical minimization\n(Ctrl-N)')
    self.doMinButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doMinButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doMinButton.clicked.connect(self.doMin)
    self.LayoutButtonContainer2.addWidget(self.doMinButton)

    # set up random fit button
    self.doBruteButton = QPushButtonMac()
    self.doBruteButton.setText('Random Search')
    self.doBruteButton.setToolTip('Perform random search of parameters')
    self.doBruteButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doBruteButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doBruteButton.clicked.connect(self.doBruteFit)
    self.LayoutButtonContainer2.addWidget(self.doBruteButton)

    # set up Reset button
    self.resetButton = QPushButtonMac()
    self.resetButton.setText('Reset Parameters')
    self.resetButton.setToolTip('Reset function parameters to previous values')
    self.resetButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.resetButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resetButton.clicked.connect(self.resetParam)
    self.LayoutButtonContainer2.addWidget(self.resetButton)

    # set up container for fit results
    self.fitResultsContainer = QWidgetMac()
    self.masterwidget.addWidget(self.fitResultsContainer)
    self.LayoutFitResultsContainer = QtWidgets.QVBoxLayout(self.fitResultsContainer)
    self.LayoutFitResultsContainer.setContentsMargins(0, 0, 0, 0)
    
    # set up text edit field for displaying fit results
    blah = self.HLine()
    self.LayoutFitResultsContainer.addWidget(blah)
    self.fitResults = myQTextEditBase()
    self.fitResults.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.fitResults.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutFitResultsContainer.addWidget(self.fitResults)
    self.fitResults.setReadOnly(True)
    self.fitResults.setText(self.fitResultsHeader)
    self.fitResults.setToolTip('Results from previous least-squares fit')
    self.parent.fit[self.parent.activeFit].fitresults = self.fitResultsHeader
    
    # set up button for display of covariances
    self.covarButton = QPushButtonMac(self.fitResults)
    self.covarButton.setText('Covariances')
    self.covarButton.setToolTip('Display covariances from previous least-squares fit')
    self.covarButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.covarButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.covarButton.clicked.connect(self.displayCovar)
    self.fitResults.resizeEvent = self.customResize
    self.repositionCovarButton()
    self.covarButton.hide()

  def customResize(self, event):
    # hijack resize event to allow repositioning of covariance button
    myQTextEditBase.resizeEvent(self.fitResults, event)
    if(hasattr(self, 'covarButton')):
      self.repositionCovarButton()

  def repositionCovarButton(self):
    # dynamically adjusts position of covariance button
    topRight = self.fitResults.rect().topRight()
    width = self.covarButton.geometry().width()
    scrollbar = self.fitResults.verticalScrollBar().sizeHint().width()
    self.covarButton.move(QtCore.QPoint(topRight.x() - width - scrollbar, topRight.y()))

  def displayCovar(self):
    # opens new window for display of covariances
    if(len(self.covar)):
      if(not (hasattr(self.parent, 'covarWindow'))):
        self.parent.covarWindow = CovarWindow()
        self.parent.covarWindow.setWindowTitle('Covariances')
      self.parent.covarWindow.covarLabel.setText('Normalized Covariances')
      self.parent.covarWindow.move(QtGui.QCursor.pos())

      # populate covariance table
      self.parent.covarWindow.populateCovariances(names=self.covarParameters, covar=self.covar)
      
      # apply styles and show
      if(QSTYLE != None):
        self.parent.covarWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.parent.covarWindow.setStyleSheet(QSTYLESHEET)
      self.parent.covarWindow.show()
      self.parent.covarWindow.activateWindow()
      self.parent.covarWindow.focusNextChild()

  def populateFfuncSelector(self):
    # initializes or updates function selector
    self.comboBox.clear()
    itemList = []
    
    for entry in self.ffuncList:
      menuItem = entry
      if('\\' in menuItem):
        menuItem = menuItem.split('\\')[-1]
      elif('/' in menuItem):
        menuItem = menuItem.split('/')[-1]
      menuItem = menuItem.split('.')[0]
      itemList.append(menuItem)
    
    # sort itemList
    if(len(itemList)):
      itemList, self.ffuncList = [list(i) for i in zip(*sorted(zip(itemList, self.ffuncList), key=lambda s: s[0].lower()))]
    
    #for menuItem in sorted(itemList):
    for menuItem in itemList:
      self.comboBox.addItem(menuItem)

  def saveFit(self):
    # saves fit function
    # determine currently selected function
    index = self.comboBox.currentIndex()
    if(index + 1):
      currFunc = self.ffuncList[index]
    else:
      currFunc = '.'
    
    # open save dialog
    saveDialog = QtWidgets.QFileDialog()
    saveDialog.selectFile(currFunc)   # strangely enough, this call is not heeded
    filename, fitler_ = saveDialog.getSaveFileName(self, filter = 'Fit function (*.ffunc)', directory=currFunc, caption='Save Fit Function')
    filename = str(filename)
    try:
      savehandle=open(filename, 'w', encoding='utf-8')
      # write parameters
      savehandle.write('<PARAMETERS>\n')
      for index, entry in enumerate(self.paramList):
        red = entry + ', ' + self.parent.formatNumber(self.param[index])
        red += ', ' + str(self.param_active[index]) + '\n'
        savehandle.write(red)
      
      # write formula
      savehandle.write('<FORMULA>\n')
      red = str(self.fitFormula.toPlainText())
      savehandle.write(red)
      savehandle.close()
      
      # add function to ffunclist and update selector
      self.ffuncList = self.initFfunc(path=WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR)
      self.comboBox.blockSignals(True)
      self.populateFfuncSelector()
      
      # determine index of new function in selector (use short filenames)
      if('/' in filename):
        shortFilename = filename.split('/')[-1]
      elif('\\' in filename):
        shortFilename = filename.split('\\')[-1]
      else:
        shortFilename = filename
        
      index = -1
      for index2, entry in enumerate(self.ffuncList):
        if(shortFilename in entry):
          index = index2

      if(index+1):
        self.comboBox.setCurrentIndex(index)
      else:
        self.comboBox.setCurrentIndex(0)
        
      # update storeParam
      self.storeParam = [i for i in self.param]

      self.comboBox.blockSignals(False)
    except:
      self.parent.statusbar.showMessage('Cannot write function file ' + filename, self.parent.STATUS_TIME)

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline
  
  def getRelativeDerivatives(self, xval, yval, yerr):
    # determine derivatives of fit parameters
    x, self.startVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=self.param_active_list)
    self.startResid = np.sum((yval - self.startVal) ** 2 / yerr ** 2)

    # cycle through parameters and calc. derivatives
    for index, entry in enumerate(self.param_active_list):
      workparam = [i for i in self.param_active_list]
      workparam[index] = self.param[index] * (1.0 + self.EPSILON)
      x, perturbVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=workparam)
      perturbResid = np.sum((yval - perturbVal) ** 2 / yerr ** 2)
      # calc. change in chi square when varying a certain parameter
      self.derivatives[index] = (perturbResid - self.startResid)# / self.EPSILON #/ self.EPSILON #startResid

    # now also assign amplitudes for random parameter variation
    self.randomAmplitudes = np.array([1.0 / i if i != 0 else 0 for i in self.derivatives])
          
    # calc. relative amplitudes
    divisor = np.max(np.abs(self.randomAmplitudes))
    divisor = np.max((divisor, self.EPSILON))
    self.randomAmplitudes = self.randomAmplitudes / divisor / 2.0

  def doBruteFit(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for fitting!', self.parent.STATUS_TIME)
    else:
      # get data from data object and start the fit procedure
      # check whether we have a data selection
      if(self.parent.selectedData.isLive):
        data = self.parent.selectedData.value()
      else:
        data = self.parent.data[self.parent.activeData].value()
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
      elif(('x' in data) and ('y' in data) and (len(data['x']) > 0)):
        # display busy pointer
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        # assign values
        xval = np.array(data['x']); yval = np.array(data['y'])
        if('yerr' in data):
          # weed out zero values
          yerr = np.array([i if(i>0) else self.EPSILON for i in data['yerr']])
        else:
          yerr = np.ones(len(data['x']))
          
        # open an extra window to interact with procedure
        self.runFlag = True
        self.restartFlag = False
        self.daughterWindow = BruteWindow(self, 'Random Search')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
        
        # create list of active parameters
        self.param_active_list = [self.param[i] for i, x in enumerate(self.param_active) if (x == 1)]
        self.param_lower_list = [self.param_lower[i] for i, j in enumerate(self.param_active) if j]
        self.param_upper_list = [self.param_upper[i] for i, j in enumerate(self.param_active) if j]
        # ensure that we start within bounds
        self.param_active_list = [min(max(init, lower), upper) for init, lower, upper in \
                                  zip(self.param_active_list, self.param_lower_list, self.param_upper_list)]
        self.origParam = [i for i in self.param_active_list]
        
        # cycle until daughter window closed
        movingCursor = '|,/,-,\\'.split(',')
        cursorCount = 0
        repeatCycleLimit, escalate, lastSuccessLimit = self.advancedRandomSearch['cycles'],\
          self.advancedRandomSearch['escalate'], self.advancedRandomSearch['maxfev']
        escalate = [escalate ** i for i in range(repeatCycleLimit)]
        residstr = ''
        repeatCycleCount = 0
        improved = False
        while repeatCycleCount < repeatCycleLimit:
          # update message label
          self.daughterWindow.messageLabel.setText('Repeat cycle ' + str(repeatCycleCount + 1) + '/' + str(repeatCycleLimit))
          
          # parameter derivatives
          self.derivatives = np.zeros(len(self.param_active_list))
          self.getRelativeDerivatives(xval, yval, yerr)
          self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.startResid) + residstr)
      
          lastSuccessCount = 0
          while ((lastSuccessCount < lastSuccessLimit) and (self.runFlag) and (not self.restartFlag)):
            # randomly vary parameters
            for trial in range(100):
              if(not self.restartFlag):
                lastSuccessCount += 1
                # randomly vary parameters -- add epsilon to get rid of zero parameters
                workamplitude = [i if (np.abs(i) > self.MIN_AMPLITUDE) else (np.sign(i + 1.1 * self.EPSILON) * self.MIN_AMPLITUDE) for i in self.param_active_list]
                workamplitude = escalate[repeatCycleCount] * np.array(workamplitude)
                workparam = self.param_active_list  + (workamplitude * (0.33 - np.random.random(len(self.param_active_list))))
                # ensure that we stay within bounds
                workparam = [min(max(init, lower), upper) for init, lower, upper in \
                             zip(workparam, self.param_lower_list, self.param_upper_list)]
                x, perturbVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=workparam)
                perturbResid = np.sum((yval - perturbVal)**2 / yerr**2)
                
                if(perturbResid < self.startResid):
                  # improvement, yeah!
                  improved = True
                  # update params
                  self.param_active_list = [i for i in workparam]
                  self.updateBruteParam(False)
                  # calc. residuals
                  self.parent.data[self.parent.activeData].setFval(perturbVal)
                  # prepare new round of random search
                  self.getRelativeDerivatives(xval, yval, yerr)
                  self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.startResid) + residstr)
                  lastSuccessCount = 0
                  self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
                    lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            
            # periodically update label in daughter window
            cursorCount += 1
            if(cursorCount >= len(movingCursor)):
              cursorCount = 0
            self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
              lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            self.daughterWindow.messageLabel4.setText('Working ' + movingCursor[cursorCount])
            # need to still process events
            QtCore.QCoreApplication.processEvents()

          if((residstr == '') or (self.startResid < self.bestResid)):
            # first cycle or improvement
            self.bestParam = [i for i in self.param_active_list]
            self.bestVal = 1.0 * self.startVal
            self.bestResid = 1.0 * self.startResid
            residstr = '; best ' + self.parent.formatNumber(self.bestResid)

          # reset original parameters for next cycle
          self.param_active_list = [i for i in self.origParam]
          
          # advance cycle counter
          if(self.restartFlag):
            self.restartFlag = False
          else:
            repeatCycleCount += 1
                      
        # finished all repeat cycles
        self.daughterWindow.close()
        self.daughterWindow = None
        
        # restore best results from previous cycle
        if(repeatCycleCount > 0):
          self.param_active_list = [i for i in self.bestParam]
          self.startVal = 1.0 * self.bestVal
        
        # calc. residuals even if no improvement
        # check whether we have a data selection
        if(self.parent.selectedData.isLive):
          x, calcVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=self.parent.data[self.parent.activeData].x, param=self.bestParam)
          self.parent.data[self.parent.activeData].setFval(calcVal)
        else:
          self.parent.data[self.parent.activeData].setFval(self.startVal)
        # reset confidences in fit object
        if(improved):
          self.confidence, self.confidence_apriori = self.parent.fit[self.parent.activeFit].clearConfidence()
        # after procedure, set new parameters and update curve
        self.updateBruteParam(True)

        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()

  def updateBruteParam(self, updateResid=False):
    # update fit parameters once found better resid
    counter = 0
    for index, entry in enumerate(self.param_active):
      if (entry == 1):
        self.param[index] = self.param_active_list[counter]
        counter += 1
    self.parent.fit[self.parent.activeFit].updateParam(self.param_active_list)
    # plot function
    self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
    self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True)
    # copy in case split axes are shown
    curve = self.parent.fit[self.parent.activeFit]
    if(self.parent.plotArea.splitY and curve.onBothAxes):
      curve.duplicateForSplit()
    self.parent.plotArea.dataplotwidget.myRefresh()
    # update param table
    self.changeParamTable()
    # also update residuals?
    if(updateResid):
      # generate resid style on the fly
      self.parent.data[self.parent.activeData].Residstyle = deepcopy(self.parent.data[self.parent.activeData].style)
      self.parent.data[self.parent.activeData].ResidBarstyle = deepcopy(self.parent.data[self.parent.activeData].Barstyle)
      self.parent.data[self.parent.activeData].ResidStackstyle = deepcopy(self.parent.data[self.parent.activeData].Stackstyle)
      self.parent.data[self.parent.activeData].ResidLinestyle = deepcopy(self.parent.fit[self.parent.activeFit].style)
      # ensure line is visible to connect dots
      if(self.parent.data[self.parent.activeData].Residstyle['linestyle'] == 'None'):
        self.parent.data[self.parent.activeData].Residstyle['linestyle'] = 'solid'
      # plot residuals
      # plot residuals on selected data object
      if(self.parent.selectedData.isLive):
        self.parent.selectedData.drawMeResid(self.parent.plotArea.ax_resid, self.parent.plotArea.ax_resid_div, redraw=False)
      self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
        self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText  = self.parent.plotArea.plotResid(\
        dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
        handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
        handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
        handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
      self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
        self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div = self.parent.plotArea.plotResid(\
        dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
        handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
        handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
        handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, splitX=True)
      
  def reportParam(self):
    # returns current parameters (ensure that a copy is returned here)
    return [i for i in self.paramList], [i for i in self.param_active], [i for i in self.param], [i for i in self.confidence],\
      [i for i in self.confidence_apriori], deepcopy(self.chisquare), deepcopy(self.red_chisquare)

  def resetParam(self):
    # restores parameters to original (or, saved) values
    # first check whether we need to restore parameters at all
    flag = False
    for index, entry in enumerate(self.storeParam):
      if(entry != self.param[index]):
        flag = True
        
    if(flag):
      self.param = [i for i in self.storeParam]
      self.confidence = ['--'] * len(self.param)
      self.confidence_apriori = ['--'] * len(self.param)
      # deal w/ parameter boundaries
      self.param_lower = [min(i, j) for i, j in zip(self.param_lower, self.param)]
      self.param_upper = [max(i, j) for i, j in zip(self.param_upper, self.param)]
  
      # update parameter table
      self.updateParamTable()
      
      # also recompile the fit function for good measure and plot
      self.setFfunc()
  
      # plot function not needed as already done by setFfunc()
      #self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      #  fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot)
  
  def doMin(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for minimization!', self.parent.STATUS_TIME)
      return False
    else:
      # get data from data object and start the fit procedure
      # check whether we have a data selection
      if(self.parent.selectedData.isLive):
        data = self.parent.selectedData.value()
      else:
        data = self.parent.data[self.parent.activeData].value()
      # check number of fit parameters vs. data points
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
        return False
      elif (('x' in data) and ('y' in data)):
        # prepare fit
        xtol, maxfev = self.advancedMinimization['xtol'], self.advancedMinimization['maxfev']
        self.fev, self.currResid = 0, 0
        # assign and check y error
        if('yerr' in data):
          sigma = data['yerr']
          sigma = [i if(i > 0) else self.EPSILON for i in sigma]
        else:
          sigma = [1] * len(data['y'])
      
        # get active parameters
        self.param_active_list = [self.param[i] for i, x in enumerate(self.param_active) if (x == 1)]
        initpa = [i for i in self.param_active_list]
        self.fitpa = [i for i in initpa]
        self.daughterWindow = None
        self.runFlag = True
        
        try:
          # define callback and wrapper functions
          def minimizeCallback(args=0):
            self.fev += 1
            self.fitpa = args
            if((self.fev > maxfev) or (not self.runFlag)):
              # have to raise a warning to terminate
              raise ValueError('exceeded')
            # process events once in a while
            if(not (self.fev % 100)):
              if(self.daughterWindow != None):
                self.daughterWindow.iterLabel.setText('iter ' + str(int(self.fev)) + ' / ' + str(int(maxfev)))
                self.daughterWindow.minLabel.setText('resid ' + self.formatNumber(self.currResid))
              QtCore.QCoreApplication.processEvents()
          
          def XX_minWrapper(param):
            # calculates square deviation b/w data and curve
            x, fval = self.parent.fit[self.parent.activeFit].evaluateFunc(data['x'], param)
            resid = (fval - data['y']) / sigma
            resid = resid ** 2
            self.currResid = np.sum(resid)
            return self.currResid

          # deal w/ boundaries
          usedAlgorithm = self.advancedMinimization['algorithm']
          boundaryLow = np.array([i for i, j in zip(self.param_lower, self.param_active) if j])
          boundaryHigh = np.array([i for i, j in zip(self.param_upper, self.param_active) if j])
          boundaryLowCheck = len(boundaryLow[boundaryLow != -np.inf])
          boundaryHighCheck = len(boundaryHigh[boundaryHigh != np.inf])
          boundaryCheck = boundaryLowCheck or boundaryHighCheck
          if(boundaryCheck):
            # adjust algorithm to use?
            if(usedAlgorithm in ['Powell', 'BFGS']):
              # algorithms that support bounds
              if(usedAlgorithm == 'BFGS'):
                usedAlgorithm = 'L-BFGS-B'
            else:
              self.parent.statusbar.showMessage('As at least some parameters were bounded, global fit was done by L-BFGS-B.', self.parent.STATUS_TIME, color='blue')
              usedAlgorithm = 'L-BFGS-B'
        
            # prepare boundaries
            boundsLow = [None if(i == -np.inf) else i for i in boundaryLow]
            boundsHigh = [None if(i == np.inf) else i for i in boundaryHigh]
            bounds = [(i, j) for i, j in zip(boundsLow, boundsHigh)]

          # display busy pointer
          QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
          # open an extra window to interact with procedure
          self.daughterWindow = MinWindow(self, usedAlgorithm + ' Minimization')
          # apply styles to popup window
          if(QSTYLE != None):
            self.daughterWindow.setStyle(QSTYLE)
          if(QSTYLESHEET != None):
            self.daughterWindow.setStyleSheet(QSTYLESHEET)
          self.daughterWindow.show()

          # now do the minimization
          options = {'disp': False}
          if(usedAlgorithm in ['Nelder-Mead', 'Powell']):
            options.update({'xtol': xtol})
          if(boundaryCheck):
            res = optim.minimize(XX_minWrapper, initpa, method=usedAlgorithm, options=options, callback=minimizeCallback, bounds=bounds)
          else:
            res = optim.minimize(XX_minWrapper, initpa, method=usedAlgorithm, options=options, callback=minimizeCallback)
          
          # restore pointer
          QtWidgets.QApplication.restoreOverrideCursor()
          success = True
        except ValueError as err:
          # restore pointer
          QtWidgets.QApplication.restoreOverrideCursor()
          if((len(err.args)) and (err.args[0] == 'exceeded')):
            success = True
          else:
            if(self.daughterWindow != None):
              self.daughterWindow.close()
              self.daughterWindow = None
            success = False
            return False
        except:
          # restore pointer
          QtWidgets.QApplication.restoreOverrideCursor()
          self.parent.statusbar.showMessage('Encountered some problem when searching minimum!', self.parent.STATUS_TIME)
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          success = False
          return False
        
        if(success):
          # finish, close window if still visible
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          # now update plot and parameter table
          self.param_active_list = [i for i in self.fitpa]
          x, numVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=self.parent.data[self.parent.activeData].x, param=self.fitpa)
          # calc. residuals even if no improvement
          self.parent.data[self.parent.activeData].setFval(numVal)
          # reset confidences in fit object
          self.confidence, self.confidence_apriori = self.parent.fit[self.parent.activeFit].clearConfidence()
          # after procedure, set new parameters and update curve
          self.updateBruteParam(True)
          # success
          return True
      else:
        self.parent.statusbar.showMessage('No y values found!', self.parent.STATUS_TIME)
        return False

  def doFit(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for fitting!', self.parent.STATUS_TIME)
      return False
    else:
      # get data from data object and start the fit procedure
      # check whether we have a data selection
      if(self.parent.selectedData.isLive):
        data = self.parent.selectedData.value()
      else:
        data = self.parent.data[self.parent.activeData].value()
      # check number of fit parameters vs. data points
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
        return False
      else:
        # display busy pointer
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        boundaryLow = [i for i, j in zip(self.param_lower, self.param_active) if j]
        boundaryHigh = [i for i, j in zip(self.param_upper, self.param_active) if j]
        success, fitpa, covar, usedAlgorithm = self.parent.fit[self.parent.activeFit].fitFunc(data, boundaryLow=boundaryLow, boundaryHigh=boundaryHigh)
        if (success):
          # evaluate fitted function at x values and store in data object
          x, fval = self.parent.fit[self.parent.activeFit].simulateFunc(x = self.parent.data[self.parent.activeData].x)
          self.parent.data[self.parent.activeData].setFval(fval)

          # calculate confidences
          normcovar = deepcopy(covar)
          try:
            confidence = np.power(covar.diagonal(), 0.5)
            nanList = confidence[np.isnan(confidence)]
            if(nanList.size):
              normcovar = np.ones((len(confidence), len(confidence)))
            else:
              try:
                for index, value in enumerate(confidence):
                  if(value != 0):
                    normcovar[:, index] /= value
                    normcovar[index, :] /= value
              except:
                normcovar = np.ones((len(confidence), len(confidence)))
          except:
            # takes care of NaN and similar errors
            confidence = ['--'] * len(fitpa)
            normcovar = np.ones((len(confidence), len(confidence)))
            
          # check for 'nan' in confidence
          if(type(confidence) == type(np.array([]))):
            nanCheck = np.isnan(confidence)
            nanList = confidence[nanCheck]
            if(nanList.size):
              confidence = ['--'] * len(fitpa)
          
          # check for 'nan' in normcovar
          if(type(normcovar) == type(np.array([]))):
            nanCheck = np.isnan(normcovar)
            nanList = normcovar[nanCheck]
            if(nanList.size):
              normcovar = np.ones((len(confidence), len(confidence)))
          
          # calculate chi_square and reduced chi_square
          if('yerr' in data):
            yerr = self.parent.data[self.parent.activeData].yerr
            # weed out zero sigma entries
            zerosigma = yerr[yerr <= 0]
            if(len(zerosigma) > 0):
              self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
              yerr = np.array([i if(i > 0) else self.EPSILON for i in yerr])
          else:
            yerr = np.array([1.0 for i in self.parent.data[self.parent.activeData].x])
          self.chisquare = self.parent.data[self.parent.activeData].resid ** 2 / yerr ** 2
          self.chisquare = np.sum(self.chisquare)
          nop = np.sum(self.param_active)
          dof = len(self.parent.data[self.parent.activeData].x) - nop
          if(dof > 0):
            self.red_chisquare = self.chisquare / dof
          else:
            self.red_chisquare = 'inf'
          # and now calculate a priori errors
          if((self.red_chisquare != 'inf') and ('yerr' in data)):
            covar_apriori = covar / self.red_chisquare
            confidence_apriori = np.power(covar_apriori.diagonal(), 0.5)
          else:
            confidence_apriori = ['--'] * len(fitpa)
          
          # also evaluate fitted function at selected x values
          if(self.parent.selectedData.isLive):
            x_sel, fval_sel = self.parent.fit[self.parent.activeFit].simulateFunc(x = self.parent.selectedData.x)
            self.parent.selectedData.setFval(fval_sel)

            if('yerr' in data):
              yerr_sel = self.parent.selectedData.yerr
              # weed out zero sigma entries
              zerosigma_sel = yerr_sel[yerr_sel <= 0]
              if(len(zerosigma_sel) > 0):
                self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
                yerr_sel = np.array([i if(i > 0) else self.EPSILON for i in yerr_sel])
            else:
              yerr_sel = np.array([1.0 for i in self.parent.selectedData.x])
            chisquare_sel = self.parent.selectedData.resid ** 2 / yerr_sel ** 2
            chisquare_sel = np.sum(chisquare_sel)
            dof_sel = len(self.parent.selectedData.x) - nop
            if(dof_sel > 0):
              red_chisquare_sel = chisquare_sel / dof_sel
            else:
              red_chisquare_sel = 'inf'
            # have to recalculate a priori errors under these circumstances
            if((red_chisquare_sel != 'inf') and ('yerr' in data)):
              covar_apriori = covar / red_chisquare_sel
              confidence_apriori = np.power(covar_apriori.diagonal(), 0.5)
            else:
              confidence_apriori = ['--'] * len(fitpa)

          # did we use x errors or boundaries?
          if(usedAlgorithm == 'odr'):
            self.parent.statusbar.showMessage('As data contained x errors, fit was done by orthogonal distance regression (odr).', self.parent.STATUS_TIME, color='blue')
          elif(usedAlgorithm == 'trf'):
            self.parent.statusbar.showMessage('As at least some parameters were bounded, fit was done by trust region reflective (trf).', self.parent.STATUS_TIME, color='blue')
          
          # update parameters in list and table
          counter = 0
          for index, entry in enumerate(self.param_active):
            # in rare circumstances, testing for entry only threw an error, which however is hard to reproduce
            # let alone fix. Therefore, put in additional check that should take care of it
            if(entry and (counter < len(fitpa))):
              self.param[index] = fitpa[counter]
              self.confidence[index] = confidence[counter]
              self.confidence_apriori[index] = confidence_apriori[counter]
              counter += 1
              
          self.changeParamTable()
          
          # in case of 'odr', check whether we had boundaries that would need to be expanded to new value
          if(usedAlgorithm == 'odr'):
            self.changeParamTableBoundaries()
          
          # generate resid style on the fly
          self.parent.data[self.parent.activeData].Residstyle.update(self.parent.data[self.parent.activeData].style)
          self.parent.data[self.parent.activeData].ResidBarstyle.update(self.parent.data[self.parent.activeData].Barstyle)
          self.parent.data[self.parent.activeData].ResidStackstyle.update(self.parent.data[self.parent.activeData].Stackstyle)
          self.parent.data[self.parent.activeData].ResidTextstyle.update(self.parent.data[self.parent.activeData].Textstyle)
          for item in ['linewidth', 'linestyle', 'color']:
            self.parent.data[self.parent.activeData].ResidLinestyle[item] = deepcopy(self.parent.fit[self.parent.activeFit].style[item])
          # ensure line is visible to connect dots
          if(self.parent.data[self.parent.activeData].Residstyle['linestyle'] == 'None'):
            self.parent.data[self.parent.activeData].Residstyle['linestyle'] = 'solid'
          # plot function
          self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
            fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
          self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
            fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True)
          # copy in case split axes are shown
          curve = self.parent.fit[self.parent.activeFit]
          if(self.parent.plotArea.splitY and curve.onBothAxes):
            curve.duplicateForSplit()
          self.parent.plotArea.dataplotwidget.myRefresh()
          # plot residuals
          # plot residuals on selected data object
          if(self.parent.selectedData.isLive):
            self.parent.selectedData.drawMeResid(self.parent.plotArea.ax_resid, self.parent.plotArea.ax_resid_div, redraw=False)
          self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
            self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText = self.parent.plotArea.plotResid(\
            dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
            handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
            handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
            handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
          self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
            self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div  = self.parent.plotArea.plotResid(\
            dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
            handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
            handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
            handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, splitX=True)
          # and we should update the results table
          self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)

          # and we should update the fit information
          freeparameters = []; fixedparameters = []
          for index, entry in enumerate(self.param_active):
            if(entry):
              if(self.confidence_apriori[index] != '--'):
                freeparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index])\
                  + ' &plusmn; ' + self.parent.formatNumber(self.confidence[index]) + ' (' + self.parent.formatNumber(self.confidence_apriori[index]) + ')')
              else:
                freeparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index]) + ' &plusmn; ' + self.parent.formatNumber(self.confidence[index]))
            else:
              fixedparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index]))
          freestring = '  ' + '\n  '.join(freeparameters)
          fixedstring = '  ' + '\n  '.join(fixedparameters)
          self.outstring = self.fitResultsHeader
          self.outstring += 'algorithm: ' + usedAlgorithm + '\n'
          if(self.parent.selectedData.isLive):
            self.outstring += '\n<u>selected data</u>\ndegrees of freedom: ' + str(dof_sel) + '\n'
            self.outstring += u'<i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(chisquare_sel) + '\n'
            self.outstring += u'red. <i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(red_chisquare_sel) + '\n\n'
            self.outstring += '<u>all data</u>\n'
          self.outstring += 'degrees of freedom: ' + str(dof) + '\n'
          self.outstring += u'<i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(self.chisquare) + '\n'
          self.outstring += u'red. <i>\N{GREEK CAPITAL LETTER CHI}</i><sup>2</sup> ' + self.parent.formatNumber(self.red_chisquare) + '\n\n'
          index = self.comboBox.currentIndex()
          if(index + 1):
            currFunc = self.ffuncList[index]
          else:
            currFunc = ''
          self.outstring += '<u>function: ' + currFunc + '</u>\n<span style="white-space: pre;">'
          self.outstring += '  ' + '\n  '.join(str(self.fitFormula.toPlainText()).splitlines()) + '\n\n</span>\n\n'
          self.outstring += '<u>free parameters</u>\n<span style="white-space: pre;">' + freestring + '\n\n</span>\n'
          if(usedAlgorithm == 'trf'):
            self.outstring += '<u>parameter bounds</u>\n<span style="white-space: pre;">'
            for index, entry in enumerate(self.param_active):
              if(entry and ((self.param_lower[index] != -np.inf) or (self.param_upper[index] != np.inf))):
                self.outstring += '  ' + self.parent.formatNumber(self.param_lower[index]) + ' &le; ' + self.parent.formatNumber(self.paramList[index])
                self.outstring += ' &le; ' + self.parent.formatNumber(self.param_upper[index]) + '\n'
            self.outstring += '\n</span>\n'
          if(len(fixedparameters)):
            self.outstring += '<u>fixed parameters</u>\n<span style="white-space: pre;">' + fixedstring + '</span>\n'
          self.outstring = self.outstring.replace('\n', '<br>')
          self.fitResults.setText(self.outstring)
          self.parent.fit[self.parent.activeFit].fitresults = self.outstring
          
          # remember that last fit was local
          self.parent.lastFitType = 'local'
          self.parent.lastFitGlobalDataSets = []
          self.parent.lastFitGlobalCurves = []

          # update fit information in object
          ffuncstr_base, ffunc_header = self.parent.fit[self.parent.activeFit].ffuncstr_base, self.parent.fit[self.parent.activeFit].ffunc_header
          self.parent.fit[self.parent.activeFit].storeInfo(self.paramList, self.param, self.param_active,\
                         self.confidence, self.confidence_apriori, ffuncstr_base, ffunc_header, self.outstring, self.chisquare, self.red_chisquare)

          # remember covariances and parameter names
          self.covar = normcovar
          self.covarParameters = [i for index, i in enumerate(self.paramList) if self.param_active[index]]
          self.covarButton.show()

        # restore pointer
        QtWidgets.QApplication.restoreOverrideCursor()
        # used for handling keyboard shortcuts
        return True
      
  def changeParamTable(self):
    # fills in values into the parameter table
    for index, entry in enumerate(self.paramList):
      self.ParamTable.cellWidget(index, 1).setText(self.parent.formatNumber(self.param[index]))
      self.ParamTable.cellWidget(index, 2).setText(self.parent.formatNumber(self.confidence[index]))
      self.ParamTable.cellWidget(index, 3).setText(self.parent.formatNumber(self.confidence_apriori[index]))

  def useFit(self, redraw=True):
    # update parameter table
    self.updateParamTable()
    # set fit function
    self.setFfunc(redraw=redraw)
    # update fit information on global tab as well
    if(hasattr(self.parent, 'globalarea')):
      self.parent.globalarea.updateDataSetTable()

  def setFfunc(self, redraw=True):
    # dynamically assign fit function
    # function body
    ffunc_orig = str(self.fitFormula.toPlainText())
    ffunc = '\t' + '\n\t'.join(ffunc_orig.split('\n'))
    
    ffunc_top = ''; ffunc_header = ''; fitpa = []
    # cycle over all parameters
    for index, entry in enumerate(self.paramList):
      if(self.param_active[index]):
        fitpa.append(float(self.param[index]))
        ffunc_header += ', ' + entry
      else:
        ffunc_top += '\t' + entry + ' = ' + str(float(self.param[index])) + '\n'
    
    ffunc = ffunc_top + ffunc
    
    # update the function in the fit object
    success, message = self.parent.fit[self.parent.activeFit].updateFunc(ffunc, ffunc_header, testParam=fitpa)
    if (success):
      # update parameters
      self.parent.fit[self.parent.activeFit].updateParam(fitpa)
      self.parent.fit[self.parent.activeFit].updateChiSquare(self.chisquare, self.red_chisquare)
      # store this information in current fit function
      if(hasattr(self, 'fitResults')):
        fitresults = self.fitResults.toPlainText()
      else:
        fitresults = ''
      self.parent.fit[self.parent.activeFit].storeInfo(self.paramList, self.param, self.param_active,\
        self.confidence, self.confidence_apriori, ffunc_orig, ffunc_header, fitresults, self.chisquare, self.red_chisquare)
      # plot function
      self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
        fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot,\
        redraw=False)
      self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
        fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div,\
        redraw=False, splitX=True)
      # copy in case split axes are shown
      curve = self.parent.fit[self.parent.activeFit]
      if(self.parent.plotArea.splitY and curve.onBothAxes):
        curve.duplicateForSplit()
      # issue redraw?
      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
      # don't use palettes as these are incompatible with style sheets
      self.fitFormula.setStyleSheet('myQTextEdit {background-color: white;}')
    else:
      # some kind of failure
      if(hasattr(self.parent, 'statusbar')):
        self.parent.statusbar.showMessage(message, self.parent.STATUS_TIME)
        print('Error in fit function:\n' + message)
        # don't use palettes as these are incompatible with style sheets
        self.fitFormula.setStyleSheet('myQTextEdit {background-color: rgb(250, 190, 190);}')
   
  def updateParamTable(self):
    # check which params we have
    self.paramList = str(self.declareParamEntry.text()).split(',')
    self.paramList = [i.strip() for i in self.paramList]
    # initialize newly added parameters to 1
    while(len(self.param) < len(self.paramList)):
      self.param.append(1.0)
    while(len(self.confidence) < len(self.paramList)):
      self.confidence.append('--')
    while(len(self.confidence_apriori) < len(self.paramList)):
      self.confidence_apriori.append('--')
    while(len(self.param_active) < len(self.paramList)):
      self.param_active.append(1)
    while(len(self.param_lower) < len(self.paramList)):
      self.param_lower.append(-np.inf)
    while(len(self.param_upper) < len(self.paramList)):
      self.param_upper.append(np.inf)
    # truncate self.param if parameters have been deleted
    if(len(self.param) > len(self.paramList)):
      self.param = self.param[:len(self.paramList)]
      self.confidence = self.confidence[:len(self.paramList)]
      self.confidence_apriori = self.confidence_apriori[:len(self.paramList)]
      self.param_active = self.param_active[:len(self.paramList)]
      self.param_lower = self.param_lower[:len(self.paramList)]
      self.param_upper = self.param_upper[:len(self.paramList)]

    # prepare table
    self.ParamTable.setRowCount(len(self.paramList))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.ParamTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.ParamTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    # initialize boundary fields
    self.boundaryLowCheck, self.boundaryLowEntry, self.boundaryHighCheck, self.boundaryHighEntry = [], [], [], []
    
    # set up new param entries
    for index, entry in enumerate(self.paramList):
      self.ParamTable.setVerticalHeaderItem(index, QtWidgets.QTableWidgetItem(entry))

      qchkbox_item = QPushButtonCheckable()
      if(self.param_active[index]):
        qchkbox_item.setChecked(True)
      else:
        qchkbox_item.setChecked(False)
      qchkbox_item.setPadMe(scaledDPI(2))
      qchkbox_item.setText('')
      qchkbox_item.setToolTip('Vary parameter ' + str(index) + ' during fit/minimization')
      qchkbox_item.setCheckMe(True)
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickParam, index))
      self.ParamTable.setCellWidget(index, 0, qchkbox_item)

      qline_item = QLineEditClick(self.parent.formatNumber(self.param[index]))
      qline_item.setToolTip('Value of parameter ' + str(index))
      qline_item.setValidator(self.validFloat)
      qline_item.setAlignment(QtCore.Qt.AlignRight)
      qline_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qline_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qline_item.editingFinished.connect(partial(self.editParam, index))
      self.ParamTable.setCellWidget(index, 1, qline_item)

      qlabel_item = QLabelToolTip(self.parent.formatNumber(self.confidence[index]))
      qlabel_item.setToolTip('A posteriori error of parameter ' + str(index))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.ParamTable.setCellWidget(index, 2, qlabel_item)
      
      qlabel_item = QLabelToolTip(self.parent.formatNumber(self.confidence_apriori[index]))
      qlabel_item.setToolTip('A priori error of parameter ' + str(index))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.ParamTable.setCellWidget(index, 3, qlabel_item)
      
      # set up boundary area
      qitem = QtWidgets.QWidget()
      qitem.setMinimumWidth(scaledDPI(132))
      qitem.setMaximumWidth(scaledDPI(132))
      self.ParamTable.setCellWidget(index, 4, qitem)
      qitem_Layout = QtWidgets.QGridLayout(qitem)
      qitem_Layout.setContentsMargins(0, 0, 0, 0)
      qitem_Layout.setSpacing(scaledDPI(1))
      
      self.boundaryLowCheck.append(QPushButtonCheckable())
      self.boundaryLowCheck[-1].setText('lower')
      self.boundaryLowCheck[-1].setToolTip('Activate lower fit boundary for parameter ' + str(index))
      self.boundaryLowCheck[-1].setChecked(self.param_lower[index] != -np.inf)
      self.boundaryLowCheck[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowCheck[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowCheck[-1].clicked.connect(partial(self.clickBoundary, index, True))
      qitem_Layout.addWidget(self.boundaryLowCheck[-1], 0, 0, 1, 1)
      
      self.boundaryLowEntry.append(QLineEditClick())
      self.boundaryLowEntry[-1].setToolTip('Lower fit boundary for parameter ' + str(index))
      self.boundaryLowEntry[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowEntry[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryLowEntry[-1].editingFinished.connect(partial(self.editBoundary, index, True))
      self.boundaryLowEntry[-1].setValidator(self.validFloat)
      qitem_Layout.addWidget(self.boundaryLowEntry[-1], 1, 0, 1, 1)
      if(self.boundaryLowCheck[-1].isChecked()):
        self.boundaryLowEntry[-1].setText(self.parent.formatNumber(self.param_lower[index]))
        # explicitly set row height as PyQt layout does not update correctly
        self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.boundaryLowEntry[-1].hide()
      
      self.boundaryHighCheck.append(QPushButtonCheckable())
      self.boundaryHighCheck[-1].setText('upper')
      self.boundaryHighCheck[-1].setToolTip('Activate upper fit boundary for parameter ' + str(index))
      self.boundaryHighCheck[-1].setChecked(self.param_upper[index] != np.inf)
      self.boundaryHighCheck[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighCheck[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighCheck[-1].clicked.connect(partial(self.clickBoundary, index, False))
      qitem_Layout.addWidget(self.boundaryHighCheck[-1], 0, 1, 1, 1)
      
      self.boundaryHighEntry.append(QLineEditClick())
      self.boundaryHighEntry[-1].setToolTip('Upper fit boundary for parameter ' + str(index))
      self.boundaryHighEntry[-1].setMaximumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighEntry[-1].setMinimumSize(scaledDPI(66), scaledDPI(BASE_SIZE))
      self.boundaryHighEntry[-1].editingFinished.connect(partial(self.editBoundary, index, False))
      self.boundaryHighEntry[-1].setValidator(self.validFloat)
      qitem_Layout.addWidget(self.boundaryHighEntry[-1], 1, 1, 1, 1)
      if(self.boundaryHighCheck[-1].isChecked()):
        self.boundaryHighEntry[-1].setText(self.parent.formatNumber(self.param_upper[index]))
        # explicitly set row height as PyQt layout does not update correctly
        self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.boundaryHighEntry[-1].hide()
      
    # set automatic column size
    self.ParamTable.resizeColumnsToContents()

  def clickBoundary(self, index, lower=True):
    # toggle lower/upper boundary fields
    if(lower):
      value = self.boundaryLowCheck[index].isChecked()
      if(value):
        if(self.param_lower[index] == -np.inf):
          self.param_lower[index] = min(0, 10 * self.param[index])
        else:
          self.param_lower[index] = min(self.param_lower[index], 0, 10 * self.param[index])
        self.boundaryLowEntry[index].show()
        self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.param_lower[index]))
        self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.param_lower[index] = -np.inf
        self.boundaryLowEntry[index].setText('')
        self.boundaryLowEntry[index].hide()
        if(self.boundaryHighCheck[index].isChecked()):
          self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
        else:
          self.ParamTable.setRowHeight(index, self.rowHeight)
    else:
      value = self.boundaryHighCheck[index].isChecked()
      if(value):
        if(self.param_upper[index] == np.inf):
          self.param_upper[index] = max(0, 10 * self.param[index])
        else:
          self.param_upper[index] = max(self.param_upper[index], 0, 10 * self.param[index])
        self.boundaryHighEntry[index].show()
        self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.param_upper[index]))
        self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
      else:
        self.param_upper[index] = np.inf
        self.boundaryHighEntry[index].setText('')
        self.boundaryHighEntry[index].hide()
        if(self.boundaryLowCheck[index].isChecked()):
          self.ParamTable.setRowHeight(index, 2 * scaledDPI(BASE_SIZE) + scaledDPI(1))
        else:
          self.ParamTable.setRowHeight(index, self.rowHeight)
    
  def editBoundary(self, index, lower=True):
    # edit boundary value
    if(lower):
      try:
        self.param_lower[index] = float(self.boundaryLowEntry[index].text())
      except:
        self.param_lower[index] = 0
    else:
      try:
        self.param_upper[index] = float(self.boundaryHighEntry[index].text())
      except:
        self.param_upper[index] = 0

    # check other boundary and parameter value
    flag = False
    if(self.param_lower[index] > self.param_upper[index]):
      self.param_lower[index], self.param_upper[index] = self.param_upper[index], self.param_lower[index]
      self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.param_lower[index]))
      self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.param_upper[index]))
    if(self.param[index] < self.param_lower[index]):
      self.param[index] = self.param_lower[index]
      flag = True
    if(self.param[index] > self.param_upper[index]):
      self.param[index] = self.param_upper[index]
      flag = True
    if(flag):
      self.ParamTable.cellWidget(index, 1).setText(self.parent.formatNumber(self.param[index]))
      # set fit function
      self.setFfunc(redraw=True)

  def changeParamTableBoundaries(self):
    # function called by odr optimization to ensure that afterwards lower and upper limits are adjusted if needed
    for index, entry in enumerate(self.paramList):
      if(self.boundaryLowCheck[index].isChecked()):
        if(self.param[index] < self.param_lower[index]):
          self.param_lower[index] = self.param[index]
          self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.param_lower[index]))
      if(self.boundaryHighCheck[index].isChecked()):
        if(self.param[index] > self.param_upper[index]):
          self.param_upper[index] = self.param[index]
          self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.param_upper[index]))

  def editParam(self, index):
    try:
      self.param[index] = float(self.ParamTable.cellWidget(index, 1).text())
    except:
      self.param[index] = 0

    # update parameters
    # check whether this parameter is fixed or not
    if (self.param_active[index]):
      fitpa = []
      for index2, entry in enumerate(self.param):
        if(self.param_active[index2]):
          fitpa.append(entry)
      self.parent.fit[self.parent.activeFit].updateParam(fitpa)
    else:
      # also have to recompile the fit function
      self.setFfunc()

    # plot function
    self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
    self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True)
    # copy in case split axes are shown
    curve = self.parent.fit[self.parent.activeFit]
    if(self.parent.plotArea.splitY and curve.onBothAxes):
      curve.duplicateForSplit()
    # refresh plot
    self.parent.plotArea.dataplotwidget.myRefresh()
    
    # update parameter boundaries if required
    if(self.param[index] < self.param_lower[index]):
      self.param_lower[index] = self.param[index]
      self.boundaryLowEntry[index].setText(self.parent.formatNumber(self.param_lower[index]))
    if(self.param[index] > self.param_upper[index]):
      self.param_upper[index] = self.param[index]
      self.boundaryHighEntry[index].setText(self.parent.formatNumber(self.param_upper[index]))

    # should we also update the global param table?
    # => I guess that's a no
    
  def clickParam(self, index):
    # test what state the checkbox now has
    if(self.ParamTable.cellWidget(index, 0).isChecked()):
      self.param_active[index] = 1
    else:
      self.param_active[index] = 0
      self.confidence[index] = '--'
      self.ParamTable.cellWidget(index, 2).setText(str(self.confidence[index]))
      self.confidence_apriori[index] = '--'
      self.ParamTable.cellWidget(index, 3).setText(str(self.confidence_apriori[index]))
    
    # update ffunc and parameters
    fitpa = []
    for index, entry in enumerate(self.param):
      if(self.param_active[index]):
        fitpa.append(entry)
    self.parent.fit[self.parent.activeFit].updateActive(self.param_active)
    self.parent.fit[self.parent.activeFit].updateParam(fitpa)
    self.setFfunc()
    # but we should not need to update the plot itself

  def initFfunc(self, path='', pattern='*.ffunc'):
    # returns list of available fit functions
    if(path == ''):
      path = WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR
    ffunc_list = glob(path+pattern)
    return ffunc_list
    
  def loadFfunc(self, filename):
    # load fit function
    try:
      # read file contents
      readhandle = open(filename, 'r', encoding='utf-8')
      red = readhandle.readline()
      params = []; formula = ''; mode = 0; values = []; active = []
      while(red):
        if ('<PARAMETERS>' in red):
          mode = 1
        elif ('<FORMULA>' in red):
          mode = 2
        elif (mode == 1):
          red = red.strip()
          if (',' in red):
            temparray = red.split(',')
            params.append(temparray[0])
            try:
              values.append(float(temparray[1]))
            except:
              values.append(0.0)
            if(red.count(',') > 1):
              try:
                active.append(bool(float(temparray[2])))
              except:
                active.append(True)
            else:
              active.append(True)
          else:
            params.append(red)
            values.append(1.0)
            active.append(True)
        elif (mode == 2):
          formula += red
        
        red = readhandle.readline()
        
      readhandle.close()
      success = True
    except:
      success = False; params = []; formula = ''; values = []; active = []
    
    return success, params, formula, values, active
    
  def selectFfunc(self):
    # a new fit function was selected in the list
    index = self.comboBox.currentIndex()
    success, parameters, formula, values, active = self.loadFfunc(self.ffuncList[index])
    if(success):
      self.paramList = parameters
      parameters = ', '.join(parameters)
      self.declareParamEntry.setText(parameters)
      self.fitFormula.setText(formula)
      self.param = values
      self.storeParam = [i for i in self.param]
      self.confidence = ['--'] * len(values)
      self.confidence_apriori = ['--'] * len(values)
      self.param_active = [1 if i else 0 for i in active]
      self.param_lower, self.param_upper = [-np.inf] * len(values), [np.inf] * len(values)
      self.updateParamTable()
      self.useFit()
    else:
      self.parent.statusbar.showMessage('Cannot load function ' + self.comboBox.currentText() + '!', self.parent.STATUS_TIME)
    
  def restoreFfunc(self, parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=True):
    # an existing fit function was restored
    self.paramList = parameters
    parameters = ', '.join(parameters)
    self.declareParamEntry.setText(parameters)
    self.fitFormula.setText(formula)
    self.fitResults.setText(fitresults)
    self.param = values
    self.storeParam = [i for i in self.param]
    # need these checks for backward compatibility
    if((type(confidence) != type([])) or (len(confidence) != len(values))):
      self.confidence = ['--'] * len(values)
    else:
      self.confidence = confidence
    if((type(confidence_apriori) != type([])) or (len(confidence_apriori) != len(values))):
      self.confidence_apriori = ['--'] * len(values)
    else:
      self.confidence_apriori = confidence_apriori
    self.param_active = [1 if i else 0 for i in active]
    self.param_lower, self.param_upper = [-np.inf] * len(values), [np.inf] * len(values)
    self.updateParamTable()
    self.useFit(redraw=redraw)
    
  def setAdvancedRandomSearch(self, key=None, value=None):
    # updates advanced random search settings
    if(key in self.advancedRandomSearch):
      self.advancedRandomSearch[key] = value

  def setAdvancedMinimization(self, key=None, value=None):
    # updates advanced minmization settings
    if(key in self.advancedMinimization):
      self.advancedMinimization[key] = value

    if(key == 'algorithm'):
      self.doMinButton.setText(self.advancedMinimization['algorithm'] + ' Min.')

  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.3f}'
    FORMAT_SCIENTIFIC = '{:.3e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number)>NUMBER_SWITCH) or (np.abs(number)<1.0/NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False
  
class FitObject(object):
  def __init__(self, parent = None):
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.onSecondAxes = False

    # locally import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()
    
    self.param = np.array([])
    self.active = []
    self.paramNames =[]
    self.paramAll = []
    self.confidence = []
    self.confidence_apriori = []
    self.ffuncstr_base = ''
    self.ffunc_header = ''
    self.fitresults = ''
    self.chisq = '--'
    self.redchisq = '--'
    
    # memorize plot formatting
    self.rememberSetting = {}
    # use epsilon as minimum error value
    self.EPSILON = 1e-9
    # initialize handles for graphics
    self.handlePlot = None
    self.handlePlot_div = None
    # initialize name
    self.setName('Curve_'+str(len(self.parent.fit)))
    # initialize visibility
    self.visibility = True
    # initialize activity state
    self.retired = False
    # initialize data storage
    self.x = np.array([])
    self.y = np.array([])
    self.x_div = np.array([])
    self.y_div = np.array([])
    # initalize style
    self.style = {}
    self.style['linewidth'] = 1.5
    self.style['linestyle'] = 'solid'
    self.style['dash_capstyle'] = 'butt'
    #self.style['solid_capstyle'] = 'butt'
    self.style['color'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgewidth'] = 1.0
    self.style['markersize'] = 14.0
    self.style['marker'] = 'None'
    self.style['fillstyle'] = 'full'
    self.style['markevery'] = 100
    self.style['doFill'] = True
    # restrict plot interval?
    self.restrictMeLow, self.restrictMeHigh, self.restrictLow, self.restrictHigh = False, False, 0.0, 1.0

    # stuff for split axes
    self.onBothAxes = False
    self.handlesBothAxes = {}
    
    # initialize funcstr_base
    self.ffuncstr_base = ''
    self.ffunc_header = ''
    self.fitresults = ''
    
    # memorize plot settings
    for key in self.style:
      self.rememberSetting[key] = 'set_' + key + '(' + repr(self.style[key]) + ')'
    
  def reportState(self):
    # reports data content for saveState function
    items = 'name,param,ffuncstr_base,ffunc_header,active,paramNames,confidence,confidence_apriori,fitresults,paramAll,zorder,retired,x,y,x_div,y_div,onSecondAxes,onBothAxes,chisq,redchisq,restrictMeLow,restrictMeHigh,restrictLow,restrictHigh'.split(',')
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry in ['x', 'y', 'x_div', 'y_div']):
          value = np.array(data[entry])
        elif(entry == 'zorder'):
          value = data[entry] + zoffset
        elif(entry == 'name'):
          value = data[entry]
          self.setName(value)
        else:
          value = data[entry]
        self.__dict__[entry] = value
        
    # redefine fit function
    if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
      self.updateFunc(self.ffuncstr_base, self.ffunc_header)
      
  def retrieveInfo(self):
    # returns previous fit formula and values etc.
    return self.paramNames, self.ffuncstr_base, self.paramAll, self.active, self.fitresults, self.confidence, self.confidence_apriori

  def retrieveInfoReport(self):
    # returns previous fit formula and values etc. -- for use in generating HTML report
    return self.paramNames, self.active, self.paramAll, self.confidence, self.confidence_apriori, self.chisq, self.redchisq
    
  def storeInfo(self, paramNames, paramAll, active, confidence, confidence_apriori, ffuncstr_base, ffunc_header, fitresults, chisq, redchisq):
    # ensure to make actual copies not soft links!!
    self.paramNames = [i for i in paramNames]
    self.paramAll = [i for i in paramAll]
    self.active = [i for i in active]
    self.confidence = [i for i in confidence]
    self.confidence_apriori = [i for i in confidence_apriori]
    self.ffuncstr_base = ffuncstr_base
    self.ffunc_header = ffunc_header
    self.fitresults = fitresults
    self.chisq = deepcopy(chisq)
    self.redchisq = deepcopy(redchisq)
    
  def clearConfidence(self):
    # clears confidence, e.g., after a minimization call
    self.confidence = ['--'] * len(self.paramAll)
    self.confidence_apriori = ['--'] * len(self.paramAll)
    return [i for i in self.confidence], [i for i in self.confidence_apriori]

  def setName(self, name='Jane Doe'):
    # updates name of object
    self.name = name
    # update plot if necessary
    if(self.handlePlot != None):
      self.handlePlot.set_label(name)
    self.rememberSetting['name'] = 'set_label(' + repr(self.name) + ')'
    
  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    if(self.zorder == zorder):
      redraw, changed = False, False
    else:
      changed = True
    self.zorder = zorder
    # update plot if necessary
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_zorder(self.zorder + self.parent.zOffset)
      if(self.parent.plotArea.splitY and ('handlePlot' in self.handlesBothAxes)):
        self.handlesBothAxes['handlePlot'].set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
      self.rememberSetting['zorder'] = 'set_zorder(' + str(self.zorder + self.parent.zOffset) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_zorder(self.zorder + self.parent.zOffset)
      if(self.parent.plotArea.splitY and ('handlePlot_div' in self.handlesBothAxes)):
        self.handlesBothAxes['handlePlot_div'].set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return changed

  def setBothAxes(self, state=False, redraw=True):
    # moves plot between axes
    self.onBothAxes = state
    # remove surplus items?
    if(self.onBothAxes):
      self.duplicateForSplit()
    else:
      self.removeFromSplit()

  def setSecondAxes(self, state=False, redraw=True):
    # moves plot between axes
    self.onSecondAxes = state
    # check whether dual display is turned on
    if(self.parent.plotArea.splitY and self.onBothAxes):
      # we can just swap the handles
      for item in ['handlePlot', 'handlePlot_div']:
        if(item in self.handlesBothAxes):
          self.__dict__[item], self.handlesBothAxes[item] = self.handlesBothAxes[item], self.__dict__[item]
      return
    # trigger redraw
    self.drawMe(redraw=redraw, rescale=not self.parent.plotArea.splitY)

  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of curve
    if(self.visibility == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibility = state
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_visible(state)
      if(self.visibility):
        self.handlePlot.set_label(self.name)
      else:
        self.handlePlot.set_label('_nolegend_')
      updateFlag = True
      if(self.parent.plotArea.splitY and ('handlePlot' in self.handlesBothAxes)):
        self.handlesBothAxes['handlePlot'].set_visible(state)
      self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_visible(state)
      updateFlag = True
      if(self.parent.plotArea.splitY and ('handlePlot_div' in self.handlesBothAxes)):
        self.handlesBothAxes['handlePlot_div'].set_visible(state)
    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return changed

  def spawned(self, source=None):
    # copies contents of the source object to current object
    # note: we do not need to copy ffunc() since we will redefine it in the new object
    if(source != None):
      copyItems = 'param,style,x,y,visibility,ffuncstr_base,ffunc_header,active,paramNames,confidence,fitresults,paramAll,onSecondAxes,onBothAxes,chisq,redchisq,restrictMeLow,restrictMeHigh,restrictLow,restrictHigh'.split(',') #, ffunc
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
      # redefine fit function
      if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
        self.updateFunc(self.ffuncstr_base, self.ffunc_header)
    
  def initialize(self):
    # initialize object with default values
    success = False
    if (len(self.parent.fitarea.ffuncList)):
      defaultFunction = 'binding_isotherm.ffunc'
      functionNo = 0
      for index, entry in enumerate(self.parent.fitarea.ffuncList):
        if(defaultFunction in entry):
          functionNo = index
      success, self.paramNames, self.ffuncstr_base, self.paramAll, self.active = self.parent.fitarea.loadFfunc(self.parent.fitarea.ffuncList[functionNo])
      self.parent.fitarea.comboBox.blockSignals(True)
      self.parent.fitarea.comboBox.setCurrentIndex(functionNo)
      self.parent.fitarea.comboBox.blockSignals(False)
    # opt for default function if problems arise
    if(not success):
      self.paramNames = ['A0', 'A1', 'KD']
      self.ffuncstr_base = '# a binding isotherm\ny = A0 + A1 * x / (x + KD)'
      self.paramAll = [1, 1, 1]
      self.active = [True] * 3
      
    # prepare and set fit function
    self.param = [i for i, j in zip(self.paramAll, self.active) if j]
    nonactive = [i for i, j in zip(self.paramAll, self.active) if (not j)]
    self.ffunc_header = ', '.join(nonactive)
    self.confidence = ['--'] * len(self.param)

    # redefine fit function
    if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
      self.updateFunc(self.ffuncstr_base, self.ffunc_header)
    
  def drawMe(self, redraw=True, rescale=True):
    # causes curve to be drawn on canvas
    self.handlePlot = self.parent.plotArea.plotFunction(fitobject=self, handlePlot=self.handlePlot, redraw=False, doAutoZoom=rescale)
    # set visibility
    if (self.handlePlot != None):
      self.handlePlot.set_visible(self.visibility)

    self.handlePlot_div = self.parent.plotArea.plotFunction(fitobject=self, handlePlot=self.handlePlot_div, redraw=False, splitX=True, doAutoZoom=rescale)
    # set visibility
    if (self.handlePlot_div != None):
      self.handlePlot_div.set_visible(self.visibility)

    # copy in case split axes are shown
    curve = self
    if(self.parent.plotArea.splitY and curve.onBothAxes):
      curve.duplicateForSplit()
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def styleMe(self, handlePlot=None):
    # applies current styles to plot handle
    if(handlePlot != None):
      for key in self.style:
        method = 'set_' + key
        if (hasattr(handlePlot, method)):
          method2call = getattr(handlePlot, method)
          if((key == 'marker') and (self.style[key] in CUSTOM_MARKERS)):
            method2call(CUSTOM_MARKERS[self.style[key]])
          elif((key == 'marker') and (not (self.style[key] in matplotlib.lines.Line2D.markers))):
            # this is to ensure compatibility with future versions that may introduce markers we don't know yet
            method2call('o')
          else:
            method2call(self.style[key])
      if(not self.style['doFill']):
        if(hasattr(handlePlot, 'set_markerfacecolor')):
          handlePlot.set_markerfacecolor('none')
      
      # set name
      if (hasattr(handlePlot, 'set_label')):
        method2call = getattr(handlePlot, 'set_label')
        method2call(self.name)

  def getStyle(self):
    # returns the style object
    return self.style

  def getRestricted(self):
    # returns restriction info
    return self.restrictMeLow, self.restrictMeHigh, self.restrictLow, self.restrictHigh

  def setRestricted(self, key, value, redraw=True):
    # toggles plot interval restriction
    if(key in ('restrictMeLow', 'restrictMeHigh', 'restrictLow', 'restrictHigh')):
      # actually, we should disable this check to allow correct updating in all instances
      ###if((key in ['restrictMeLow', 'restrictMeHigh']) or (self.__dict__[key] != value)):
      self.__dict__[key] = value
      if(self.retired):
        # temporarily unretire and update
        prevActive = self.parent.activeFit
        self.parent.activeFit = self.parent.fit.index(self)
        self.retired, self.parent.fit[prevActive].retired = False, True
        # change fit formula
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=False)
        self.drawMe(redraw=redraw, rescale=False)
        # restore previous function
        self.retired, self.parent.fit[prevActive].retired = True, False
        self.parent.activeFit = prevActive
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[prevActive].retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=redraw)
      else:
        self.drawMe(redraw=False, rescale=False)
        # need to do the autoscale via the plotArea function to heed split axes
        self.parent.plotArea.doAutoScale(axis='y', redraw=redraw)

  def toggleMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.style['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.style['doFill'] = value
    # adjust value
    if(value):
      value = self.style['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_markerfacecolor(value)
      self.rememberSetting['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_markerfacecolor(value)

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)
    
  def setStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.style):
      if(self.style[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.style[key] = value
      # cause plot to be updated
      updateFlag = False
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.style['doFill']):
        handles, handles_div = [self.handlePlot], [self.handlePlot_div]
        if(self.parent.plotArea.splitY and ('handlePlot' in self.handlesBothAxes)):
          handles += [self.handlesBothAxes['handlePlot']]
        if(self.parent.plotArea.splitY and ('handlePlot_div' in self.handlesBothAxes)):
          handles_div += [self.handlesBothAxes['handlePlot_div']]

        method = 'set_' + key
        for handlePlot in handles:
          if(handlePlot != None):
            if (hasattr(handlePlot, method)):
              method2call = getattr(handlePlot, method)
              if(key == 'marker'):
                if(value in CUSTOM_MARKERS):
                  method2call(CUSTOM_MARKERS[value])
                elif(not (value in matplotlib.lines.Line2D.markers)):
                  # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                  method2call('o')
                else:
                  method2call(value)
              else:
                method2call(value)
              updateFlag = True
              self.rememberSetting[key] = 'set_' + key + '(' + repr(value) + ')'
              # special treatment for capstyle
              if((key == 'dash_capstyle') and (hasattr(handlePlot, 'set_solid_capstyle'))):
                method2call = getattr(handlePlot, 'set_solid_capstyle')
                method2call(value)
                self.rememberSetting['solid_capstyle'] = 'set_solid_capstyle(' + repr(value) + ')'

        for handlePlot_div in handles_div:
          if(handlePlot_div != None):
            method = 'set_' + key
            if (hasattr(handlePlot_div, method)):
              method2call = getattr(handlePlot_div, method)
              if(key == 'marker'):
                if(value in CUSTOM_MARKERS):
                  method2call(CUSTOM_MARKERS[value])
                elif(not (value in matplotlib.lines.Line2D.markers)):
                  # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                  method2call('o')
                else:
                  method2call(value)
              else:
                method2call(value)
              updateFlag = True
              # special treatment for capstyle
              if((key == 'dash_capstyle') and (hasattr(handlePlot_div, 'set_solid_capstyle'))):
                method2call = getattr(handlePlot_div, 'set_solid_capstyle')
                method2call(value)
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)
    
  def updateFunc(self, funcstr_base, ffunc_header, testParam=[]):
    try:
      funcstr = 'def ffunc(self, x' + ffunc_header + '):\n' + funcstr_base + '\n\treturn y'
      # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
      namespace = self.mySpace
      exec(funcstr, namespace)
      # we need to do some initial test to see whether the function can be called
      if(len(testParam)):
        # determine x-range over which function will be applied => we should test this
        xmin, xmax = self.parent.plotArea.minX, self.parent.plotArea.maxX
        if(self.parent.plotArea.modeX == 'linear'):
          testRange = np.linspace(xmin, xmax, self.parent.plotArea.DATAPOINTS_SIMULATION)
        elif(self.parent.plotArea.modeX == 'log'):
          testRange = np.linspace(np.log(xmin), np.log(xmax), self.parent.plotArea.DATAPOINTS_SIMULATION)
          testRange = np.exp(testRange)
        # call function for test purposes
        retv = namespace['ffunc'](self, testRange, *testParam)
        # check for dimension mismatch
        if(retv.shape != testRange.shape):
          # we found some mismatch b/w x and y -- raise error to prevent program crash
          raise ValueError
      # now define the new function in the object scope
      setattr(FitObject, 'ffunc', namespace['ffunc'])
      self.funcstr_base = funcstr_base
      self.ffunc_header = ffunc_header
      return True, ''
    except Exception as e:
      returnstr = repr(e)
      try:
        # determine line numbe of error (subtract 1 because of function header)
        lineno = exc_info()[-1].tb_next.tb_lineno - len(self.paramAll) + len(self.param) - 1
        returnstr = 'line ' + str(lineno) + ': ' + returnstr
      except:
        # need to except this, not least for indentation errors
        pass
      return False, returnstr

  def updateXY(self, x=[], y=[], splitX=False):
    # called by global fit to update fit curve
    if((len(x)) and (len(y))):
      if(splitX):
        self.x_div, self.y_div = x, y
      else:
        self.x, self.y = x, y

  def updateChiSquare(self, chisquare, red_chisquare):
    self.chisq, self.redchisq = chisquare, red_chisquare

  def updateActive(self, active=[]):
    # changes active parameters
    self.active = deepcopy(active)

  def updateParam(self, param=[]):
    self.param = deepcopy(param)
    # also need to change self.paramAll accordingly
    index = 0
    for index2, entry in enumerate(self.paramAll):
      if(self.active[index2]):
        if(index < len(self.param)):
          self.paramAll[index2] = self.param[index]
          index += 1

  def updateParamSelect(self, names=[], values=[]):
    # called by global fit to update parameters
    updated = False
    paramActiveNames = [i for i, j in zip(self.paramNames, self.active) if j]
    for index, entry in enumerate(names):
      if(entry in self.paramNames):
        updated = True
        self.paramAll[self.paramNames.index(entry)] = values[index]
      if(entry in paramActiveNames):
        self.param[paramActiveNames.index(entry)] = values[index]
    
    # reset all confidences and a priori confidences to '--'
    if(updated):
      self.confidence = ['--'] * len(self.paramAll)
      self.confidence_apriori = ['--'] * len(self.paramAll)
      
  def evaluateFunc(self, x=np.array([]), param=[]):
    # evaluate function for a given param array
    if(len(param) == 0):
      param = self.param
    if(not self.retired):
      # evaluate function
      try:
        retv = self.ffunc(x, *param)
      except:
        # some kind of function problem, return empty array
        # for the future: could do this for each data point individually
        retv = np.array([0 for i in x])

    return x, retv

  def simulateFunc(self, x=np.array([]), splitX=False):
    # is this function still active?
    if(splitX):
      if(not self.retired):
        # check for empty x and, if so, use existing self.x
        if(not x.size):
          x = self.x_div
        # evaluate function
        try:
          retv = self.ffunc(x, *self.param)
        except:
          # some kind of function problem, return empty array
          # for the future: could do this for each data point individually
          retv = np.array([0 for i in x])
          
        # store results for future use
        self.x_div, self.y_div = x, retv
      
      # implement check for size -- if mismatch then better return x/y for principal axis
      if((self.x_div.size > 0) and (self.x_div.size == self.y_div.size)):
        return self.x_div, self.y_div
      else:
        return self.x, self.y
    else:
      if(not self.retired):
        # check for empty x and, if so, use existing self.x
        if(not x.size):
          x = self.x
        # evaluate function
        try:
          retv = self.ffunc(x, *self.param)
        except:
          # some kind of function problem, return empty array
          # for the future: could do this for each data point individually
          retv = np.array([0 for i in x])
          
        # store results for future use
        self.x, self.y = x, retv
      
      return self.x, self.y
    
  def fitFunc(self, data={}, initpa=[], boundaryLow=[], boundaryHigh=[]):
    # ensure that boundaries are numpy arrays
    boundaryLow, boundaryHigh = np.array(boundaryLow), np.array(boundaryHigh)
    
    # check if ffunc is defined
    if (hasattr(FitObject, 'ffunc')):
      if (('x' in data) and ('y' in data)):
        # prepare fit
        maxfev = 100000
        # assign and check y error
        if('yerr' in data):
          sigma = data['yerr']
          sigma = [i if (i > 0) else self.EPSILON for i in sigma]
        else:
          sigma = [1] * len(data['y'])
          
        if(not len(initpa)):
          initpa = self.param
          
        # do the actual fit
        if('xerr' in data):
          useAlgorithm = 'odr'
          try:
            # generate wrapper function to refactor x and param vectors
            def odrWrapper(param, x):
              return self.ffunc(x, *param)
            # populate x errors
            sigmaX = data['xerr']
            sigmaX = [i if (i > 0) else self.EPSILON for i in sigmaX]
            # call odr
            odrData = odr.RealData(data['x'], data['y'], sigmaX, sigma)
            odrModel = odr.Model(odrWrapper)
            odrODR = odr.ODR(odrData, odrModel, beta0=initpa)
            odrODR.set_job(fit_type=2)
            odrOut = odrODR.run()
            fitpa, covar = odrOut.beta, odrOut.cov_beta
          except:
            # catch all kind of fit problems
            fitpa = initpa
            covar = np.zeros((len(fitpa), len(fitpa)))
        else:
          # determine whether we have boundaries
          useAlgorithm = 'lm'
          if(len(boundaryLow) or len(boundaryHigh)):
            if(len(boundaryLow[boundaryLow != -np.inf]) or len(boundaryHigh[boundaryHigh != np.inf])):
              # careful -- we need to check whether trf is supported
              try:
                # fake fit call
                optim.curve_fit(lambda y, p: y + 3 + p, [1, 2, 3], [0, -1, 2], [2], method='trf', bounds=(-10, 10))
                useAlgorithm = 'trf'
              except:
                self.parent.statusbar.showMessage('Trf fitting not supported on your platform, will switch to lm!', self.parent.STATUS_TIME)

          # do appropriate fit
          if(useAlgorithm == 'trf'):
            # we do have boundaries here
            # ensure that we start within bounds
            initpa = [min(max(init, lower), upper) for init, lower, upper in zip(initpa, boundaryLow, boundaryHigh)]
            try:
              fitpa, covar = optim.curve_fit(self.ffunc, data['x'], data['y'], initpa, sigma, maxfev=maxfev,\
                                             method=useAlgorithm, bounds=(boundaryLow, boundaryHigh))
            except:
              # catch all kind of fit problems
              fitpa = initpa
              covar = np.zeros((len(fitpa), len(fitpa)))
          else:
            # no boundaries, use Levenberg Marquardt
            try:
              # careful -- we need to check whether method argument is supported
              try:
                optim.curve_fit(lambda y, p: y + 3 + p, [1, 2, 3], [0, -1, 2], [2], method='lm')
                fitpa, covar = optim.curve_fit(self.ffunc, data['x'], data['y'], initpa, sigma, maxfev=maxfev, method=useAlgorithm)
              except:
                fitpa, covar = optim.curve_fit(self.ffunc, data['x'], data['y'], initpa, sigma, maxfev=maxfev)
            except:
              # catch all kind of fit problems
              fitpa = initpa
              covar = np.zeros((len(fitpa), len(fitpa)))

        # update parameters
        self.param = fitpa

        return True, fitpa, covar, useAlgorithm
      else:
        return False, [], [], ''
    else:
      self.parent.statusbar.showMessage('No fit function defined!', self.parent.STATUS_TIME)
      return False, [], [], ''

  def duplicateForSplit(self):
    # duplicates current curve and draws it on split y axis
    # delete all previous items (if any)
    self.removeFromSplit()

    if(self.onSecondAxes):
      axisobjectBase = 'ax'
    else:
      axisobjectBase = 'ax2'
    
    for handle in ['handlePlot', 'handlePlot_div']:
      if(self.__dict__[handle] != None):
        if(handle == 'handlePlot'):
          axisobject = self.parent.plotArea.__dict__[axisobjectBase]
        else:
          axisobject = self.parent.plotArea.__dict__[axisobjectBase + '_div']
        # better get x and y from curve to duplicate (can weed out nans and infs this way)
        xval, yval = self.__dict__[handle].get_xdata(), self.__dict__[handle].get_ydata()
        self.handlesBothAxes[handle], = axisobject.plot(xval, yval, 'ko', zorder = self.zorder + self.parent.zOffset)
        self.styleMe(handlePlot=self.handlesBothAxes[handle])

  def removeFromSplit(self):
    # removes duplicated curve from split y axes
    for handle in self.handlesBothAxes:
      if(hasattr(self.handlesBothAxes[handle], 'remove')):
        self.handlesBothAxes[handle].remove()
    self.handlesBothAxes = {}

# the extras object is used to draw annotation and text on the canvas
class ExtrasObject(object):
  def __init__(self, parent=None):
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.onSecondAxes = False

    self.name = ''
    self.visibility = True
    self.handle = None
    self.handle_div = None
    self.extrasType = 'text'
    self.x, self.y = 1, 1
    self.labeltext = 'text'
    self.color = [0.0, 0.0, 0.0, 1.0]
    self.fontsize = 12.0
    self.fontname = 'DejaVu Sans'
    self.rotation = 0.0
    self.horizontalalignment = 'center'
    self.verticalalignment = 'center'
    self.fontweight = 'normal'
    self.fontstyle = 'normal'
    
    self.arrow__x, self.arrow__y = 2, 2
    self.arrow__arrowstyle = '->'
    self.arrow__head_length, self.arrow__head_width, self.arrow__tail_width = 0.4, 0.4, 0.2
    self.arrow__facecolor, self.arrow__edgecolor = [1.0, 1.0, 1.0, 0.7], [0.0, 0.0, 0.0, 1.0]
    self.arrow__linewidth, self.arrow__linestyle, self.arrow__dash_capstyle = 1.0, 'solid', 'butt'
    self.arrow__shrinkA, self.arrow__shrinkB = 5, 5
    self.arrow__lengthA, self.arrow__lengthB = 0.5, 0.5
    self.arrow__widthA, self.arrow__widthB = 0.5, 0.5
    self.arrow__connector = 'arc3'
    self.arrow__hatch = ''
    self.arrow__hatchMultiply = 1
    self.arrow__doFill = True
    
    self.bbox__show = True
    self.bbox__boxstyle = 'square'
    self.bbox__facecolor, self.bbox__edgecolor = [1.0, 1.0, 1.0, 0.7], [0.0, 0.0, 0.0, 1.0]
    self.bbox__linewidth, self.bbox__linestyle, self.bbox__dash_capstyle = 1.0, 'solid', 'butt'
    self.bbox__pad = 0.5
    self.bbox__hatch = ''
    self.bbox__hatchMultiply = 1
    self.bbox__tooth_size, self.bbox__rounding_size = 0.5, 0.5
    self.bbox__doFill = True
    
    self.x2, self.y2 = self.arrow__x, self.arrow__y
    self.line__linewidth = 1.0
    self.line__linestyle = 'solid'
    self.line__dash_capstyle = 'butt'
    self.line__solid_capstyle = 'butt'
    self.line__color = self.color

    self.shape__type = 'rect'
    self.shape__facecolor = [1.0, 1.0, 1.0, 1.0]
    self.shape__hatch = ''
    self.shape__hatchMultiply = 1
    self.shape__numSpokes = 5
    self.shape__spikiness = 0.6
    self.shape__doFill = True
    self.shape__innerRadius = 0.5
    self.shape__pie = 0.5
    self.shape__vertices = []
    self.shape__closed = False
    
    # store information for graphics export as Python script
    self.rememberSetting = {}
    
    # extra handle for drawing line when interactively modifying annotation object
    self.handleMarkerLine = None

    # stuff for split axes
    self.onBothAxes = False
    self.handlesBothAxes = {}

  def reportState(self):
    # reports data content for saveState function
    items = 'name,zorder,extrasType,x,y,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
    items += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle'
    items += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__dash_capstyle,arrow__connector,arrow__hatch,arrow__hatchMultiply,arrow__doFill'
    items += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
    items += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
    items += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
    items += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
    items += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,shape__innerRadius,shape__pie,shape__vertices,shape__closed,onSecondAxes,onBothAxes'
    items = items.split(',')
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry == 'zorder'):
          value = data[entry] + zoffset
        else:
          value = data[entry]
        self.__dict__[entry] = value

  def drawMe(self, redraw=True):
    # delete previous object if present
    if(self.handle != None):
      self.handle.remove()
    if(self.handle_div != None):
      self.handle_div.remove()
      
    # call helper function to enable drawing of extras for duplication
    self.handle, self.handle_div = self.drawMeHelper(redraw=redraw, duplicate=False)
      
  def drawMeHelper(self, redraw=True, duplicate=False):
    # determine which axes to draw on
    if(self.onSecondAxes):
      if(duplicate):
        useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
      else:
        useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    elif(duplicate):
      useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    else:
      useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
    
    # treat lines differently
    if(self.extrasType == 'line'):
      handle, = useAxes.plot([self.x, self.x2], [self.y, self.y2])
      handle.set_pickradius(PICK_TOLERANCE)
      handle.set_marker('None')
      handle_div, = useAxes2.plot([self.x, self.x2], [self.y, self.y2])
      handle.set_pickradius(PICK_TOLERANCE)
      handle_div.set_marker('None')
      
      # remember settings
      self.rememberSetting['origin_before'] = ''
      self.rememberSetting['origin'] = 'plot([' + repr(self.x) + ', ' + repr(self.arrow__x) + '], [' 
      self.rememberSetting['origin'] += repr(self.y) + ', ' + repr(self.arrow__y) + '])'
      self.rememberSetting['marker'] = 'set_marker(\'None\')'
      
      # apply styles
      for entry in ['linewidth', 'linestyle', 'color', 'dash_capstyle', 'solid_capstyle']:
        if(hasattr(handle, 'set_' + entry)):
          method2call = getattr(handle, 'set_' + entry)
          method2call(self.__dict__['line__' + entry])
          self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['line__' + entry]) + ')'
        if(hasattr(handle_div, 'set_' + entry)):
          method2call = getattr(handle_div, 'set_' + entry)
          method2call(self.__dict__['line__' + entry])
      # treat z order separately
      handle.set_zorder(self.zorder + self.parent.zOffset)
      handle_div.set_zorder(self.zorder + self.parent.zOffset)
      self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'

      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
    elif(self.extrasType == 'shape'):
      # generate shape
      if(self.shape__type == 'rect'):
        useX, useY = self.x - self.x2 / 2.0, self.y - self.y2 / 2.0
        useWidth, useHeight = self.x2, self.y2
        # generate default rectangle
        extraPatch = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)
        extraPatch2 = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)
        # apply transforms (needed b/c rectangle rotates around bottom left corner, not center)
        transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight, self.rotation, duplicate=duplicate)
        extraPatch.set_transform(transform)
        extraPatch2.set_transform(transform2)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useWidth / 2.0) + ', ty=' + repr(useHeight / 2.0) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
        self.rememberSetting['origin_before'] += 'extraPatch = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)\n'
        self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      elif(self.shape__type == 'circle'):
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        extraPatch = matplotlib.patches.Ellipse(xy=(useX, useY), width=useWidth, height=useHeight, angle=self.rotation)
        extraPatch2 = matplotlib.patches.Ellipse(xy=(useX, useY), width=useWidth, height=useHeight, angle=self.rotation)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraPatch = matplotlib.patches.Ellipse(xy=(' + repr(useX) + ', ' + repr(useY) + '), width=' + repr(useWidth)
        self.rememberSetting['origin_before'] += ', height=' + repr(useHeight) + ', angle=' + repr(self.rotation) + ')'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      elif(self.shape__type == 'poly'):
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        # generate regular polygon
        extraPatch = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5)
        extraPatch2 = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5)
        # apply transforms
        transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight, self.rotation, duplicate=duplicate)
        extraPatch.set_transform(transform)
        extraPatch2.set_transform(transform2)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useWidth / 2.0) + ', ty=' + repr(useHeight / 2.0) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
        self.rememberSetting['origin_before'] += 'extraPatch = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=' + repr(self.shape__numSpokes) + ', radius=0.5)\n'
        self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      elif(self.shape__type == 'freehand'):
        if(len(self.shape__vertices)):
          ### mayhaps implement this in a future version but not for now
          ###codes = len(self.shape__vertices) * [matplotlib.path.Path.CURVE4]
          ###codes[0] = matplotlib.path.Path.MOVETO
          ###codes[-1] = matplotlib.path.Path.STOP
          codes = None
          lassoPath = matplotlib.path.Path(self.shape__vertices, codes=codes, closed=self.shape__closed)
          extraPatch = matplotlib.patches.PathPatch(lassoPath)
          extraPatch2 = matplotlib.patches.PathPatch(lassoPath)

          # apply transforms
          useX, useY, useWidth, useHeight = self.x, self.y, self.x2, self.y2
          transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight, self.rotation, duplicate=duplicate)
          extraPatch.set_transform(transform)
          extraPatch2.set_transform(transform2)
      else:
        # use star shape as default
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        if(self.shape__type == 'star'):
          extraPatch = self.pointyStar(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5, ratio=self.shape__spikiness)
          extraPatch2 = self.pointyStar(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5, ratio=self.shape__spikiness)
        else:
          extraPatch = self.torus(xy=(-0.5, -0.5), radius=0.5, innerRadius=self.shape__innerRadius, pie=self.shape__pie)
          extraPatch2 = self.torus(xy=(-0.5, -0.5), radius=0.5, innerRadius=self.shape__innerRadius, pie=self.shape__pie)
        if(extraPatch != None):
          # apply transforms
          transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight, self.rotation, duplicate=duplicate)
          extraPatch.set_transform(transform)
          extraPatch2.set_transform(transform2)

          # remember settings
          self.rememberSetting['origin_before'] = 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
          self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
          self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      
      if(extraPatch != None):
        handle = useAxes.add_patch(extraPatch)
      if(extraPatch2 != None):
        handle_div = useAxes2.add_patch(extraPatch2)
      
      # apply line styles
      for entry in ['linewidth', 'linestyle', 'color', 'capstyle', 'solid_capstyle']:
        if(hasattr(handle, 'set_' + entry)):
          method2call = getattr(handle, 'set_' + entry)
          if(entry == 'capstyle'):
            method2call(self.__dict__['line__dash_capstyle'])
            self.rememberSetting[entry] = 'set_capstyle(' + repr(self.__dict__['line__dash_capstyle']) + ')'
          else:
            method2call(self.__dict__['line__' + entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['line__' + entry]) + ')'
        if(hasattr(handle_div, 'set_' + entry)):
          method2call = getattr(handle_div, 'set_' + entry)
          if(entry == 'capstyle'):
            method2call(self.__dict__['line__dash_capstyle'])
          else:
            method2call(self.__dict__['line__' + entry])

      # apply fill styles
      for entry in ['hatch', 'facecolor']:
        if(hasattr(handle, 'set_' + entry)):
          method2call = getattr(handle, 'set_' + entry)
          if(entry == 'hatch'):
            hatchString = self.shape__hatch * self.shape__hatchMultiply
            method2call(hatchString)
            self.rememberSetting[entry] = 'set_hatch(' + repr(hatchString) + ')'
          else:
            method2call(self.__dict__['shape__' + entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['shape__' + entry]) + ')'
        if(hasattr(handle_div, 'set_' + entry)):
          method2call = getattr(handle_div, 'set_' + entry)
          if(entry == 'hatch'):
            hatchString = self.shape__hatch * self.shape__hatchMultiply
            method2call(hatchString)
          else:
            method2call(self.__dict__['shape__' + entry])
            
      # check whether to fill shape
      if(not self.shape__doFill):
        handle.set_facecolor('none')
        handle_div.set_facecolor('none')

      # treat z order separately
      handle.set_zorder(self.zorder + self.parent.zOffset)
      handle_div.set_zorder(self.zorder + self.parent.zOffset)
      self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'

      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
    else:
      # prepare bbox
      if(self.bbox__show):
        if(self.bbox__hatch == ''):
          hatchString = self.bbox__hatch
        else:
          hatchString = self.bbox__hatch * self.bbox__hatchMultiply
        # implement check to account for different bbox styles on different operating systems
        availableBoxStyles = list(matplotlib.patches.BoxStyle.get_styles().keys())
        if(not(self.bbox__boxstyle in availableBoxStyles)):
          self.bbox__boxstyle = 'square'
        
        # check whether to fill box
        if(self.bbox__doFill):
          useFaceColor = self.bbox__facecolor
        else:
          useFaceColor = 'none'
        # need to implement pad and rounding_size and tooth_size
        bboxProps = {'boxstyle': self.bbox__boxstyle, 'facecolor': useFaceColor, 'edgecolor': self.bbox__edgecolor,\
                     'linewidth': self.bbox__linewidth, 'linestyle': self.bbox__linestyle, 'hatch': hatchString, 'capstyle': self.bbox__dash_capstyle}
        #bboxProps['pad'] = self.bbox__pad  # this effing will not work under Linux
        bboxProps['boxstyle'] = bboxProps['boxstyle'] + ',pad=' + str(self.bbox__pad)  # this will work under Linux as well
      # causes extras to be drawn on canvas
      if(self.extrasType == 'text'):
        if(self.bbox__show):
          handle = useAxes.text(self.x, self.y, self.labeltext, bbox=bboxProps)
          handle_div = useAxes2.text(self.x, self.y, self.labeltext, bbox=bboxProps)
          handle.set_clip_on(True)
          handle_div.set_clip_on(True)
          # apply bbox properties post creation
          styleObject = handle.get_bbox_patch().get_boxstyle()
          boxstyleExtension = ''
          for entry in ['tooth_size', 'rounding_size', 'pad']:
            if(hasattr(styleObject, entry)):
              boxstyleExtension += ',' + entry + '=' + str(self.__dict__['bbox__' + entry])
          bboxProps['boxstyle'] = self.bbox__boxstyle + boxstyleExtension
          handle.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
          # remember settings
          self.rememberSetting['origin_before'] = ''
          self.rememberSetting['origin'] = 'text(' + repr(self.x) + ', ' + repr(self.y) + ', ' + repr(self.labeltext)
          self.rememberSetting['origin'] += ', bbox=' + repr(bboxProps) + ')'
          # and do this for handle_div
          handle_div.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
        else:
          handle = useAxes.text(self.x, self.y, self.labeltext)
          handle_div = useAxes2.text(self.x, self.y, self.labeltext)
          self.rememberSetting['origin'] = 'text(' + repr(self.x) + ', ' + repr(self.y) + ', ' + repr(self.labeltext) + ')'
      else:
        # implement check for quadratic connector
        safeConnector = 'arc3'
        if(self.arrow__arrowstyle in ['fancy', 'simple', 'wedge']):
          if(not(self.arrow__connector in ['arc3', 'angle3'])):
            self.parent.statusbar.showMessage('Connector style ' + self.arrow__connector + ' incompatible with ' + self.arrow__arrowstyle + '. Reverting to ' + safeConnector + '!', self.parent.STATUS_TIME)
            self.arrow__connector = safeConnector
  
        # check whether to fill arrow
        if(self.arrow__doFill):
          useFaceColor = self.arrow__facecolor
        else:
          useFaceColor = 'none'
        # draw annotation (unfortunately, matplotlib hard-codes 'round' capstyle, so this setting won't do anything)
        arrowProps = {'facecolor': useFaceColor, 'arrowstyle': self.arrow__arrowstyle,\
                      'edgecolor': self.arrow__edgecolor, 'linewidth': self.arrow__linewidth, 'linestyle': self.arrow__linestyle,\
                      'capstyle': self.arrow__dash_capstyle, 'shrinkA': self.arrow__shrinkA, 'shrinkB': self.arrow__shrinkB,\
                      'connectionstyle': self.arrow__connector}#, 'head_length': self.arrow__head_length}
        if(self.bbox__show):
          handle = useAxes.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps, bbox=bboxProps)
          handle_div = useAxes2.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps, bbox=bboxProps)
          # apply bbox properties post creation
          styleObject = handle.get_bbox_patch().get_boxstyle()
          boxstyleExtension = ''
          for entry in ['tooth_size', 'rounding_size', 'pad']:
            if(hasattr(styleObject, entry)):
              boxstyleExtension += ',' + entry + '=' + str(self.__dict__['bbox__' + entry])
          bboxProps['boxstyle'] = self.bbox__boxstyle + boxstyleExtension
          handle.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
          handle_div.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
        else:
          handle = useAxes.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps)
          handle_div = useAxes2.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps)
        
        # apply properties to annotation
        if(self.arrow__hatch == ''):
          hatchString = self.arrow__hatch
        else:
          hatchString = self.arrow__hatch * self.arrow__hatchMultiply
        handle.arrow_patch.set_hatch(hatchString)
        handle_div.arrow_patch.set_hatch(hatchString)
        self.rememberSetting['hatch'] = 'arrow_patch.set_hatch(' + repr(hatchString) + ')'
        
        # apply arrow properties post creation
        goodProperties = []
        styleObject = handle.arrow_patch.get_arrowstyle()
        self.arrow__head_width, self.arrow__head_length = self.arrow__widthB, self.arrow__lengthB
        self.arrow__tail_width = self.arrow__widthA
        properties = 'arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB,arrow__head_width,arrow__head_length,arrow__tail_width'
        for entry in properties.split(','):
          workArrowStyle = self.arrow__arrowstyle
          currProp = entry.split('__')[-1]
          if(hasattr(styleObject, currProp)):
            workArrowStyle += ', ' + currProp + '=' + str(self.__dict__[entry])
            # try setting this property to thus check wether current style accepts it (this is really ugly but matplotlib wants it like this, grrrrrrrrr)
            try:
              handle.arrow_patch.set_arrowstyle(workArrowStyle)
              handle_div.arrow_patch.set_arrowstyle(workArrowStyle)
              goodProperties.append(entry)
            except:
              # suck it up and do nothing
              pass
        # check whether any property survived
        if(len(goodProperties)):
          workArrowStyle = self.arrow__arrowstyle
          for entry in goodProperties:
            currProp = entry.split('__')[-1]
            workArrowStyle += ', ' + currProp + '=' + str(self.__dict__[entry])
          # throw in another try for safety's measure
          try:
            handle.arrow_patch.set_arrowstyle(workArrowStyle)
            handle_div.arrow_patch.set_arrowstyle(workArrowStyle)
          except:
            pass
          # remember this
          self.rememberSetting['arrowstyle'] = 'arrow_patch.set_arrowstyle(' + repr(workArrowStyle) + ')'
        elif('arrowstyle' in self.rememberSetting):
          # delete key from dict
          self.rememberSetting.pop('arrowstyle', None)
          
        # now remember all this
        self.rememberSetting['origin_before'] = ''
        self.rememberSetting['origin'] = 'annotate(' + repr(self.labeltext) + ', xytext=(' + repr(self.x) + ', ' + repr(self.y) + ')'
        self.rememberSetting['origin'] += ', xy=(' + repr(self.arrow__x) + ', ' + repr(self.arrow__y) + '), arrowprops=' + repr(arrowProps)
        if(self.bbox__show):
          self.rememberSetting['origin'] += ', bbox=' + repr(bboxProps) + ')'
        else:
          self.rememberSetting['origin'] += ')'
  
      # set visibility
      if (handle != None):
        handle.set_visible(self.visibility)
        self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
        
        styleItems = 'color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'.split(',')
        for entry in styleItems:
          if((hasattr(handle, 'set_' + entry)) and (hasattr(self, entry))):
            method2call = getattr(handle, 'set_' + entry)
            method2call(self.__dict__[entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__[entry]) + ')'
          if((handle_div != None) and (hasattr(handle_div, 'set_' + entry)) and (hasattr(self, entry))):
            method2call = getattr(handle_div, 'set_' + entry)
            method2call(self.__dict__[entry])
        
        # treat z order separately
        handle.set_zorder(self.zorder + self.parent.zOffset)
        self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'
        if(handle_div != None):
          handle_div.set_visible(self.visibility)
          handle_div.set_zorder(self.zorder + self.parent.zOffset)
  
        # process text and check for bad math text
        try:
          handle._get_layout(self.parent.plotArea.matplot.canvas.renderer)
          if(handle_div != None):
            handle_div._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        except:
          self.parent.statusbar.showMessage('Problems setting label to ' + self.labeltext + '!', self.parent.STATUS_TIME)
          self.labeltext = self.labeltext.replace('$', '')
        
        self.labeltext = self.labeltext.replace('\n', '\\n')
        self.labeltext = self.labeltext.replace('\t', '\\t')
        self.labeltext = '\n'.join([i for i in self.labeltext.split('\\n') if (len(i.strip()))])
        self.labeltext = '\t'.join([i for i in self.labeltext.split('\\t') if (len(i.strip()))])
        handle.set_text(self.labeltext)
        if(handle_div != None):
          handle_div.set_text(self.labeltext)
  
        # need to implement extra check for fontname due to erroneous fonts
        try:
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Experiencing problems with font ' + self.fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.fontname = safeFont
          handle.set_fontname(safeFont)
          if(handle_div != None):
            handle_div.set_fontname(safeFont)
  
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
        
        # adjust remember settings
        self.rememberSetting['text'] = 'set_text(' + repr(self.labeltext) + ')'
        self.rememberSetting['fontname'] = 'set_fontname(' + repr(self.fontname) + ')'

    # return handles
    return handle, handle_div

  def masterTransform(self, useX, useY, useWidth, useHeight, useRotation, duplicate=False):
    # helper function that calculates transforms for extras object
    # needed to outsource it to here as also required by updateMe()
    if(self.onSecondAxes):
      if(duplicate):
        useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
      else:
        useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    elif(duplicate):
      useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    else:
      useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div

    if(self.shape__type == 'rect'):
      # apply transforms (needed b/c rectangle rotates around bottom left corner, not center)
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().rotate_deg(useRotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useWidth / 2.0, ty=useHeight / 2.0)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)
    elif(self.shape__type == 'circle'):
      # return matrix for circle (first return to origin before scaling)
      transform = matplotlib.transforms.Affine2D().translate(tx=-self.x, ty=-self.y)
      transform += matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX + self.x, ty=useY + self.y)
    elif(self.shape__type == 'poly'):
      # transformation for polygon
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().translate(tx=useWidth / 2.0, ty=useHeight / 2.0)
      transform += matplotlib.transforms.Affine2D().rotate_deg(useRotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)
    elif(self.shape__type == 'freehand'):
      # transformations for freehand
      intrinsicX, intrinsicY, intrinsicWidth, intrinsicHeight = self.getFreehandDimensions()
      try:
        sx = useWidth / intrinsicWidth
      except:
        sx = 1
      try:
        sy = useHeight / intrinsicHeight
      except:
        sy = 1
      transform = matplotlib.transforms.Affine2D().scale(sx=sx, sy=sy)
      transform += matplotlib.transforms.Affine2D().rotate_deg(useRotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX - intrinsicX, ty=useY - intrinsicY)
    else:
      # use star shape and torus as default
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().rotate_deg(useRotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)

    transform2 = transform + useAxes2.transData
    transform += useAxes.transData

    return transform, transform2

  def torus(self, xy=(0, 0), radius=1, innerRadius=0.5, pie=1):
    # draws a toroidal shape
    def drawCircle(r):
      # copied from Matplotlib documentation
      t = np.arange(0, np.pi * 2.0 * pie, 0.01)
      t = t.reshape((len(t), 1))
      x = r * np.cos(t)
      y = r * np.sin(t)
      return np.hstack((x, y))

    # calculate coordinates for inside and outside coordinates
    outside = drawCircle(radius)
    inside = drawCircle(radius * innerRadius)

    # prepare path coordinates
    codes = [matplotlib.path.Path.LINETO for i in range(len(outside))]
    if(pie < 1):
      codes.extend(codes)
      codes[0] = matplotlib.path.Path.MOVETO
    else:
      codes[0] = matplotlib.path.Path.MOVETO
      codes.extend(codes)

    # calculate the path
    coords = np.concatenate((outside, inside[::-1]))
    if(pie < 1):
      codes.append(matplotlib.path.Path.LINETO)
      coords = np.concatenate((coords, outside[:1]))
    path = matplotlib.path.Path(coords, codes)

    # draw the shape
    extrasPatch = matplotlib.patches.PathPatch(path)
    return extrasPatch

  def pointyStar(self, xy=(0, 0), numVertices=5, radius=1, ratio=0.7):
    # draws a pointy star with arbitrary spokes
    if(numVertices > 2):
      # calculate the coords
      coords = []
      angles = np.linspace(0, 2.0 * np.pi, numVertices + 1)
      for index, entry in enumerate(angles):
        coords.append([radius * np.sin(entry), radius * np.cos(entry)])
        if(index < len(angles) - 1):
          coords.append([ratio * radius * np.sin((entry + angles[index + 1]) / 2.0), ratio * radius * np.cos((entry + angles[index + 1]) / 2.0)])
        
      # remember setting
      self.rememberSetting['origin_before'] = 'extraPatch = matplotlib.patches.Polygon(xy=' + repr(coords) + ', closed=True)\n'
        
      # draw the shape
      extrasPatch = matplotlib.patches.Polygon(xy=coords, closed=True)
      return extrasPatch

    return None

  def setValues(self, valueDict, redraw=True):
    # sets values of the extras object
    tempRedraw = False
    if(type(valueDict) == type({})):
      keys = valueDict.keys()
      for entry in keys:
        if(hasattr(self, entry)):
          if(self.__dict__[entry] != valueDict[entry]):
            tempRedraw = True
          self.__dict__[entry] = valueDict[entry]
          
      # check whether we updated vertices => need to initialize coordinates, width and height
      if(('shape__vertices' in keys) and (self.shape__type == 'freehand')):
        deltaX, deltaY, self.x2, self.y2 = self.getFreehandDimensions()
        self.shape__vertices = self.shiftFreehand(-deltaX, -deltaY)
        self.x, self.y = deltaX, deltaY
          
      if(redraw and tempRedraw):
        self.drawMe(redraw=redraw)

  def getFreehandDimensions(self):
    # returns center position and height and width of freehand shape
    if(len(self.shape__vertices)):
      tempVertices = np.array(self.shape__vertices)
      xmin, xmax = np.min(tempVertices[:, 0]), np.max(tempVertices[:, 0])
      ymin, ymax = np.min(tempVertices[:, 1]), np.max(tempVertices[:, 1])
      x, y = (xmax + xmin) / 2., (ymax + ymin) / 2.
      width, height = np.abs(xmax - xmin), np.abs(ymax - ymin)
      return x, y, width, height
    else:
      return 0, 0, 1, 1

  def shiftFreehand(self, deltaX, deltaY):
    # moves freehand shape by deltaX and deltaY
    if(len(self.shape__vertices)):
      tempVertices = np.array(self.shape__vertices)
      tempVertices[:, 0] += deltaX
      tempVertices[:, 1] += deltaY
      return tempVertices
    else:
      return []
    
  def simplifyMe(self, redraw=True):
    # reduces number of vertices and hence simplifies freehand object
    windowSize = 5 # should be at least 3
    if(len(self.shape__vertices)):
      nuVertices = []
      oldBatchPos = [i / windowSize for i in range(windowSize - 1)]
      newBatchPos = [i / windowSize for i in range(windowSize - 2)]
      currpos = 0
      while(currpos + windowSize <= len(self.shape__vertices)):
        for index, value in enumerate(newBatchPos):
          # determine fraction for calculating new coordinates
          fraction = (oldBatchPos[index + 1] - value) / (oldBatchPos[index + 1] - oldBatchPos[index])
          x1, y1 = self.shape__vertices[currpos + index]
          x2, y2 = self.shape__vertices[currpos + index + 1]
          nuVertices.append([x1 * fraction + (1 - fraction) * x2, y1 * fraction + (1 - fraction) * y2])
        currpos += windowSize - 1
      # append final vertices
      nuVertices = np.vstack((nuVertices, self.shape__vertices[currpos:]))
      ###nuVertices.extend(self.shape__vertices[currpos:])
      self.shape__vertices = nuVertices

      if(redraw):
        self.drawMe(redraw=redraw)

  def setBothAxes(self, state=False, redraw=True):
    # moves plot between axes
    self.onBothAxes = state
    # remove surplus items?
    if(self.onBothAxes):
      self.duplicateForSplit()
    else:
      self.removeFromSplit()

  def setSecondAxes(self, state=False, redraw=True):
    # moves extra between axes
    self.onSecondAxes = state
    # check whether dual display is turned on
    if(self.parent.plotArea.splitY and self.onBothAxes):
      # we can just swap the handles
      for item in ['handle', 'handle_div']:
        if(item in self.handlesBothAxes):
          self.__dict__[item], self.handlesBothAxes[item] = self.handlesBothAxes[item], self.__dict__[item]
      return
    # update plot
    self.drawMe(redraw=redraw)
          
  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of extra
    self.visibility = state
    updateFlag = False
    if(self.handle != None):
      self.handle.set_visible(state)
      if(self.parent.plotArea.splitY and ('handle' in self.handlesBothAxes)):
        self.handlesBothAxes['handle'].set_visible(state)
      updateFlag = True
      # adjust remember settings
      self.rememberSetting['visible'] = 'set_visible(' + repr(state) + ')'
    if(self.handle_div != None):
      self.handle_div.set_visible(state)
      if(self.parent.plotArea.splitY and ('handle_div' in self.handlesBothAxes)):
        self.handlesBothAxes['handle_div'].set_visible(state)
      updateFlag = True

    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def spawned(self, source=None):
    # copies contents of the source object to current object
    if(source != None):
      copyItems = 'x,y,visibility,extrasType,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
      copyItems += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle,arrow__dash_capstyle'
      copyItems += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__connector,arrow__hatch,arrow__hatchMultiply,arrow__doFill'
      copyItems += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
      copyItems += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
      copyItems += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
      copyItems += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
      copyItems += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,shape__innerRadius,shape__pie,shape__vertices,shape__closed,onSecondAxes,onBothAxes'
      copyItems = copyItems.split(',')
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
          
  def getStyle(self):
    # returns as dictionary various style settings
    copyItems = 'x,y,visibility,extrasType,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
    copyItems += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle,arrow__dash_capstyle'
    copyItems += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__connector,arrow__hatch,arrow__hatchMultiply,arrow__doFill'
    copyItems += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
    copyItems += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
    copyItems += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
    copyItems += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
    copyItems += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,shape__innerRadius,shape__pie,shape__vertices,shape__closed,onSecondAxes,onBothAxes'
    copyItems = copyItems.split(',')
    style = {}
    for entry in copyItems:
      if(hasattr(self, entry)):
        style[entry] = self.__dict__[entry]
    
    return style

  def setStyle(self, key=None, value=0, redraw=True):
    # sets a style setting
    if(hasattr(self, key)):
      if(self.__dict__[key] == value):
        redraw = False
      self.__dict__[key] = value
      if((key == 'shape__facecolor') and (not self.shape__doFill)):
        redraw = False
      if(redraw):
        if(self.parent.plotArea.splitY and self.onBothAxes):
          self.removeFromSplit()
          self.handlesBothAxes['handle'], self.handlesBothAxes['handle_div'] = self.drawMeHelper(redraw=False, duplicate=True)
        self.drawMe()

  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    self.zorder = zorder
    # update plot if necessary
    updateFlag = False
    if(self.handle != None):
      self.handle.set_zorder(self.zorder + self.parent.zOffset)
      if(self.parent.plotArea.splitY and ('handle' in self.handlesBothAxes)):
        self.handlesBothAxes['handle'].set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
    if(self.handle_div != None):
      self.handle_div.set_zorder(self.zorder + self.parent.zOffset)
      if(self.parent.plotArea.splitY and ('handle_div' in self.handlesBothAxes)):
        self.handlesBothAxes['handle_div'].set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True

    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def updateMe(self, deltaX, deltaY, pickedAxes, pickedBackground, pickedMode=0, transient=True):
    # function called by interactive drag and resize
    if((pickedAxes != None) and (pickedBackground != None)):
      tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.x2 + deltaX, self.y + deltaY, self.y2 + deltaY
      renderer = self.parent.plotArea.matplot.canvas.renderer
      
      # determine which axis we are on -- don't confuse second axis with div
      if(pickedAxes in (self.parent.plotArea.ax_div, self.parent.plotArea.ax2_div)):
        useHandle = self.handle_div
        if(self.parent.plotArea.splitY and self.onBothAxes):
          if(self.onSecondAxes and (pickedAxes == self.parent.plotArea.ax_div)):
            useHandle = self.handlesBothAxes['handle_div']
          if((not self.onSecondAxes) and (pickedAxes == self.parent.plotArea.ax2_div)):
            useHandle = self.handlesBothAxes['handle_div']
      else:
        useHandle = self.handle
        if(self.parent.plotArea.splitY and self.onBothAxes):
          if(self.onSecondAxes and (pickedAxes == self.parent.plotArea.ax)):
            useHandle = self.handlesBothAxes['handle']
          if((not self.onSecondAxes) and (pickedAxes == self.parent.plotArea.ax2)):
            useHandle = self.handlesBothAxes['handle']
        
      # calculate rotation value
      if(pickedMode == 2):
        if(deltaX):
          if(self.extrasType in ['text', 'annotation']):
            xlim, ylim = pickedAxes.get_xlim(), pickedAxes.get_ylim()
            xdist, ydist = np.abs(xlim[0] - xlim[1]), np.abs(ylim[0] - ylim[1])
            deltaAngle = np.arctan((deltaY / ydist) / (deltaX / xdist)) * 2 / np.pi * 180.0
          else:
            deltaAngle = np.arctan(deltaY / deltaX) * 2 / np.pi * 180.0
          useRotation = self.rotation + deltaAngle
          if(useRotation < 0):
            useRotation += 360.0
          if(useRotation > 360.0):
            useRotation -= 360.0
        else:
          useRotation = self.rotation
      else:
        useRotation = self.rotation
      
      # restore background
      pickedAxes.figure.canvas.restore_region(pickedBackground)

      if(self.extrasType == 'line'):
        if(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x - deltaX / 2.0, self.x2 + deltaX / 2.0, self.y - deltaY / 2.0, self.y2 + deltaY / 2.0
  
        useHandle.set_xdata([tempX, tempX2])
        useHandle.set_ydata([tempY, tempY2])
  
        if(not transient):
          self.x, self.x2, self.y, self.y2 = tempX, tempX2, tempY, tempY2
      elif(self.extrasType == 'shape'):
        if(pickedMode == 2):
          tempX, tempX2, tempY, tempY2 = self.x, self.x2, self.y, self.y2
        elif(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x, self.x2 + deltaX, self.y, self.y2 + deltaY
        else:
          tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.x2, self.y + deltaY, self.y2

        # here it will be better to go via set_transform
        if(self.shape__type == 'circle'):
          useHandle.angle = useRotation
          transform, transform2 = self.masterTransform(useX=tempX - self.x, useY=tempY - self.y, useWidth=tempX2 / self.x2, useHeight=tempY2 / self.y2, useRotation=useRotation)
        elif(self.shape__type == 'rect'):
          transform, transform2 = self.masterTransform(useX=tempX - self.x2 / 2.0, useY=tempY - self.y2 / 2.0, useWidth=tempX2, useHeight=tempY2, useRotation=useRotation)
        else:
          transform, transform2 = self.masterTransform(useX=tempX, useY=tempY, useWidth=tempX2, useHeight=tempY2, useRotation=useRotation)

        if(pickedAxes in (self.parent.plotArea.ax_div, self.parent.plotArea.ax2_div)):
          useHandle.set_transform(transform2)
        else:
          useHandle.set_transform(transform)

        if(not transient):
          if(pickedMode == 2):
            self.rotation = useRotation
          elif(pickedMode and (self.shape__type == 'rect')):
            self.x, self.x2, self.y, self.y2 = tempX - (self.x2 - tempX2) / 2.0, tempX2, tempY - (self.y2 - tempY2) / 2.0, tempY2
          else:
            self.x, self.x2, self.y, self.y2 = tempX, tempX2, tempY, tempY2
      elif(self.extrasType == 'text'):
        if(pickedMode == 2):
          useHandle.set_rotation(useRotation)
          if(not transient):
            self.rotation = useRotation
        elif(not pickedMode):
          useHandle.set_x(tempX)
          useHandle.set_y(tempY)
          if(not transient):
            self.x, self.y = tempX, tempY
      elif(self.extrasType == 'annotation'):
        if(pickedMode == 2):
          useHandle.set_rotation(useRotation)
        elif(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x, self.arrow__x + deltaX, self.y, self.arrow__y + deltaY
  
          # we need to generate a temp line here to serve as the marker for the interactive modification as the arrow object does not update
          if(self.handleMarkerLine == None):
            self.handleMarkerLine, = pickedAxes.plot([tempX, tempX2], [tempY, tempY2])
            self.handleMarkerLine.set_linestyle('solid')
            self.handleMarkerLine.set_linewidth(1)
            if(pickedAxes == self.parent.plotArea.ax_div):
              canvasColor = self.parent.plotArea.ax2_div.patch.get_facecolor()
            elif(pickedAxes == self.parent.plotArea.ax):
              canvasColor = self.parent.plotArea.ax2.patch.get_facecolor()
            else:
              canvasColor = pickedAxes.patch.get_facecolor()
            # we need this check to deal with canvas having 'none' facecolor
            if(np.isclose(sum(canvasColor), 0.0)):
              canvasColor = self.parent.plotArea.matplot.get_facecolor()
            if(sum(canvasColor[0:3]) < 1.5):
              self.handleMarkerLine.set_color('white')
            else:
              self.handleMarkerLine.set_color('black')
            self.handleMarkerLine.set_zorder(self.zorder + self.parent.zOffset + 0.1)
          else:
            self.handleMarkerLine.set_xdata([tempX, tempX2])
            self.handleMarkerLine.set_ydata([tempY, tempY2])
            
          self.handleMarkerLine.draw(renderer)
        else:
          tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.arrow__x, self.y + deltaY, self.arrow__y
  
          useHandle.set_x(tempX)
          useHandle.set_y(tempY)
    
        if(not transient):
          if(pickedMode == 2):
            self.rotation = useRotation
          else:
            self.x, self.arrow__x, self.y, self.arrow__y = tempX, tempX2, tempY, tempY2
            if(self.handleMarkerLine != None):
              if(hasattr(self.handleMarkerLine, 'remove')):
                self.handleMarkerLine.remove()
              self.handleMarkerLine = None

      # update object
      useHandle.draw(renderer)
    
      # and blit just the redrawn area
      pickedAxes.figure.canvas.blit(pickedAxes.bbox)

  def duplicateForSplit(self):
    # duplicates current extra and draws it on split y axis
    # delete all previous items (if any)
    self.removeFromSplit()
    # draw me on split y axis
    self.handlesBothAxes['handle'], self.handlesBothAxes['handle_div'] = self.drawMeHelper(redraw=False, duplicate=True)

  def removeFromSplit(self):
    # removes duplicated extra from split y axes
    for handle in self.handlesBothAxes:
      if(hasattr(self.handlesBothAxes[handle], 'remove')):
        self.handlesBothAxes[handle].remove()
    self.handlesBothAxes = {}
    
# the data object holds individual data sets
class DataObject(object):
  def __init__(self, parent=None):
    self.initValues()
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.zorderResid = len(self.parent.data) + 2
    self.onSecondAxes = False
    
    # stuff for split axes
    self.onBothAxes = False
    self.handlesBothAxes = {}
    
    # parameters for global fit
    self.globalFitCheck = True
    self.globalFitCurve = 0

    # initalize parameters
    self.initParam()

  def initValues(self):
    # initializes data values
    self.x = np.array([])
    self.y = np.array([])
    self.xerr = np.array([])
    self.yerr = np.array([])
    self.fval = np.array([])
    self.resid = np.array([])
    self.labels = []
    
  def initParam(self):    
    # memorize plot formatting
    self.rememberSetting = {}
    self.rememberSettingError = {}
    self.rememberSettingErrorShady = {}
    self.rememberSettingBar = {}
    self.rememberSettingStack = {}
    self.rememberSettingStackNeg = {}
    self.rememberSettingResid = {}
    self.rememberSettingResidBar = {}
    self.rememberSettingResidStack = {}
    self.rememberSettingResidStackNeg = {}
    # initialize handles for graphics
    self.handleData = None
    self.handleErr = None
    self.handleBar = None
    self.handleStack = None
    self.handleStackNeg = None
    self.handleErrShady = None
    self.handleText = None
    self.handleViolin = None
    self.handleResid = None
    self.handleResidBar = None
    self.handleResidStack = None
    self.handleResidStackNeg = None
    self.handleResidText = None
    ##
    self.handleData_div = None
    self.handleErr_div = None
    self.handleBar_div = None
    self.handleStack_div = None
    self.handleStackNeg_div = None
    self.handleErrShady_div = None
    self.handleText_div = None
    self.handleViolin_div = None
    self.handleResid_div = None
    self.handleResidBar_div = None
    self.handleResidStack_div = None
    self.handleResidStackNeg_div = None
    self.handleResidText_div = None
    # initialize name
    self.setName('Data_' + str(len(self.parent.data)))
    self.setNameResid('Resid_' + str(len(self.parent.data)))
    # initialize visibility
    self.visibility = True
    self.visibilityResid = True
    # initalize style
    self.style = {}
    self.style['linewidth'] = 1.0
    self.style['linestyle'] = 'None'
    self.style['dash_capstyle'] = 'butt'
    #self.style['solid_capstyle'] = 'butt'
    self.style['color'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgewidth'] = 0.5
    self.style['markersize'] = 10.0
    self.style['marker'] = 'o'
    self.style['fillstyle'] = 'full'
    self.style['markevery'] = 1
    self.style['doFill'] = True
    
    # intialize error style
    self.Errorstyle = {}
    self.Errorstyle['color'] = [0.0, 0.0, 0.0, 1.0]
    self.Errorstyle['linewidth'] = 1.0
    self.Errorstyle['linestyle'] = 'solid'
    self.Errorstyle['marker'] = '_'
    self.Errorstyle['markerX'] = '|'
    self.Errorstyle['markerfacecolor'] = [0.89, 0.29, 0.2, 0.5]
    self.Errorstyle['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.Errorstyle['markeredgecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.Errorstyle['markeredgewidth'] = 0.5
    self.Errorstyle['markersize'] = 10.0
    self.Errorstyle['fillstyle'] = 'full'
    self.Errorstyle['doFill'] = True
    self.Errorstyle['errorInFront'] = False
    self.Errorstyle['visible'] = True
    self.Errorstyle['direction'] = 'both'
    
    # intialize error shading style
    self.ErrorShadystyle = {}
    self.ErrorShadystyle['visible'] = False
    self.ErrorShadystyle['facecolor'] = [0.8, 0.2, 0.2, 0.5]
    self.ErrorShadystyle['edgecolor'] = [0.8, 0.2, 0.2, 1.0]
    self.ErrorShadystyle['linestyle'] = 'solid'
    self.ErrorShadystyle['linewidth'] = 0.0
    
    # initialize bar style
    self.Barstyle = {}
    self.Barstyle['showBar'] = False
    self.Barstyle['linewidth'] = 0.5
    self.Barstyle['linestyle'] = 'solid'
    self.Barstyle['capstyle'] = 'butt'
    self.Barstyle['facecolor'] = [0.8, 0.2, 0.2, 1.0]
    self.Barstyle['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
    self.Barstyle['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
    self.Barstyle['width'] = 0.1
    self.Barstyle['hatch'] = ''
    self.Barstyle['hatchMultiply'] = 1
    self.Barstyle['offset'] = 0
    self.Barstyle['doFill'] = True
    
    # initialize stack style
    self.Stackstyle = {}
    self.Stackstyle['showStack'] = False
    self.Stackstyle['linewidth'] = 0.5
    self.Stackstyle['linestyle'] = 'solid'
    self.Stackstyle['facecolor'] = [0.2, 0.8, 0.2, 0.5]
    self.Stackstyle['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
    self.Stackstyle['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
    self.Stackstyle['hatch'] = ''
    self.Stackstyle['hatchMultiply'] = 1
    self.Stackstyle['doFill'] = True
    
    # initialize text style
    self.Textstyle = {}
    self.Textstyle['showText'] = False
    self.Textstyle['skip'] = 1
    self.Textstyle['color'] = [0.2, 0.2, 0.2, 1.0]
    self.Textstyle['fontsize'] = 10
    self.Textstyle['fontweight'] = 'normal'
    self.Textstyle['fontstyle'] = 'normal'
    self.Textstyle['fontname'] = 'Dejavu Sans'
    self.Textstyle['rotation'] = 0.0
    self.Textstyle['padX'] = 0.0
    self.Textstyle['padY'] = 0.0
    self.Textstyle['type'] = 'y'
    
    # initialize violin style
    self.Violinstyle = {}
    self.Violinstyle['mode'] = 0
    self.Violinstyle['bodies'] = {'facecolor': [0.99, 0.59, 0.5, 1.0], 'edgecolor': [0.2, 0.2, 0.2, 1.0], 'linestyle': 'solid', 'linewidth': 1.0,\
                    'capstyle': 'butt', 'hatch': '', 'hatchMultiply': 1, 'visible': True, 'width': 0.5, 'doFill': True}
    self.Violinstyle['cmaxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'capstyle': 'butt', 'visible': True}
    for slaved in ['cbars', 'cmeans']:
      self.Violinstyle[slaved] = {}
      self.Violinstyle[slaved].update(self.Violinstyle['cmaxes'])
    self.Violinstyle['cmedians'] = {'visible': False}
    self.Violinstyle['cmins'] = {'visible': True}

    # initialize boxplot style -- we can lumo this together with the violin style as the keys are non-overlapping
    self.Violinstyle['boxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.89, 0.29, 0.2, 1.0], 'dash_capstyle': 'butt', 'visible': True}
    for slaved in ['whiskers', 'medians', 'caps']:
      self.Violinstyle[slaved] = {}
      self.Violinstyle[slaved].update(self.Violinstyle['boxes'])
    self.Violinstyle['boxes'].update({'edgecolor': [0.2, 0.2, 0.2, 1.0], 'width': 0.5, 'boxFill': True, 'facecolor': [0.99, 0.59, 0.5, 1.0], 'hatch': '', 'hatchMultiply': 1})
    # only used this key temporarily for slaving whiskers etc.
    del self.Violinstyle['boxes']['color']
    self.Violinstyle['fliers'] = {'visible': True, 'marker': 'o', 'markerfacecolor': [0.89, 0.29, 0.2, 1.0], 'markerfacecoloralt': [0.0, 0.0, 0.0, 1.0],\
                    'markeredgecolor': [0.0, 0.0, 0.0, 1.0], 'markeredgewidth': 0.5, 'markersize': 10.0, 'fillstyle': 'full', 'doFill': True}

    # initialize resid style
    self.Residstyle = deepcopy(self.style)
    self.ResidLinestyle = {}
    self.ResidLinestyle['linewidth'] = 1.0
    self.ResidLinestyle['linestyle'] = 'solid'
    self.ResidLinestyle['dash_capstyle'] = 'butt'
    self.ResidLinestyle['color'] = [0.8, 0.2, 0.2, 1.0]
    self.ResidBarstyle = deepcopy(self.Barstyle)
    self.ResidStackstyle = deepcopy(self.Stackstyle)
    self.ResidTextstyle = deepcopy(self.Textstyle)
    
    # fine-sort zorder
    self.relativeZOrderError = -0.4
    self.relativeZOrderBar = -0.2
    self.relativeZOrderText = 0.2
    self.relativeZOrderViolin = -0.05

    # memorize plot settings
    for key in self.style:
      self.rememberSetting[key] = 'set_' + key + '(' + repr(self.style[key]) + ')'
    for key in self.Errorstyle:
      if(key != 'errorInFront'):
        self.rememberSettingError[key] = 'set_' + key + '(' + repr(self.Errorstyle[key]) + ')'
    for key in self.ErrorShadystyle:
      self.rememberSettingErrorShady[key] = 'set_' + key + '(' + repr(self.ErrorShadystyle[key]) + ')'
    for key in self.Barstyle:
      if(not (key in ['showBar', 'offset', 'hatchMultiply'])):
        self.rememberSettingBar[key] = 'set_' + key + '(' + repr(self.Barstyle[key]) + ')'
    for key in self.Stackstyle:
      if(key.startswith('facecolor')):
        if(key == 'facecolor'):
          self.rememberSettingStack[key] = 'set_facecolor(' + repr(self.Stackstyle[key]) + ')'
        else:
          self.rememberSettingStackNeg[key] = 'set_facecolor(' + repr(self.Stackstyle[key]) + ')'
      elif(not (key in ['showStack', 'hatchMultiply'])):
        self.rememberSettingStack[key] = 'set_' + key + '(' + repr(self.Stackstyle[key]) + ')'
        self.rememberSettingStackNeg[key] = 'set_' + key + '(' + repr(self.Stackstyle[key]) + ')'
    for key in self.Residstyle:
      self.rememberSettingResid[key] = 'set_' + key + '(' + repr(self.Residstyle[key]) + ')'
    for key in self.ResidBarstyle:
      if(not (key in ['showBar', 'offset', 'hatchMultiply'])):
        self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(self.ResidBarstyle[key]) + ')'
    for key in self.ResidStackstyle:
      if(key.startswith('facecolor')):
        if(key == 'facecolor'):
          self.rememberSettingResidStack[key] = 'set_facecolor(' + repr(self.ResidStackstyle[key]) + ')'
        else:
          self.rememberSettingResidStackNeg[key] = 'set_facecolor(' + repr(self.ResidStackstyle[key]) + ')'
      elif(not (key in ['showStack', 'hatchMultiply'])):
        self.rememberSettingResidStack[key] = 'set_' + key + '(' + repr(self.ResidStackstyle[key]) + ')'
        self.rememberSettingResidStackNeg[key] = 'set_' + key + '(' + repr(self.ResidStackstyle[key]) + ')'
    
  def toggleResidBar(self, showBar):
    # turns on/off bar graphics
    self.ResidBarstyle['showBar'] = showBar
    self.drawMeResid(rescale=False)

  def toggleResidStack(self, showStack):
    # turns on/off stack graphics
    self.ResidStackstyle['showStack'] = showStack
    self.drawMeResid(rescale=False)

  def toggleBar(self, showBar):
    # turns on/off bar graphics
    self.Barstyle['showBar'] = showBar
    self.drawMe(rescale=False)

  def toggleStack(self, showStack):
    # turns on/off stack graphics
    self.Stackstyle['showStack'] = showStack
    self.drawMe(rescale=False)

  def toggleText(self, showText):
    # turns on/off text graphics
    self.Textstyle['showText'] = showText
    self.drawMe(rescale=False)

  def toggleResidText(self, showText):
    # turns on/off text graphics
    self.ResidTextstyle['showText'] = showText
    self.drawMeResid(rescale=False)

  def toggleViolin(self, mode, redraw=False):
    # turns on/off violin graphics
    self.Violinstyle['mode'] = mode
    self.drawMe(rescale=False, redraw=redraw)

  def reportState(self):
    # reports data content for saveState function
    items = ['name', 'nameResid', 'zorder', 'zorderResid', 'x', 'y', 'xerr', 'yerr', 'fval', 'resid', 'labels', 'onSecondAxes', 'onBothAxes', 'globalFitCheck', 'globalFitCurve']
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0, zoffsetResid=0, zoffsetCurve=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry in ['x', 'y', 'xerr', 'yerr', 'fval', 'resid']):
          value = np.array(data[entry])
        elif(entry in ['zorder']):
          value = data[entry] + zoffset
        elif(entry in ['zorderResid']):
          value = data[entry] + zoffsetResid
        elif(entry == 'name'):
          value = data[entry]
          self.setName(value)
        elif(entry == 'nameResid'):
          value = data[entry]
          self.setNameResid(value)
        elif(entry in ['globalFitCurve']):
          value = data[entry] + zoffsetCurve
        else:
          value = data[entry]
        self.__dict__[entry] = value

  def setName(self, name='John Doe'):
    # updates name of object
    self.name = name
    # update plot if necessary
    if(self.handleData != None):
      self.handleData.set_label(self.name)
    self.rememberSetting['name'] = 'set_label(' + repr(self.name) + ')'
    
  def setNameResid(self, name='John Doe'):
    # updates name of object
    self.nameResid = name
    # update plot if necessary
    if(self.handleResid != None):
      self.handleResid.set_label(self.nameResid)
    self.rememberSettingResid['name'] = 'set_label(' + repr(self.nameResid) + ')'
    
  def setZOrderError(self, state=True, redraw=True):
    # toggles relative z order of error bars
    self.Errorstyle['errorInFront'] = state
    if(state):
      self.relativeZOrderError = 0.4
    else:
      self.relativeZOrderError = -0.4
    # reassign z values
    # in case of redraw, ensure that this is done by temporarily altering z-order ever so slightly
    if(redraw):
      self.zorder -= 0.01
      self.setZOrder(self.zorder + 0.01, redraw=redraw)
    else:
      self.setZOrder(self.zorder, redraw=redraw)

  def setZOrderResid(self, zorder=0, redraw=True):
    # updates z order of residuals
    self.zorderResid = zorder
    # update plot if necessary
    if(self.handleResid != None):
      self.handleResid.set_zorder(self.zorderResid + self.parent.zOffset)
      self.rememberSettingResid['zorder'] = 'set_zorder(' + str(self.zorderResid + self.parent.zOffset) + ')'
    if(self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidBar['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidStack != None):
      self.handleResidStack.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidStack['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidStackNeg['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_zorder(self.zorderResid + self.parent.zOffset + self.relativeZOrderText)
      
    if(self.handleResid_div != None):
      self.handleResid_div.set_zorder(self.zorderResid + self.parent.zOffset)
    if(self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidStack_div != None):
      self.handleResidStack_div.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_zorder(self.zorderResid + self.parent.zOffset + self.relativeZOrderText)
      
    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    if(self.zorder == zorder):
      redraw, changed = False, False
    else:
      changed = True
    self.zorder = zorder
    
    # prepare list of handles
    handlesData = [self.handleData, self.handleData_div] + [self.handlesBothAxes[item] for item in ['handleData', 'handleData_div'] if item in self.handlesBothAxes]
    handlesErr = [self.handleErr, self.handleErr_div] + [self.handlesBothAxes[item] for item in ['handleErr', 'handleErr_div'] if item in self.handlesBothAxes]
    handlesErrShady = [self.handleErrShady, self.handleErrShady_div] + [self.handlesBothAxes[item] for item in ['handleErrShady', 'handleErrShady_div'] if item in self.handlesBothAxes]
    handlesBar = [self.handleBar, self.handleBar_div] + [self.handlesBothAxes[item] for item in ['handleBar', 'handleBar_div'] if item in self.handlesBothAxes]
    handlesStack = [self.handleStack, self.handleStack_div] + [self.handlesBothAxes[item] for item in ['handleStack', 'handleStack_div'] if item in self.handlesBothAxes]
    handlesStackNeg = [self.handleStackNeg, self.handleStackNeg_div] + [self.handlesBothAxes[item] for item in ['handleStackNeg', 'handleStackNeg_div'] if item in self.handlesBothAxes]
    handlesText = [self.handleText, self.handleText_div] + [self.handlesBothAxes[item] for item in ['handleText', 'handleText_div'] if item in self.handlesBothAxes]
    handlesViolin = [self.handleViolin, self.handleViolin_div] + [self.handlesBothAxes[item] for item in ['handleViolin', 'handleViolin_div'] if item in self.handlesBothAxes]
    
    # update plot if necessary
    for handleData in handlesData:
      if(handleData != None):
        handleData.set_zorder(self.zorder + self.parent.zOffset)
        self.rememberSetting['zorder'] = 'set_zorder(' + str(self.zorder + self.parent.zOffset) + ')'
    for handleErr in handlesErr:
      if(handleErr != None):
        handleErr[0].set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
        for entry in handleErr[1]:
          entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
        for entry in handleErr[2]:
          entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
        self.rememberSettingError['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderError + self.parent.zOffset) + ')'
    for handleErrShady in handlesErrShady:
      if(handleErrShady != None):
        handleErrShady.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05)
        self.rememberSettingErrorShady['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05) + ')'
    for handleBar in handlesBar:
      if(handleBar != None):
        for entry in handleBar.patches:
          entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
        self.rememberSettingBar['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    for handleStack in handlesStack:
      if(handleStack != None):
        handleStack.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
        self.rememberSettingStack['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    for handleStackNeg in handlesStackNeg:
      if(handleStackNeg != None):
        handleStackNeg.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
        self.rememberSettingStackNeg['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    for handleText in handlesText:
      if(handleText != None):
        for entry in handleText:
          entry.set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderText)
    for handleViolin in handlesViolin:
      if(handleViolin != None):
        for key in handleViolin:
          if(type(handleViolin[key]) == type([])):
            for entry in handleViolin[key]:
              entry.set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderViolin)
          else:
            self.handleViolin[key].set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderViolin)

    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()
      
    return changed

  def collateViolinData(self):
    # arranges data for violin plot
    EPSILON, MINMEMBERS = 1e-6, 2
    
    if(len(self.x) * len(self.y)):
      xvector, yvector = [], []
      for x, y in zip(self.x, self.y):
        # check for close previous x entry
        closeness = np.isclose(x, xvector, rtol=EPSILON)
        position = [i for i in range(len(closeness)) if closeness[i]]
        if(len(position)):
          yvector[position[0]].append(y)
        else:
          # make new entry
          xvector.append(x)
          yvector.append([])
          yvector[-1].append(y)
      
      # exclude  groups that have too few points
      nu_xvector = [i for i, j in zip(xvector, yvector) if (len(j) >= MINMEMBERS)]
      nu_yvector = [j for j in yvector if (len(j) >= MINMEMBERS)]
      xvector, yvector = nu_xvector, nu_yvector
      return xvector, yvector
    else:
      return [], []

  def getData_n_Fit(self):
    # returns data, fit and residuals along with rolestr
    descriptors = ['x', 'xerr', 'y', 'yerr', 'fval', 'resid']
    roles = []
    values = np.array([])
    for entry in descriptors:
      if(len(self.__dict__[entry])):
        if(len(values)):
          values = np.vstack((values, self.__dict__[entry]))
        else:
          values = self.__dict__[entry]
        roles.append(entry)
    
    if(len(values)):
      values = values.transpose()
    return values, roles

  def getLabels(self):
    # returns data labels
    return list(self.labels)

  def setFval(self, fval=np.array([])):
    # updates fitted values and residuals after fit
    if(fval.size):
      self.fval = fval
      self.resid = np.array([i - j for i, j in zip(self.y, self.fval)])
      
  def setBothAxes(self, state=False, redraw=True):
    # moves plot between axes
    self.onBothAxes = state
    # remove surplus items?
    if(self.onBothAxes):
      self.duplicateForSplit()
    else:
      self.removeFromSplit()

  def setSecondAxes(self, state=False, redraw=True):
    # moves data between axes
    self.onSecondAxes = state
    # check whether dual display is turned on
    if(self.parent.plotArea.splitY and self.onBothAxes):
      # we can just swap the handles
      items = 'handleData,handleErr,handleErrShady,handleBar,handleStack,handleStackNeg,handleText,handleViolin'.split(',')
      items += [i + '_div' for i in items]
      for item in items:
        if(item in self.handlesBothAxes):
          self.__dict__[item], self.handlesBothAxes[item] = self.handlesBothAxes[item], self.__dict__[item]
      return
    # trigger redraw
    self.drawMe(redraw=redraw, rescale=not self.parent.plotArea.splitY)

  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of data and error bars
    if(self.visibility == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibility = state

    # prepare list of handles
    handlesData = [self.handleData, self.handleData_div] + [self.handlesBothAxes[item] for item in ['handleData', 'handleData_div'] if item in self.handlesBothAxes]
    handlesErr = [self.handleErr, self.handleErr_div] + [self.handlesBothAxes[item] for item in ['handleErr', 'handleErr_div'] if item in self.handlesBothAxes]
    handlesErrShady = [self.handleErrShady, self.handleErrShady_div] + [self.handlesBothAxes[item] for item in ['handleErrShady', 'handleErrShady_div'] if item in self.handlesBothAxes]
    handlesBar = [self.handleBar, self.handleBar_div] + [self.handlesBothAxes[item] for item in ['handleBar', 'handleBar_div'] if item in self.handlesBothAxes]
    handlesStack = [self.handleStack, self.handleStack_div] + [self.handlesBothAxes[item] for item in ['handleStack', 'handleStack_div'] if item in self.handlesBothAxes]
    handlesStackNeg = [self.handleStackNeg, self.handleStackNeg_div] + [self.handlesBothAxes[item] for item in ['handleStackNeg', 'handleStackNeg_div'] if item in self.handlesBothAxes]
    handlesText = [self.handleText, self.handleText_div] + [self.handlesBothAxes[item] for item in ['handleText', 'handleText_div'] if item in self.handlesBothAxes]
    handlesViolin = [self.handleViolin, self.handleViolin_div] + [self.handlesBothAxes[item] for item in ['handleViolin', 'handleViolin_div'] if item in self.handlesBothAxes]
    
    for handleData in handlesData:
      if(handleData != None):
        handleData.set_visible(state)
        if(handleData == self.handleData):
          self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
          if(self.visibility):
            handleData.set_label(self.name)
          else:
            handleData.set_label('_nolegend_')
    for handleErr in handlesErr:
      if(handleErr != None):
        workstate = state and self.Errorstyle['visible']
        handleErr[0].set_visible(workstate)
        for entry in handleErr[1]:
          entry.set_visible(workstate)
        for entry in handleErr[2]:
          entry.set_visible(workstate)
        self.rememberSettingError['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    for handleErrShady in handlesErrShady:
      if(handleErrShady != None):
        handleErrShady.set_visible(state)
        self.rememberSettingErrorShady['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    for handleBar in handlesBar:
      if(handleBar != None):
        for entry in handleBar.patches:
          entry.set_visible(state)
        self.rememberSettingBar['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    for handleStack in handlesStack:
      if(handleStack != None):
        handleStack.set_visible(state)
        self.rememberSettingStack['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    for handleStackNeg in handlesStackNeg:
      if(handleStackNeg != None):
        handleStackNeg.set_visible(state)
        self.rememberSettingStackNeg['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    for handleText in handlesText:
      if(handleText != None):
        for entry in handleText:
          entry.set_visible(state)
    for handleViolin in handlesViolin:
      if(handleViolin != None):
        for key in handleViolin:
          if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
            modState = self.Violinstyle[key]['visible']
          else:
            modState = True
          if(type(handleViolin[key]) == type([])):
            for entry in handleViolin[key]:
              entry.set_visible(state and modState)
          else:
            handleViolin[key].set_visible(state and modState)
      
    # hide caps when error display is only in one direction
    if(self.Errorstyle['direction'] != 'both'):
      for handleErr in handlesErr:
        if(handleErr != None):
          if(self.xerr.size):
            offset = 2
            if(self.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
                entry.set_visible(False)
            elif(self.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
                entry.set_visible(False)
          else:
            offset = 0
          if(self.yerr.size):
            if(self.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][offset:-1]:
                entry.set_visible(False)
            elif(self.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][offset + 1:]:
                entry.set_visible(False)      
      
    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()
      
    return changed

  def setVisibilityResid(self, state=True, redraw=True):
    # toggles visibility of residuals
    if(self.visibilityResid == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibilityResid = state
    if(self.handleResid != None):
      self.handleResid.set_visible(state)
      self.rememberSettingResid['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_visible(state)
      self.rememberSettingResidBar['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidStack != None):
      self.handleResidStack.set_visible(state)
      self.rememberSettingResidStack['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_visible(state)
      self.rememberSettingResidStackNeg['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_visible(state)
      
    if(self.handleResid_div != None):
      self.handleResid_div.set_visible(state)
    if(self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_visible(state)
    if(self.handleResidStack_div != None):
      self.handleResidStack_div.set_visible(state)
    if(self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_visible(state)
    if(self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_visible(state)
      
    # update plot
    if(redraw):
      self.parent.plotArea.residplotwidget.myRefresh()
      
    return changed

  def spawned(self, source=None):
    # copies contents of the source object to current object
    if(source != None):
      copyItems = 'x,y,xerr,yerr,style,Errorstyle,ErrorShadystyle,fval,resid,visibility,visibilityResid,Barstyle,Stackstyle,Textstyle,Violinstyle,Residstyle,ResidBarstyle,ResidStackstyle,ResidTextstyle,labels,relativeZOrderError,relativeZOrderBar,relativeZOrderText,onSecondAxes,onBothAxes,globalFitCheck,globalFitCurve'.split(',')
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
          
  def styleMe(self, handleData=None, handleErr=None, handleErrShady=None, handleBar=None, handleStack=None, handleStackNeg=None, handleText=None, handleViolin=None):
    # apply styles to plot object
    if(handleData != None):
      style = self.style
      for key in style:
        method = 'set_' + key
        if(hasattr(handleData, method)):
          method2call = getattr(handleData, method)
          if((key == 'marker') and (style[key] in CUSTOM_MARKERS)):
            method2call(CUSTOM_MARKERS[style[key]])
          elif((key == 'marker') and (not (style[key] in matplotlib.lines.Line2D.markers))):
            # this is to ensure compatibility with future versions that may introduce markers we don't know yet
            method2call('o')
          else:
            method2call(style[key])
      if(not style['doFill']):
        handleData.set_markerfacecolor('none')

      # set name
      if(hasattr(handleData, 'set_label')):
        method2call = getattr(handleData, 'set_label')
        method2call(self.name)
        
      # set z order
      if(hasattr(handleData, 'set_zorder')):
        handleData.set_zorder(self.zorder + self.parent.zOffset)
          
    # apply styles to error bars
    if (handleErr != None):
      errorstyle = self.Errorstyle
      # Note: handleErr[1] are the caps, handleErr[2] are the lines (super confusing!!)
      for key in errorstyle:
        method = 'set_' + key
        if(key in ['marker', 'markerX']):
          # deal w/ x-errors
          if(len(self.xerr)):
            # we have x errors, those should be the first two entries in handleErr[1]
            offset = 2
            if(key == 'markerX'):
              for entry in handleErr[1][:min(offset, len(handleErr[1]))]:
                if (hasattr(entry, 'set_marker')):
                  marker = errorstyle[key]
                  if(marker in CUSTOM_MARKERS):
                    entry.set_marker(CUSTOM_MARKERS[marker])
                  elif(not (marker in matplotlib.lines.Line2D.markers)):
                    # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                    entry.set_marker('o')
                  else:
                    entry.set_marker(marker)
          else:
            offset = 0
          # deal w/ y-errors
          if(len(self.yerr)):
            # we have y errors, those should be the first two entries in handleErr[1]
            if(key == 'marker'):
              for entry in handleErr[1][offset:]:
                if (hasattr(entry, 'set_marker')):
                  marker = errorstyle[key]
                  if(marker in CUSTOM_MARKERS):
                    entry.set_marker(CUSTOM_MARKERS[marker])
                  elif(not (marker in matplotlib.lines.Line2D.markers)):
                    # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                    entry.set_marker('o')
                  else:
                    entry.set_marker(marker)
        else:
          for entry in handleErr[1]:
            if (hasattr(entry, method)):
              method2call = getattr(entry, method)
              method2call(errorstyle[key])
        for entry in handleErr[2]:
          if (hasattr(entry, method)):
            method2call = getattr(entry, method)
            method2call(errorstyle[key])
      # don't connect caps of error bars
      for entry in handleErr[1]:
        entry.set_linestyle('None')
      # check visibility of entire object
      if(not self.visibility):
        if(hasattr(handleErr[0], 'set_visible')):
          handleErr[0].set_visible(False)
        for entry in handleErr[1]:
          if(hasattr(entry, 'set_visible')):
            entry.set_visible(False)
        for entry in handleErr[2]:
          if(hasattr(entry, 'set_visible')):
            entry.set_visible(False)
      # hide caps when error display is only in one direction
      if(self.Errorstyle['direction'] != 'both'):
        if(len(self.xerr)):
          offset = 2
          if(self.Errorstyle['direction'] == 'positive'):
            for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
              entry.set_visible(False)
          elif(self.Errorstyle['direction'] == 'negative'):
            for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
              entry.set_visible(False)
        else:
          offset = 0
        if(len(self.yerr)):
          if(self.Errorstyle['direction'] == 'positive'):
            for entry in handleErr[1][offset:-1]:
              entry.set_visible(False)
          elif(self.Errorstyle['direction'] == 'negative'):
            for entry in handleErr[1][offset + 1:]:
              entry.set_visible(False)

      # special treatment for fill of error markers
      if(not self.Errorstyle['doFill']):
        for entry in handleErr[1]:
          if(hasattr(entry, 'set_markerfacecolor')):
            entry.set_markerfacecolor('none')
            
      # set z order
      if(hasattr(handleErr[0], 'set_zorder')):
        handleErr[0].set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      for entry in (handleErr[1] + handleErr[2]):
        if(hasattr(entry, 'set_zorder')):
          entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
            
    # error shading
    if (handleErrShady != None):
      style = self.ErrorShadystyle
      for key in style:
        method = 'set_' + key
        if (hasattr(handleErrShady, method)):
          method2call = getattr(handleErrShady, method)
          method2call(style[key])
      # check visibility of entire object
      if(not self.visibility):
        if(hasattr(handleErrShady, 'set_visible')):
          handleErrShady.set_visible(False)
      # set z order
      if(hasattr(handleErrShady, 'set_zorder')):
        handleErrShady.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05)

    # apply bar styles
    if (handleBar != None):
      if(self.Barstyle['showBar']):
        barstyle = self.Barstyle
        for entry in handleBar.patches:
          for key in barstyle:
            method = 'set_' + key
            # treat width differently to avoid recentering of bars upon width change (does not heed center position)
            if ((key != 'width') and (hasattr(entry, method))):
              method2call = getattr(entry, method)
              # extra check b/c of hatchMultiply
              if((key == 'hatch') and ('hatchMultiply' in barstyle)):
                method2call(barstyle[key] * barstyle['hatchMultiply'])
              else:
                method2call(barstyle[key])
            # set alternate color?
            if((entry.get_height() < 0) and ('facecolorAlt' in barstyle)):
              entry.set_facecolor(barstyle['facecolorAlt'])
        # check visibility of entire object
        if(not self.visibility):
          for entry in handleBar.patches:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)
 
        # special treatment for fill of bars
        if(not self.Barstyle['doFill']):
          for entry in handleBar.patches:
            if(hasattr(entry, 'set_facecolor')):
              entry.set_facecolor('none')

        # set z order
        for patch in handleBar.patches:
          if(hasattr(patch, 'set_zorder')):
            patch.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
  
    # apply stack styles
    if((handleStack != None) or (handleStackNeg != None)):
      if(self.Stackstyle['showStack']):
        stackstyle = self.Stackstyle
        for handle in [handleStack, handleStackNeg]:
          if(handle != None):
            for key in stackstyle:
              method = 'set_' + key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                # extra check b/c of hatchMultiply
                if((key == 'hatch') and ('hatchMultiply' in stackstyle)):
                  method2call(stackstyle[key] * stackstyle['hatchMultiply'])
                else:
                  method2call(stackstyle[key])
            # set alternate color?
            if((handle == handleStackNeg) and ('facecolorAlt' in stackstyle)):
              handle.set_facecolor(stackstyle['facecolorAlt'])
            else:
              handle.set_facecolor(stackstyle['facecolor'])
        # check visibility of entire object
        if(not self.visibility):
          handles = [handleStack, handleStackNeg]
          for entry in handles:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)

        # special treatment for fill of error markers
        if(not self.Stackstyle['doFill']):
          for entry in [handleStack, handleStackNeg]:
            if(hasattr(entry, 'set_facecolor')):
              entry.set_facecolor('none')

        # set z order
        for entry in [handleStack, handleStackNeg]:
          if(hasattr(entry, 'set_zorder')):
            entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
 
    # apply text styles
    if(handleText != None):
      textstyle = self.Textstyle
      if((handleText != None) and (len(handleText))):
        # apply styles
        for key in textstyle:
          method = 'set_' + key
          if(hasattr(handleText[0], method)):
            value = textstyle[key]; safeFont = 'DejaVu Sans'
            for item in handleText:
              method2call = getattr(item, method)
              method2call(value)
              if(key == 'fontname'):
                # test last element descent, should be larger than zero
                _, _, descent = item._get_layout(self.parent.plotArea.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                  value = safeFont
                  method2call(value)
        # check visibility of entire object
        if(not self.visibility):
          for item in handleText:
            if(hasattr(item, 'set_visible')):
              item.set_visible(False)
        # set z order of entire object
        for item in handleText:
          if(hasattr(item, 'set_zorder')):
            item.set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderText)

    # apply violin styles
    if(handleViolin != None):
      violinstyle = self.Violinstyle
      if(handleViolin != None):
        # for boxplot ensure that mean has no symbol
        if(self.Violinstyle['mode'] == 2):
          for item in handleViolin['means']:
            item.set_marker('None')
        for entry in handleViolin:
          if(entry in violinstyle):
            if(type(handleViolin[entry]) == type([])):
              # slave cmins to cmaxes and cmedians to cmeans
              if(entry in ['cmaxes', 'cmins']):
                targetList = handleViolin['cmaxes'] + handleViolin['cmins']
              elif(entry in ['cmeans', 'cmedians']):
                targetList = handleViolin['cmeans'] + handleViolin['cmedians']
              else:
                targetList = handleViolin[entry]
              for key in violinstyle[entry]:
                method, value = 'set_' + key, violinstyle[entry][key]
                if((key == 'visible') and (entry in ['cmeans', 'cmedians'])):
                  for item in handleViolin[entry]:
                    if(hasattr(item, method)):
                      method2call = getattr(item, method)
                      method2call(value)
                else:
                  for item in targetList:
                    if(hasattr(item, method)):
                      method2call = getattr(item, method)
                      if((key == 'marker') and (value in CUSTOM_MARKERS)):
                        method2call(CUSTOM_MARKERS[value])
                      elif((key == 'marker') and (not (value in matplotlib.lines.Line2D.markers))):
                        # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                        method2call('o')
                      else:
                        method2call(value)
                    if(('color' in key) and (len(value) == 4) and (key != 'facecolor')):
                      item.set_alpha(value[-1])
              for item in targetList:
                if(hasattr(item, 'set_zorder')):
                  item.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + self.relativeZOrderViolin)
                if(hasattr(item, 'set_pickradius')):
                  item.set_pickradius(PICK_TOLERANCE)
            else:
              # slave cmins to cmaxes and cmedians to cmeans
              if(entry in ['cmaxes', 'cmins']):
                targetList = ['cmaxes', 'cmins']
              elif(entry in ['cmeans', 'cmedians']):
                targetList = ['cmeans', 'cmedians']
              else:
                targetList = [entry]
              for key in violinstyle[entry]:
                method, value = 'set_' + key, violinstyle[entry][key]
                if((key == 'visible') and (entry in ['cmeans', 'cmedians', 'cmins', 'cmaxes'])):
                  if(hasattr(handleViolin[entry], method)):
                    method2call = getattr(handleViolin[entry], method)
                    method2call(value)
                else:
                  for item in targetList:
                    if(hasattr(handleViolin[item], method)):
                      method2call = getattr(handleViolin[item], method)
                      method2call(value)
                    if(('color' in key) and (len(value) == 4) and (key != 'facecolor')):
                      handleViolin[item].set_alpha(value[-1])
              for item in targetList:
                if(hasattr(handleViolin[item], 'set_zorder')):
                  handleViolin[item].set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + self.relativeZOrderViolin)
                if(hasattr(handleViolin[item], 'set_pickradius')):
                  handleViolin[item].set_pickradius(PICK_TOLERANCE)
    
        # special treatment for fills of various items
        if(('bodies' in handleViolin) and (not self.Violinstyle['bodies']['doFill'])):
          for entry in handleViolin['bodies']:
            if(hasattr(entry, 'set_facecolor')):
              entry.set_facecolor('none')
        if(('fliers' in handleViolin) and (not self.Violinstyle['fliers']['doFill'])):
          for entry in handleViolin['fliers']:
            if(hasattr(entry, 'set_markerfacecolor')):
              entry.set_markerfacecolor('none')
        if(('boxes' in handleViolin) and (not self.Violinstyle['boxes']['boxFill'])):
          for entry in handleViolin['boxes']:
            if(hasattr(entry, 'set_color')):
              entry.set_color(self.Violinstyle['boxes']['edgecolor'])

        # set z order
        for key in handleViolin:
          if(type(handleViolin[key]) == type([])):
            for entry in handleViolin[key]:
              entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + self.relativeZOrderViolin)
          else:
            handleViolin[key].set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + self.relativeZOrderViolin)
    
  def drawMe(self, redraw=True, rescale=True):
    # causes data to be drawn on canvas
    self.handleData, self.handleErr, self.handleErrShady, self.handleBar, self.handleStack, self.handleStackNeg, self.handleText, self.handleViolin = self.parent.plotArea.plotData(self.value(),\
      dataobject = self, handleData = self.handleData, handleErr = self.handleErr, handleErrShady=self.handleErrShady, handleBar=self.handleBar,\
      handleStack=self.handleStack, handleStackNeg=self.handleStackNeg, handleText=self.handleText, handleViolin=self.handleViolin, redraw=False, rescale=rescale)
    if (self.handleData != None):
      self.handleData.set_visible(self.visibility)
      self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleBar != None):
      for entry in self.handleBar.patches:
        entry.set_visible(self.visibility)
      self.rememberSettingBar['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleStack != None):
      self.handleStack.set_visible(self.visibility)
      self.rememberSettingStack['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleStackNeg != None):
      self.handleStackNeg.set_visible(self.visibility)
      self.rememberSettingStackNeg['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleErrShady != None):
      self.handleErrShady.set_visible(self.visibility)
      self.rememberSettingErrorShady['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleErr != None):
      self.rememberSettingError['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleText != None):
      for entry in self.handleText:
        entry.set_visible(self.visibility)
    if(self.handleViolin != None):
      for key in self.handleViolin:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin[key]) == type([])):
          for entry in self.handleViolin[key]:
            entry.set_visible(self.visibility and modState)
        else:
          self.handleViolin[key].set_visible(self.visibility and modState)

    # causes data to be drawn on canvas
    self.handleData_div, self.handleErr_div, self.handleErrShady_div, self.handleBar_div, self.handleStack_div, self.handleStackNeg_div, self.handleText_div, self.handleViolin_div = self.parent.plotArea.plotData(self.value(),\
      dataobject = self, handleData = self.handleData_div, handleErr = self.handleErr_div, handleErrShady=self.handleErrShady_div, handleBar=self.handleBar_div,\
      handleStack=self.handleStack_div, handleStackNeg=self.handleStackNeg_div, handleText=self.handleText_div, handleViolin=self.handleViolin_div, redraw=False, rescale=rescale, splitX=True)
    # set visibility
    if (self.handleData_div != None):
      self.handleData_div.set_visible(self.visibility)
    if (self.handleBar_div != None):
      for entry in self.handleBar_div.patches:
        entry.set_visible(self.visibility)
    if (self.handleStack_div != None):
      self.handleStack_div.set_visible(self.visibility)
    if (self.handleStackNeg_div != None):
      self.handleStackNeg_div.set_visible(self.visibility)
    if (self.handleErrShady_div != None):
      self.handleErrShady_div.set_visible(self.visibility)
    if (self.handleText_div != None):
      for entry in self.handleText_div:
        entry.set_visible(self.visibility)
    if(self.handleViolin_div != None):
      for key in self.handleViolin_div:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin_div[key]) == type([])):
          for entry in self.handleViolin_div[key]:
            entry.set_visible(self.visibility and modState)
        else:
          self.handleViolin_div[key].set_visible(self.visibility and modState)

    # redraw? -- update legend in this go if required (this is needed to draw stack/bar entries for legend when line/marker invisible)
    value = self.parent.plotArea.legendVisible
    if(value):
      self.parent.plotArea.setLegend(value=value, redraw=False) 
      
    if(redraw and self.visibility):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def drawMeResid(self, redraw=True, rescale=True):
    # causes residuals to be drawn on canvas
    self.handleResid, self.parent.plotArea.handleResidZero, self.handleResidBar, self.handleResidStack, self.handleResidStackNeg, self.handleResidText = self.parent.plotArea.plotResid(\
      dataobject = self, handleResid = self.handleResid, handleResidZero = self.parent.plotArea.handleResidZero,\
      handleResidBar = self.handleResidBar, handleResidStack = self.handleResidStack, handleResidStackNeg = self.handleResidStackNeg,\
       handleResidText = self.handleResidText, redraw=False, rescale=rescale)
    # set visibility
    if (self.handleResid != None):
      self.handleResid.set_visible(self.visibilityResid)
      self.rememberSettingResid['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_visible(self.visibilityResid)
      self.rememberSettingResidBar['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidStack != None):
      self.handleResidStack.set_visible(self.visibilityResid)
      self.rememberSettingResidStack['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_visible(self.visibilityResid)
      self.rememberSettingResidStackNeg['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_visible(self.visibilityResid)

    # causes residuals to be drawn on canvas
    self.handleResid_div, self.parent.plotArea.handleResidZero_div, self.handleResidBar_div, self.handleResidStack_div, self.handleResidStackNeg_div, self.handleResidText_div = self.parent.plotArea.plotResid(\
      dataobject = self, handleResid = self.handleResid_div, handleResidZero = self.parent.plotArea.handleResidZero_div,\
      handleResidBar = self.handleResidBar_div, handleResidStack = self.handleResidStack_div, handleResidStackNeg = self.handleResidStackNeg_div,\
      handleResidText = self.handleResidText_div, redraw=False, splitX=True, rescale=rescale)
    # set visibility
    if (self.handleResid_div != None):
      self.handleResid_div.set_visible(self.visibilityResid)
    if (self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_visible(self.visibilityResid)
    if (self.handleResidStack_div != None):
      self.handleResidStack_div.set_visible(self.visibilityResid)
    if (self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_visible(self.visibilityResid)
    if (self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_visible(self.visibilityResid)

    # redraw?
    if(redraw and self.visibilityResid):
      self.parent.plotArea.residplotwidget.myRefresh()

  def getStyle(self):
    # returns the style object
    return self.style
    
  def getTextStyle(self):
    # returns the textstyle object
    return self.Textstyle
    
  def getBarStyle(self):
    # returns the barstyle object
    return self.Barstyle
    
  def getStackStyle(self):
    # returns the stackstyle object
    return self.Stackstyle
    
  def getViolinStyle(self):
    # returns the violinstyle object
    return self.Violinstyle
    
  def getResidStyle(self):
    # returns the residuals style object
    return self.Residstyle
    
  def getResidTextStyle(self):
    # returns the resid textstyle object
    return self.ResidTextstyle
    
  def getResidBarStyle(self):
    # returns the resid barstyle object
    return self.ResidBarstyle
    
  def getResidStackStyle(self):
    # returns the resid stackstyle object
    return self.ResidStackstyle
    
  def setResidStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.Residstyle):
      if(self.Residstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Residstyle[key] = value
      # cause plot to be updated
      updateFlag = False
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.Residstyle['doFill']):
        if(self.handleResid != None):
          method = 'set_' + key
          if (hasattr(self.handleResid, method)):
            method2call = getattr(self.handleResid, method)
            if((key == 'marker') and (value in CUSTOM_MARKERS)):
              method2call(CUSTOM_MARKERS[value])
            elif((key == 'marker') and not (value in matplotlib.lines.Line2D.markers)):
              # this is to ensure compatibility with future versions that may introduce markers we don't know yet
              method2call('o')
            else:
              method2call(value)
            updateFlag = True
            self.rememberSettingResid[key] = 'set_' + key + '(' + repr(value) + ')'
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handleResid, 'set_solid_capstyle'))):
              method2call = getattr(self.handleResid, 'set_solid_capstyle')
              method2call(value)
              self.rememberSettingResid['solid_capstyle'] = 'set_solid_capstyle(' + repr(value) + ')'
  
        if(self.handleResid_div != None):
          method = 'set_' + key
          if (hasattr(self.handleResid_div, method)):
            method2call = getattr(self.handleResid_div, method)
            if((key == 'marker') and (value in CUSTOM_MARKERS)):
              method2call(CUSTOM_MARKERS[value])
            elif((key == 'marker') and not (value in matplotlib.lines.Line2D.markers)):
              # this is to ensure compatibility with future versions that may introduce markers we don't know yet
              method2call('o')
            else:
              method2call(value)
            updateFlag = True
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handleResid_div, 'set_solid_capstyle'))):
              method2call = getattr(self.handleResid_div, 'set_solid_capstyle')
              method2call(value)
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibilityResid and updateFlag):
        self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def setResidBarStyle(self, key, value, redraw=True, rescale=True):
    # changes the barstyle value
    if(key in self.ResidBarstyle):
      if(self.ResidBarstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidBarstyle[key] = value
      # cause plot to be updated
      if(key in ['showBar', 'offset']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      elif(key in ['width']):
        if((self.handleResidBar != None) or (self.handleResidBar != None)):
          # have to trigger redraw to avoid recentering of bars
          self.drawMeResid(redraw=redraw)
          self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(value) + ')'
      else:
        updateFlag = False
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.ResidBarstyle['doFill']):
          if(self.handleResidBar != None):
            if(key in ['hatch', 'hatchMultiply']):
              key = 'hatch'
              value = self.ResidBarstyle['hatch'] * self.ResidBarstyle['hatchMultiply']
            method = 'set_'+key
            for entry in self.handleResidBar.patches:
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(entry, 'set_facecolor')):
                  if(entry.get_height() >= 0):
                    useValue = self.ResidBarstyle['facecolor']
                  else:
                    useValue = self.ResidBarstyle['facecolorAlt']
                  entry.set_facecolor(useValue)
              elif (hasattr(entry, method)):
                method2call = getattr(entry, method)
                method2call(value)
            updateFlag =True
            if(key == 'facecolorAlt'):
              self.rememberSettingResidBar[key] = 'set_facecolor(' + repr(value) + ')'
            else:
              self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(value) + ')'
  
          if(self.handleResidBar_div != None):
            if(key in ['hatch', 'hatchMultiply']):
              key = 'hatch'
              value = self.ResidBarstyle['hatch'] * self.ResidBarstyle['hatchMultiply']
            method = 'set_'+key
            for entry in self.handleResidBar_div.patches:
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(entry, 'set_facecolor')):
                  if(entry.get_height() >= 0):
                    useValue = self.ResidBarstyle['facecolor']
                  else:
                    useValue = self.ResidBarstyle['facecolorAlt']
                  entry.set_facecolor(useValue)
              elif (hasattr(entry, method)):
                method2call = getattr(entry, method)
                method2call(value)
            updateFlag =True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibilityResid and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def setResidStackStyle(self, key, value, redraw=True, rescale=True):
    # changes the stackstyle value
    if(key in self.ResidStackstyle):
      if(self.ResidStackstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidStackstyle[key] = value
      # cause plot to be updated
      if(key in ['showStack']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        for handle in [self.handleResidStack, self.handleResidStackNeg, self.handleResidStack_div, self.handleResidStackNeg_div]:
          if(handle != None):
            updateFlag = True
            if(key in ['facecolor', 'facecolorAlt']):
              if (hasattr(handle, 'set_facecolor')):
                if(handle == self.handleResidStack):
                  useValue = self.ResidStackstyle['facecolor']
                else:
                  useValue = self.ResidStackstyle['facecolorAlt']
                handle.set_facecolor(useValue)
            else:
              if(key in ['hatch', 'hatchMultiply']):
                key = 'hatch'
                value = self.ResidStackstyle['hatch'] * self.ResidStackstyle['hatchMultiply']
              method = 'set_'+key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                method2call(value)
  
          if(handle in [self.handleResidStack, self.handleResidStackNeg]):
            if(key.startswith('facecolor')):
              if(key == 'facecolor'):
                self.rememberSettingResidStack[key] = 'set_facecolor(' + repr(value) + ')'
              else:
                self.rememberSettingResidStackNeg[key] = 'set_facecolor(' + repr(value) + ')'
            else:
              self.rememberSettingResidStack[key] = 'set_' + key + '(' + repr(value) + ')'
              self.rememberSettingResidStackNeg[key] = 'set_' + key + '(' + repr(value) + ')'
        
        if(redraw and self.visibilityResid and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def getResidLineStyle(self):
    # returns the residuals line style object
    return self.ResidLinestyle
    
  def setResidLineStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.ResidLinestyle):
      if(self.ResidLinestyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidLinestyle[key] = value
      # cause plot to be updated
      updateFlag = False
      for handle in [self.parent.plotArea.handleResidZero, self.parent.plotArea.handleResidZero_div]:
        if(handle != None):
          method = 'set_'+key
          if (hasattr(handle, method)):
            method2call = getattr(handle, method)
            method2call(value)
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(handle, 'set_solid_capstyle'))):
              method2call = getattr(handle, 'set_solid_capstyle')
              method2call(value)
          if(handle.get_visible()):
            updateFlag = True

      if(redraw and updateFlag):
        self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.parent.plotArea.handleResidZero.get_visible())

  def setResidTextStyle(self, key, value, redraw=True, rescale=False):
    # changes the residuals textstyle value
    if(key in self.ResidTextstyle):
      if(self.ResidTextstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidTextstyle[key] = value
      # cause plot to be updated
      if(key in ['showText', 'skip', 'padX', 'padY', 'type']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        if(self.handleResidText != None):
          method = 'set_' + key
          if (hasattr(self.handleResidText[0], method)):
            safeFont = 'DejaVu Sans'
            updateFlag = True
            for item in self.handleResidText:
              method2call = getattr(item, method)
              method2call(value)
              # special treatment for font type to catch errors
              if(key == 'fontname'):
                _, _, descent = item._get_layout(self.parent.plotArea.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                  value = safeFont
                  method2call(value)

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleResidMarkerFill(self, value, redraw=True):
    # toggles resid marker fill
    if(self.Residstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Residstyle['doFill'] = value
    # adjust value
    if(value):
      value = self.Residstyle['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handleResid != None):
      self.handleResid.set_markerfacecolor(value)
      self.rememberSettingResid['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'
      updateFlag = True
    if(self.handleResid_div != None):
      self.handleResid_div.set_markerfacecolor(value)
      updateFlag = True

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()
    return (changed and self.visibilityResid)

  def toggleMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.style['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.style['doFill'] = value
    # adjust value
    if(value):
      value = self.style['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    handles = [self.handleData, self.handleData_div]
    if(self.parent.plotArea.splitY):
      handles += [self.handlesBothAxes[i] for i in ['handleData', 'handleData_div'] if i in self.handlesBothAxes]
    for handleData in handles:
      if(handleData != None):
        handleData.set_markerfacecolor(value)
        updateFlag = True
        if(handleData == self.handleData):
          self.rememberSetting['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleStackFill(self, value, redraw=True):
    # toggles stack fill
    if(self.Stackstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Stackstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setStackStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.Stackstyle['facecolor']
      self.Stackstyle['facecolor'] = 'tilt'
      self.setStackStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      handles = [self.handleStack, self.handleStack_div, self.handleStackNeg, self.handleStackNeg_div]
      if(self.parent.plotArea.splitY):
        handles += [self.handlesBothAxes[i] for i in ['handleStack', 'handleStack_div', 'handleStackNeg', 'handleStackNeg_div'] if i in self.handlesBothAxes]
      for handleStack in handles:
        if(handleStack != None):
          handleStack.set_facecolor('none')
          updateFlag = True

        if(handleStack in [self.handleStack, self.handleStackNeg]):
          self.rememberSettingStack['facecolor'] = 'set_facecolor(\'none\')'
          self.rememberSettingStackNeg['facecolor'] = 'set_facecolor(\'none\')'

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleResidStackFill(self, value, redraw=True):
    # toggles resid stack fill
    if(self.ResidStackstyle['doFill'] == value):
      redraw = False

    self.ResidStackstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setResidStackStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.ResidStackstyle['facecolor']
      self.ResidStackstyle['facecolor'] = 'tilt'
      self.setResidStackStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleResidStack in (self.handleResidStack, self.handleResidStack_div, self.handleResidStackNeg, self.handleResidStackNeg_div):
        if(handleResidStack != None):
          handleResidStack.set_facecolor('none')
          updateFlag = True

        if(handleResidStack in [self.handleResidStack, self.handleResidStackNeg]):
          self.rememberSettingResidStack['facecolor'] = 'set_facecolor(\'none\')'
          self.rememberSettingResidStackNeg['facecolor'] = 'set_facecolor(\'none\')'

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()

  def toggleBarFill(self, value, redraw=True):
    # toggles bar fill
    if(self.Barstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Barstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setBarStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.Barstyle['facecolor']
      self.Barstyle['facecolor'] = 'tilt'
      self.setBarStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      handles = [self.handleBar, self.handleBar_div]
      if(self.parent.plotArea.splitY):
        handles += [self.handlesBothAxes[i] for i in ['handleBar', 'handleBar_div'] if i in self.handlesBothAxes]
      for handleBar in handles:
        if(handleBar != None):
          for entry in handleBar.patches:
            entry.set_facecolor('none')
          if(handleBar == self.handleBar):
            self.rememberSettingBar['facecolor'] = 'set_facecolor(\'none\')'
          updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleResidBarFill(self, value, redraw=True):
    # toggles resid bar fill
    if(self.ResidBarstyle['doFill'] == value):
      redraw = False

    self.ResidBarstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setBarStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.ResidBarstyle['facecolor']
      self.ResidBarstyle['facecolor'] = 'tilt'
      self.setResidBarStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleResidBar in (self.handleResidBar, self.handleResidBar_div):
        if(handleResidBar != None):
          for entry in handleResidBar.patches:
            entry.set_facecolor('none')
          if(handleResidBar == self.handleResidBar):
            self.rememberSettingResidBar['facecolor'] = 'set_facecolor(\'none\')'
          updateFlag = True

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()

  def toggleFliersMarkerFill(self, value, redraw=True):
    # toggles fliers marker fill
    if(self.Violinstyle['fliers']['doFill'] == value):
      redraw = False

    self.Violinstyle['fliers']['doFill'] = value
    # adjust value
    if(value):
      value = self.Violinstyle['fliers']['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    handles = [self.handleViolin, self.handleViolin_div]
    if(self.parent.plotArea.splitY):
      handles += [self.handlesBothAxes[i] for i in ['handleViolin', 'handleViolin_div'] if i in self.handlesBothAxes]
    for handleViolin in handles:
      if(handleViolin != None):
        for entry in handleViolin['fliers']:
          entry.set_markerfacecolor(value)
        updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.style):
      if(self.style[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.style[key] = value
      # cause plot to be updated
      updateFlag = False
      handles = [self.handleData, self.handleData_div]
      if(self.parent.plotArea.splitY):
        handles += [self.handlesBothAxes[i] for i in ['handleData', 'handleData_div'] if i in self.handlesBothAxes]
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.style['doFill']):
        for handleData in handles:
          if(handleData != None):
            method = 'set_' + key
            if (hasattr(handleData, method)):
              method2call = getattr(handleData, method)
              if(key == 'marker'):
                if(value in CUSTOM_MARKERS):
                  method2call(CUSTOM_MARKERS[value])
                elif(not (value in matplotlib.lines.Line2D.markers)):
                  # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                  method2call('o')
                else:
                  method2call(value)
              else:
                method2call(value)
              updateFlag = True
              if(handleData == self.handleData):
                self.rememberSetting[key] = 'set_' + key + '(' + repr(value) + ')'
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def getErrorStyle(self):
    # returns the style object
    return self.Errorstyle
    
  def getErrorShadyStyle(self):
    # returns the style object
    return self.ErrorShadystyle

  def setErrorShadyStyle(self, key, value, redraw=True):
    # changes the errorstyle value
    if(key in self.ErrorShadystyle):
      if(self.ErrorShadystyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ErrorShadystyle[key] = value
      # cause plot to be updated
      if((key == 'visible') and (value)):
        # if error shading is turned on, we need to issue redraw to generate shading object
        self.drawMe(redraw=redraw, rescale=False)
        self.rememberSettingErrorShady['visible'] = 'set_visible(' + repr(value) + ')'
      else:
        updateFlag = False
        handles = [self.handleErrShady, self.handleErrShady_div]
        if(self.parent.plotArea.splitY):
          handles += [self.handlesBothAxes[i] for i in ['handleErrShady', 'handleErrShady_div'] if i in self.handlesBothAxes]
        for handleErrShady in handles:
          if(handleErrShady != None):
            method = 'set_' + key
            if (hasattr(handleErrShady, method)):
              method2call = getattr(handleErrShady, method)
              method2call(value)
              updateFlag = True
              if(handleErrShady == self.handleErrShady):
                self.rememberSettingErrorShady[key] = 'set_' + key + '(' + repr(value) + ')'

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)
    
  def setErrorStyle(self, key, value, redraw=True):
    # changes the errorstyle value
    if(key in self.Errorstyle):
      if(self.Errorstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Errorstyle[key] = value
      # cause plot to be updated
      updateFlag, redrawFlag = False, False
      handles = [self.handleErr, self.handleErr_div]
      if(self.parent.plotArea.splitY):
        handles += [self.handlesBothAxes[i] for i in ['handleErr', 'handleErr_div'] if i in self.handlesBothAxes]
      for handleErr in handles:
        if(handleErr != None):
          if(key in ['marker', 'markerX']):
            # deal w/ x-errors
            if(len(self.xerr)):
              # we have x errors, those should be the first two entries in self.handleErr[1]
              offset = 2
              if(key == 'markerX'):
                for entry in handleErr[1][:min(offset, len(handleErr[1]))]:
                  if(value in CUSTOM_MARKERS):
                    entry.set_marker(CUSTOM_MARKERS[value])
                  elif(not (value in matplotlib.lines.Line2D.markers)):
                    # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                    entry.set_marker('o')
                  else:
                    entry.set_marker(value)
            else:
              offset = 0
            # deal w/ y-errors
            if(len(self.yerr)):
              # we have y errors, those should be the first two entries in self.handleErr[1]
              if(key == 'marker'):
                for entry in handleErr[1][offset:]:
                  if(value in CUSTOM_MARKERS):
                    entry.set_marker(CUSTOM_MARKERS[value])
                  elif(not (value in matplotlib.lines.Line2D.markers)):
                    # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                    entry.set_marker('o')
                  else:
                    entry.set_marker(value)
            if(key == 'marker'):
              self.rememberSettingError['marker'] = 'set_' + key + '(' + repr(value) + ')'
          elif(key in ['errorInFront']):
            self.setZOrderError(state=value, redraw=redraw)
          elif(key in ['direction']):
            if(not redrawFlag):
              # need to handle this by redrawing curve
              self.drawMe(redraw=redraw, rescale=False)
              redraw, redrawFlag = False, True
          else:
            # special treatment for markerfacecolor
            if((key != 'markerfacecolor') or self.Errorstyle['doFill']):
              # extra check for set_visible() -- this prevents error display when entire data set not displayed
              if(key == 'visible'):
                value = value and self.visibility
              method = 'set_' + key
              for entry in handleErr[1]:
                # remember the organization of the error handles
                if (hasattr(entry, method)):
                  method2call = getattr(entry, method)
                  method2call(value)
              for entry in handleErr[2]:
                if (hasattr(entry, method)):
                  method2call = getattr(entry, method)
                  method2call(value)
              self.rememberSettingError[key] = 'set_' + key + '(' + repr(value) + ')'
            else:
              # prevent update of plot
              changed = False

          # don't connect the error bars by line
          for entry in handleErr[1]:
            entry.set_linestyle('None')
          # hide caps when error display is only in one direction
          if(self.Errorstyle['direction'] != 'both'):
            if(self.xerr.size):
              offset = 2
              if(self.Errorstyle['direction'] == 'positive'):
                for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
                  entry.set_visible(False)
              elif(self.Errorstyle['direction'] == 'negative'):
                for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
                  entry.set_visible(False)
            else:
              offset = 0
            if(self.yerr.size):
              if(self.Errorstyle['direction'] == 'positive'):
                for entry in handleErr[1][offset:-1]:
                  entry.set_visible(False)
              elif(self.Errorstyle['direction'] == 'negative'):
                for entry in handleErr[1][offset + 1:]:
                  entry.set_visible(False)
        
        # to be safe, always update (at some point revisit this)
        updateFlag = True
            
      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleErrorMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.Errorstyle['doFill'] == value):
      redraw = False

    self.Errorstyle['doFill'] = value
    # adjust value
    if(value):
      value = self.Errorstyle['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    handles = [self.handleErr, self.handleErr_div]
    if(self.parent.plotArea.splitY):
      handles += [self.handlesBothAxes[i] for i in ['handleErr', 'handleErr_div'] if i in self.handlesBothAxes]
    for handleErr in handles:
      if(handleErr != None):
        for entry in handleErr[1]:
          entry.set_markerfacecolor(value)
        updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setBarStyle(self, key, value, redraw=True, rescale=True):
    # changes the barstyle value
    if(key in self.Barstyle):
      if(self.Barstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Barstyle[key] = value
      # cause plot to be updated
      if(key in ['showBar', 'offset']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag, redrawFlag = False, False
        handles = [self.handleBar, self.handleBar_div]
        if(self.parent.plotArea.splitY):
          handles += [self.handlesBothAxes[i] for i in ['handleBar', 'handleBar_div'] if i in self.handlesBothAxes]
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.Barstyle['doFill']):
          for handleBar in handles:
            if(handleBar != None):
              if(key in ['width']):
                if(not redrawFlag):
                  # have to trigger redraw to avoid recentering of bars
                  self.drawMe(redraw=redraw, rescale=False)
                  self.rememberSettingBar[key] = 'set_' + key + '(' + repr(value) + ')'
                  redraw, redrawFlag = False, True
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Barstyle['hatch'] * self.Barstyle['hatchMultiply']
                method = 'set_'+key
                for entry in handleBar.patches:
                  if(key in ['facecolor', 'facecolorAlt']):
                    if (hasattr(entry, 'set_facecolor')):
                      if(entry.get_height() >= 0):
                        useValue = self.Barstyle['facecolor']
                      else:
                        useValue = self.Barstyle['facecolorAlt']
                      entry.set_facecolor(useValue)
                  elif (hasattr(entry, method)):
                    method2call = getattr(entry, method)
                    method2call(value)
                if(key == 'facecolorAlt'):
                  self.rememberSettingBar[key] = 'set_facecolor(' + repr(value) + ')'
                else:      
                  self.rememberSettingBar[key] = 'set_' + key + '(' + repr(value) + ')'
              updateFlag = True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setStackStyle(self, key, value, redraw=True, rescale=True):
    # changes the stackstyle value
    if(key in self.Stackstyle):
      if(self.Stackstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Stackstyle[key] = value
      # cause plot to be updated
      if(key in ['showStack']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        handles = [self.handleStack, self.handleStackNeg, self.handleStack_div, self.handleStackNeg_div]
        handlesPos = [self.handleStack, self.handleStack_div]
        if(self.parent.plotArea.splitY):
          handles += [self.handlesBothAxes[i] for i in ['handleStack', 'handleStackNeg', 'handleStackNeg_div', 'handleStack_div'] if i in self.handlesBothAxes]
          handlesPos += [self.handlesBothAxes[i] for i in ['handleStack', 'handleStack_div'] if i in self.handlesBothAxes]
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.Stackstyle['doFill']):
          for handle in handles:
            if(handle != None):
              updateFlag = True
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(handle, 'set_facecolor')):
                  if(handle in handlesPos):
                    useValue = self.Stackstyle['facecolor']
                  else:
                    useValue = self.Stackstyle['facecolorAlt']
                  handle.set_facecolor(useValue)
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Stackstyle['hatch'] * self.Stackstyle['hatchMultiply']
                method = 'set_'+key
                if (hasattr(handle, method)):
                  method2call = getattr(handle, method)
                  method2call(value)
    
            if(handle in [self.handleStack, self.handleStackNeg]):
              if(key.startswith('facecolor')):
                if(key == 'facecolor'):
                  self.rememberSettingStack[key] = 'set_facecolor(' + repr(value) + ')'
                else:
                  self.rememberSettingStackNeg[key] = 'set_facecolor(' + repr(value) + ')'
              else:
                self.rememberSettingStack[key] = 'set_' + key + '(' + repr(value) + ')'
                self.rememberSettingStackNeg[key] = 'set_' + key + '(' + repr(value) + ')'
        else:
          # prevent update of plot
          changed = False
  
        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setTextStyle(self, key, value, redraw=True, rescale=False):
    # changes the textstyle value
    if(key in self.Textstyle):
      if(self.Textstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Textstyle[key] = value
      # cause plot to be updated
      if(key in ['showText', 'skip', 'padX', 'padY', 'type']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        handles = [self.handleText, self.handleText_div]
        if(self.parent.plotArea.splitY):
          handles += [self.handlesBothAxes[i] for i in ['handleText', 'handleText_div'] if i in self.handlesBothAxes]
        for handleText in handles:
          if(handleText != None):
            method = 'set_' + key
            if (hasattr(handleText[0], method)):
              safeFont = 'DejaVu Sans'
              updateFlag = True
              for item in handleText:
                method2call = getattr(item, method)
                method2call(value)
                # special treatment for font type to catch errors
                if(key == 'fontname'):
                  _, _, descent = item._get_layout(self.parent.plotArea.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    value = safeFont
                    method2call(value)

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleViolinBodyFill(self, value, redraw=True):
    # toggles violin body fill
    if(self.Violinstyle['bodies']['doFill'] == value):
      redraw = False

    self.Violinstyle['bodies']['doFill'] = value
    # adjust value
    if(value):
      value = self.Violinstyle['bodies']['facecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    handles = [self.handleViolin, self.handleViolin_div]
    if(self.parent.plotArea.splitY):
      handles += [self.handlesBothAxes[i] for i in ['handleViolin', 'handleViolin_div'] if i in self.handlesBothAxes]
    for handleViolin in handles:
      # toggle fill
      if(handleViolin != None):
        for entry in handleViolin['bodies']:
          entry.set_facecolor(value)
        updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setViolinStyle(self, subtarget, key, value, redraw=True, rescale=True):
    # changes the violinstyle value
    if((subtarget != None) and (subtarget in self.Violinstyle) and (key in self.Violinstyle[subtarget])):
      if(self.Violinstyle[subtarget][key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Violinstyle[subtarget][key] = value
      # cause plot to be updated
      if(key in ['width']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        handles = [self.handleViolin, self.handleViolin_div]
        if(self.parent.plotArea.splitY):
          handles += [self.handlesBothAxes[i] for i in ['handleViolin', 'handleViolin_div'] if i in self.handlesBothAxes]
        # special treatment for markerfacecolor
        if((key != 'markerfacecolor') or self.Violinstyle['fliers']['doFill']):
          for handleViolin in handles:
            if(handleViolin != None):
              if(key == 'boxFill'):
                self.drawMe(redraw=redraw, rescale=False)
                redraw = False
              elif((subtarget == 'boxes') and (key == 'facecolor')):
                # need to redraw here to deal with monkey business related to how filled/unfilled boxes are drawn
                if(self.Violinstyle['boxes']['boxFill']):
                  self.drawMe(redraw=redraw, rescale=False)
                redraw = False
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Violinstyle[subtarget]['hatch'] * self.Violinstyle[subtarget]['hatchMultiply']
                if((subtarget == 'boxes') and (key == 'edgecolor') and (not self.Violinstyle['boxes']['boxFill'])):
                  # this is ugly -- boxes with no fill respect color instead of edgecolor
                  key = 'color'
                method = 'set_' + key
                if(subtarget in handleViolin):
                  if(type(handleViolin[subtarget]) == type([])):
                    # for time being slave cmins to cmaxes
                    if((subtarget in ['cmaxes', 'cmins']) and (key != 'visible')):
                      targetList = handleViolin['cmaxes'] + handleViolin['cmins']
                    elif((subtarget in ['cmeans', 'cmedians']) and (key != 'visible')):
                      targetList = handleViolin['cmeans'] + handleViolin['cmedians']
                    elif((subtarget in ['means', 'medians']) and (key != 'visible')):
                      targetList = handleViolin['means'] + handleViolin['medians']
                    else:
                      targetList = handleViolin[subtarget]
                    for item in targetList:
                      if(hasattr(item, method)):
                        method2call = getattr(item, method)
                        if((key == 'marker') and (value in CUSTOM_MARKERS)):
                          method2call(CUSTOM_MARKERS[value])
                        elif((key == 'marker') and not (value in matplotlib.lines.Line2D.markers)):
                          # this is to ensure compatibility with future versions that may introduce markers we don't know yet
                          method2call('o')
                        else:
                          method2call(value)
                      elif((key == 'dash_capstyle') and hasattr(item, 'set_capstyle')):
                        # need this if box is plotted as patch
                        item.set_capstyle(value)
                      # alpha channel of color is somehow ignored -- need to manually set alpha for the entire object though :(
                      if(('color' in key) and (type(value) == type([]))):
                        item.set_alpha(value[-1])
                  else:
                    if((subtarget in ['cmaxes', 'cmins']) and (key != 'visible')):
                      targetList = ['cmaxes', 'cmins']
                    elif((subtarget in ['cmeans', 'cmedians']) and (key != 'visible')):
                      targetList = ['cmeans', 'cmedians']
                    elif((subtarget in ['means', 'medians']) and (key != 'visible')):
                      targetList = ['means', 'medians']
                    else:
                      targetList = [subtarget]
                      
                    for target in targetList:
                      if(hasattr(handleViolin[target], method)):
                        method2call = getattr(handleViolin[target], method)
                        method2call(value)
                      elif((key == 'dash_capstyle') and hasattr(handleViolin[target], 'set_capstyle')):
                        # need this if box is plotted as patch
                        handleViolin[target].set_capstyle(value)
              updateFlag = True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setData(self, data=[], roles=[], labels=[]):
    # use this function to change the data value
    # check whether roles have been provided
    if(len(roles)):
      if(('x' in roles) and ('y' in roles)):
        self.x = data[:, roles.index('x')]
        self.y = data[:, roles.index('y')]
        if ('xerr' in roles):
          self.xerr = data[:, roles.index('xerr')]
        else:
          self.xerr = np.array([])
        if ('yerr' in roles):
          self.yerr = data[:, roles.index('yerr')]
        else:
          self.yerr = np.array([])
    else:
      if(len(data)):
        self.xerr = np.array([]); self.yerr = np.array([])
        array_dim = data.shape
        if (len(array_dim)>1 and array_dim[1]>1):
          # okay found valid data, now assign values
          self.x = data[:, 0]
          if (array_dim[1] == 2):
            self.y = data[:, 1]
          elif (array_dim[1] == 3):
            self.y = data[:, 1]
            self.yerr = data[:, 2]
          else:
            self.xerr = data[:, 1]
            self.y = data[:, 2]
            self.yerr = data[:, 3]
    
    # assign labels
    self.labels = labels
            
    # clear fval and resid (need to do this as x values and dimensions probably will have changed)
    self.fval = np.array([])
    self.resid = np.array([])
  
  def value(self):
    # use this function to read out value of data object
    data = {}
    if (len(self.x)):
      data['x'] = self.x
    if (len(self.y)):
      data['y'] = self.y
    if (len(self.xerr)):
      data['xerr'] = self.xerr
    if (len(self.yerr)):
      data['yerr'] = self.yerr
    if (len(self.fval)):
      data['fval'] = self.fval
    if (len(self.resid)):
      data['resid'] = self.resid
      
    return data

  def duplicateForSplit(self, xval=[], yval=[], xerr=[], yerr=[]):
    # duplicates current data set and draws it on split y axis
    # delete all previous items (if any)
    self.removeFromSplit()
    
    # assign x and y values
    if(not len(xval)):
      xval, yval, xerr, yerr = self.x, self.y, self.xerr, self.yerr
    xval, yval, xerr, yerr = np.array(xval), np.array(yval), np.array(xerr), np.array(yerr)

    if(self.onSecondAxes):
      axisobjectBase = 'ax'
    else:
      axisobjectBase = 'ax2'
      
    # intialize dictionary with None
    items = 'handleData,handleErr,handleErrShady,handleBar,handleStack,handleStackNeg,handleText,handleViolin'.split(',')
    for item in items:
      self.handlesBothAxes[item] = None
      self.handlesBothAxes[item + '_div'] = None
      
    # copy plot objects
    for extension in ['', '_div']:
      if(extension == ''):
        # first treat main x axes
        handleData, handleErr, handleErrShady, handleBar, handleStack, handleStackNeg, handleText, handleViolin =\
          self.handleData, self.handleErr, self.handleErrShady, self.handleBar, self.handleStack, self.handleStackNeg, self.handleText, self.handleViolin
      else:
        # then treat spit x axes
        handleData, handleErr, handleErrShady, handleBar, handleStack, handleStackNeg, handleText, handleViolin =\
          self.handleData_div, self.handleErr_div, self.handleErrShady_div, self.handleBar_div, self.handleStack_div, self.handleStackNeg_div, self.handleText_div, self.handleViolin_div
      axisobject = self.parent.plotArea.__dict__[axisobjectBase + extension]
        
      if(handleData != None):
        handle = 'handleData' + extension
        self.handlesBothAxes[handle], = axisobject.plot(xval, yval, 'ko')
      
      if(handleErr != None):
        handle = 'handleErr' + extension
        if(self.Barstyle['showBar']):
          useOffset = self.Barstyle['offset']
        else:
          useOffset = 0
          
        if(len(xerr)):
          if(len(yerr)):
            self.handlesBothAxes[handle] = axisobject.errorbar(xval + useOffset, yval, xerr=xerr, yerr=yerr, zorder=self.zorder + self.relativeZOrderError + self.parent.zOffset, capsize=1)
          else:
            self.handlesBothAxes[handle] = axisobject.errorbar(xval + useOffset, yval, xerr=xerr, zorder=self.zorder + self.relativeZOrderError + self.parent.zOffset, capsize=1)
        elif(len(yerr)):
          self.handlesBothAxes[handle] = axisobject.errorbar(xval + useOffset, yval, yerr=yerr, zorder=self.zorder + self.relativeZOrderError + self.parent.zOffset, capsize=1)
          
        if(self.handlesBothAxes[handle] != None):
          # don't draw the error curve
          self.handlesBothAxes[handle][0].set_linestyle('None')
          self.handlesBothAxes[handle][0].set_marker('None')

      if(handleErrShady != None):
        handle = 'handleErrShady' + extension
        if(self.Barstyle['showBar']):
          useOffset = self.Barstyle['offset']
        else:
          useOffset = 0
        useYerrPos, useYerrNeg = 0.0 * yerr, 0.0 * yerr
        
        if(self.Errorstyle['direction'] in ['both', 'positive']):
          useYerrPos = yerr
        if(self.Errorstyle['direction'] in ['both', 'negative']):
          useYerrNeg = yerr
        self.handlesBothAxes[handle] = axisobject.fill_between(xval + useOffset, yval - useYerrNeg, yval + useYerrPos, zorder=self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05)
  
      if(handleBar != None):
        handle = 'handleBar' + extension
        self.handlesBothAxes[handle] = axisobject.bar(xval + self.Barstyle['offset'], yval, align='center', width=self.Barstyle['width'])
        
      if((handleStack != None) or (handleStackNeg != None)):
        handlePos, handleNeg = 'handleStack' + extension, 'handleStackNeg' + extension
        posVals = (yval >= 0)
        posCount = [i for i in posVals if i]
        negCount = [i for i in posVals if (not i)]
        if(len(posCount)):
          self.handlesBothAxes[handlePos], = axisobject.stackplot(xval, yval, zorder=self.zorder + self.relativeZOrderBar + self.parent.zOffset, where=(yval >= 0), interpolate=True)
        if(len(negCount)):
          self.handlesBothAxes[handleNeg], = axisobject.stackplot(xval, yval, zorder=self.zorder + self.relativeZOrderBar + self.parent.zOffset, where=(yval <= 0), interpolate=True)

      if((handleText != None) and len(handleText)):
        handle = 'handleText' + extension
        self.handlesBothAxes[handle] = []
        for entry in handleText:
          position, text = entry.get_position(), entry.get_text()
          self.handlesBothAxes[handle].append(axisobject.text(position[0], position[1], text, horizontalalignment='center',
                              verticalalignment='bottom', zorder=self.zorder + self.relativeZOrderText + self.parent.zOffset))
          self.handlesBothAxes[handle][-1].set_clip_on(True)

      if((handleViolin != None) and len(handleViolin)):
        handle = 'handleViolin' + extension
        # get data organized into vectors
        xvector, yvector = self.collateViolinData()
        if(len(xvector) * len(yvector)):
          if(self.Violinstyle['mode'] == 1):
            if(('bodies' in self.Violinstyle) and ('width' in self.Violinstyle['bodies'])):
              useWidth = self.Violinstyle['bodies']['width']
            else:
              useWidth = 0.5
            self.handlesBothAxes[handle] = axisobject.violinplot(yvector, xvector, vert=True, showmeans=True, showextrema=True, showmedians=True, widths=useWidth)
          else:
            if(('boxes' in self.Violinstyle) and ('width' in self.Violinstyle['boxes'])):
              useWidth = self.Violinstyle['boxes']['width']
            else:
              useWidth = 0.5
            if(('boxes' in self.Violinstyle) and ('boxFill' in self.Violinstyle['boxes'])):
              useFill = self.Violinstyle['boxes']['boxFill']
            else:
              useFill = False
            # check matplotlib version
            version = matplotlib.__version__.split('.')
            if((len(version) > 1) and ((int(version[0]) > 3) or ((int(version[0]) == 3) and (int(version[1]))))):
              self.handlesBothAxes[handle] = axisobject.boxplot(yvector, positions=xvector, manage_ticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})
            else:
              self.handlesBothAxes[handle] = axisobject.boxplot(yvector, positions=xvector, manage_xticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})
        
      # apply all styles
      self.styleMe(handleData=self.handlesBothAxes['handleData' + extension], handleErr=self.handlesBothAxes['handleErr' + extension],\
                   handleErrShady=self.handlesBothAxes['handleErrShady' + extension], handleBar=self.handlesBothAxes['handleBar' + extension],\
                   handleStack=self.handlesBothAxes['handleStack' + extension], handleStackNeg=self.handlesBothAxes['handleStackNeg' + extension],\
                   handleText=self.handlesBothAxes['handleText' + extension], handleViolin=self.handlesBothAxes['handleViolin' + extension])
   
  def removeFromSplit(self):
    # removes duplicated data set from split y axes
    for handle in ['handleText', 'handleText_div']:
      if(handle in self.handlesBothAxes):
        if((self.handlesBothAxes[handle] != None) and len(self.handlesBothAxes[handle])):
          for entry in self.handlesBothAxes[handle]:
            entry.remove()
          self.handlesBothAxes.pop(handle)

    for handle in ['handleViolin', 'handleViolin_div']:
      if(handle in self.handlesBothAxes):
        if((self.handlesBothAxes[handle] != None) and len(self.handlesBothAxes[handle])):
          for entry in self.handlesBothAxes[handle]:
            if(type(self.handlesBothAxes[handle][entry]) == type([])):
              for entry2 in self.handlesBothAxes[handle][entry]:
                if(hasattr(entry2, 'remove')):
                  entry2.remove()
            elif(hasattr(self.handlesBothAxes[handle][entry], 'remove')):
              self.handlesBothAxes[handle][entry].remove()
          self.handlesBothAxes.pop(handle)

    for handle in ['handleErr', 'handleErr_div']:
      if(handle in self.handlesBothAxes):
        if((self.handlesBothAxes[handle] != None) and len(self.handlesBothAxes[handle])):
          if(hasattr(self.handlesBothAxes[handle][0], 'remove')):
            self.handlesBothAxes[handle][0].remove()
          if(type(self.handlesBothAxes[handle][1]) in [type([]), type(())]):
            for entry in self.handlesBothAxes[handle][1]:
              if(hasattr(entry, 'remove')):
                entry.remove()
          if(type(self.handlesBothAxes[handle][2]) in [type([]), type(())]):
            for entry in self.handlesBothAxes[handle][2]:
              if(hasattr(entry, 'remove')):
                entry.remove()
        self.handlesBothAxes.pop(handle)
   
    for handle in self.handlesBothAxes:
      if(hasattr(self.handlesBothAxes[handle], 'remove')):
        self.handlesBothAxes[handle].remove()
    self.handlesBothAxes = {}

class markerStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(markerStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # valid line styles
    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]
    if(self.parent.parent.parent.graphicsarea.advancedExport['advancedGraphics']):
      self.orderedstyles += [i for i in CUSTOM_MARKERS]

    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        getStyle = self.target.getStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['markerfacecolor'] = [1.0, 1.0, 1.0, 1.0]
      self.style['markerfacecoloralt'] = [0.0, 1.0, 1.0, 1.0]
      self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
      self.style['markeredgewidth'] = 1.0
      self.style['markersize'] = 8.0
      self.style['marker'] = 'o'
      self.style['fillstyle'] = 'full'
      self.style['markevery'] = 1
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.markerStyleLabel = QtWidgets.QLabel()
    self.markerStyleLabel.setText('Marker')
    font = self.markerStyleLabel.font()
    font.setBold(True)
    self.markerStyleLabel.setFont(font)
    self.vLayout.addWidget(self.markerStyleLabel)    
    
    # marker size
    self.markerSizeGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerSizeGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.markerSizeGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.markerSizeLabel = QtWidgets.QLabel('Size')
    self.markerSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.markerSizeLabel)
    # marker size spin box
    self.markerSizeSpin = QDoubleSpinClick()
    self.hLayout.addWidget(self.markerSizeSpin)
    self.markerSizeSpin.setMinimum(0.0)
    self.markerSizeSpin.setMaximum(100.0)
    self.markerSizeSpin.setValue(self.style['markersize'])
    self.markerSizeSpin.setToolTip('Marker size of object')
    self.markerSizeSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'markersize', self.markerSizeSpin, False))
    
    # marker facecolor
    self.markerFaceColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerFaceColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.markerFaceColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.markerFaceColorLabel = QPushButtonCheckable()
    self.markerFaceColorLabel.setText('Face')
    self.markerFaceColorLabel.setToolTip('Show marker fill of object')
    self.markerFaceColorLabel.setChecked(self.style['doFill'])
    self.markerFaceColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.clicked.connect(partial(self.toggleMarkerFill, self.target, self.markerFaceColorLabel))
    self.hLayout2.addWidget(self.markerFaceColorLabel)
    
    self.markerFaceColorButton = QPushButtonColor()
    self.markerFaceColorButton.setToolTip('Marker fill color of object')
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markerfacecolor'][0:3]]
    self.markerFaceColorButton.setMyColor(*colorvalue)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, target=self.target, key='markerfacecolor'))
    self.hLayout2.addWidget(self.markerFaceColorButton)
      
    # marker edgecolor
    self.markerEdgeColorLabel = QtWidgets.QLabel('Edge')
    self.markerEdgeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.markerEdgeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.markerEdgeColorLabel)

    self.markerEdgeColorButton = QPushButtonColor()
    self.markerEdgeColorButton.setToolTip('Marker edge color of object')
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markeredgecolor'][0:3]]
    self.markerEdgeColorButton.setMyColor(*colorvalue)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, target=self.target, key='markeredgecolor'))
    self.hLayout2.addWidget(self.markerEdgeColorButton)
      
    # marker edge width
    self.markerEdgeWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerEdgeWidthGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.markerEdgeWidthGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEdgeWidthLabel = QtWidgets.QLabel('Edgewidth')
    self.markerEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerEdgeWidthLabel)
    # marker size spin box
    self.markerEdgeWidthSpin = QDoubleSpinClick()
    self.hLayout4.addWidget(self.markerEdgeWidthSpin)
    self.markerEdgeWidthSpin.setMinimum(0.0)
    self.markerEdgeWidthSpin.setMaximum(100.0)
    self.markerEdgeWidthSpin.setValue(self.style['markeredgewidth'])
    self.markerEdgeWidthSpin.setToolTip('Marker edge width of object')
    self.markerEdgeWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'markeredgewidth', self.markerEdgeWidthSpin, False))
    
    # marker style
    self.markerStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerStyleGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.markerStyleGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.markerStyleLabel = QtWidgets.QLabel('Style')
    self.markerStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.markerStyleLabel)
    self.comboStyle = MarkerButton()
    self.comboStyle.setToolTip('Marker symbol of object')
    self.comboStyle.clicked.connect(partial(self.markerCallback, self.comboStyle))
    if(self.style['marker'] in self.orderedstyles):
      self.comboStyle.setSymbol(self.style['marker'])
    else:
      self.comboStyle.setSymbol(self.orderedstyles[0])
    self.comboStyle.setSymbolList(self.orderedstyles)
    self.comboStyle.setParent(self)
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.comboStyle)    

    # marker fill style
    self.markerFillStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerFillStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.markerFillStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)

    self.markerFillStyleLabel = QtWidgets.QLabel('Fillstyle')
    self.markerFillStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFillStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.markerFillStyleLabel)
    self.comboFillStyle = QComboBoxMac()
    self.comboFillStyle.setToolTip('Marker fill style of object')
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboFillStyle)    

    self.markerAltColorButton = QPushButtonColor()
    self.markerAltColorButton.setToolTip('Marker alternate fill color of object')
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markerfacecoloralt'][0:3]]
    self.markerAltColorButton.setMyColor(*colorvalue)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, target=self.target, key='markerfacecoloralt'))
    self.hLayout3.addWidget(self.markerAltColorButton)

    # markevery group
    self.markerEveryGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerEveryGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.markerEveryGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEveryLabel = QtWidgets.QLabel('Mark every')
    self.markerEveryLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEveryLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.markerEveryLabel)
    # marker size spin box
    self.markerEverySpin = QSpinClick()
    self.hLayout6.addWidget(self.markerEverySpin)
    self.markerEverySpin.setMinimum(1)
    self.markerEverySpin.setMaximum(1000)
    self.markerEverySpin.setValue(self.style['markevery'])
    self.markerEverySpin.setToolTip('Put marker on every nth point of object')
    self.markerEverySpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEverySpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEverySpin.editingFinished.connect(partial(self.alterStyle, self.target, 'markevery', self.markerEverySpin, True))

  def setColor(self, target = None, key = None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in target.style):
        prevColor = [255*i for i in target.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'markerfacecolor'):
          self.markerFaceColorButton.setMyColor(*value)
        elif(key == 'markeredgecolor'):
          self.markerEdgeColorButton.setMyColor(*value)
        elif(key == 'markerfacecoloralt'):
          self.markerAltColorButton.setMyColor(*value)
        value = [i/255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        else:
          changed = target.setStyle(key, value, redraw=False)
          # update legend if needed
          self.updateLegend(redraw=changed)

      # bring back the QMenu
      self.parent.togglePersist(False)

  def toggleMarkerFill(self, target = None, entryfield = None):
    # toggles whether to fill markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidMarkerFill(value, redraw=True)
      else:
        changed = target.toggleMarkerFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
    
  def selectStyle(self, target = None, key = None, entryfield = None):
    if((target != None) and (key != None)):
      index = entryfield.currentIndex()
      if(key == 'marker'):
        value = self.orderedstyles[index]
      else:
        value = self.fillstyles[index]
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def alterStyle(self, target=None, key=None, entryfield=None, integer=False):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        if(integer):
          value = int(entryfield.value())
        else:
          value = float(entryfield.value())
        originalvalue = value
      except:
        if(integer):
          value = 0
          originalvalue = 1
        else:
          value = 0.0
          originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

  def markerCallback(self, callButton=None):
    # opens menu to access advanced configuration options
    self.menu = MarkerMenu(self)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # bottom align position of QMenu
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def setMarker(self, symbol='', alternate=False):
    # sets marker symbol to selected type
    if((symbol in self.orderedstyles) and (symbol != self.style['marker'])):
      self.style['marker'] = symbol
      self.comboStyle.setSymbol(symbol)

      if(self.residMode):
        self.target.setResidStyle('marker', symbol, redraw=True)
      else:
        changed = self.target.setStyle('marker', symbol, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

# define subclassed button for marker button
class MarkerButton(QPushButtonMac):
  def __init__(self, *args, **kwargs):
    super(QPushButtonMac, self).__init__(*args, **kwargs)
    self.mySymbol = ''
    self.mySymbolList = []
    self.setText('')
    self.parent = None
    self.alternate = False
    
  def setSymbol(self, symbol=''):
    self.mySymbol = symbol
    # update button label
    self.update()

  def setSymbolList(self, symbolList=[]):
    if(type(symbolList) == type([])):
      self.mySymbolList = symbolList

  def setParent(self, parent=None):
    self.parent = parent
    
  def setAlternate(self, alternate=False):
    self.alternate = alternate
    
  def paintEvent(self, event):
    # regular draw event
    QPushButtonMac.paintEvent(self, event)
    
    # draw little triangle
    PSIZE = 4
    s = self.size()
    buttonWidth, buttonHeight = s.width(), s.height()
    offsetX, offsetY = int(buttonWidth - scaledDPI(PSIZE + 4)), int(buttonHeight / 2 - scaledDPI(PSIZE / 2 - 2))
    polygon = QtGui.QPolygon([QtCore.QPoint(offsetX, offsetY), QtCore.QPoint(int(offsetX + scaledDPI(PSIZE)), offsetY),\
                              QtCore.QPoint(int(offsetX + scaledDPI(PSIZE / 2)), int(offsetY + scaledDPI(PSIZE)))])
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.setPen(QtCore.Qt.NoPen)
    # draw dropdown triangle
    qp.setBrush(QtGui.QColor(0, 0, 0, 255))
    qp.drawPolygon(polygon)
    # write text (do this via painter such as have left alignment w/o breaking Fusion style)
    pen = QtGui.QPen()
    pen.setStyle(QtCore.Qt.SolidLine)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)
    pen.setColor(QtGui.QColor(0, 0, 0, 255))
    pen.setWidth(scaledDPI(0.5))
    pen.setCapStyle(QtCore.Qt.SquareCap)
    qp.setPen(pen)
    textHeight = self.fontMetrics().height()
    qp.drawText(scaledDPI(2), textHeight, str(self.mySymbol))
    # fini
    qp.end()
    
  def wheelEvent(self, event):
    # handles wheel events to change marker symbol (mimics qcombobox style)
    if(self.mySymbol in self.mySymbolList):
      current = self.mySymbolList.index(self.mySymbol)
      if((event.angleDelta().y() < 0) and (current < len(self.mySymbolList) - 1) and (self.parent != None)):
        self.parent.setMarker(self.mySymbolList[current + 1], self.alternate)
      elif((event.angleDelta().y() > 0) and (current > 0) and (self.parent != None)):
        self.parent.setMarker(self.mySymbolList[current - 1], self.alternate)
        
  def keyPressEvent(self, event):
    # handles up and down arrow
    if(event.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down, QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter, QtCore.Qt.Key_Home,\
       QtCore.Qt.Key_End, QtCore.Qt.Key_PageDown, QtCore.Qt.Key_PageUp]):
      if(event.key() in [QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter]):
        self.parent.markerCallback(self)
      elif(event.key() in [QtCore.Qt.Key_Home, QtCore.Qt.Key_PageUp]):
        self.parent.setMarker(self.mySymbolList[0], self.alternate)
      elif(event.key() in [QtCore.Qt.Key_End, QtCore.Qt.Key_PageDown]):
        self.parent.setMarker(self.mySymbolList[-1], self.alternate)
      elif(self.mySymbol in self.mySymbolList):
        current = self.mySymbolList.index(self.mySymbol)
        if((event.key() == QtCore.Qt.Key_Down) and (current < len(self.mySymbolList) - 1) and (self.parent != None)):
          self.parent.setMarker(self.mySymbolList[current + 1], self.alternate)
        elif((event.key() == QtCore.Qt.Key_Up) and (current > 0) and (self.parent != None)):
          self.parent.setMarker(self.mySymbolList[current - 1], self.alternate)
      else:
        event.ignore()
    else:
      # activate normal event handling
      QPushButtonMac.keyPressEvent(self, event)

# define marker dialog
class MarkerMenu(KuhMenu):
  def __init__(self, parent = None):
    super(MarkerMenu, self).__init__()
    self.parent = parent
    self.data = []
    self.alternate = False
      
    # float validator
    self.validFloat = MyValidFloat()
    self.validInt = MyValidInt()

    # set up GUI
    self.buildRessource()
    
  def setAlternate(self, alternate=False):
    self.alternate = alternate

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[2]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    
    # argh -- we will need a new table model for this
    if(self.parent != None):
      items = self.parent.orderedstyles
      nitems = len(items)
      if(nitems):
        # determine dimensions of table
        ncolumns = int(np.ceil(nitems ** 0.5))
        nrows = int(np.ceil(nitems / ncolumns))
        # set up data
        self.data = [['tilt' for i in range(ncolumns)] for i in range(nrows)]
        for i in range(nitems):
          self.data[i % nrows][int(i / nrows)] = items[i]
        self.model = StandardItemModel(nrows, ncolumns, self)
        self.model.populateModel(self.data)
        self.model.layoutChanged.emit()
        # set up view
        self.tableView = QtWidgets.QTableView()
        self.tableView.setModel(self.model)
        self.tableView.resizeColumnsToContents()
        self.tableView.horizontalHeader().hide()
        self.tableView.verticalHeader().hide()
        self.tableView.setShowGrid(False)
        self.tableView.setStyleSheet("QTableView::item:hover {color: white; background-color: #0078d7; border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                                      QTableView::item {background-color: transparent; text-align: center;}\n\
                                      QTableView::item:focus {background-color: transparent; border-width: 2px; border-color: #444444; border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                                      QTableView::item:hover:focus {color: white; background-color: #0078d7; border-width: 2px; border-color: #444444; border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                                      QTableView {border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                                      QTableView {background-color: #f0f0f0;}")
        self.tableView.clicked.connect(self.clickHandler)
        self.tableView.activated.connect(self.activateHandler)
        self.tableView.setSelectionMode(self.tableView.NoSelection)
        self.tableView.setEditTriggers(self.tableView.NoEditTriggers)
        # set delegate
        self.tableView.setItemDelegate(MarkerDelegate())
        # set focus to target item
        if(self.parent.style['marker'] in items):
          selectedIndex = items.index(self.parent.style['marker'])
          selectItem = self.model.index(selectedIndex % nrows, int(selectedIndex / nrows))
          self.tableView.selectionModel().setCurrentIndex(selectItem, QtCore.QItemSelectionModel.Current)
        
        self.vLayout.addWidget(self.tableView)
        self.tableView.setFocus()
        
        # now correctly size the QMenu -- seriously effing bugger this
        width, height = self.tableView.viewportSizeHint().width(), self.tableView.viewportSizeHint().height()
        self.tableView.setMinimumWidth(width)
        self.tableView.setMinimumHeight(height)
        self.adjustSize()
      
  def clickHandler(self, index):
    # callback for click on table
    column, row = index.column(), index.row()
    if(self.data[row][column] != 'tilt'):
      self.parent.setMarker(self.data[row][column], self.alternate)
      self.close()

  def activateHandler(self, index):
    # callback for enter press in table
    self.clickHandler(index)

# define item delegate for coloring of specific cells
class MarkerDelegate(QtWidgets.QStyledItemDelegate):
  def __init__(self):
    super(MarkerDelegate, self).__init__()

  def paint(self, painter, option, index):
    item = index.data(QtCore.Qt.DisplayRole)
    if(item in CUSTOM_MARKERS):
      brushColor = QtGui.QColor('#bfbce8')
      painter.save()
      painter.setBrush(QtGui.QBrush(brushColor))
      painter.setOpacity(1.0)
      painter.setPen(QtCore.Qt.NoPen)
      r = QtCore.QRect(option.rect)
      painter.drawRect(r)
      #painter.drawRoundedRect(r, scaledDPI(4), scaledDPI(4))
      painter.restore()
    # regular draw event
    QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)

# custom table model for multi-column pull-down menu
class StandardItemModel(QtGui.QStandardItemModel):
  def __init__(self, *args, **kwargs):
    super(StandardItemModel, self).__init__(*args, **kwargs)

  def populateModel(self, data):
    if((type(data) == type([])) and len(data)):
      nrows, ncolumns = self.rowCount(), self.columnCount()
      nitems = min(len(data) * len(data[0]), nrows * ncolumns)
      [self.setItem(i % nrows, int(i / nrows), QtGui.QStandardItem(str(data[i % nrows][int(i / nrows)]))) for i in range(nitems) if (data[i % nrows][int(i / nrows)] != 'tilt')]
      [self.setItem(i % nrows, int(i / nrows), QtGui.QStandardItem('')) for i in range(nitems) if (data[i % nrows][int(i / nrows)] == 'tilt')]
      [self.item(i % nrows, int(i / nrows)).setEnabled(False) for i in range(nitems) if (data[i % nrows][int(i / nrows)] == 'tilt')]
      
# the linestyle menu
class lineStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False, residZero=False):
    super(lineStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    self.residZero = residZero
    
    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        if(self.residZero):
          getStyle = self.parent.parent.parent.data[self.parent.parent.parent.activeData].getResidLineStyle()
        else:
          getStyle = self.target.getStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {'linewidth': 1.0, 'color': [0, 0, 0, 1], 'linestyle': 'solid', 'dash_capstyle': 'butt'}
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.lineStyleLabel = QtWidgets.QLabel()
    self.lineStyleLabel.setText('Line')
    font = self.lineStyleLabel.font()
    font.setBold(True)
    self.lineStyleLabel.setFont(font)
    self.vLayout.addWidget(self.lineStyleLabel)    
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Width')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    # line width spin box
    self.lineWidthSpin = QDoubleSpinClick()
    self.hLayout.addWidget(self.lineWidthSpin)
    self.lineWidthSpin.setMinimum(0.0)
    self.lineWidthSpin.setMaximum(100.0)
    self.lineWidthSpin.setValue(self.style['linewidth'])
    self.lineWidthSpin.setToolTip('Line width of object')
    self.lineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'linewidth', self.lineWidthSpin))

    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Color')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonColor()
    self.lineColorButton.setToolTip('Line color of object')
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['color'][0:3]]
    self.lineColorButton.setMyColor(*colorvalue)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Style')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    self.comboStyle.setToolTip('Line style of object')
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)
    
    # cap style
    self.lineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.lineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.lineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.lineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.lineDashStyleLabel)
    self.comboDashStyle = QComboBoxMac()
    self.comboDashStyle.setToolTip('Cap style of object')
    for entry in self.dashstyles:
      self.comboDashStyle.addItem(entry)
    if(self.style['dash_capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['dash_capstyle'])
    else:
      currindex = 0
    self.comboDashStyle.setCurrentIndex(currindex)
    self.comboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'dash_capstyle', self.comboDashStyle))
    self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.comboDashStyle)

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'color'):
          self.lineColorButton.setMyColor(*value)
        # process color and update plot
        value = [i / 255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        elif(self.residZero):
          self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
        else:
          changed = target.setStyle(key, value, redraw=False)
          # update legend if needed
          self.updateLegend(redraw=changed)

      # bring back the QMenu
      self.parent.togglePersist(False)
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      elif(self.residZero):
        self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
      
  def alterStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      elif(self.residZero):
        self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class barStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(barStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # valid hatch styles
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidBarStyle()
      else:
        getStyle = self.target.getBarStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['linewidth'] = 0.5
      self.style['linestyle'] = 'solid'
      self.style['facecolor'] = [0.8, 0.0, 0.0, 0.5]
      self.style['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
      self.style['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
      self.style['width'] = 0.1
      self.style['hatch'] = 'None'
      self.style['hatchMultiply'] = 1
      self.style['showBar'] = False
      self.style['offset'] = 0
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.barStyleLabel = QtWidgets.QLabel()
    self.barStyleLabel.setText('Bar')
    font = self.barStyleLabel.font()
    font.setBold(True)
    self.barStyleLabel.setFont(font)
    self.barStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.barStyleLabel)    
    
    # display bar?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setToolTip('Show bar graphics of object')
    self.displayLabel.setChecked(self.style['showBar'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    # line width spin box
    self.lineWidthSpin = QDoubleSpinClick()
    self.hLayout.addWidget(self.lineWidthSpin)
    self.lineWidthSpin.setMinimum(0.0)
    self.lineWidthSpin.setMaximum(100.0)
    self.lineWidthSpin.setValue(self.style['linewidth'])
    self.lineWidthSpin.setToolTip('Bar line width of object')
    self.lineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'linewidth', self.lineWidthSpin))
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonColor()
    self.lineColorButton.setToolTip('Bar line color of object')
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['edgecolor'][0:3]]
    self.lineColorButton.setMyColor(*colorvalue)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'edgecolor'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    self.comboStyle.setToolTip('Bar line style of object')
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)

    # cap style
    self.lineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.lineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.lineDashStyleLabel = QtWidgets.QLabel('Linecap')
    self.lineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.lineDashStyleLabel)
    self.comboDashStyle = QComboBoxMac()
    self.comboDashStyle.setToolTip('Bar cap style of object')
    for entry in self.dashstyles:
      self.comboDashStyle.addItem(entry)
    if(self.style['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['capstyle'])
    else:
      currindex = 0
    self.comboDashStyle.setCurrentIndex(currindex)
    self.comboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'capstyle', self.comboDashStyle))
    self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.comboDashStyle)

    # fill color
    self.fillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.fillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.fillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorLabel = QPushButtonCheckable()
    self.fillColorLabel.setText('Fillcolor')
    self.fillColorLabel.setToolTip('Show bar fill of object')
    self.fillColorLabel.setChecked(self.style['doFill'])
    self.fillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.clicked.connect(partial(self.toggleBarFill, self.target, self.fillColorLabel))
    self.hLayout5.addWidget(self.fillColorLabel)
      
    self.fillColorButton = QPushButtonColor()
    self.fillColorButton.setToolTip('Bar fill color of object')
    self.fillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['facecolor'][0:3]]
    self.fillColorButton.setMyColor(*colorvalue)
    self.fillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolor'))
    self.hLayout5.addWidget(self.fillColorButton)
      
    self.fillColorButtonAlt = QPushButtonColor()
    self.fillColorButtonAlt.setToolTip('Bar alternate fill color of object')
    self.fillColorButtonAlt.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['facecolorAlt'][0:3]]
    self.fillColorButtonAlt.setMyColor(*colorvalue)
    self.fillColorButtonAlt.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButtonAlt.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolorAlt'))
    self.hLayout5.addWidget(self.fillColorButtonAlt)
      
    # hatch style
    self.hatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.hatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.hatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.hatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.hatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.hatchStyleLabel)
    self.comboHatchStyle = QComboBoxMac()
    self.comboHatchStyle.setToolTip('Bar hatch style of object')
    for entry in self.hatchstyles:
      self.comboHatchStyle.addItem(entry)
    if(self.style['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['hatch'])
    else:
      currindex = 0
    self.comboHatchStyle.setCurrentIndex(currindex)
    self.comboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'hatch', self.comboHatchStyle))
    self.comboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchStyle)
    self.comboHatchMultiplyStyle = QComboBoxMac()
    self.comboHatchMultiplyStyle.setToolTip('Bar hatch repeat of object')
    for entry in self.hatchMultiplystyles:
      self.comboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['hatchMultiply']))
    else:
      currindex = 0
    self.comboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.comboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'hatchMultiply', self.comboHatchMultiplyStyle))
    self.comboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchMultiplyStyle)

    # bar width
    self.barWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.barWidthGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.barWidthGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.barWidthLabel = QtWidgets.QLabel('Barwidth')
    self.barWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.barWidthLabel)
    self.barWidthEntry = QLineEditClick()
    self.barWidthEntry.setToolTip('Bar width of object')
    self.barWidthEntry.setText(str(self.style['width']))
    self.barWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.barWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.barWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'width', self.barWidthEntry, 0.0, 1000.0))
    self.barWidthEntry.setValidator(self.validFloat)
    self.hLayout7.addWidget(self.barWidthEntry)
    
    # bar offset
    self.barOffsetGroup = QWidgetMac()
    self.vLayout.addWidget(self.barOffsetGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.barOffsetGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.barOffsetLabel = QtWidgets.QLabel('Offset')
    self.barOffsetLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barOffsetLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.barOffsetLabel)
    self.barOffsetEntry = QLineEditClick()
    self.barOffsetEntry.setToolTip('Bar x offset of object')
    self.barOffsetEntry.setText(str(self.style['offset']))
    self.barOffsetEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.barOffsetEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.barOffsetEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'offset', self.barOffsetEntry, -1000.0, 1000.0))
    self.barOffsetEntry.setValidator(self.validFloat)
    self.hLayout8.addWidget(self.barOffsetEntry)
    
  def setDisplay(self, target=None):
    # toggled display of bar graphics
    if(target != None):
      self.style['showBar'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidBar(self.style['showBar'])
      else:
        target.toggleBar(self.style['showBar'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'edgecolor'):
          self.lineColorButton.setMyColor(*value)
        elif(key == 'facecolor'):
          self.fillColorButton.setMyColor(*value)
        elif(key == 'facecolorAlt'):
          self.fillColorButtonAlt.setMyColor(*value)
        value = [i / 255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidBarStyle(key, value, redraw=True)
        else:
          target.setBarStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()

      # bring back the QMenu
      self.parent.togglePersist(False)
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      #value = str(self.comboStyle.currentText())
      value = str(entryfield.currentText())
      if(key in self.style):
        if(key == 'hatchMultiply'):
          value = int(value)
        self.style[key] = value
      if(self.residMode):
        target.setResidBarStyle(key, value, redraw=True)
      else:
        target.setBarStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def toggleBarFill(self, target = None, entryfield = None):
    # toggles whether to fill bars or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidBarFill(value, redraw=True)
      else:
        changed = target.toggleBarFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def alterStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidBarStyle(key, value, redraw=True)
      else:
        target.setBarStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()
      
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidBarStyle(key, value, redraw=True)
      else:
        target.setBarStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class stackStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(stackStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # valid hatch styles
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStackStyle()
      else:
        getStyle = self.target.getStackStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['linewidth'] = 0.5
      self.style['linestyle'] = 'solid'
      self.style['facecolor'] = [0.8, 0.0, 0.0, 0.5]
      self.style['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
      self.style['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
      self.style['hatch'] = 'None'
      self.style['hatchMultiply'] = 1
      self.style['showStack'] = False
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.stackStyleLabel = QtWidgets.QLabel()
    self.stackStyleLabel.setText('Stack')
    font = self.stackStyleLabel.font()
    font.setBold(True)
    self.stackStyleLabel.setFont(font)
    self.stackStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.stackStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.stackStyleLabel)    
    
    # display stack?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setToolTip('Show stack graphics of object')
    self.displayLabel.setChecked(self.style['showStack'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    # line width spin box
    self.lineWidthSpin = QDoubleSpinClick()
    self.hLayout.addWidget(self.lineWidthSpin)
    self.lineWidthSpin.setMinimum(0.0)
    self.lineWidthSpin.setMaximum(100.0)
    self.lineWidthSpin.setValue(self.style['linewidth'])
    self.lineWidthSpin.setToolTip('Stack line width of object')
    self.lineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'linewidth', self.lineWidthSpin))
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonColor()
    self.lineColorButton.setToolTip('Stack line color of object')
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['edgecolor'][0:3]]
    self.lineColorButton.setMyColor(*colorvalue)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'edgecolor'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    self.comboStyle.setToolTip('Stack line style of object')
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)

    # fill color
    self.fillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.fillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.fillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorLabel = QPushButtonCheckable()
    self.fillColorLabel.setText('Fillcolor')
    self.fillColorLabel.setToolTip('Show stack fill of object')
    self.fillColorLabel.setChecked(self.style['doFill'])
    self.fillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.clicked.connect(partial(self.toggleStackFill, self.target, self.fillColorLabel))
    self.hLayout5.addWidget(self.fillColorLabel)
      
    self.fillColorButton = QPushButtonColor()
    self.fillColorButton.setToolTip('Stack fill color of object')
    self.fillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['facecolor'][0:3]]
    self.fillColorButton.setMyColor(*colorvalue)
    self.fillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolor'))
    self.hLayout5.addWidget(self.fillColorButton)
      
    self.fillColorButtonAlt = QPushButtonColor()
    self.fillColorButtonAlt.setToolTip('Stack alternate fill color of object')
    self.fillColorButtonAlt.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['facecolorAlt'][0:3]]
    self.fillColorButtonAlt.setMyColor(*colorvalue)
    self.fillColorButtonAlt.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButtonAlt.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolorAlt'))
    self.hLayout5.addWidget(self.fillColorButtonAlt)
      
    # hatch style
    self.hatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.hatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.hatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.hatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.hatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.hatchStyleLabel)
    self.comboHatchStyle = QComboBoxMac()
    self.comboHatchStyle.setToolTip('Stack hatch style of object')
    for entry in self.hatchstyles:
      self.comboHatchStyle.addItem(entry)
    if(self.style['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['hatch'])
    else:
      currindex = 0
    self.comboHatchStyle.setCurrentIndex(currindex)
    self.comboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'hatch', self.comboHatchStyle))
    self.comboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchStyle)
    self.comboHatchMultiplyStyle = QComboBoxMac()
    self.comboHatchMultiplyStyle.setToolTip('Stack hatch repeat of object')
    for entry in self.hatchMultiplystyles:
      self.comboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['hatchMultiply']))
    else:
      currindex = 0
    self.comboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.comboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'hatchMultiply', self.comboHatchMultiplyStyle))
    self.comboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchMultiplyStyle)
    
  def setDisplay(self, target=None):
    # toggled display of bar graphics
    if(target != None):
      self.style['showStack'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidStack(self.style['showStack'])
      else:
        target.toggleStack(self.style['showStack'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'edgecolor'):
          self.lineColorButton.setMyColor(*value)
        elif(key == 'facecolor'):
          self.fillColorButton.setMyColor(*value)
        elif(key == 'facecolorAlt'):
          self.fillColorButtonAlt.setMyColor(*value)
        value = [i / 255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidStackStyle(key, value, redraw=True)
        else:
          target.setStackStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()

      # bring back the QMenu
      self.parent.togglePersist(False)
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      #value = str(self.comboStyle.currentText())
      value = str(entryfield.currentText())
      if(key in self.style):
        if(key == 'hatchMultiply'):
          value = int(value)
        self.style[key] = value
      if(self.residMode):
        target.setResidStackStyle(key, value, redraw=True)
      else:
        target.setStackStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def alterStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStackStyle(key, value, redraw=True)
      else:
        target.setStackStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def toggleStackFill(self, target = None, entryfield = None):
    # toggles whether to fill stacks or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidStackFill(value, redraw=True)
      else:
        changed = target.toggleStackFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
      
  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class textStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(textStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # float validator
    self.validFloat = MyValidFloat()

    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidTextStyle()
      else:
        getStyle = self.target.getTextStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['showText'] = False
      self.style['skip'] = 0
      self.style['color'] = [0.2, 0.2, 0.2, 1.0]
      self.style['fontsize'] = 12
      self.style['fontweight'] = 'normal'
      self.style['fontstyle'] = 'normal'
      self.style['fontname'] = 'Dejavu Sans'
      self.style['rotation'] = 0.0
      self.style['padX'] = 0.0
      self.style['padY'] = 0.0
      self.style['type'] = 'y'
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.textStyleLabel = QtWidgets.QLabel()
    self.textStyleLabel.setText('Text')
    font = self.textStyleLabel.font()
    font.setBold(True)
    self.textStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textStyleLabel.setFont(font)
    self.hLayout0.addWidget(self.textStyleLabel)    
    
    # display text?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setToolTip('Show text labels of object')
    self.displayLabel.setChecked(self.style['showText'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # text skip
    self.textSkipGroup = QWidgetMac()
    self.vLayout.addWidget(self.textSkipGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.textSkipGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.textSkipLabel = QtWidgets.QLabel('Skip')
    self.textSkipLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textSkipLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.textSkipLabel)
    # text skip spin box
    self.textSkipSpin = QSpinClick()
    self.hLayout.addWidget(self.textSkipSpin)
    self.textSkipSpin.setMinimum(0)
    self.textSkipSpin.setMaximum(10000)
    self.textSkipSpin.setValue(self.style['skip'])
    self.textSkipSpin.setToolTip('Put text labels on object skipping every n data points')
    self.textSkipSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textSkipSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textSkipSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'skip', self.textSkipSpin, True))

    # text pad
    self.textPadGroup = QWidgetMac()
    self.vLayout.addWidget(self.textPadGroup)
    self.hLayout1 = QtWidgets.QHBoxLayout(self.textPadGroup)
    self.hLayout1.setContentsMargins(0, 0, 0, 0)
    self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
    self.textXLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}x')
    self.textXLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textXLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.textXLabel)
    self.textXEntry = QLineEditClick()
    self.textXEntry.setToolTip('Text label x offset of object')
    self.textXEntry.setText(str(self.style['padX']))
    self.textXEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textXEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textXEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'padX', self.textXEntry, None, None, False))
    self.textXEntry.setValidator(self.validFloat)
    self.hLayout1.addWidget(self.textXEntry)

    self.textYLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}y')
    self.textYLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.textYLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.textYLabel)
    self.textYEntry = QLineEditClick()
    self.textYEntry.setToolTip('Text label y offset of object')
    self.textYEntry.setText(str(self.style['padY']))
    self.textYEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textYEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textYEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'padY', self.textYEntry, None, None, False))
    self.textYEntry.setValidator(self.validFloat)
    self.hLayout1.addWidget(self.textYEntry)

    # text font settings
    self.textFontGroup = QWidgetMac()
    self.vLayout.addWidget(self.textFontGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.textFontGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.textFontLabel = QtWidgets.QLabel('Font')
    self.textFontLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textFontLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.textFontLabel)
      
    self.textColorButton = QPushButtonColor()
    self.textColorButton.setToolTip('Text label color of object')
    self.textColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['color'][0:3]]
    self.textColorButton.setMyColor(*colorvalue)
    self.textColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.textColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.textColorButton)

    self.textSizeSpin = QDoubleSpinClick()
    self.hLayout2.addWidget(self.textSizeSpin)
    self.textSizeSpin.setMinimum(0.0)
    self.textSizeSpin.setMaximum(100.0)
    self.textSizeSpin.setValue(self.style['fontsize'])
    self.textSizeSpin.setToolTip('Text label font size of object')
    self.textSizeSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textSizeSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textSizeSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'fontsize', self.textSizeSpin, False))
    self.textSizeSpin.setDecimals(1)
      
    self.textBoldButton = QPushButtonCheckable()
    self.textBoldButton.setText('B')
    self.textBoldButton.setToolTip('Text label font weight of object')
    self.textBoldButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textBoldButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    if(self.style['fontweight'] == 'bold'):
      self.textBoldButton.setChecked(True)
    useFont = self.textBoldButton.font()
    useFont.setWeight(75)
    self.textBoldButton.setFont(useFont)
    self.textBoldButton.clicked.connect(partial(self.changeFontStyle, self.target, 'fontweight', self.textBoldButton))
    self.hLayout2.addWidget(self.textBoldButton)
    
    self.textItalicButton = QPushButtonCheckable()
    self.textItalicButton.setText('I')
    self.textItalicButton.setToolTip('Text label font style of object')
    self.textItalicButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textItalicButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    if(self.style['fontstyle'] == 'italic'):
      self.textItalicButton.setChecked(True)
    useFont = self.textItalicButton.font()
    useFont.setItalic(True)
    self.textItalicButton.setFont(useFont)
    self.textItalicButton.clicked.connect(partial(self.changeFontStyle, self.target, 'fontstyle', self.textItalicButton))
    self.hLayout2.addWidget(self.textItalicButton)
      
    self.textFontGroup2 = QWidgetMac()
    self.vLayout.addWidget(self.textFontGroup2)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.textFontGroup2)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    spacer = QtWidgets.QLabel('')
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(spacer)

    defaultFont = 'DejaVu Sans'
    self.textFontBox = QComboBoxMac()
    self.textFontBox.setToolTip('Text label font of object')
    self.textFontBox.addItems(self.parent.parent.parent.fontNames)
    self.textFontBox.setMaximumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
    self.textFontBox.setMinimumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
    if(self.style['fontname'] in self.parent.parent.parent.fontNames):
      currindex = self.parent.parent.parent.fontNames.index(self.style['fontname'])
      self.textFontBox.setCurrentIndex(currindex)
    elif(defaultFont in self.parent.parent.parent.fontNames):
      currindex = self.parent.parent.parent.fontNames.index(defaultFont)
      self.textFontBox.setCurrentIndex(currindex)
    else:
      self.textFontBox.setCurrentIndex(0)
    self.textFontBox.activated.connect(partial(self.changeFont, self.target))
    self.hLayout3.addWidget(self.textFontBox)
    
    # text rotation
    self.textAngleGroup = QWidgetMac()
    self.vLayout.addWidget(self.textAngleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.textAngleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.textAngleLabel = QtWidgets.QLabel('Angle')
    self.textAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.textAngleLabel)
    # text angle spin
    self.textAngleSpin = QDoubleSpinClick()
    self.hLayout4.addWidget(self.textAngleSpin)
    self.textAngleSpin.setMinimum(0.0)
    self.textAngleSpin.setMaximum(360.0)
    self.textAngleSpin.setValue(self.style['rotation'])
    self.textAngleSpin.setToolTip('Text label angle of object')
    self.textAngleSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textAngleSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.textAngleSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'rotation', self.textAngleSpin, False))
    self.textAngleSpin.setSingleStep(10)
    self.textAngleSpin.setWrapping(True)
    self.textAngleSpin.setAdaptive(False)
    
    # text type
    self.textTypeGroup = QWidgetMac()
    self.vLayout.addWidget(self.textTypeGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.textTypeGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.textTypeLabel = QtWidgets.QLabel('Type')
    self.textTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.textTypeLabel)

    self.textTypes = ['x', 'y', 'labels']
    self.textTypeBox = QComboBoxMac()
    self.textTypeBox.setToolTip('Text label type of object')
    self.textTypeBox.addItems(self.textTypes)
    self.textTypeBox.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.textTypeBox.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    if(self.style['type'] in self.textTypes):
      currindex = self.textTypes.index(self.style['type'])
      self.textTypeBox.setCurrentIndex(currindex)
    else:
      self.textTypeBox.setCurrentIndex(0)
    self.textTypeBox.activated.connect(partial(self.selectStyle, self.target, 'type', self.textTypeBox))
    self.hLayout5.addWidget(self.textTypeBox)

  def setDisplay(self, target=None):
    # toggled display of text graphics
    if(target != None):
      self.style['showText'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidText(self.style['showText'])
      else:
        target.toggleText(self.style['showText'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'color'):
          self.textColorButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidTextStyle(key, value, redraw=True)
        else:
          target.setTextStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()

      # bring back the QMenu
      self.parent.togglePersist(False)

  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
        # update legend if needed - not needed as errors do not feature in legend
        #self.updateLegend(redraw=True)

  def alterStyle(self, target=None, key=None, entryfield=None, integer=False):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        if(integer):
          value = int(entryfield.value())
        else:
          value = float(entryfield.value())
        originalvalue = value
      except:
        if(integer):
          value = 0
          originalvalue = 1
        else:
          value = 0.0
          originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
      # update legend if needed - not needed as text does not feature in legend
      #self.updateLegend()
    
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1, integer=False):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        if(integer):
          value = int(entryfield.text())
        else:
          value = float(entryfield.text())
        originalvalue = value
      except:
        if(integer):
          value = 0
          originalvalue = 1
        else:
          value = 0.0
          originalvalue = 1.0
      if(maxval != None):
        if(integer):
          value = min(value, maxval)
        else:
          value = np.min((value, maxval))
      if(minval != None):
        if(integer):
          value = max(value, minval)
        else:
          value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
      # update legend if needed - not needed as text does not feature in legend
      #self.updateLegend()

  def changeFontStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key in ['fontweight', 'fontstyle']) and (entryfield != None)):
      value = 'normal'
      isChecked = entryfield.isChecked()
      if(key == 'fontweight'):
        if(isChecked):
          value = 'bold'
      else:
        if(isChecked):
          value = 'italic'
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
    
  def changeFont(self, target=None):
    if(target != None):
      useFont = str(self.textFontBox.currentText())
      if(self.residMode):
        target.setResidTextStyle('fontname', useFont, redraw=True)
      else:
        target.setTextStyle('fontname', useFont, redraw=True)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class errorStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(errorStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]
    if(self.parent.parent.parent.graphicsarea.advancedExport['advancedGraphics']):
      self.orderedstyles += [i for i in CUSTOM_MARKERS]
      
    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]

    # set up initial values
    self.style, self.shadystyle = {}, {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        getStyle = self.target.getErrorStyle()
        getShadystyle = self.target.getErrorShadyStyle()
        for entry in getShadystyle:
          self.shadystyle[entry] = getShadystyle[entry]
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['color'] = [0.0, 0.0, 0.0, 1.0]
      self.style['linewidth'] = 1.0
      self.style['marker'] = '_'
      self.style['markerX'] = '|'
      self.style['markeredgewidth'] = 1.0
      self.style['markersize'] = 10.0
      self.style['fillstyle'] = 'full'
      self.style['errorInFront'] = False
      self.style['markerfacecolor'] = [1.0, 1.0, 1.0, 1.0]
      self.style['markerfacecoloralt'] = [0.0, 1.0, 1.0, 1.0]
      self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
      self.style['fillstyle'] = 'full'
      self.style['doFill'] = True
      
      self.shadystyle = {}
      self.shadystyle['visible'] = True
      self.shadystyle['facecolor'] = [0.8, 0.2, 0.2, 0.5]
      self.shadystyle['edgecolor'] = [0.8, 0.2, 0.2, 1.0]
      self.shadystyle['linestyle'] = 'None'
      self.shadystyle['linewidth'] = 1.0
      
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout_top = QtWidgets.QHBoxLayout(self)
    self.hLayout_top.setContentsMargins(0, 0, 0, 0)
    self.hLayout_top.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.topGroup1 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup1)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.topGroup1)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.errorStyleLabel = QtWidgets.QLabel()
    self.errorStyleLabel.setText('Error')
    font = self.errorStyleLabel.font()
    font.setBold(True)
    self.errorStyleLabel.setFont(font)
    self.errorStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.errorStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.errorStyleLabel)    
    
    # display error?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setToolTip('Show error bar of object')
    self.displayLabel.setChecked(self.style['visible'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # show bars in which direction?
    self.directionstyles = ['negative', 'both', 'positive']
    self.directionGroup = QWidgetMac()
    self.vLayout.addWidget(self.directionGroup)
    self.hLayout05 = QtWidgets.QHBoxLayout(self.directionGroup)
    self.hLayout05.setContentsMargins(0, 0, 0, 0)
    self.hLayout05.setAlignment(QtCore.Qt.AlignLeft)
    self.directionLabel = QtWidgets.QLabel('Direction')
    self.directionLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.directionLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.directionLabel)
    self.comboDirection = QComboBoxMac()
    self.comboDirection.setToolTip('Error bar direction of object')
    for entry in self.directionstyles:
      self.comboDirection.addItem(entry)
    if(self.style['direction'] in self.directionstyles):
      currindex = self.directionstyles.index(self.style['direction'])
    else:
      currindex = 0
    self.comboDirection.setCurrentIndex(currindex)
    self.comboDirection.activated.connect(partial(self.selectStyle, self.target, 'direction', self.comboDirection))
    self.comboDirection.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboDirection.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.comboDirection)

    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    # line width spin box
    self.lineWidthSpin = QDoubleSpinClick()
    self.hLayout.addWidget(self.lineWidthSpin)
    self.lineWidthSpin.setMinimum(0.0)
    self.lineWidthSpin.setMaximum(100.0)
    self.lineWidthSpin.setValue(self.style['linewidth'])
    self.lineWidthSpin.setToolTip('Error bar line width of object')
    self.lineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'linewidth', self.lineWidthSpin))
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
    
    self.lineColorButton = QPushButtonColor()
    self.lineColorButton.setToolTip('Error bar line color of object')
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['color'][0:3]]
    self.lineColorButton.setMyColor(*colorvalue)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.lineColorButton)

    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    self.comboStyle.setToolTip('Error bar line style of object')
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)
    
    # marker in front?
    self.markerZOrderGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerZOrderGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.markerZOrderGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.markerZOrderLabel = QPushButtonCheckable()
    self.markerZOrderLabel.setText('In front?')
    self.markerZOrderLabel.setToolTip('Show error bar in front of marker')
    self.markerZOrderLabel.setChecked(self.style['errorInFront'])
    self.markerZOrderLabel.clicked.connect(partial(self.setZOrder, self.target))
    self.markerZOrderLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.markerZOrderLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.markerZOrderLabel)
    
    # set up configuration of cap style
    divider = self.VLine()
    self.hLayout_top.addWidget(divider)
    self.topGroup3 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup3)
    
    self.vLayout3 = QtWidgets.QVBoxLayout(self.topGroup3)
    self.vLayout3.setContentsMargins(0, 0, 0, 0)
    self.vLayout3.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout3.setSpacing(scaledDPI(2))

    # heading
    self.errorStyleLabel3 = QtWidgets.QLabel()
    self.errorStyleLabel3.setText('Cap')
    font = self.errorStyleLabel3.font()
    font.setBold(True)
    self.errorStyleLabel3.setFont(font)
    self.vLayout3.addWidget(self.errorStyleLabel3)    

    # marker size
    self.markerSizeGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerSizeGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.markerSizeGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.markerSizeLabel = QtWidgets.QLabel('Size')
    self.markerSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.markerSizeLabel)
    # marker size spin box
    self.markerSizeSpin = QDoubleSpinClick()
    self.hLayout6.addWidget(self.markerSizeSpin)
    self.markerSizeSpin.setMinimum(0.0)
    self.markerSizeSpin.setMaximum(100.0)
    self.markerSizeSpin.setValue(self.style['markersize'])
    self.markerSizeSpin.setToolTip('Error cap size of object')
    self.markerSizeSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'markersize', self.markerSizeSpin))

    # marker facecolor
    self.markerFaceColorGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerFaceColorGroup)
    self.hLayout30 = QtWidgets.QHBoxLayout(self.markerFaceColorGroup)
    self.hLayout30.setContentsMargins(0, 0, 0, 0)
    self.hLayout30.setAlignment(QtCore.Qt.AlignLeft)
    self.markerFaceColorLabel = QPushButtonCheckable()
    self.markerFaceColorLabel.setText('Face')
    self.markerFaceColorLabel.setToolTip('Show error cap fill of object')
    self.markerFaceColorLabel.setChecked(self.style['doFill'])
    self.markerFaceColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.clicked.connect(partial(self.toggleMarkerFill, self.target, self.markerFaceColorLabel))
    self.hLayout30.addWidget(self.markerFaceColorLabel)
    
    self.markerFaceColorButton = QPushButtonColor()
    self.markerFaceColorButton.setToolTip('Error cap fill color of object')
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markerfacecolor'][0:3]]
    self.markerFaceColorButton.setMyColor(*colorvalue)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecolor'))
    self.hLayout30.addWidget(self.markerFaceColorButton)
      
    # marker edgecolor
    self.markerEdgeColorLabel = QtWidgets.QLabel('Edge')
    self.markerEdgeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.markerEdgeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayout30.addWidget(self.markerEdgeColorLabel)

    self.markerEdgeColorButton = QPushButtonColor()
    self.markerEdgeColorButton.setToolTip('Error cap edge color of object')
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markeredgecolor'][0:3]]
    self.markerEdgeColorButton.setMyColor(*colorvalue)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markeredgecolor'))
    self.hLayout30.addWidget(self.markerEdgeColorButton)

    # marker edge width
    self.markerEdgeWidthGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerEdgeWidthGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.markerEdgeWidthGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEdgeWidthLabel = QtWidgets.QLabel('Edgewidth')
    self.markerEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.markerEdgeWidthLabel)
    # marker edge width spin box
    self.markerEdgeWidthSpin = QDoubleSpinClick()
    self.hLayout5.addWidget(self.markerEdgeWidthSpin)
    self.markerEdgeWidthSpin.setMinimum(0.0)
    self.markerEdgeWidthSpin.setMaximum(100.0)
    self.markerEdgeWidthSpin.setValue(self.style['markeredgewidth'])
    self.markerEdgeWidthSpin.setToolTip('Error cap edge width of object')
    self.markerEdgeWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'markeredgewidth', self.markerEdgeWidthSpin))

    # marker style
    self.markerTypeGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerTypeGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.markerTypeGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.markerTypeLabel = QtWidgets.QLabel('Style')
    self.markerTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerTypeLabel)
    self.markerType = MarkerButton()
    self.markerType.setToolTip('Error cap vertical symbol of object')
    self.markerType.clicked.connect(partial(self.markerCallback, self.markerType))
    if(self.style['marker'] in self.orderedstyles):
      self.markerType.setSymbol(self.style['marker'])
    else:
      self.markerType.setSymbol(self.orderedstyles[0])
    self.markerType.setSymbolList(self.orderedstyles)
    self.markerType.setParent(self)
    self.markerType.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerType.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerType)
    
    # marker styleX
    self.markerTypeXGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerTypeXGroup)
    self.hLayout41 = QtWidgets.QHBoxLayout(self.markerTypeXGroup)
    self.hLayout41.setContentsMargins(0, 0, 0, 0)
    self.hLayout41.setAlignment(QtCore.Qt.AlignLeft)
    self.markerTypeXLabel = QtWidgets.QLabel('StyleX')
    self.markerTypeXLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeXLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout41.addWidget(self.markerTypeXLabel)
    self.markerTypeX = MarkerButton()
    self.markerTypeX.setToolTip('Error cap horizontal symbol of object')
    self.markerTypeX.clicked.connect(partial(self.markerCallback, self.markerTypeX))
    # need to exclude certain styles that make matplotlib crash -- this is quite ugly
    excludeStyles = [0, 5, 6, 7, 9, 10, 11]
    self.okayStyles = [i for i in self.orderedstyles if (not i in excludeStyles)]
    if(self.style['markerX'] in self.okayStyles):
      self.markerTypeX.setSymbol(self.style['markerX'])
    else:
      self.markerTypeX.setSymbol(self.okayStyles[0])
    self.markerTypeX.setSymbolList(self.okayStyles)
    self.markerTypeX.setParent(self)
    self.markerTypeX.setAlternate(True)
    self.markerTypeX.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeX.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout41.addWidget(self.markerTypeX)
    
    # marker fill style
    self.markerFillStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerFillStyleGroup)
    self.hLayout31 = QtWidgets.QHBoxLayout(self.markerFillStyleGroup)
    self.hLayout31.setContentsMargins(0, 0, 0, 0)
    self.hLayout31.setAlignment(QtCore.Qt.AlignLeft)

    self.markerFillStyleLabel = QtWidgets.QLabel('Fillstyle')
    self.markerFillStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFillStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.markerFillStyleLabel)
    self.comboFillStyle = QComboBoxMac()
    self.comboFillStyle.setToolTip('Error cap fill style of object')
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.comboFillStyle)    

    self.markerAltColorButton = QPushButtonColor()
    self.markerAltColorButton.setToolTip('Error cap alternate fill color of object')
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['markerfacecoloralt'][0:3]]
    self.markerAltColorButton.setMyColor(*colorvalue)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecoloralt'))
    self.hLayout31.addWidget(self.markerAltColorButton)

    # set up configuration of error shading
    divider = self.VLine()
    self.hLayout_top.addWidget(divider)
    self.topGroup2 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup2)
    
    self.vLayout2 = QtWidgets.QVBoxLayout(self.topGroup2)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))

    # heading
    self.displayShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.displayShadyGroup)
    self.hLayout20 = QtWidgets.QHBoxLayout(self.displayShadyGroup)
    self.hLayout20.setContentsMargins(0, 0, 0, 0)
    self.hLayout20.setAlignment(QtCore.Qt.AlignLeft)
    self.errorStyleLabel2 = QtWidgets.QLabel()
    self.errorStyleLabel2.setText('Shading')
    font = self.errorStyleLabel2.font()
    font.setBold(True)
    self.errorStyleLabel2.setFont(font)
    self.errorStyleLabel2.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.errorStyleLabel2.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.errorStyleLabel2)    

    self.displayShadyCheck = QPushButtonCheckable()
    self.displayShadyCheck.setText('Show?')
    self.displayShadyCheck.setToolTip('Show error shading of object')
    self.displayShadyCheck.setChecked(self.shadystyle['visible'])
    self.displayShadyCheck.clicked.connect(partial(self.setShadyDisplay, self.target))
    self.displayShadyCheck.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayShadyCheck.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.displayShadyCheck)

    # line width
    self.lineWidthShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineWidthShadyGroup)
    self.hLayout21 = QtWidgets.QHBoxLayout(self.lineWidthShadyGroup)
    self.hLayout21.setContentsMargins(0, 0, 0, 0)
    self.hLayout21.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthShadyLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.lineWidthShadyLabel)
    # shady line width spin box
    self.lineWidthShadySpin = QDoubleSpinClick()
    self.hLayout21.addWidget(self.lineWidthShadySpin)
    self.lineWidthShadySpin.setMinimum(0.0)
    self.lineWidthShadySpin.setMaximum(100.0)
    self.lineWidthShadySpin.setValue(self.shadystyle['linewidth'])
    self.lineWidthShadySpin.setToolTip('Error shading line width of object')
    self.lineWidthShadySpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthShadySpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lineWidthShadySpin.editingFinished.connect(partial(self.alterShadyStyle, self.target, 'linewidth', self.lineWidthShadySpin))
    
    # line color
    self.lineColorShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineColorShadyGroup)
    self.hLayout22 = QtWidgets.QHBoxLayout(self.lineColorShadyGroup)
    self.hLayout22.setContentsMargins(0, 0, 0, 0)
    self.hLayout22.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorShadyLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.lineColorShadyLabel)
    
    self.lineColorShadyButton = QPushButtonColor()
    self.lineColorShadyButton.setToolTip('Error shading line color of object')
    self.lineColorShadyButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.shadystyle['edgecolor'][0:3]]
    self.lineColorShadyButton.setMyColor(*colorvalue)
    self.lineColorShadyButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorShadyButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorShadyButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorShadyButton.clicked.connect(partial(self.setShadyColor, target = self.target, key = 'edgecolor'))
    self.hLayout22.addWidget(self.lineColorShadyButton)

    # line style
    self.shadylinestyles = [i for i in self.linestyles if (i != 'None')]
    self.lineStyleShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineStyleShadyGroup)
    self.hLayout23 = QtWidgets.QHBoxLayout(self.lineStyleShadyGroup)
    self.hLayout23.setContentsMargins(0, 0, 0, 0)
    self.hLayout23.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleShadyLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout23.addWidget(self.lineStyleShadyLabel)
    self.comboShadyStyle = QComboBoxMac()
    self.comboShadyStyle.setToolTip('Error shading line style of object')
    for entry in self.shadylinestyles:
      self.comboShadyStyle.addItem(entry)
    if(self.shadystyle['linestyle'] in self.shadylinestyles):
      currindex = self.shadylinestyles.index(self.shadystyle['linestyle'])
    else:
      currindex = 0
    self.comboShadyStyle.setCurrentIndex(currindex)
    self.comboShadyStyle.activated.connect(partial(self.selectShadyStyle, self.target, 'linestyle', self.comboShadyStyle))
    self.comboShadyStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboShadyStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout23.addWidget(self.comboShadyStyle)
    
    # fill color
    self.fillColorShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.fillColorShadyGroup)
    self.hLayout24 = QtWidgets.QHBoxLayout(self.fillColorShadyGroup)
    self.hLayout24.setContentsMargins(0, 0, 0, 0)
    self.hLayout24.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorShadyLabel = QtWidgets.QLabel('Fillcolor')
    self.fillColorShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout24.addWidget(self.fillColorShadyLabel)
      
    self.fillColorShadyButton = QPushButtonColor()
    self.fillColorShadyButton.setToolTip('Error shading fill color of object')
    self.fillColorShadyButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.shadystyle['facecolor'][0:3]]
    self.fillColorShadyButton.setMyColor(*colorvalue)
    self.fillColorShadyButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorShadyButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorShadyButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorShadyButton.clicked.connect(partial(self.setShadyColor, target = self.target, key = 'facecolor'))
    self.hLayout24.addWidget(self.fillColorShadyButton)

  def setShadyDisplay(self, target=None):
    # toggled display of error bars
    if(target != None):
      self.shadystyle['visible'] = self.displayShadyCheck.isChecked()
      target.setErrorShadyStyle('visible', self.shadystyle['visible'], redraw=True)

  def setDisplay(self, target=None):
    # toggled display of error bars
    if(target != None):
      self.style['visible'] = self.displayLabel.isChecked()
      target.setErrorStyle('visible', self.style['visible'], redraw=True)

  def setZOrder(self, target=None):
    # toggle relative z order of error bars
    state = self.markerZOrderLabel.isChecked()
    self.style['errorInFront'] = state
    if(target != None):
      target.setZOrderError(state, redraw=True)

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'color'):
          self.lineColorButton.setMyColor(*value)
        elif(key == 'markerfacecolor'):
          self.markerFaceColorButton.setMyColor(*value)
        elif(key == 'markeredgecolor'):
          self.markerEdgeColorButton.setMyColor(*value)
        elif(key == 'markerfacecoloralt'):
          self.markerAltColorButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        self.style[key] = value
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        else:
          target.setErrorStyle(key, value, redraw=True)

      # bring back the QMenu
      self.parent.togglePersist(False)
    
  def setShadyColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if (key in self.shadystyle):
        prevColor = [255 * i for i in self.shadystyle[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'edgecolor'):
          self.lineColorShadyButton.setMyColor(*value)
        elif(key == 'facecolor'):
          self.fillColorShadyButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        target.setErrorShadyStyle(key, value, redraw=True)

      # bring back the QMenu
      self.parent.togglePersist(False)
          
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      if(key == 'marker'):
        value = self.orderedstyles[entryfield.currentIndex()]
      elif(key == 'markerX'):
        value = self.okayStyles[entryfield.currentIndex()]
      else:
        value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        target.setErrorStyle(key, value, redraw=True)
        # update legend if needed - not needed as errors do not feature in legend
        #self.updateLegend(redraw=True)
      
  def selectShadyStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.shadystyle):
        self.shadystyle[key] = value
      target.setErrorShadyStyle(key, value, redraw=True)
      # update legend if needed - not needed as errors do not feature in legend
      #self.updateLegend(redraw=True)

  def toggleMarkerFill(self, target = None, entryfield = None):
    # toggles whether to fill markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidMarkerFill(value, redraw=True)
      else:
        target.toggleErrorMarkerFill(value, redraw=True)

  def alterStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        target.setErrorStyle(key, value, redraw=True)

  def alterShadyStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.shadystyle):
        self.shadystyle[key] = value
      target.setErrorShadyStyle(key, value, redraw=True)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def markerCallback(self, callButton=None):
    # opens menu to access advanced configuration options
    self.menu = MarkerMenu(self)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # bottom align position of QMenu
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)
    
    # toggle to discriminate between marker and markerX
    self.menu.setAlternate(callButton == self.markerTypeX)

  def setMarker(self, symbol='', alternate=False):
    # sets marker symbol to selected type
    if(alternate):
      key, targetField, testList = 'markerX', self.markerTypeX, self.okayStyles
    else:
      key, targetField, testList = 'marker', self.markerType, self.orderedstyles
        
    if((symbol in testList) and (symbol != self.style[key])):
      self.style[key] = symbol
      targetField.setSymbol(symbol)
      self.target.setErrorStyle(key, symbol, redraw=True)

class ObjectsArea(QWidgetMac):
  def __init__(self, parent = None):
    super(ObjectsArea, self).__init__()
    self.parent = parent
    
    # set up cycling colors and markers
    self.cycleColors = [[0.886, 0.29, 0.2, 1.0], [0.204, 0.5414, 0.7414, 1.0], [0.596, 0.557, 0.835, 1.0],
                        [0.467, 0.467, 0.467, 1.0], [0.984, 0.757, 0.369, 1.0], [0.557, 0.7299, 0.259, 1.0]]
    self.cycleMarkers = ['o', '^', 's', 'p', 'h', 'd']
    self.cycleLinestyles = ['solid', 'dashed', 'dotted', 'dashdot']
    
    # control display of config menu
    self.displayBarConfig, self.displayErrorConfig, self.displayTextConfig, self.displayLineConfig = False, False, False, True
    self.displayDeclusterConfig, self.displayViolinConfig, self.displayIntervalConfig = False, False, False
    self.declusterTolX, self.declusterTolY = 0.1, 0.1
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Vertical)
    self.vLayout.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)

    # data sets
    self.dataSetOuterContainer = QWidgetMac()
    self.vLayout_data = QtWidgets.QVBoxLayout(self.dataSetOuterContainer)
    self.vLayout_data.setContentsMargins(0, 0, 0, 0)
    self.vLayout_data.setSpacing(scaledDPI(2))
    self.masterwidget.addWidget(self.dataSetOuterContainer)

    self.dataSetContainer = QWidgetMac()
    self.hLayout00 = QtWidgets.QHBoxLayout(self.dataSetContainer)
    self.hLayout00.setContentsMargins(0, 0, 0, 0)
    self.vLayout_data.addWidget(self.dataSetContainer)
    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data Sets')
    self.hLayout00.addWidget(self.dataSetLabel)
    self.dataSetCreateButton = QPushButtonMac()
    self.dataSetCreateButton.setText('Add Data Set')
    self.dataSetCreateButton.setToolTip('Create empty data object')
    self.dataSetCreateButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
    self.dataSetCreateButton.setMaximumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
    self.dataSetCreateButton.clicked.connect(self.dataSetCreate)
    self.hLayout00.addWidget(self.dataSetCreateButton)
    self.hLayout00.addStretch()

    self.dataSetTable = QtWidgets.QTableWidget()
    self.dataSetTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout_data.addWidget(self.dataSetTable)
    self.refreshDataTable()

    # curves
    self.curvesOuterContainer = QWidgetMac()
    self.vLayout_curves = QtWidgets.QVBoxLayout(self.curvesOuterContainer)
    self.vLayout_curves.setContentsMargins(0, 0, 0, 0)
    self.vLayout_curves.setSpacing(scaledDPI(2))
    self.masterwidget.addWidget(self.curvesOuterContainer)

    self.curvesContainer = QWidgetMac()
    self.hLayout0 = QtWidgets.QHBoxLayout(self.curvesContainer)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.vLayout_curves.addWidget(self.curvesContainer)
    self.curvesLabel = QtWidgets.QLabel()
    useFont = self.curvesLabel.font()
    useFont.setBold(True)
    self.curvesLabel.setFont(useFont)
    self.curvesLabel.setText('Curves')
    self.hLayout0.addWidget(self.curvesLabel)
    self.curvesCreateButton = QPushButtonMac()
    self.curvesCreateButton.setText('Add Curve')
    self.curvesCreateButton.setToolTip('Create new curve object')
    self.curvesCreateButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.curvesCreateButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.curvesCreateButton.clicked.connect(self.curveCreate)
    self.hLayout0.addWidget(self.curvesCreateButton)
    self.hLayout0.addStretch()

    self.curvesTable = QtWidgets.QTableWidget()
    self.curvesTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout_curves.addWidget(self.curvesTable)
    self.refreshCurvesTable()
    
    # extras
    self.extrasOuterContainer = QWidgetMac()
    self.vLayout_extras = QtWidgets.QVBoxLayout(self.extrasOuterContainer)
    self.vLayout_extras.setContentsMargins(0, 0, 0, 0)
    self.vLayout_extras.setSpacing(scaledDPI(2))
    self.masterwidget.addWidget(self.extrasOuterContainer)

    self.extrasContainer = QWidgetMac()
    self.hLayout = QtWidgets.QHBoxLayout(self.extrasContainer)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout_extras.addWidget(self.extrasContainer)

    self.extrasLabel = QtWidgets.QLabel()
    useFont = self.extrasLabel.font()
    useFont.setBold(True)
    self.extrasLabel.setFont(useFont)
    self.extrasLabel.setText('Extras')
    self.hLayout.addWidget(self.extrasLabel)
    self.extrasCreateLineButton = QPushButtonMac()
    self.extrasCreateLineButton.setText('Add Line')
    self.extrasCreateLineButton.setToolTip('Create new line object')
    self.extrasCreateLineButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateLineButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateLineButton.clicked.connect(partial(self.extrasCreate, 'line'))
    self.hLayout.addWidget(self.extrasCreateLineButton)
    self.extrasCreateShapeButton = QPushButtonMac()
    self.extrasCreateShapeButton.setText('Add Shape')
    self.extrasCreateShapeButton.setToolTip('Create new shape object')
    self.extrasCreateShapeButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateShapeButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateShapeButton.clicked.connect(partial(self.extrasCreate, 'shape'))
    self.hLayout.addWidget(self.extrasCreateShapeButton)
    self.extrasCreateTextButton = QPushButtonMac()
    self.extrasCreateTextButton.setText('Add Text')
    self.extrasCreateTextButton.setToolTip('Create new text object')
    self.extrasCreateTextButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateTextButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateTextButton.clicked.connect(partial(self.extrasCreate, 'text'))
    self.hLayout.addWidget(self.extrasCreateTextButton)
    self.extrasCreateAnnotationButton = QPushButtonMac()
    self.extrasCreateAnnotationButton.setText('Add Annotation')
    self.extrasCreateAnnotationButton.setToolTip('Create new annotation object')
    self.extrasCreateAnnotationButton.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateAnnotationButton.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateAnnotationButton.clicked.connect(partial(self.extrasCreate, 'annotation'))
    self.hLayout.addWidget(self.extrasCreateAnnotationButton)
    self.extrasCreateFreehandButton = QPushButtonCheckable()
    self.extrasCreateFreehandButton .setText('Add Freehand')
    self.extrasCreateFreehandButton .setToolTip('Create new freehand object')
    self.extrasCreateFreehandButton .setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateFreehandButton .setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateFreehandButton .clicked.connect(partial(self.extrasCreate, 'freehand'))
    self.hLayout.addWidget(self.extrasCreateFreehandButton )
    self.hLayout.addStretch()
    
    self.extrasTable = QtWidgets.QTableWidget()
    self.extrasTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout_extras.addWidget(self.extrasTable)
    self.refreshExtrasTable()
    
    # resdiuals
    self.residualsOuterContainer = QWidgetMac()
    self.vLayout_residuals = QtWidgets.QVBoxLayout(self.residualsOuterContainer)
    self.vLayout_residuals.setContentsMargins(0, 0, 0, 0)
    self.vLayout_residuals.setSpacing(scaledDPI(2))
    self.masterwidget.addWidget(self.residualsOuterContainer)

    self.residLabel = QtWidgets.QLabel()
    useFont = self.residLabel.font()
    useFont.setBold(True)
    self.residLabel.setFont(useFont)
    self.residLabel.setText('Residuals')
    self.vLayout_residuals.addWidget(self.residLabel)
    self.residTable = QtWidgets.QTableWidget()
    self.residTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout_residuals.addWidget(self.residTable)
    self.refreshResidTable()

  def reportState(self):
    # reports contents for saveState function
    retv = {}
    retv['activeFit'] = self.parent.activeFit
    retv['activeData'] = self.parent.activeData
    retv['visibilityData'] = [i.visibility for i in self.parent.data]
    retv['visibilityFit'] = [i.visibility for i in self.parent.fit]
    retv['visibilityExtras'] = [i.visibility for i in self.parent.extras]
    retv['visibilityResid'] = [i.visibilityResid for i in self.parent.data]
    
    retstring = ''
    for entry in retv:
      retstring += '>>>' + entry + '\n'
      retstring += repr(retv[entry]) + '\n'
    
    return retstring
  
  def restoreState(self, data, zoffsetData=0, zoffsetCurve=0, zoffsetExtras=0, zoffsetResid=0):
    # restores contents for loadState function
    # set visibility of objects
    if('visibilityData' in data):
      for index, entry in enumerate(data['visibilityData']):
        if(index + zoffsetData < len(self.parent.data)):
          self.parent.data[index + zoffsetData].setVisibility(entry, redraw=False)
    if('visibilityFit' in data):
      for index, entry in enumerate(data['visibilityFit']):
        if(index + zoffsetCurve < len(self.parent.fit)):
          self.parent.fit[index + zoffsetCurve].setVisibility(entry, redraw=False)
    if('visibilityExtras' in data):
      for index, entry in enumerate(data['visibilityExtras']):
        if(index + zoffsetExtras < len(self.parent.extras)):
          self.parent.extras[index + zoffsetExtras].setVisibility(entry, redraw=False)
    if('visibilityResid' in data):
      for index, entry in enumerate(data['visibilityResid']):
        if(index + zoffsetResid < len(self.parent.data)):
          self.parent.data[index + zoffsetResid].setVisibilityResid(entry, redraw=False)
    
    # fix possible gaps/duplications in zorder
    self.sanityCheckZOrder()
    
    # update tables
    self.refreshDataTable()
    self.refreshResidTable()
    self.refreshCurvesTable()
    self.parent.globalarea.updateDataSetTable()
        
    # set active data set and curve
    if('activeData' in data):
      # check whether new object to be selected exists (can arise from edits in state file)
      if(zoffsetData + data['activeData'] < len(self.parent.data)):
        # turn off previous radio button
        prevActive = self.parent.activeData
        widget = self.dataSetTable.cellWidget(prevActive, 1)
        widget.blockSignals(True)
        widget.setChecked(False)
        widget.blockSignals(False)
        self.residTable.cellWidget(prevActive + 1, 1).setChecked(False)
        
        widget = self.dataSetTable.cellWidget(zoffsetData + data['activeData'], 1)
        widget.setChecked(True)
        self.residTable.cellWidget(zoffsetData + data['activeData'] + 1, 1).setChecked(True)
      
    if('activeFit' in data):
      # check whether new object to be selected exists (can arise from edits in state file)
      if(zoffsetCurve + data['activeFit'] < len(self.parent.fit)):
        # turn off previous radio button
        prevActive = self.parent.activeFit
        widget = self.curvesTable.cellWidget(prevActive, 1)
        widget.blockSignals(True)
        widget.setChecked(False)
        widget.blockSignals(False)
        
        widget = self.curvesTable.cellWidget(zoffsetCurve + data['activeFit'], 1)
        if(widget != None):
          # in case sth. went wrong with the state file
          widget.blockSignals(True)
          widget.setChecked(True)
          widget.blockSignals(False)
          self.changeActiveCurve(zoffsetCurve + data['activeFit'], redraw=False)

  def extrasCreate(self, extrasType='text'):
    # check whether this is a freehand item which will be handled differently
    if(extrasType == 'freehand'):
      state = self.extrasCreateFreehandButton.isChecked()
      self.parent.plotArea.drawFreehand = state
      if(state):
        self.parent.statusbar.showMessage('Click left mouse button and draw freehand shape on canvas.', self.parent.STATUS_TIME, color='blue')
      return
    # generate extras element
    self.parent.extras.append(ExtrasObject(self.parent))
    # x values
    if(self.parent.plotArea.modeX == 'linear'):
      x = (self.parent.plotArea.minX + self.parent.plotArea.maxX) / 2.0
      arrow__x = (self.parent.plotArea.minX + 2 * self.parent.plotArea.maxX) / 3.0
    else:
      x = np.exp((np.log(self.parent.plotArea.minX) + np.log(self.parent.plotArea.maxX)) / 2.0)
      arrow__x = np.exp((np.log(self.parent.plotArea.minX) + 2 * np.log(self.parent.plotArea.maxX)) / 3.0)
    arrow__x_alt = abs((self.parent.plotArea.minX - self.parent.plotArea.maxX) / 2.0)
    # y values
    if(self.parent.plotArea.modeY == 'linear'):
      y = (self.parent.plotArea.minY + self.parent.plotArea.maxY) / 2.0
      arrow__y = y
    else:
      y = np.exp((np.log(self.parent.plotArea.minY) + np.log(self.parent.plotArea.maxY)) / 2.0)
      arrow__y = y
    arrow__y_alt = abs((self.parent.plotArea.minY - self.parent.plotArea.maxY) / 2.0)
    # process and report
    if(extrasType == 'shape'):
      arrow__x, arrow__y = arrow__x_alt, arrow__y_alt
    x, y, arrow__x, arrow__y = self.roundNumber(x), self.roundNumber(y), self.roundNumber(arrow__x), self.roundNumber(arrow__y)
    x2, y2 = arrow__x, arrow__y
    labeltext = extrasType.capitalize()
    valueDict = {'x': x, 'y': y, 'labeltext': labeltext, 'extrasType': extrasType,\
                 'arrow__x': arrow__x, 'arrow__y': arrow__y, 'x2': x2, 'y2': y2}
    self.parent.extras[-1].setValues(valueDict, redraw=True)
    
    # check for split y axis
    if(self.parent.plotArea.splitY):
      self.parent.extras[-1].onBothAxes = True
      self.parent.extras[-1].duplicateForSplit()

    # update extras table
    self.refreshExtrasTable()
    self.refreshCurvesTable()
    self.refreshDataTable()
      
  def refreshExtrasTable(self):
    # updates extras table
    number_extrasEntry = len(self.parent.extras)
    self.extrasTable.setRowCount(number_extrasEntry)
    self.extrasTable.setColumnCount(7)
    for index, label in enumerate(['vis', 'z', 'text', '', 'action', '', 'axes']):
      self.extrasTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.extrasTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.extrasTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    self.extraSecondAxes, self.extraBothAxes = [], []

    for index in range(number_extrasEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityExtra = QPushButtonCheckable()
      visibilityExtra.setPadMe(scaledDPI(2))
      visibilityExtra.setText('')
      visibilityExtra.setToolTip('Set visibility of extra object ' + str(index))
      visibilityExtra.setCheckMe(True)
      visibilityExtra.setChecked(self.parent.extras[index].visibility)
      visibilityExtra.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityExtra.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityExtra.clicked.connect(partial(self.toggleVisibilityExtras, index))
      self.extrasTable.setCellWidget(index, 0, visibilityExtra)

      spinselector = QSpinBoxToolTip()
      spinselector.setToolTip('Set z order of extra object ' + str(index))
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.extras[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'extras', index = index))
      self.extrasTable.setCellWidget(index, 1, spinselector)

      entryField = QLineEditClick(str(self.parent.extras[index].labeltext))
      entryField.setToolTip('Name of extra object ' + str(index))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameExtra, index))
      self.extrasTable.setCellWidget(index, 2, entryField)
      
      extrasButton = QPushButtonMac()
      extrasButton.setText('Conf \u25be')
      extrasButton.setToolTip('Configure extra object ' + str(index))
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.changeStyleExtra, index, extrasButton))
      self.extrasTable.setCellWidget(index, 3, extrasButton)

      extrasButton = QPushButtonMac()
      extrasButton.setText('Copy')
      extrasButton.setToolTip('Copy extra object ' + str(index))
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.copyExtra, index))
      self.extrasTable.setCellWidget(index, 4, extrasButton)
        
      extrasButton = QPushButtonMac()
      extrasButton.setText('Del')
      extrasButton.setToolTip('Delete extra object ' + str(index))
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.deleteExtra, index, True))
      self.extrasTable.setCellWidget(index, 5, extrasButton)
    
      extraAxesBox = QWidgetMac()
      extraAxesBox.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      extraAxesBox.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      Layout_extraAxesBox = QtWidgets.QHBoxLayout(extraAxesBox)
      Layout_extraAxesBox.setContentsMargins(0, 0, 0, 0)
      Layout_extraAxesBox.setAlignment(QtCore.Qt.AlignLeft)
      Layout_extraAxesBox.setSpacing(0)
      self.extrasTable.setCellWidget(index, 6, extraAxesBox)

      self.extraSecondAxes.append(QPushButtonCheckable())
      self.extraSecondAxes[-1].setPadMe(scaledDPI(2))
      self.extraSecondAxes[-1].setText('2')
      self.extraSecondAxes[-1].setToolTip('Move extra object ' + str(index) + ' to second axes')
      self.extraSecondAxes[-1].setChecked(self.parent.extras[index].onSecondAxes)
      self.extraSecondAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.extraSecondAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.extraSecondAxes[-1].clicked.connect(partial(self.toggleSecondAxesExtras, index))
      Layout_extraAxesBox.addWidget(self.extraSecondAxes[-1])

      if(self.parent.plotArea.splitY):
        self.extraBothAxes.append(QPushButtonCheckable())
        self.extraBothAxes[-1].setPadMe(scaledDPI(2))
        self.extraBothAxes[-1].setText('D')
        self.extraBothAxes[-1].setToolTip('Display extra object ' + str(index) + ' on both of the split axes')
        self.extraBothAxes[-1].setChecked(self.parent.extras[index].onBothAxes)
        self.extraBothAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.extraBothAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.extraBothAxes[-1].clicked.connect(partial(self.toggleBothAxesExtras, index))
        Layout_extraAxesBox.addWidget(self.extraBothAxes[-1])
      Layout_extraAxesBox.addStretch()
      
    # resize columns
    self.extrasTable.resizeColumnsToContents()

  def sanityCheckZOrder(self):    
    # checks for inconsistencies in zorder (can happen upon restoration/deletion of entries)
    # refresh tables is probably necessary but should be done outside this function
    # data sets and curves
    zorders = {}
    for entry in self.parent.data:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    for entry in self.parent.fit:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    for entry in self.parent.extras:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    
    # reassign zorder values
    keys = sorted(list(zorders.keys()))
    index = 1
    for entry in keys:
      zorders[entry].setZOrder(index, redraw=False)
      index +=1
      
    # residuals
    zordersResid = {}
    # populate with resid zero line
    zordersResid[self.parent.plotArea.zorderResidLine] = 'zero_line'
    for entry in self.parent.data:
      key = entry.zorderResid
      while(key in zordersResid):
        key += 0.001
      zordersResid[key] = entry
    
    # reassign zorderResid values
    keys = sorted(list(zordersResid.keys()))
    index = 1
    for entry in keys:
      if(zordersResid[entry] == 'zero_line'):
        self.parent.plotArea.setZOrderResidLine(index, redraw=False)
      else:
        zordersResid[entry].setZOrderResid(index, redraw=False)
      index +=1
      
  def refreshResidTable(self):
    # updates resid table
    number_residEntry = len(self.parent.data)
    self.residTable.setRowCount(number_residEntry+1)
    self.residTable.setColumnCount(5)
    #self.residTable.horizontalHeader().hide()
    for index, label in enumerate(['vis', 'act', 'z', 'name', 'action']):
      self.residTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.residTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.residTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    # set up group box for active curve selection
    self.activeResidBox = QtWidgets.QGroupBox()

    for index in range(number_residEntry+1):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityResid = QPushButtonCheckable()
      visibilityResid.setPadMe(scaledDPI(2))
      visibilityResid.setText('')
      visibilityResid.setCheckMe(True)
      if(index):
        visibilityResid.setChecked(self.parent.data[index-1].visibilityResid)
        visibilityResid.setToolTip('Set visibility of residuals object ' + str(index - 1))
      else:
        visibilityResid.setChecked(self.parent.plotArea.visibilityResidLine)
        visibilityResid.setToolTip('Set visibility of zero line')
      visibilityResid.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityResid.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityResid.clicked.connect(partial(self.toggleVisibilityResid, index))
      self.residTable.setCellWidget(index, 0, visibilityResid)

      if(index):
        radiobutton = QRadioButtonToolTip(self.activeResidBox)
        radiobutton.setToolTip('Is residuals object ' + str(index - 1) + ' active?')
        radiobutton.setObjectName('listos')
        radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        radiobutton.setChecked(index-1 == self.parent.activeData)
        radiobutton.setText('')
        radiobutton.setEnabled(False)
        self.residTable.setCellWidget(index, 1, radiobutton)

      spinselector = QSpinBoxToolTip()
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(len(self.parent.data)+1)
      if(index):
        spinselector.setValue(self.parent.data[index-1].zorderResid)
        spinselector.setToolTip('Set z order of residuals object ' + str(index - 1))
      else:
        spinselector.setValue(self.parent.plotArea.zorderResidLine)
        spinselector.setToolTip('Set z order of zero line')
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrderResid, index = index))
      self.residTable.setCellWidget(index, 2, spinselector)

      if(index):
        entryField = QLineEditClick(str(self.parent.data[index-1].nameResid))
        entryField.editingFinished.connect(partial(self.editNameResid, self.parent.data[index-1], index))
        entryField.setToolTip('Name of residuals object ' + str(index - 1))
      else:
        entryField = QLineEditClick('zero line')
        entryField.setToolTip('Name of zero line')
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.residTable.setCellWidget(index, 3, entryField)
      
      residButton = QPushButtonMac()
      residButton.setText('Conf \u25b4')
      if(index):
        residButton.setToolTip('Configure residuals object ' + str(index - 1))
      else:
        residButton.setToolTip('Configure zero line')
      residButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      residButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      if(index):
        residButton.clicked.connect(partial(self.changeStyle, self.parent.data[index-1], False, True, residButton))
      else:
        residButton.clicked.connect(partial(self.changeResidZeroStyle, residButton))
      self.residTable.setCellWidget(index, 4, residButton)
        
    # resize columns
    self.residTable.resizeColumnsToContents()

  def refreshCurvesTable(self):
    # updates curves table
    number_curveEntry = len(self.parent.fit)
    self.curvesTable.setRowCount(number_curveEntry)
    self.curvesTable.setColumnCount(8)
    for index, label in enumerate(['vis', 'act', 'z', 'name', '', 'action', '', 'axes']):
      self.curvesTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.curvesTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.curvesTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    self.curveSecondAxes, self.curveBothAxes = [], []
    # set up group box for active curve selection
    self.activeCurveBox = QtWidgets.QGroupBox()

    for index in range(number_curveEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityCurve = QPushButtonCheckable()
      visibilityCurve.setPadMe(scaledDPI(2))
      visibilityCurve.setText('')
      visibilityCurve.setToolTip('Set visibility of curve object ' + str(index))
      visibilityCurve.setCheckMe(True)
      visibilityCurve.setChecked(self.parent.fit[index].visibility)
      visibilityCurve.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityCurve.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityCurve.clicked.connect(partial(self.toggleVisibilityCurve, index))
      self.curvesTable.setCellWidget(index, 0, visibilityCurve)
      
      radiobutton = QRadioButtonToolTip(self.activeCurveBox)
      radiobutton.setToolTip('Set curve object ' + str(index) + ' active')
      radiobutton.setObjectName('listos')
      radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setChecked(index == self.parent.activeFit)
      radiobutton.toggled.connect(partial(self.changeActiveCurve, index))
      radiobutton.setText('')
      self.curvesTable.setCellWidget(index, 1, radiobutton)

      spinselector = QSpinBoxToolTip()
      spinselector.setToolTip('Set z order of curve object ' + str(index))
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.fit[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'curve', index = index))
      self.curvesTable.setCellWidget(index, 2, spinselector)

      entryField = QLineEditClick(str(self.parent.fit[index].name))
      entryField.setToolTip('Name of curve object ' + str(index))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameCurve, self.parent.fit[index], index))
      self.curvesTable.setCellWidget(index, 3, entryField)
      
      curveButton = QPushButtonMac()
      curveButton.setText('Conf \u25be')
      curveButton.setToolTip('Configure curve object ' + str(index))
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.changeStyle, self.parent.fit[index], False, False, curveButton))
      self.curvesTable.setCellWidget(index, 4, curveButton)

      curveButton = QPushButtonMac()
      curveButton.setText('Copy')
      curveButton.setToolTip('Copy curve object ' + str(index))
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.copyFit, index))
      self.curvesTable.setCellWidget(index, 5, curveButton)
        
      curveButton = QPushButtonMac()
      curveButton.setText('Del')
      curveButton.setToolTip('Delete curve object ' + str(index))
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.deleteCurve, index, True))
      self.curvesTable.setCellWidget(index, 6, curveButton)
    
      curveAxesBox = QWidgetMac()
      curveAxesBox.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      curveAxesBox.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      Layout_curveAxesBox = QtWidgets.QHBoxLayout(curveAxesBox)
      Layout_curveAxesBox.setContentsMargins(0, 0, 0, 0)
      Layout_curveAxesBox.setAlignment(QtCore.Qt.AlignLeft)
      Layout_curveAxesBox.setSpacing(0)
      self.curvesTable.setCellWidget(index, 7, curveAxesBox)

      self.curveSecondAxes.append(QPushButtonCheckable())
      self.curveSecondAxes[-1].setPadMe(scaledDPI(2))
      self.curveSecondAxes[-1].setText('2')
      self.curveSecondAxes[-1].setToolTip('Move curve object ' + str(index) + ' to second axes')
      self.curveSecondAxes[-1].setChecked(self.parent.fit[index].onSecondAxes)
      self.curveSecondAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.curveSecondAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.curveSecondAxes[-1].clicked.connect(partial(self.toggleSecondAxesCurve, index))
      Layout_curveAxesBox.addWidget(self.curveSecondAxes[-1])

      if(self.parent.plotArea.splitY):
        self.curveBothAxes.append(QPushButtonCheckable())
        self.curveBothAxes[-1].setPadMe(scaledDPI(2))
        self.curveBothAxes[-1].setText('D')
        self.curveBothAxes[-1].setToolTip('Display curve object ' + str(index) + ' on both of the split axes')
        self.curveBothAxes[-1].setChecked(self.parent.fit[index].onBothAxes)
        self.curveBothAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.curveBothAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.curveBothAxes[-1].clicked.connect(partial(self.toggleBothAxesCurve, index))
        Layout_curveAxesBox.addWidget(self.curveBothAxes[-1])
      Layout_curveAxesBox.addStretch()
      
    # resize columns
    self.curvesTable.resizeColumnsToContents()

  def refreshDataTable(self):
    # updates data table
    number_dataEntry = len(self.parent.data)
    self.dataSetTable.setRowCount(number_dataEntry)
    self.dataSetTable.setColumnCount(8)
    for index, label in enumerate(['vis', 'act', 'z', 'name', '', 'action', '', 'axes']):
      self.dataSetTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.dataSetTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.dataSetTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    self.dataSecondAxes, self.dataBothAxes = [], []
    # set up group box for active curve selection
    self.activeDataSetBox = QtWidgets.QGroupBox()

    for index in range(number_dataEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityData = QPushButtonCheckable()
      visibilityData.setPadMe(scaledDPI(2))
      visibilityData.setText('')
      visibilityData.setToolTip('Set visibility of data object ' + str(index))
      visibilityData.setCheckMe(True)
      visibilityData.setChecked(self.parent.data[index].visibility)
      visibilityData.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityData.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      visibilityData.clicked.connect(partial(self.toggleVisibilityData, index))
      self.dataSetTable.setCellWidget(index, 0, visibilityData)

      radiobutton = QRadioButtonToolTip(self.activeDataSetBox)
      radiobutton.setToolTip('Set data object ' + str(index) + ' active')
      radiobutton.setObjectName('listos')
      radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setChecked(index == self.parent.activeData)
      radiobutton.toggled.connect(partial(self.changeActiveDataSet, index, redraw=True))
      radiobutton.setText('')
      self.dataSetTable.setCellWidget(index, 1, radiobutton)

      spinselector = QSpinBoxToolTip()
      spinselector.setToolTip('Set z order of data object ' + str(index))
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.data[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'data', index = index))
      self.dataSetTable.setCellWidget(index, 2, spinselector)

      entryField = QLineEditClick(str(self.parent.data[index].name))
      entryField.setToolTip('Name of data object ' + str(index))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameData, self.parent.data[index], index))
      self.dataSetTable.setCellWidget(index, 3, entryField)

      dataButton = QPushButtonMac()
      dataButton.setText('Conf \u25be')
      dataButton.setToolTip('Configure data object ' + str(index))
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.changeStyle, self.parent.data[index], True, False, dataButton))
      self.dataSetTable.setCellWidget(index, 4, dataButton)

      dataButton = QPushButtonMac()
      dataButton.setText('Copy')
      dataButton.setToolTip('Copy data object ' + str(index))
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.copyData, index))
      self.dataSetTable.setCellWidget(index, 5, dataButton)
        
      dataButton = QPushButtonMac()
      dataButton.setText('Del')
      dataButton.setToolTip('Delete data object ' + str(index))
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.deleteDataSet, index, True))
      self.dataSetTable.setCellWidget(index, 6, dataButton)

      dataAxesBox = QWidgetMac()
      dataAxesBox.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      dataAxesBox.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE * 2 + 2), scaledDPI(BASE_SIZE)))
      Layout_dataAxesBox = QtWidgets.QHBoxLayout(dataAxesBox)
      Layout_dataAxesBox.setContentsMargins(0, 0, 0, 0)
      Layout_dataAxesBox.setAlignment(QtCore.Qt.AlignLeft)
      Layout_dataAxesBox.setSpacing(0)
      self.dataSetTable.setCellWidget(index, 7, dataAxesBox)

      self.dataSecondAxes.append(QPushButtonCheckable())
      self.dataSecondAxes[-1].setPadMe(scaledDPI(2))
      self.dataSecondAxes[-1].setText('2')
      self.dataSecondAxes[-1].setToolTip('Move data object ' + str(index) + ' to second axes')
      self.dataSecondAxes[-1].setChecked(self.parent.data[index].onSecondAxes)
      self.dataSecondAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.dataSecondAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      self.dataSecondAxes[-1].clicked.connect(partial(self.toggleSecondAxesData, index))
      Layout_dataAxesBox.addWidget(self.dataSecondAxes[-1])

      if(self.parent.plotArea.splitY):
        self.dataBothAxes.append(QPushButtonCheckable())
        self.dataBothAxes[-1].setPadMe(scaledDPI(2))
        self.dataBothAxes[-1].setText('D')
        self.dataBothAxes[-1].setToolTip('Display data object ' + str(index) + ' on both of the split axes')
        self.dataBothAxes[-1].setChecked(self.parent.data[index].onBothAxes)
        self.dataBothAxes[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.dataBothAxes[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        self.dataBothAxes[-1].clicked.connect(partial(self.toggleBothAxesData, index))
        Layout_dataAxesBox.addWidget(self.dataBothAxes[-1])
      Layout_dataAxesBox.addStretch()
      
    # resize columns
    self.dataSetTable.resizeColumnsToContents()

  def deleteExtra(self, index, redraw=True):
    # deletes extra
    killObject = self.parent.extras[index]
    
    # check whether displayed on both axes
    if(killObject.onBothAxes):
      killObject.removeFromSplit()
      
    # delete from plot
    if(killObject.handle != None):
      killObject.handle.remove()
    if(killObject.handle_div != None):
      killObject.handle_div.remove()

    # delete from self.parent.fit
    nuList = [self.parent.extras[i] for i in range(len(self.parent.extras)) if (i != index)]
    self.parent.extras = nuList

    # destroy object
    del killObject
    
    # adjust zorders etc.
    self.parent.zcount -= 1
    self.sanityCheckZOrder()
    self.refreshDataTable()
    self.refreshCurvesTable()
    self.refreshExtrasTable()
    self.checkSecondAxes()

    # update plot?
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def deleteCurve(self, index, redraw=True):
    # deletes curve
    if(len(self.parent.fit) == 1):
      self.parent.statusbar.showMessage('Cannot delete last and only curve!', self.parent.STATUS_TIME)
    else:
      killObject = self.parent.fit[index]
      
      # check whether displayed on both axes
      if(killObject.onBothAxes):
        killObject.removeFromSplit()
      
      # delete from plot
      if((hasattr(killObject, 'handlePlot')) and (killObject.handlePlot != None)):
        killObject.handlePlot.remove()
      if((hasattr(killObject, 'handlePlot_div')) and (killObject.handlePlot_div != None)):
        killObject.handlePlot_div.remove()

      # delete from self.parent.fit
      nuList = [self.parent.fit[i] for i in range(len(self.parent.fit)) if (i != index)]
      self.parent.fit = nuList

      if(index == self.parent.activeFit):
        # our active fit was deleted, too bad
        if(self.parent.activeFit):
          self.parent.activeFit -= 1
        # activate new function
        self.parent.fit[self.parent.activeFit].retired = False
        # change fit formula
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[self.parent.activeFit].retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=False)
      elif((index < self.parent.activeFit) and (self.parent.activeFit > 0)):
        # need to shift number of activeFit
        self.parent.activeFit -= 1
      
      # destroy object
      del killObject
      
      # adjust zorders etc.
      self.parent.zcount -= 1
      self.sanityCheckZOrder()
      self.refreshDataTable()
      self.refreshCurvesTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      self.checkSecondAxes()

      # update legend
      self.updateLegend(redraw=redraw)

  def deleteDataSet(self, index, redraw=True):
    # deletes data set
    if(len(self.parent.data) == 1):
      self.parent.statusbar.showMessage('Cannot delete last and only data set!', self.parent.STATUS_TIME)
    else:
      killObject = self.parent.data[index]
      
      # check whether displayed on both axes
      if(killObject.onBothAxes):
        killObject.removeFromSplit()
      
      # delete from plot
      items = 'handleData,handleErr,handleErrShady,handleBar,handleStack,handleStackNeg,handleText,handleViolin,handleResid,handleResidBar,handleResidStack,handleResidStackNeg'.split(',')
      items.extend('handleData_div,handleErr_div,handleErrShady_div,handleBar_div,handleStack_div,handleStackNeg_div,handleText_div,handleViolin_div,handleResid_div,handleResidBar_div,handleResidStack_div,handleResidStackNeg_div'.split(','))
      for entry in items:
        # need to catch this in case previous data import caused problems
        try:
          if((hasattr(killObject, entry)) and (killObject.__dict__[entry] != None)):
            if(entry in ['handleText', 'handleText_div']):
              for item in killObject.__dict__[entry]:
                item.remove()
            elif(entry in ['handleViolin', 'handleViolin_div']):
              for entry2 in killObject.__dict__[entry]:
                if(type(killObject.__dict__[entry][entry2]) == type([])):
                  for item in killObject.__dict__[entry][entry2]:
                    item.remove()
                else:
                  killObject.__dict__[entry][entry2].remove()
                
            elif(not (entry in ['handleErr', 'handleErr_div'])):
              killObject.__dict__[entry].remove()
            else:
              killObject.__dict__[entry][0].remove()
              for entry2 in killObject.__dict__[entry][1]:
                entry2.remove()
              for entry2 in killObject.__dict__[entry][2]:
                entry2.remove()
        except:
          pass

      # delete from self.parent.data
      nuList = [self.parent.data[i] for i in range(len(self.parent.data)) if (i != index)]
      self.parent.data = nuList

      if(index == self.parent.activeData):
        # our active data set was deleted, too bad
        if(self.parent.activeData):
          self.parent.activeData -= 1
        # if selected dataset exists, clear it
        if(self.parent.selectedData.isLive):
          self.parent.selectedData.clearMe(redraw=False)
      elif((index < self.parent.activeData) and (self.parent.activeData > 0)):
        # need to shift number of activeFit
        self.parent.activeData -= 1

      # update results table
      self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData, maxIndex=len(self.parent.data) - 1)
      
      # destroy object
      del killObject
      
      # adjust zorders etc.
      self.parent.zcount -= 1
      self.sanityCheckZOrder()
      self.refreshDataTable()
      self.refreshCurvesTable()
      self.refreshResidTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      self.checkSecondAxes()

      # update legend
      self.updateLegend(redraw=redraw)
      if(redraw):
        self.parent.plotArea.residplotwidget.myRefresh()

  def changeActiveCurve(self, index=0, redraw=True):
    # changes active curve 
    if(len(self.parent.fit) - 1):
      prevActive = self.parent.activeFit
      if(prevActive != index):
        # update active fit function
        self.parent.activeFit = index
        # stuff to do
        # 1. retire previous function
        self.parent.fit[prevActive].retired = True
        #self.parent.fit[prevActive].retireMe()
        # 2. activate new function
        self.parent.fit[self.parent.activeFit].retired = False
        # change fit formula
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[self.parent.activeFit].retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=redraw)
        # change fit parameter table
        # change last fit results
    else:
      # have to set button to checked to prevent turning off
      widget = self.curvesTable.cellWidget(0, 1)
      widget.blockSignals(True)
      widget.setChecked(True)
      widget.blockSignals(False)
  
  def changeActiveDataSet(self, index=0, setCheck=True, redraw=True):
    # changes active data set
    if(len(self.parent.data) - 1):
      prevActive = self.parent.activeData
      if(prevActive != index):
        # if selected dataset exists, clear it
        if(self.parent.selectedData.isLive):
          self.parent.selectedData.clearMe(redraw=redraw)
        # update active data set and residuals
        self.parent.activeData = index
        if(setCheck):
          self.residTable.cellWidget(index + 1, 1).setChecked(True)
        # update results table
        self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData, maxIndex=len(self.parent.data) - 1)
    else:
      # have to set button to checked to prevent turning off
      widget = self.dataSetTable.cellWidget(0, 1)
      widget.blockSignals(True)
      widget.setChecked(True)
      widget.blockSignals(False)
  
  def changeZOrderResid(self, index=0):
    # updates z-order of plot items
    source_index = index
    new_zorder = self.residTable.cellWidget(index, 2).value()
    if(source_index):
      sourceItem = self.parent.data[source_index-1]
      orig_zorder = sourceItem.zorderResid
    else:
      sourceItem = self.parent.plotArea
      orig_zorder = sourceItem.zorderResidLine

    # hunt for the item that needs to be swapped in z-order
    flag = False
    # parse data sets
    for index in range(len(self.parent.data) + 1):
      if(index == 0):
        if(self.parent.plotArea.zorderResidLine == new_zorder):
          target_index = index
          flag = True
      elif(self.parent.data[index-1].zorderResid == new_zorder):
        # we found the guy
        target_index = index
        flag = True

    # now swap the z-order values
    if (flag):
      dest_qspin = self.residTable.cellWidget(target_index, 2)
      # have to temporarily disable event logging
      dest_qspin.blockSignals(True)
      dest_qspin.setValue(orig_zorder)
      dest_qspin.blockSignals(False)
      # update z-order in source object
      if(source_index):
        sourceItem.setZOrderResid(new_zorder, redraw=False)
      else:
        sourceItem.setZOrderResidLine(new_zorder, redraw=False)
      # update z-order in destination object
      if(target_index):
        self.parent.data[target_index-1].setZOrderResid(orig_zorder, redraw=False)
      else:
        self.parent.plotArea.setZOrderResidLine(orig_zorder, redraw=False)

      # trigger redrawing of objects
      self.parent.plotArea.residplotwidget.myRefresh()

  def changeZOrder(self, group='data', index=0):
    # updates z-order of plot items
    if(group in ['data', 'curve', 'extras']):
      # determine field that triggered event
      if (group == 'data'):
        sourceItem = self.parent.data[index]
        new_zorder = self.dataSetTable.cellWidget(index, 2).value()
      elif(group == 'curve'):
        sourceItem = self.parent.fit[index]
        new_zorder = self.curvesTable.cellWidget(index, 2).value()
      else:
        sourceItem = self.parent.extras[index]
        new_zorder = self.extrasTable.cellWidget(index, 1).value()
      orig_zorder = sourceItem.zorder
      
      # hunt for the item that needs to be swapped in z-order
      flag = False
      # parse data sets
      for index in range(len(self.parent.data)):
        if(self.parent.data[index].zorder == new_zorder):
          # we found the guy
          flag = True
          dest_qspin = self.dataSetTable.cellWidget(index, 2)
          # have to temporarily disable event logging
          dest_qspin.blockSignals(True)
          dest_qspin.setValue(orig_zorder)
          dest_qspin.blockSignals(False)
          destItem = self.parent.data[index]
          index = len(self.parent.data)+1
      # parse curves
      if (not flag):
        for index in range(len(self.parent.fit)):
          if(self.parent.fit[index].zorder == new_zorder):
            # we found the guy
            flag = True
            dest_qspin = self.curvesTable.cellWidget(index, 2)
            # have to temporarily disable event logging
            dest_qspin.blockSignals(True)
            dest_qspin.setValue(orig_zorder)
            dest_qspin.blockSignals(False)
            destItem = self.parent.fit[index]
            index = len(self.parent.fit)+1
      # parse extras
      if (not flag):
        for index in range(len(self.parent.extras)):
          if(self.parent.extras[index].zorder == new_zorder):
            # we found the guy
            flag = True
            dest_qspin = self.extrasTable.cellWidget(index, 1)
            # have to temporarily disable event logging
            dest_qspin.blockSignals(True)
            dest_qspin.setValue(orig_zorder)
            dest_qspin.blockSignals(False)
            destItem = self.parent.extras[index]
            index = len(self.parent.extras)+1
            
      # now swap the z-order values
      if (flag):
        # set z-order in objects to new values
        sourceItem.setZOrder(new_zorder, redraw=False)
        destItem.setZOrder(orig_zorder, redraw=False)
        
        # update legend if needed
        self.updateLegend(redraw=True)
        
  def checkSecondAxes(self):
    # checks whether at least one item slaved to the second axes
    state = False or self.parent.plotArea.splitY
    for entry in self.parent.data:
      state = state or entry.onSecondAxes
    for entry in self.parent.fit:
      state = state or entry.onSecondAxes
    for entry in self.parent.extras:
      state = state or entry.onSecondAxes
    # control display of axes controls
    self.parent.plotArea.toggleSecondAxes(state)
        
  def toggleVisibilityExtras(self, index=0):
    visibilityExtra = self.extrasTable.cellWidget(index, 0)
    if (visibilityExtra.isChecked()):
      self.parent.extras[index].setVisibility(True, redraw=False)
      # need to check for bad fonts here
      if(self.parent.extras[index].extrasType in ['text', 'annotation']):
        safeFont = 'DejaVu Sans'
        _, _, descent = self.parent.extras[index].handle._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.parent.extras[index].fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.parent.extras[index].fontname = safeFont
          self.parent.extras[index].handle.set_fontname(safeFont)
    else:
      self.parent.extras[index].setVisibility(False, redraw=False)
    # update plot
    self.parent.plotArea.dataplotwidget.myRefresh()

  def toggleBothAxesExtras(self, index=0):
    extrasBothAxes = self.extraBothAxes[index]
    state = extrasBothAxes.isChecked()
    self.parent.extras[index].setBothAxes(state, redraw=False)
    # update legend if needed
    self.parent.plotArea.dataplotwidget.myRefresh()
    self.checkSecondAxes()

  def toggleSecondAxesExtras(self, index=0):
    extrasSecondAxes = self.extraSecondAxes[index]
    if (extrasSecondAxes.isChecked()):
      self.parent.extras[index].setSecondAxes(True, redraw=False)
      # need to check for bad fonts here
      if(self.parent.extras[index].extrasType in ['text', 'annotation']):
        safeFont = 'DejaVu Sans'
        _, _, descent = self.parent.extras[index].handle_div._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.parent.extras[index].fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.parent.extras[index].fontname = safeFont
          self.parent.extras[index].handle_div.set_fontname(safeFont)
    else:
      self.parent.extras[index].setSecondAxes(False, redraw=False)
    # update plot
    self.parent.plotArea.dataplotwidget.myRefresh()
    self.checkSecondAxes()

  def toggleBothAxesCurve(self, index=0):
    state = self.curveBothAxes[index].isChecked()
    self.parent.fit[index].setBothAxes(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleSecondAxesCurve(self, index=0):
    curveSecondAxes = self.curveSecondAxes[index]
    state = curveSecondAxes.isChecked()
    self.parent.fit[index].setSecondAxes(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleBothAxesData(self, index=0):
    dataBothAxes = self.dataBothAxes[index]
    state = dataBothAxes.isChecked()
    self.parent.data[index].setBothAxes(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleSecondAxesData(self, index=0):
    dataSecondAxes = self.dataSecondAxes[index]
    state = dataSecondAxes.isChecked()
    self.parent.data[index].setSecondAxes(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleVisibilityCurve(self, index=0):
    visibilityCurve = self.curvesTable.cellWidget(index, 0)
    state = visibilityCurve.isChecked()
    self.parent.fit[index].setVisibility(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)

  def toggleVisibilityData(self, index=0):
    visibilityData = self.dataSetTable.cellWidget(index, 0)
    state = visibilityData.isChecked()
    self.parent.data[index].setVisibility(state, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)

  def toggleVisibilityResid(self, index=0):
    visibilityResid = self.residTable.cellWidget(index, 0)
    if(index):
      index -= 1
      method = self.parent.data[index].setVisibilityResid
    else:
      method = self.parent.plotArea.setVisibilityResidLine
    if (visibilityResid.isChecked()):
      method(True)
    else:
      method(False)

  def editNameExtra(self, targetIndex=None):
    if (targetIndex != None):
      entryField = self.extrasTable.cellWidget(targetIndex, 2)
      nuName = str(entryField.text())
      prevName = self.parent.extras[targetIndex].labeltext
      valueDict = {'labeltext': nuName}
      # update label if needed
      if(prevName != nuName):
        self.parent.extras[targetIndex].setValues(valueDict, redraw=True)
 
  def editNameCurve(self, target=None, index=0):
    if (target != None):
      entryField = self.curvesTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      prevName = target.name
      target.setName(nuName)
      # update legend and global tab if needed
      if(prevName != nuName):
        self.updateLegend(redraw=True)
        self.parent.globalarea.updateDataSetTable()
 
  def editNameData(self, target=None, index=0):
    if (target != None):
      entryField = self.dataSetTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      prevName = target.name
      target.setName(nuName)
      # update legend and global tab if needed
      if(prevName != nuName):
        self.updateLegend(redraw=True)
        self.parent.globalarea.updateDataSetTable()
 
  def editNameResid(self, target=None, index=0):
    if (target != None):
      entryField = self.residTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      target.setNameResid(nuName)
 
  def changeResidZeroStyle(self, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenu(self, target=self.parent.plotArea, residMode=False, residZero=True, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width() / 2
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2

    menuY -= self.menu.height()
    menuX, menuY = max(menuX, 0), max(menuY, 0)
    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def changeStyle(self, target=None, errorbar=False, residMode=False, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenu(self, target, residMode, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())

    # adjust window position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width() / 2
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2

    if(residMode):
      # bottom align position of QMenu
      # now move window to new position
      menuY -= self.menu.height()
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    else:
      if(callButton != None):
        menuY += callButton.geometry().height()
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    
  def changeStyleExtra(self, targetIndex=None, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenuExtra(self, targetIndex, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # adjust window position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuY += callButton.geometry().height()
      menuX += callButton.geometry().width() / 2
      self.menu.popup(QtCore.QPoint(menuX, menuY))
    else:
      # first need to display QMenu to get reliable size (even sizeHint fails)
      self.menu.popup(QtGui.QCursor.pos())
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    
  def copyData(self, source=0):
    # this routine copies the current data set
    sourceData = self.parent.data[source].value()
    if('x' in sourceData):
      # would need some kind of deep copy to make this work ...
      # ... but deepcopy produces an error due to matplotlib links, so do it manually
      self.parent.data.append(DataObject(self.parent))
      self.parent.data[-1].setName('Data_' + str(len(self.parent.data) - 1))
      # need to copy contents of original object
      self.parent.data[-1].spawned(self.parent.data[source])
      # set new data object as active
      #self.parent.activeData = (len(self.parent.data) - 1)
      self.changeActiveDataSet(len(self.parent.data) - 1, setCheck=False, redraw=False)
      # cause data to be drawn
      self.parent.data[-1].drawMe(redraw=False)
      self.refreshDataTable()
      self.dataSetTable.scrollToBottom()
      # also create a new resid object
      self.parent.data[-1].drawMeResid()
      self.refreshResidTable()
      self.residTable.scrollToBottom()
      # also refresh curves table to account for increased total number of items
      self.refreshCurvesTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      # update results table
      self.parent.resultsarea.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)
      # duplicate?
      if(self.parent.plotArea.splitY and self.parent.data[-1].onBothAxes):
        self.parent.data[-1].duplicateForSplit()
      # update legend if needed
      self.updateLegend(redraw=True)
    else:
      self.parent.statusbar.showMessage('Data object is empty, will not copy!', self.parent.STATUS_TIME)

  def copyFit(self, source=0):
    # this routine copies the current curve
    self.parent.fit.append(FitObject(self.parent))
    self.parent.fit[-1].setName('Curve_' + str(len(self.parent.fit) - 1))
    self.parent.fit[-1].retired = True
    # need to copy contents of original object
    self.parent.fit[-1].spawned(self.parent.fit[source])
    # set new curve object as active
    #self.parent.activeFit = (len(self.parent.fit) - 1)
    self.changeActiveCurve(len(self.parent.fit) - 1, redraw=False)
    # cause fxn to be drawn
    self.parent.fit[-1].drawMe(redraw=False)
    self.refreshCurvesTable()
    self.curvesTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # duplicate?
    if(self.parent.plotArea.splitY and self.parent.fit[-1].onBothAxes):
      self.parent.fit[-1].duplicateForSplit()
    # update legend if needed
    self.updateLegend(redraw=True)
    
  def curveCreate(self):
    # generates a new curve with default settings (vs. copying the fit)
    self.parent.fit.append(FitObject(self.parent))
    self.parent.fit[-1].setName('Curve_' + str(len(self.parent.fit) - 1))
    self.parent.fit[-1].retired = True
    # need to initialize object with default settings
    self.parent.fit[-1].initialize()
    # update styles to cycling styles
    useColor = self.cycleColors[(len(self.parent.fit) - 1) % len(self.cycleColors)]
    useLinestyle = self.cycleLinestyles[int((len(self.parent.fit) - 1) / len(self.cycleColors))]
    self.parent.fit[-1].style['color'], self.parent.fit[-1].style['markerfacecolor'] = useColor, useColor
    self.parent.fit[-1].style['linestyle'] = useLinestyle
    # set new curve object as active
    self.changeActiveCurve(len(self.parent.fit) - 1, redraw=False)
    # cause fxn to be drawn
    self.parent.fit[-1].drawMe(redraw=False)
    # check for split y axis
    if(self.parent.plotArea.splitY):
      self.parent.fit[-1].onBothAxes = True
      self.parent.fit[-1].duplicateForSplit()
    self.refreshCurvesTable()
    self.curvesTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # update legend if needed
    self.updateLegend(redraw=True)

  def dataSetCreate(self):
    # generates a new, emtpy data set with default settings
    self.parent.data.append(DataObject(self.parent))
    self.parent.data[-1].setName('Data_' + str(len(self.parent.data) - 1))
    # update styles to cycling styles
    useColor = self.cycleColors[(len(self.parent.data) - 1) % len(self.cycleColors)]
    useMarker = self.cycleMarkers[int((len(self.parent.data) - 1) / len(self.cycleColors))]
    self.parent.data[-1].style['color'], self.parent.data[-1].Residstyle['color'] = useColor, useColor
    self.parent.data[-1].style['markerfacecolor'], self.parent.data[-1].Residstyle['markerfacecolor'] = useColor, useColor
    self.parent.data[-1].style['marker'], self.parent.data[-1].Residstyle['marker'] = useMarker, useMarker
    self.parent.data[-1].Errorstyle['color'] = useColor
    self.parent.data[-1].Errorstyle['markerfacecolor'], self.parent.data[-1].Errorstyle['markeredgecolor'] = useColor[:3] + [0.5], useColor
    self.parent.data[-1].ErrorShadystyle['facecolor'], self.parent.data[-1].ErrorShadystyle['edgecolor'] = useColor[:3] + [0.5], useColor
    self.parent.data[-1].Barstyle['facecolor'], self.parent.data[-1].Barstyle['facecolorAlt'] = useColor, [i * 0.5 for i in useColor[:3]] + [1.0]
    self.parent.data[-1].Stackstyle['facecolor'], self.parent.data[-1].Stackstyle['facecolorAlt'] = useColor, [i * 0.5 for i in useColor[:3]] + [1.0]
    self.parent.data[-1].Violinstyle['bodies']['facecolor'], self.parent.data[-1].Violinstyle['boxes']['color'] = [min(1.0, i * 1.3) for i in useColor[:3]] + [1.0], [min(1.0, i * 1.3) for i in useColor[:3]] + [1.0]
    # check whether selectedData exist
    if(self.parent.selectedData.isLive):
      # then we should redraw to clear marker symbols
      redraw = True
    else:
      redraw = False
    # set new data object as active
    self.changeActiveDataSet(len(self.parent.data) - 1, setCheck=False, redraw=False)
    # do not need to draw data as it is empty
    ###self.parent.data[-1].drawMe(redraw=False)
    # check for split y axis
    if(self.parent.plotArea.splitY):
      self.parent.data[-1].onBothAxes = True
      self.parent.data[-1].duplicateForSplit()
    self.refreshDataTable()
    self.dataSetTable.scrollToBottom()
    # also create a new resid object
    ###self.parent.data[-1].drawMeResid()
    self.refreshResidTable()
    self.residTable.scrollToBottom()
    # also refresh curves table to account for increased total number of items
    self.refreshCurvesTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # update results table
    self.parent.resultsarea.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)
    # update legend if needed (no redraw as newly generated data set is empty)
    self.updateLegend(redraw=redraw)
    
  def copyExtra(self, source=0):
    # this routine copies the current extra
    self.parent.extras.append(ExtrasObject(self.parent))
    # need to copy contents of original object
    self.parent.extras[-1].spawned(self.parent.extras[source])
    # cause fxn to be drawn
    self.parent.extras[-1].drawMe(redraw=False)
    self.refreshExtrasTable()
    self.extrasTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshCurvesTable()
    # duplicate?
    if(self.parent.plotArea.splitY and self.parent.extras[-1].onBothAxes):
      self.parent.extras[-1].duplicateForSplit()
    # update legend if needed
    self.parent.plotArea.dataplotwidget.myRefresh()

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.plotArea.setLegend(value=value, redraw=redraw)

  def roundNumber(self, number, places=3):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.' + str(places) + 'f}'
    FORMAT_SCIENTIFIC = '{:.' + str(places) + 'e}'
    # determine return string
    if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0/NUMBER_SWITCH)):
      numberstr = FORMAT_SCIENTIFIC.format(number)
    else:
      numberstr = FORMAT_DECIMAL.format(number)

    return float(numberstr)

class ConfigMenuExtra(KuhMenu):
  def __init__(self, parent = None, targetIndex = None, displayName=False):
    super(ConfigMenuExtra, self).__init__()
    self.parent = parent
    self.targetIndex = targetIndex
    self.displayName = displayName
    self.extrasType = self.parent.parent.extras[targetIndex].extrasType
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchStyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.shapetypes = ['rect', 'circle', 'poly', 'star', 'torus']
      
    # float validator
    self.validFloat = MyValidFloat()
    # int validator
    self.validInt = MyValidInt()

    # set up initial values (needs to be much expanded)
    if (self.targetIndex != None):
      self.style = self.parent.parent.extras[targetIndex].getStyle()
    else:
      self.style = {'x': 1, 'y': 1, 'color': [0.0, 0.0, 0.0, 1.0], 'fontsize': 12, 'fontname': 'DejaVu Sans',\
                    'rotation': 0.0, 'horizontalalignment': 'center', 'verticalalignment': 'center',\
                    'fontweight': 'normal', 'fontstyle': 'normal'}

    self.persist = False
    self.persistPos = None

    # initialize drag values
    self.startPos = None
      
    # set up GUI
    self.buildRessource()

  def togglePersist(self, state):
    # toggles QMenu persistence for click events that would close it, see below
    # when state True, save current menu coordinates
    # when state False, restore QMenu at previous coordinates
    self.persist = state
    if(state):
      self.persistPos = self.pos()
    elif(self.persistPos != None):
      self.popup(self.persistPos)
      self.persistPos = None

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(self.underMouse()):
      if(self.displayName and (event.button() == QtCore.Qt.LeftButton)):
        self.startPos = event.globalPos()
    else:
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def mouseMoveEvent(self, event):
    if((event.buttons() == QtCore.Qt.LeftButton) and (self.startPos != None)):
      currentPos = event.globalPos()
      menuPos = self.mapToGlobal(self.pos()) + (currentPos - self.startPos)
      menuPos = self.mapFromGlobal(menuPos)
      self.move(menuPos)
      self.startPos = currentPos
    
  def mouseReleaseEvent(self, event):
    # turn off tracking
    if(event.button() == QtCore.Qt.LeftButton):
      self.startPos = None

  def buildRessource(self):
    # build outer gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[scaledDPI(4)]*4)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # display name of item?
    if(self.displayName):
      self.topContainer = QWidgetMac(self)
      self.vLayout.addWidget(self.topContainer)
      self.LayoutTopContainer = QtWidgets.QHBoxLayout(self.topContainer)
      self.LayoutTopContainer.setContentsMargins(0, 0, 0, 0)

      leader = 'Extra ' + str(self.targetIndex)
      self.targetLabel = QtWidgets.QLabel()
      self.targetLabel.setText(leader)
      font = self.targetLabel.font()
      font.setBold(True)
      self.targetLabel.setFont(font)
      self.LayoutTopContainer.addWidget(self.targetLabel)
      
      # create entry field to edit name
      name = self.parent.parent.extras[self.targetIndex].labeltext
      if(name != None):
        name = name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        self.entryField = QLineEditClick(name)
        self.entryField.setToolTip('Name of extra object ' + str(self.targetIndex))
        self.entryField.setAlignment(QtCore.Qt.AlignLeft)
        self.entryField.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.editingFinished.connect(partial(self.setField, self.targetIndex))
        self.LayoutTopContainer.addWidget(self.entryField)

      # put controls for altering z position
      self.LayoutTopContainer.addStretch()
      self.zLabel = QtWidgets.QLabel('z')
      self.LayoutTopContainer.addWidget(self.zLabel)

      self.innerContainer = QWidgetMac(self)
      self.LayoutTopContainer.addWidget(self.innerContainer)
      self.LayoutInnerContainer = QtWidgets.QHBoxLayout(self.innerContainer)
      self.LayoutInnerContainer.setContentsMargins(0, 0, 0, 0)
      self.LayoutInnerContainer.setSpacing(0)

      self.zDownButton = QPushButtonMac()
      self.zDownButton.setText('\u25be')
      self.zDownButton.setToolTip('Lower z order')
      self.zDownButton.setAutoRepeat(True)
      self.zDownButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.clicked.connect(partial(self.alterZ, self.targetIndex, -1))
      self.LayoutInnerContainer.addWidget(self.zDownButton)

      self.zUpButton = QPushButtonMac()
      self.zUpButton.setToolTip('Raise z order')
      self.zUpButton.setText('\u25b4')
      self.zUpButton.setAutoRepeat(True)
      self.zUpButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.clicked.connect(partial(self.alterZ, self.targetIndex, 1))
      self.LayoutInnerContainer.addWidget(self.zUpButton)
      
      # call alterZ to initiate button disabling
      self.alterZ(self.targetIndex, 0)
     
      blah = self.HLine()
      self.vLayout.addWidget(blah)

    self.upperRow = QWidgetMac()
    self.vLayout.addWidget(self.upperRow)

    self.hLayout0 = QtWidgets.QHBoxLayout(self.upperRow)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)

    # handle line separately -- too different from the other objects
    if(self.extrasType in ['line', 'shape']):
      # build gui for line formatting
      self.formatLine = QWidgetMac()    
      self.vLayout = QtWidgets.QVBoxLayout(self.formatLine)
      self.vLayout.setContentsMargins(0, 0, 0, 0)
      self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayout.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatLine)
      
      # heading
      self.extrasStyleLabel = QtWidgets.QLabel()
      if(self.extrasType == 'line'):
        self.extrasStyleLabel.setText('Line')
      else:
        self.extrasStyleLabel.setText('Shape')
      font = self.extrasStyleLabel.font()
      font.setBold(True)
      self.extrasStyleLabel.setFont(font)
      self.vLayout.addWidget(self.extrasStyleLabel)    
      
      # configure shape type
      if(self.extrasType == 'shape'):
        self.shapeTypeGroup = QWidgetMac()
        self.vLayout.addWidget(self.shapeTypeGroup)
        self.hLayout0 = QtWidgets.QHBoxLayout(self.shapeTypeGroup)
        self.hLayout0.setContentsMargins(0, 0, 0, 0)
        self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
        self.shapeTypeLabel = QtWidgets.QLabel('Type')
        self.shapeTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0.addWidget(self.shapeTypeLabel)
  
        self.shapeType = QComboBoxMac()
        self.shapeType.setToolTip('Shape type of extra object')
        for entry in self.shapetypes:
          self.shapeType.addItem(entry)
        if(self.style['shape__type'] in self.shapetypes):
          currindex = self.shapetypes.index(self.style['shape__type'])
        else:
          currindex = 0
        self.shapeType.setCurrentIndex(currindex)
        self.shapeType.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__type', self.shapeType))
        self.shapeType.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.shapeType.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayout0.addWidget(self.shapeType)
        
        self.spokeNumberSpinBox = QtWidgets.QSpinBox()
        self.spokeNumberSpinBox.setToolTip('Number corners/spokes of extra object')
        self.spokeNumberSpinBox.setAlignment(QtCore.Qt.AlignRight)
        self.spokeNumberSpinBox.setMinimum(3)
        self.spokeNumberSpinBox.setMaximum(30)
        self.spokeNumberSpinBox.setValue(self.style['shape__numSpokes'])
        self.spokeNumberSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
        self.spokeNumberSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
        self.spokeNumberSpinBox.valueChanged.connect(partial(self.changeSpokeNumber, self.targetIndex, 'shape__numSpokes', self.spokeNumberSpinBox))
        self.hLayout0.addWidget(self.spokeNumberSpinBox)
        
        if(self.style['shape__type'] in ['poly', 'star']):
          self.spokeNumberSpinBox.show()
        else:
          self.spokeNumberSpinBox.hide()
          
        if(self.style['shape__type'] == 'freehand'):
          self.shapeTypeGroup.hide()

        # spikiness of spokes
        self.spikySpokeGroup = QWidgetMac()
        self.vLayout.addWidget(self.spikySpokeGroup)
        self.hLayout0A = QtWidgets.QHBoxLayout(self.spikySpokeGroup)
        self.hLayout0A.setContentsMargins(0, 0, 0, 0)
        self.hLayout0A.setAlignment(QtCore.Qt.AlignLeft)
        self.spikySpokeLabel = QtWidgets.QLabel('Spiky')
        self.spikySpokeLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.spikySpokeLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0A.addWidget(self.spikySpokeLabel)
        
        self.spikySpokeEntry = QLineEditClick()
        self.spikySpokeEntry.setToolTip('Spikiness of extra object')
        self.spikySpokeEntry.setText(str(self.style['shape__spikiness']))
        self.spikySpokeEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.spikySpokeEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.spikySpokeEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'shape__spikiness', self.spikySpokeEntry, 0, 3))
        self.spikySpokeEntry.setValidator(self.validFloat)
        self.hLayout0A.addWidget(self.spikySpokeEntry)

        if(self.style['shape__type'] == 'star'):
          self.spikySpokeGroup.show()
        else:
          self.spikySpokeGroup.hide()

        # inner radius of torus
        self.innerRadiusGroup = QWidgetMac()
        self.vLayout.addWidget(self.innerRadiusGroup)
        self.hLayout0B = QtWidgets.QHBoxLayout(self.innerRadiusGroup)
        self.hLayout0B.setContentsMargins(0, 0, 0, 0)
        self.hLayout0B.setAlignment(QtCore.Qt.AlignLeft)

        self.innerRadiusLabel = QtWidgets.QLabel('Inner')
        self.innerRadiusLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.innerRadiusLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0B.addWidget(self.innerRadiusLabel)
        self.innerRadiusEntry = QLineEditClick()
        self.innerRadiusEntry.setToolTip('Inner radius of extra object')
        self.innerRadiusEntry.setText(str(self.style['shape__innerRadius']))
        self.innerRadiusEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.innerRadiusEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.innerRadiusEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'shape__innerRadius', self.innerRadiusEntry, 0, 1))
        self.innerRadiusEntry.setValidator(self.validFloat)
        self.hLayout0B.addWidget(self.innerRadiusEntry)

        self.pieLabel = QtWidgets.QLabel('Pie')
        self.pieLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.pieLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0B.addWidget(self.pieLabel)
        self.pieEntry = QLineEditClick()
        self.pieEntry.setToolTip('Pie slice of extra object')
        self.pieEntry.setText(str(self.style['shape__pie']))
        self.pieEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.pieEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.pieEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'shape__pie', self.pieEntry, 0, 1))
        self.pieEntry.setValidator(self.validFloat)
        self.hLayout0B.addWidget(self.pieEntry)

        if(self.style['shape__type'] == 'torus'):
          self.innerRadiusGroup.show()
        else:
          self.innerRadiusGroup.hide()

      # line position x
      self.labelXGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup)
      self.hLayout = QtWidgets.QHBoxLayout(self.labelXGroup)
      self.hLayout.setContentsMargins(0, 0, 0, 0)
      self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
      self.labelXLabel = QtWidgets.QLabel('x')
      self.labelXLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelXLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelXLabel)
  
      self.labelXEntry = QLineEditClick()
      self.labelXEntry.setToolTip('X coordinate of extra object')
      self.labelXEntry.setText(str(self.style['x']))
      self.labelXEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelXEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x', self.labelXEntry, None, None))
      self.labelXEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelXEntry)
  
      # line position y
      self.labelYGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup)
      self.labelYLabel = QtWidgets.QLabel('y')
      self.labelYLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelYLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelYLabel)
  
      self.labelYEntry = QLineEditClick()
      self.labelYEntry.setToolTip('Y coordinate of extra object')
      self.labelYEntry.setText(str(self.style['y']))
      self.labelYEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelYEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y', self.labelYEntry, None, None))
      self.labelYEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelYEntry)

      # line position x2
      self.labelXGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup2)
      self.hLayout1 = QtWidgets.QHBoxLayout(self.labelXGroup2)
      self.hLayout1.setContentsMargins(0, 0, 0, 0)
      self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
      if(self.extrasType == 'shape'):
        self.labelXLabel2 = QtWidgets.QLabel('width')
      else:
        self.labelXLabel2 = QtWidgets.QLabel('x2')
      self.labelXLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelXLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.labelXLabel2)
  
      self.labelXEntry2 = QLineEditClick()
      if(self.extrasType == 'shape'):
        self.labelXEntry2.setToolTip('Width of extra object')
      else:
        self.labelXEntry2.setToolTip('X2 coordinate of extra object')
      self.labelXEntry2.setText(str(self.style['x2']))
      self.labelXEntry2.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelXEntry2.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      if(self.extrasType == 'shape'):
        self.labelXEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x2', self.labelXEntry2, 0, None))
      else:
        self.labelXEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x2', self.labelXEntry2, None, None))
      self.labelXEntry2.setValidator(self.validFloat)
      self.hLayout1.addWidget(self.labelXEntry2)
  
      # line position y
      self.labelYGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup2)
      if(self.extrasType == 'shape'):
        self.labelYLabel2 = QtWidgets.QLabel('height')
      else:
        self.labelYLabel2 = QtWidgets.QLabel('y2')
      self.labelYLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelYLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.labelYLabel2)
  
      self.labelYEntry2 = QLineEditClick()
      if(self.extrasType == 'shape'):
        self.labelYEntry2.setToolTip('Height of extra object')
      else:
        self.labelYEntry2.setToolTip('Y2 coordinate of extra object')
      self.labelYEntry2.setText(str(self.style['y2']))
      self.labelYEntry2.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelYEntry2.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      if(self.extrasType == 'shape'):
        self.labelYEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y2', self.labelYEntry2, 0, None))
      else:
        self.labelYEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y2', self.labelYEntry2, None, None))
      self.labelYEntry2.setValidator(self.validFloat)
      self.hLayout1.addWidget(self.labelYEntry2)
      
      # line style
      self.linePropsGroup = QWidgetMac()
      self.vLayout.addWidget(self.linePropsGroup)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.linePropsGroup)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
      self.linePropsLabel = QtWidgets.QLabel('Line')
      self.linePropsLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.linePropsLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout2.addWidget(self.linePropsLabel)
      # line width spin box
      self.lineWidthSpin = QDoubleSpinClick()
      self.hLayout2.addWidget(self.lineWidthSpin)
      self.lineWidthSpin.setMinimum(0.0)
      self.lineWidthSpin.setMaximum(100.0)
      self.lineWidthSpin.setValue(self.style['line__linewidth'])
      self.lineWidthSpin.setToolTip('Line width of extra object')
      self.lineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'line__linewidth', self.lineWidthSpin))
    
      # line color
      self.lineColorButton = QPushButtonColor()
      self.lineColorButton.setToolTip('Line color of extra object')
      self.lineColorButton.setAutoFillBackground(False)
      colorvalue = [int(i * 255.0) for i in self.style['line__color'][0:3]]
      self.lineColorButton.setMyColor(*colorvalue)
      self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.lineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'line__color'))
      self.hLayout2.addWidget(self.lineColorButton)

      # close shape?
      if((self.style['extrasType'] == 'shape') and (self.style['shape__type'] == 'freehand')):
        self.closeFreehandButton = QPushButtonCheckable()
        self.closeFreehandButton.setText('closed')
        self.closeFreehandButton.setToolTip('Close freehand shape')
        self.closeFreehandButton.setChecked(self.style['shape__closed'])
        self.closeFreehandButton.setMaximumSize(QtCore.QSize(scaledDPI(44), scaledDPI(BASE_SIZE)))
        self.closeFreehandButton.setMinimumSize(QtCore.QSize(scaledDPI(44), scaledDPI(BASE_SIZE)))
        self.closeFreehandButton.clicked.connect(partial(self.toggleFreehandClose, self.targetIndex))
        self.hLayout2.addWidget(self.closeFreehandButton)
      
      # line style
      self.lineStyleGroup = QWidgetMac()
      self.vLayout.addWidget(self.lineStyleGroup)
      self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
      self.hLayout3.setContentsMargins(0, 0, 0, 0)
      self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
      self.lineStyleLabel = QtWidgets.QLabel('Style')
      self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.lineStyleLabel)

      self.lineStyle = QComboBoxMac()
      self.lineStyle.setToolTip('Line style of extra object')
      for entry in self.linestyles:
        self.lineStyle.addItem(entry)
      if(self.style['line__linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style['line__linestyle'])
      else:
        currindex = 0
      self.lineStyle.setCurrentIndex(currindex)
      self.lineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'line__linestyle', self.lineStyle))
      self.lineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.lineStyle)
 
      # cap style
      self.comboDashStyle = QComboBoxMac()
      self.comboDashStyle.setToolTip('Cap style of extra object')
      for entry in self.dashstyles:
        self.comboDashStyle.addItem(entry)
      if(self.style['line__dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style['line__dash_capstyle'])
      else:
        currindex = 0
      self.comboDashStyle.setCurrentIndex(currindex)
      self.comboDashStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'line__dash_capstyle', self.comboDashStyle))
      self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.comboDashStyle)
      
      # now add some extra attributes for shapes
      if(self.extrasType == 'shape'):
        # shape colors
        self.shapeColorGroup = QWidgetMac()
        self.vLayout.addWidget(self.shapeColorGroup)
        self.hLayout4 = QtWidgets.QHBoxLayout(self.shapeColorGroup)
        self.hLayout4.setContentsMargins(0, 0, 0, 0)
        self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
        self.shapeColorLabel = QPushButtonCheckable()
        self.shapeColorLabel.setText('Fill')
        self.shapeColorLabel.setToolTip('Show fill of extra object')
        self.shapeColorLabel.setChecked(self.style['shape__doFill'])
        self.shapeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'shape__doFill', self.shapeColorLabel))
        self.hLayout4.addWidget(self.shapeColorLabel)
    
        self.shapeFaceColorButton = QPushButtonColor()
        self.shapeFaceColorButton.setToolTip('Fill color of extra object')
        self.shapeFaceColorButton.setAutoFillBackground(False)
        colorvalue = [int(i * 255.0) for i in self.style['shape__facecolor'][0:3]]
        self.shapeFaceColorButton.setMyColor(*colorvalue)
        self.shapeFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.shapeFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.shapeFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.shapeFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'shape__facecolor'))
        self.hLayout4.addWidget(self.shapeFaceColorButton)    
    
        self.comboShapeHatch = QComboBoxMac()
        self.comboShapeHatch.setToolTip('Hatch style of extra object')
        for entry in self.hatchStyles:
          self.comboShapeHatch.addItem(entry)
        if(self.style['shape__hatch'] in self.hatchStyles):
          currindex = self.hatchStyles.index(self.style['shape__hatch'])
        else:
          currindex = 0
        self.comboShapeHatch.setCurrentIndex(currindex)
        self.comboShapeHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__hatch', self.comboShapeHatch))
        self.comboShapeHatch.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.comboShapeHatch.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.hLayout4.addWidget(self.comboShapeHatch)
        self.comboShapeHatchMultiply = QComboBoxMac()
        self.comboShapeHatchMultiply.setToolTip('Hatch repeat of extra object')
        for entry in self.hatchMultiplystyles:
          self.comboShapeHatchMultiply.addItem(str(entry))
        if(str(self.style['shape__hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['shape__hatchMultiply']))
        else:
          currindex = 0
        self.comboShapeHatchMultiply.setCurrentIndex(currindex)
        self.comboShapeHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__hatchMultiply', self.comboShapeHatchMultiply))
        self.comboShapeHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.comboShapeHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.hLayout4.addWidget(self.comboShapeHatchMultiply)

        # shape angle
        self.configAngleGroup = QWidgetMac()
        self.vLayout.addWidget(self.configAngleGroup)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.configAngleGroup)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)    
        self.configAngleLabel = QtWidgets.QLabel('Angle')
        self.configAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.configAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.configAngleLabel)
        # angle spin box
        self.configAngleSpin = QDoubleSpinClick()
        self.hLayout5.addWidget(self.configAngleSpin)
        self.configAngleSpin.setMinimum(0.0)
        self.configAngleSpin.setMaximum(360.0)
        self.configAngleSpin.setValue(self.style['rotation'])
        self.configAngleSpin.setToolTip('Angle of extra object')
        self.configAngleSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.configAngleSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.configAngleSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'rotation', self.configAngleSpin))
        self.configAngleSpin.setWrapping(True)
        self.configAngleSpin.setSingleStep(10)
        self.configAngleSpin.setAdaptive(False)

        # freehand shape reduction
        if(self.style['shape__type'] == 'freehand'):
          self.configReductionGroup = QWidgetMac()
          self.vLayout.addWidget(self.configReductionGroup)
          self.hLayout6 = QtWidgets.QHBoxLayout(self.configReductionGroup)
          self.hLayout6.setContentsMargins(0, 0, 0, 0)
          self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)    
          self.configReductionLabel = QtWidgets.QLabel('Vertex')
          self.configReductionLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
          self.configReductionLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
          self.hLayout6.addWidget(self.configReductionLabel)

          self.configReductionButton = QPushButtonMac()
          self.configReductionButton.setText('Simplify')
          self.configReductionButton.setToolTip('Reduce number of vertices in extra object')
          self.configReductionButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
          self.configReductionButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
          self.configReductionButton.clicked.connect(partial(self.toggleFreehandReduce, self.targetIndex))
          self.hLayout6.addWidget(self.configReductionButton)
          
          self.configReductionCount = QtWidgets.QLabel('')
          self.configReductionCount.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
          self.configReductionCount.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
          self.hLayout6.addWidget(self.configReductionCount)

          if(('shape__vertices' in self.style) and len(self.style['shape__vertices'])):
            self.configReductionCount.setText(str(len(self.style['shape__vertices'])))
    else:
      # build gui for label formatting
      self.formatLabel = QWidgetMac()    
      self.vLayout = QtWidgets.QVBoxLayout(self.formatLabel)
      self.vLayout.setContentsMargins(0, 0, 0, 0)
      self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayout.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatLabel)
      
      # heading
      self.extrasStyleLabel = QtWidgets.QLabel()
      self.extrasStyleLabel.setText('Text')
      font = self.extrasStyleLabel.font()
      font.setBold(True)
      self.extrasStyleLabel.setFont(font)
      self.vLayout.addWidget(self.extrasStyleLabel)    
      
      # label position x
      self.labelXGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup)
      self.hLayout = QtWidgets.QHBoxLayout(self.labelXGroup)
      self.hLayout.setContentsMargins(0, 0, 0, 0)
      self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
      self.labelXLabel = QtWidgets.QLabel('x')
      self.labelXLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.labelXLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelXLabel)
  
      self.labelXEntry = QLineEditClick()
      self.labelXEntry.setToolTip('X coordinate of extra object')
      self.labelXEntry.setText(str(self.style['x']))
      self.labelXEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelXEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x', self.labelXEntry, None, None))
      self.labelXEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelXEntry)
  
      # label position y
      self.labelYGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup)
      self.labelYLabel = QtWidgets.QLabel('y')
      self.labelYLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.labelYLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelYLabel)
  
      self.labelYEntry = QLineEditClick()
      self.labelYEntry.setToolTip('Y coordinate of extra object')
      self.labelYEntry.setText(str(self.style['y']))
      self.labelYEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelYEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.labelYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y', self.labelYEntry, None, None))
      self.labelYEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelYEntry)
      
      # label text style
      self.configSizeGroup = QWidgetMac()
      self.vLayout.addWidget(self.configSizeGroup)
      self.hLayout1 = QtWidgets.QHBoxLayout(self.configSizeGroup)
      self.hLayout1.setContentsMargins(0, 0, 0, 0)
      self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
      self.configSizeLabel = QtWidgets.QLabel('Font')
      self.configSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.configSizeLabel)
  
      self.configColorLabelButton = QPushButtonColor()
      self.configColorLabelButton.setToolTip('Text color of extra object')
      self.configColorLabelButton.setAutoFillBackground(False)
      colorvalue = [int(i * 255.0) for i in self.style['color'][0:3]]
      self.configColorLabelButton.setMyColor(*colorvalue)
      self.configColorLabelButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configColorLabelButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configColorLabelButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.configColorLabelButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'color'))
      self.hLayout1.addWidget(self.configColorLabelButton)

      # font size spin box
      self.configLabelSizeSpin = QDoubleSpinClick()
      self.hLayout1.addWidget(self.configLabelSizeSpin)
      self.configLabelSizeSpin.setMinimum(0.0)
      self.configLabelSizeSpin.setMaximum(100.0)
      self.configLabelSizeSpin.setValue(self.style['fontsize'])
      self.configLabelSizeSpin.setToolTip('Text font size of extra object')
      self.configLabelSizeSpin.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configLabelSizeSpin.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configLabelSizeSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'fontsize', self.configLabelSizeSpin))
      
      self.configLabelBold = QPushButtonCheckable()
      self.configLabelBold.setToolTip('Text font weight of extra object')
      self.configLabelBold.setText('B')
      self.configLabelBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLabelBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      if(self.style['fontweight'] == 'bold'):
        self.configLabelBold.setChecked(True)
      useFont = self.configLabelBold.font()
      useFont.setWeight(75)
      self.configLabelBold.setFont(useFont)
      self.configLabelBold.clicked.connect(partial(self.changeLabelFontStyle, self.targetIndex, 'fontweight', self.configLabelBold))
      self.hLayout1.addWidget(self.configLabelBold)
      
      self.configLabelItalic = QPushButtonCheckable()
      self.configLabelItalic.setText('I')
      self.configLabelItalic.setToolTip('Text font style of extra object')
      self.configLabelItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLabelItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      if(self.style['fontstyle'] == 'italic'):
        self.configLabelItalic.setChecked(True)
      useFont = self.configLabelItalic.font()
      useFont.setItalic(True)
      self.configLabelItalic.setFont(useFont)
      self.configLabelItalic.clicked.connect(partial(self.changeLabelFontStyle, self.targetIndex, 'fontstyle', self.configLabelItalic))
      self.hLayout1.addWidget(self.configLabelItalic)
      
      self.configSizeGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.configSizeGroup2)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.configSizeGroup2)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QtWidgets.QLabel('')
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout2.addWidget(spacer)
  
      defaultFont = 'DejaVu Sans'
      self.configLabelFont = QComboBoxMac()
      self.configLabelFont.setToolTip('Text font of extra object')
      self.configLabelFont.addItems(self.parent.parent.fontNames)
      self.configLabelFont.setMaximumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
      self.configLabelFont.setMinimumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
      if(self.style['fontname'] in self.parent.parent.fontNames):
        currindex = self.parent.parent.fontNames.index(self.style['fontname'])
        self.configLabelFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.parent.fontNames):
        currindex = self.parent.parent.fontNames.index(defaultFont)
        self.configLabelFont.setCurrentIndex(currindex)
      else:
        self.configLabelFont.setCurrentIndex(0)
      self.configLabelFont.activated.connect(partial(self.changeLabelFont, self.targetIndex))
      self.hLayout2.addWidget(self.configLabelFont)
  
      # label angle
      self.configAngleGroup = QWidgetMac()
      self.vLayout.addWidget(self.configAngleGroup)
      self.hLayout3 = QtWidgets.QHBoxLayout(self.configAngleGroup)
      self.hLayout3.setContentsMargins(0, 0, 0, 0)
      self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)    
      self.configAngleLabel = QtWidgets.QLabel('Angle')
      self.configAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.configAngleLabel)
      # label angle spin box
      self.configAngleSpin = QDoubleSpinClick()
      self.hLayout3.addWidget(self.configAngleSpin)
      self.configAngleSpin.setMinimum(0.0)
      self.configAngleSpin.setMaximum(360.0)
      self.configAngleSpin.setValue(self.style['rotation'])
      self.configAngleSpin.setToolTip('Text angle of extra object')
      self.configAngleSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAngleSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAngleSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'rotation', self.configAngleSpin))
      self.configAngleSpin.setWrapping(True)
      self.configAngleSpin.setSingleStep(10)
      self.configAngleSpin.setAdaptive(False)
      
      # label alignment
      self.configAlignmentGroup = QWidgetMac()
      self.vLayout.addWidget(self.configAlignmentGroup)
      self.hLayout4 = QtWidgets.QHBoxLayout(self.configAlignmentGroup)
      self.hLayout4.setContentsMargins(0, 0, 0, 0)
      self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)    
      self.configAlignmentLabel = QtWidgets.QLabel('Align')
      self.configAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout4.addWidget(self.configAlignmentLabel)
  
      self.alignHorizontal = ['left', 'center', 'right']
      self.configAlignment = QComboBoxMac()
      self.configAlignment.setToolTip('Text horizontal alignment of extra object')
      self.configAlignment.addItems(self.alignHorizontal)
      if(self.style['horizontalalignment'] in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.style['horizontalalignment'])
        self.configAlignment.setCurrentIndex(currindex)
      else:
        self.configAlignment.setCurrentIndex(0)
      self.configAlignment.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAlignment.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAlignment.activated.connect(partial(self.changeLabelAlignment, self.targetIndex))
      self.hLayout4.addWidget(self.configAlignment)
      
      self.alignVertical = ['top', 'center', 'bottom', 'baseline']
      self.configAlignmentVertical = QComboBoxMac()
      self.configAlignmentVertical.setToolTip('Text vertical alignment of extra object')
      self.configAlignmentVertical.addItems(self.alignVertical)
      if(self.style['verticalalignment'] in self.alignVertical):
        currindex = self.alignVertical.index(self.style['verticalalignment'])
        self.configAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configAlignmentVertical.setCurrentIndex(0)
      self.configAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAlignmentVertical.activated.connect(partial(self.changeLabelAlignmentVertical, self.targetIndex))
      self.hLayout4.addWidget(self.configAlignmentVertical)
 
      # checkbox for display of bbox
      self.bboxShowGroup = QWidgetMac()
      self.vLayout.addWidget(self.bboxShowGroup)
      self.hLayout5 = QtWidgets.QHBoxLayout(self.bboxShowGroup)
      self.hLayout5.setContentsMargins(0, 0, 0, 0)
      self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)    
      self.bboxShowLabel = QPushButtonCheckable()
      self.bboxShowLabel.setText('Box?')
      self.bboxShowLabel.setToolTip('Show bounding box of extra object')
      self.bboxShowLabel.setChecked(self.style['bbox__show'])
      self.bboxShowLabel.clicked.connect(partial(self.toggleBbox, self.targetIndex))
      self.bboxShowLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.bboxShowLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout5.addWidget(self.bboxShowLabel)
  
      # bbox config menu
      self.divider = self.VLine()
      self.hLayout0.addWidget(self.divider)
      # build gui for label formatting
      self.formatBbox = QWidgetMac()    
      self.vLayoutA1 = QtWidgets.QVBoxLayout(self.formatBbox)
      self.vLayoutA1.setContentsMargins(0, 0, 0, 0)
      self.vLayoutA1.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayoutA1.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatBbox)
        
      # heading
      self.extrasBboxLabel = QtWidgets.QLabel()
      self.extrasBboxLabel.setText('Box')
      font = self.extrasBboxLabel.font()
      font.setBold(True)
      self.extrasBboxLabel.setFont(font)
      self.vLayoutA1.addWidget(self.extrasBboxLabel)
      
      # bbox line style
      self.bboxLineGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxLineGroup)
      self.hLayoutA2 = QtWidgets.QHBoxLayout(self.bboxLineGroup)
      self.hLayoutA2.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA2.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxLineLabel = QtWidgets.QLabel('Line')
      self.bboxLineLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxLineLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA2.addWidget(self.bboxLineLabel)

      # bbox edge width spin box
      self.bboxLineWidthSpin = QDoubleSpinClick()
      self.hLayoutA2.addWidget(self.bboxLineWidthSpin)
      self.bboxLineWidthSpin.setMinimum(0.0)
      self.bboxLineWidthSpin.setMaximum(100.0)
      self.bboxLineWidthSpin.setValue(self.style['line__linewidth'])
      self.bboxLineWidthSpin.setToolTip('Bounding box edge width of extra object')
      self.bboxLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'bbox__linewidth', self.bboxLineWidthSpin))
    
      self.comboBboxLineStyle = QComboBoxMac()
      self.comboBboxLineStyle.setToolTip('Bounding box line style of extra object')
      for entry in self.linestyles:
        self.comboBboxLineStyle.addItem(entry)
      if(self.style['bbox__linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style['bbox__linestyle'])
      else:
        currindex = 0
      self.comboBboxLineStyle.setCurrentIndex(currindex)
      self.comboBboxLineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__linestyle', self.comboBboxLineStyle))
      self.comboBboxLineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.comboBboxLineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.hLayoutA2.addWidget(self.comboBboxLineStyle)
      
      # cap style
      self.bboxLineGroup2 = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxLineGroup2)
      self.hLayoutA22 = QtWidgets.QHBoxLayout(self.bboxLineGroup2)
      self.hLayoutA22.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA22.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxLineLabel2 = QtWidgets.QLabel('')
      self.bboxLineLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxLineLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA22.addWidget(self.bboxLineLabel2)

      self.comboBboxDashStyle = QComboBoxMac()
      self.comboBboxDashStyle.setToolTip('Bounding box cap style of extra object')
      for entry in self.dashstyles:
        self.comboBboxDashStyle.addItem(entry)
      if(self.style['bbox__dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style['bbox__dash_capstyle'])
      else:
        currindex = 0
      self.comboBboxDashStyle.setCurrentIndex(currindex)
      self.comboBboxDashStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__dash_capstyle', self.comboBboxDashStyle))
      self.comboBboxDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.comboBboxDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayoutA22.addWidget(self.comboBboxDashStyle)      
  
      self.bboxLineColorButton = QPushButtonColor()
      self.bboxLineColorButton.setToolTip('Bounding box edge color of extra object')
      self.bboxLineColorButton.setAutoFillBackground(False)
      colorvalue = [int(i * 255.0) for i in self.style['bbox__edgecolor'][0:3]]
      self.bboxLineColorButton.setMyColor(*colorvalue)
      self.bboxLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.bboxLineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'bbox__edgecolor'))
      self.hLayoutA22.addWidget(self.bboxLineColorButton)

      # bbox colors
      self.bboxColorGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxColorGroup)
      self.hLayoutA3 = QtWidgets.QHBoxLayout(self.bboxColorGroup)
      self.hLayoutA3.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA3.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxColorLabel = QPushButtonCheckable()
      self.bboxColorLabel.setText('Fill')
      self.bboxColorLabel.setToolTip('Show bounding box fill of extra object')
      self.bboxColorLabel.setChecked(self.style['bbox__doFill'])
      self.bboxColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'bbox__doFill', self.bboxColorLabel))
      self.hLayoutA3.addWidget(self.bboxColorLabel)
  
      self.bboxFaceColorButton = QPushButtonColor()
      self.bboxFaceColorButton.setToolTip('Bounding ox fill color of extra object')
      self.bboxFaceColorButton.setAutoFillBackground(False)
      colorvalue = [int(i * 255.0) for i in self.style['bbox__facecolor'][0:3]]
      self.bboxFaceColorButton.setMyColor(*colorvalue)
      self.bboxFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.bboxFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'bbox__facecolor'))
      self.hLayoutA3.addWidget(self.bboxFaceColorButton)    
  
      self.comboBboxHatch = QComboBoxMac()
      self.comboBboxHatch.setToolTip('Bounding box hatch style of extra object')
      for entry in self.hatchStyles:
        self.comboBboxHatch.addItem(entry)
      if(self.style['bbox__hatch'] in self.hatchStyles):
        currindex = self.hatchStyles.index(self.style['bbox__hatch'])
      else:
        currindex = 0
      self.comboBboxHatch.setCurrentIndex(currindex)
      self.comboBboxHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__hatch', self.comboBboxHatch))
      self.comboBboxHatch.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.comboBboxHatch.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.hLayoutA3.addWidget(self.comboBboxHatch)
      self.comboBboxHatchMultiply = QComboBoxMac()
      self.comboBboxHatchMultiply.setToolTip('Bounding box hatch repeat of extra object')
      for entry in self.hatchMultiplystyles:
        self.comboBboxHatchMultiply.addItem(str(entry))
      if(str(self.style['bbox__hatchMultiply']) in self.hatchMultiplystyles):
        currindex = self.hatchMultiplystyles.index(str(self.style['bbox__hatchMultiply']))
      else:
        currindex = 0
      self.comboBboxHatchMultiply.setCurrentIndex(currindex)
      self.comboBboxHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__hatchMultiply', self.comboBboxHatchMultiply))
      self.comboBboxHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.comboBboxHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.hLayoutA3.addWidget(self.comboBboxHatchMultiply)
      
      # bbox boxstyle
      self.bboxBoxStyleGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxBoxStyleGroup)
      self.hLayoutA4 = QtWidgets.QHBoxLayout(self.bboxBoxStyleGroup)
      self.hLayoutA4.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA4.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxBoxStyleLabel = QtWidgets.QLabel('Style')
      self.bboxBoxStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxBoxStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA4.addWidget(self.bboxBoxStyleLabel)
  
      self.boxStyles = list(matplotlib.patches.BoxStyle.get_styles().keys())
      self.comboBboxBoxStyle = QComboBoxMac()
      self.comboBboxBoxStyle.setToolTip('Bounding box style of extra object')
      for entry in self.boxStyles:
        self.comboBboxBoxStyle.addItem(entry)
      if(self.style['bbox__boxstyle'] in self.boxStyles):
        currindex = self.boxStyles.index(self.style['bbox__boxstyle'])
      else:
        currindex = 0
      self.comboBboxBoxStyle.setCurrentIndex(currindex)
      self.comboBboxBoxStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__boxstyle', self.comboBboxBoxStyle))
      self.comboBboxBoxStyle.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.comboBboxBoxStyle.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.hLayoutA4.addWidget(self.comboBboxBoxStyle)
      
      # bbox pad
      self.bboxPadGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxPadGroup)
      self.hLayoutA5 = QtWidgets.QHBoxLayout(self.bboxPadGroup)
      self.hLayoutA5.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA5.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxPadLabel = QtWidgets.QLabel('Pad')
      self.bboxPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA5.addWidget(self.bboxPadLabel)
  
      self.bboxPadEntry = QLineEditClick()
      self.bboxPadEntry.setToolTip('Bounding box padding of extra object')
      self.bboxPadEntry.setText(str(self.style['bbox__pad']))
      self.bboxPadEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxPadEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxPadEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__pad', self.bboxPadEntry, 0.0, 100.0))
      self.bboxPadEntry.setValidator(self.validFloat)
      self.hLayoutA5.addWidget(self.bboxPadEntry)
  
      # bbox tooth and round
      self.bboxMiscGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxMiscGroup)
      self.hLayoutA6 = QtWidgets.QHBoxLayout(self.bboxMiscGroup)
      self.hLayoutA6.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA6.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxToothLabel = QtWidgets.QLabel('Tooth')
      self.bboxToothLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxToothLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA6.addWidget(self.bboxToothLabel)
      self.bboxToothEntry = QLineEditClick()
      self.bboxToothEntry.setToolTip('Bounding box tooth size of extra object')
      self.bboxToothEntry.setText(str(self.style['bbox__tooth_size']))
      self.bboxToothEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxToothEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxToothEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__tooth_size', self.bboxToothEntry, 0.0, 100.0))
      self.bboxToothEntry.setValidator(self.validFloat)
      self.hLayoutA6.addWidget(self.bboxToothEntry)
  
      self.bboxRoundingLabel = QtWidgets.QLabel('Round')
      self.bboxRoundingLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxRoundingLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA6.addWidget(self.bboxRoundingLabel)
      self.bboxRoundingEntry = QLineEditClick()
      self.bboxRoundingEntry.setToolTip('Bounding box roundedness of extra object')
      self.bboxRoundingEntry.setText(str(self.style['bbox__rounding_size']))
      self.bboxRoundingEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxRoundingEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.bboxRoundingEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__rounding_size', self.bboxRoundingEntry, 0.0, 100.0))
      self.bboxRoundingEntry.setValidator(self.validFloat)
      self.hLayoutA6.addWidget(self.bboxRoundingEntry)
  
      # annotation arrow menu
      if(self.extrasType == 'annotation'):
        blah = self.VLine()
        self.hLayout0.addWidget(blah)
        # build gui for label formatting
        self.formatArrow = QWidgetMac()    
        self.vLayoutB1 = QtWidgets.QVBoxLayout(self.formatArrow)
        self.vLayoutB1.setContentsMargins(0, 0, 0, 0)
        self.vLayoutB1.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.vLayoutB1.setSpacing(scaledDPI(2))
        self.hLayout0.addWidget(self.formatArrow)
        
        # heading
        self.extrasArrowLabel = QtWidgets.QLabel()
        self.extrasArrowLabel.setText('Arrow')
        font = self.extrasArrowLabel.font()
        font.setBold(True)
        self.extrasArrowLabel.setFont(font)
        self.vLayoutB1.addWidget(self.extrasArrowLabel)    
  
        # arrow tip position x
        self.arrowXGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowXGroup)
        self.hLayoutB1 = QtWidgets.QHBoxLayout(self.arrowXGroup)
        self.hLayoutB1.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB1.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowXLabel = QtWidgets.QLabel('x')
        self.arrowXLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowXLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB1.addWidget(self.arrowXLabel)
        
        self.arrowXEntry = QLineEditClick()
        self.arrowXEntry.setToolTip('Arrow x coordinate of extra object')
        self.arrowXEntry.setText(str(self.style['arrow__x']))
        self.arrowXEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowXEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__x', self.arrowXEntry, None, None))
        self.arrowXEntry.setValidator(self.validFloat)
        self.hLayoutB1.addWidget(self.arrowXEntry)
    
        # label position y
        self.arrowYGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowYGroup)
        self.arrowYLabel = QtWidgets.QLabel('y')
        self.arrowYLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowYLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB1.addWidget(self.arrowYLabel)
    
        self.arrowYEntry = QLineEditClick()
        self.arrowYEntry.setToolTip('Arrow y coordinate of extra object')
        self.arrowYEntry.setText(str(self.style['arrow__y']))
        self.arrowYEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowYEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__y', self.arrowYEntry, None, None))
        self.arrowYEntry.setValidator(self.validFloat)
        self.hLayoutB1.addWidget(self.arrowYEntry)
      
        # arrow line style
        self.arrowLineGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowLineGroup)
        self.hLayoutB2 = QtWidgets.QHBoxLayout(self.arrowLineGroup)
        self.hLayoutB2.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB2.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowLineLabel = QtWidgets.QLabel('Line')
        self.arrowLineLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowLineLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB2.addWidget(self.arrowLineLabel)

        # arrow edge width spin box
        self.arrowLineWidthSpin = QDoubleSpinClick()
        self.hLayoutB2.addWidget(self.arrowLineWidthSpin)
        self.arrowLineWidthSpin.setMinimum(0.0)
        self.arrowLineWidthSpin.setMaximum(100.0)
        self.arrowLineWidthSpin.setValue(self.style['arrow__linewidth'])
        self.arrowLineWidthSpin.setToolTip('Arrow edge width of extra object')
        self.arrowLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.targetIndex, 'arrow__linewidth', self.arrowLineWidthSpin))
    
        self.comboArrowLineStyle = QComboBoxMac()
        self.comboArrowLineStyle.setToolTip('Arrow line style of extra object')
        for entry in self.linestyles:
          self.comboArrowLineStyle.addItem(entry)
        if(self.style['arrow__linestyle'] in self.linestyles):
          currindex = self.linestyles.index(self.style['arrow__linestyle'])
        else:
          currindex = 0
        self.comboArrowLineStyle.setCurrentIndex(currindex)
        self.comboArrowLineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__linestyle', self.comboArrowLineStyle))
        self.comboArrowLineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboArrowLineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB2.addWidget(self.comboArrowLineStyle)

        self.arrowLineColorButton = QPushButtonColor()
        self.arrowLineColorButton.setToolTip('Arrow edge color of extra object')
        self.arrowLineColorButton.setAutoFillBackground(False)
        colorvalue = [int(i * 255.0) for i in self.style['arrow__edgecolor'][0:3]]
        self.arrowLineColorButton.setMyColor(*colorvalue)
        self.arrowLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.arrowLineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'arrow__edgecolor'))
        self.hLayoutB2.addWidget(self.arrowLineColorButton)
    
        # arrow colors
        self.arrowColorGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowColorGroup)
        self.hLayoutB3 = QtWidgets.QHBoxLayout(self.arrowColorGroup)
        self.hLayoutB3.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB3.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowColorLabel = QPushButtonCheckable()
        self.arrowColorLabel.setText('Fill')
        self.arrowColorLabel.setToolTip('Show arrow fill of extra object')
        self.arrowColorLabel.setChecked(self.style['arrow__doFill'])
        self.arrowColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'arrow__doFill', self.arrowColorLabel))
        self.hLayoutB3.addWidget(self.arrowColorLabel)

        self.arrowFaceColorButton = QPushButtonColor()
        self.arrowFaceColorButton.setToolTip('Arrow fill color of extra object')
        self.arrowFaceColorButton.setAutoFillBackground(False)
        colorvalue = [int(i * 255.0) for i in self.style['arrow__facecolor'][0:3]]
        self.arrowFaceColorButton.setMyColor(*colorvalue)
        self.arrowFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.arrowFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'arrow__facecolor'))
        self.hLayoutB3.addWidget(self.arrowFaceColorButton)
        
        self.hatchStyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
        self.comboArrowHatch = QComboBoxMac()
        self.comboArrowHatch.setToolTip('Arrow hatch style of extra object')
        for entry in self.hatchStyles:
          self.comboArrowHatch.addItem(entry)
        if(self.style['arrow__hatch'] in self.hatchStyles):
          currindex = self.hatchStyles.index(self.style['arrow__hatch'])
        else:
          currindex = 0
        self.comboArrowHatch.setCurrentIndex(currindex)
        self.comboArrowHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__hatch', self.comboArrowHatch))
        self.comboArrowHatch.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.comboArrowHatch.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.hLayoutB3.addWidget(self.comboArrowHatch)
        self.comboArrowHatchMultiply = QComboBoxMac()
        self.comboArrowHatchMultiply.setToolTip('Arrow hatch repeat of extra object')
        for entry in self.hatchMultiplystyles:
          self.comboArrowHatchMultiply.addItem(str(entry))
        if(str(self.style['arrow__hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['arrow__hatchMultiply']))
        else:
          currindex = 0
        self.comboArrowHatchMultiply.setCurrentIndex(currindex)
        self.comboArrowHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__hatchMultiply', self.comboArrowHatchMultiply))
        self.comboArrowHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.comboArrowHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
        self.hLayoutB3.addWidget(self.comboArrowHatchMultiply)
      
        # arrow style
        self.arrowStyleGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowStyleGroup)
        self.hLayoutB5 = QtWidgets.QHBoxLayout(self.arrowStyleGroup)
        self.hLayoutB5.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB5.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowStyleLabel = QtWidgets.QLabel('Style')
        self.arrowStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB5.addWidget(self.arrowStyleLabel)
  
        self.arrowStyles = list(matplotlib.patches.ArrowStyle.get_styles().keys())
        self.asymmetricArrowStyles = [i for i in self.arrowStyles if i in [']-[', '-[', ']-', '|-|', 'simple', 'fancy', 'wedge']]
        self.comboArrowStyle = QComboBoxMac()
        self.comboArrowStyle.setToolTip('Arrow style of extra object')
        for entry in self.arrowStyles:
          self.comboArrowStyle.addItem(entry)
        if(self.style['arrow__arrowstyle'] in self.arrowStyles):
          currindex = self.arrowStyles.index(self.style['arrow__arrowstyle'])
        else:
          currindex = 0
        self.comboArrowStyle.setCurrentIndex(currindex)
        self.comboArrowStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__arrowstyle', self.comboArrowStyle))
        self.comboArrowStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboArrowStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB5.addWidget(self.comboArrowStyle)
        
        # connection style
        self.arrowConnectGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowConnectGroup)
        self.hLayoutB6 = QtWidgets.QHBoxLayout(self.arrowConnectGroup)
        self.hLayoutB6.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB6.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowConnectLabel = QtWidgets.QLabel('Connect')
        self.arrowConnectLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowConnectLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB6.addWidget(self.arrowConnectLabel)
  
        self.connectStyles = list(matplotlib.patches.ConnectionStyle.get_styles().keys())
        if(('arc' in self.connectStyles) and ('arc3' in self.connectStyles)):
          self.connectStyles.remove('arc')
        if(('angle' in self.connectStyles) and ('angle3' in self.connectStyles)):
          self.connectStyles.remove('angle')
        self.comboConnectStyle = QComboBoxMac()
        self.comboConnectStyle.setToolTip('Arrow connector style of extra object')
        for entry in self.connectStyles:
          self.comboConnectStyle.addItem(entry)
        if(self.style['arrow__connector'] in self.connectStyles):
          currindex = self.connectStyles.index(self.style['arrow__connector'])
        else:
          currindex = 0
        self.comboConnectStyle.setCurrentIndex(currindex)
        self.comboConnectStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__connector', self.comboConnectStyle))
        self.comboConnectStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboConnectStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB6.addWidget(self.comboConnectStyle)
  
        # arrow shrink
        self.arrowShrinkGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowShrinkGroup)
        self.hLayoutB4 = QtWidgets.QHBoxLayout(self.arrowShrinkGroup)
        self.hLayoutB4.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB4.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowShrinkALabel = QtWidgets.QLabel('ShrinkA')
        self.arrowShrinkALabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowShrinkALabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB4.addWidget(self.arrowShrinkALabel)
  
        self.arrowShrinkAEntry = QLineEditClick()
        self.arrowShrinkAEntry.setToolTip('Arrow shrink factor A of extra object')
        self.arrowShrinkAEntry.setText(str(self.style['arrow__shrinkA']))
        self.arrowShrinkAEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowShrinkAEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowShrinkAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__shrinkA', self.arrowShrinkAEntry, 0.0, 1000.0))
        self.arrowShrinkAEntry.setValidator(self.validFloat)
        self.hLayoutB4.addWidget(self.arrowShrinkAEntry)
        
        self.arrowShrinkBLabel = QtWidgets.QLabel('ShrinkB')
        self.arrowShrinkBLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB4.addWidget(self.arrowShrinkBLabel)
  
        self.arrowShrinkBEntry = QLineEditClick()
        self.arrowShrinkBEntry.setToolTip('Arrow shrink factor B of extra object')
        self.arrowShrinkBEntry.setText(str(self.style['arrow__shrinkB']))
        self.arrowShrinkBEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__shrinkB', self.arrowShrinkBEntry, 0.0, 1000.0))
        self.arrowShrinkBEntry.setValidator(self.validFloat)
        self.hLayoutB4.addWidget(self.arrowShrinkBEntry)
        
        # arrow configuration encore
        self.arrowParamGroup1 = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowParamGroup1)
        self.hLayoutB7 = QtWidgets.QHBoxLayout(self.arrowParamGroup1)
        self.hLayoutB7.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB7.setAlignment(QtCore.Qt.AlignLeft)
  
        self.arrowLengthALabel = QtWidgets.QLabel('LengthA')
        self.arrowLengthALabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowLengthALabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB7.addWidget(self.arrowLengthALabel)
        self.arrowLengthAEntry = QLineEditClick()
        self.arrowLengthAEntry.setToolTip('Arrow length A of extra object')
        self.arrowLengthAEntry.setText(str(self.style['arrow__lengthA']))
        self.arrowLengthAEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLengthAEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLengthAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__lengthA', self.arrowLengthAEntry, 0.0, 500.0))
        self.arrowLengthAEntry.setValidator(self.validFloat)
        self.hLayoutB7.addWidget(self.arrowLengthAEntry)
  
        self.arrowLengthBLabel = QtWidgets.QLabel('LengthB')
        self.arrowLengthBLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowLengthBLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB7.addWidget(self.arrowLengthBLabel)
        self.arrowLengthBEntry = QLineEditClick()
        self.arrowLengthBEntry.setToolTip('Arrow length B of extra object')
        self.arrowLengthBEntry.setText(str(self.style['arrow__lengthB']))
        self.arrowLengthBEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLengthBEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowLengthBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__lengthB', self.arrowLengthBEntry, 0.0, 500.0))
        self.arrowLengthBEntry.setValidator(self.validFloat)
        self.hLayoutB7.addWidget(self.arrowLengthBEntry)
  
        self.arrowParamGroup2 = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowParamGroup2)
        self.hLayoutB8 = QtWidgets.QHBoxLayout(self.arrowParamGroup2)
        self.hLayoutB8.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB8.setAlignment(QtCore.Qt.AlignLeft)
  
        self.arrowWidthALabel = QtWidgets.QLabel('WidthA')
        self.arrowWidthALabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowWidthALabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB8.addWidget(self.arrowWidthALabel)
        self.arrowWidthAEntry = QLineEditClick()
        self.arrowWidthAEntry.setToolTip('Arrow width A of extra object')
        self.arrowWidthAEntry.setText(str(self.style['arrow__widthA']))
        self.arrowWidthAEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowWidthAEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowWidthAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__widthA', self.arrowWidthAEntry, 0.0, 500.0))
        self.arrowWidthAEntry.setValidator(self.validFloat)
        self.hLayoutB8.addWidget(self.arrowWidthAEntry)
  
        self.arrowWidthBLabel = QtWidgets.QLabel('WidthB')
        self.arrowWidthBLabel.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.arrowWidthBLabel.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
        self.hLayoutB8.addWidget(self.arrowWidthBLabel)
        self.arrowWidthBEntry = QLineEditClick()
        self.arrowWidthBEntry.setToolTip('Arrow width B of extra object')
        self.arrowWidthBEntry.setText(str(self.style['arrow__widthB']))
        self.arrowWidthBEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowWidthBEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.arrowWidthBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__widthB', self.arrowWidthBEntry, 0.0, 500.0))
        self.arrowWidthBEntry.setValidator(self.validFloat)
        self.hLayoutB8.addWidget(self.arrowWidthBEntry)
        
        # update arrow selection boxes
        self.toggleArrowStyles()
        
      # finally update display of bbox config
      self.toggleBbox(self.targetIndex)
    
    self.setFocus()
    self.focusNextChild()

  def toggleArrowStyles(self):
    # (de)activates config dialogues as required based on current arrow style
    if(self.style['arrow__arrowstyle'] in self.asymmetricArrowStyles):
      state = True
    else:
      state = False
      
    items = [self.arrowLengthAEntry, self.arrowWidthAEntry]
    for item in items:
      item.setEnabled(state)

  def toggleBbox(self, targetIndex=None):
    # toggles display of bbox
    if(targetIndex != None):
      state = self.bboxShowLabel.isChecked()
      self.style['bbox__show'] = state
      self.parent.parent.extras[targetIndex].setStyle('bbox__show', state, redraw=True)
      # toggle display of bbox config menu
      if(state):
        self.formatBbox.show()
        self.divider.show()
      else:
        self.formatBbox.hide()
        self.divider.hide()
      self.upperRow.adjustSize()
      self.adjustSize()

  def changeLabelAlignment(self, targetIndex=None):
    if(targetIndex != None):
      useAlignment = str(self.configAlignment.currentText())
      self.parent.parent.extras[targetIndex].setStyle('horizontalalignment', useAlignment, redraw=True)
    
  def changeLabelAlignmentVertical(self, targetIndex=None):
    if(targetIndex != None):
      useAlignment = str(self.configAlignmentVertical.currentText())
      self.parent.parent.extras[targetIndex].setStyle('verticalalignment', useAlignment, redraw=True)
    
  def changeLabelFont(self, targetIndex=None):
    if(targetIndex != None):
      useFont = str(self.configLabelFont.currentText())
      self.parent.parent.extras[targetIndex].setStyle('fontname', useFont, redraw=True)
    
  def changeLabelFontStyle(self, targetIndex=None, key=None, entryfield=None):
    if((targetIndex != None) and (key in ['fontweight', 'fontstyle']) and (entryfield != None)):
      value = 'normal'
      isChecked = entryfield.isChecked()
      if(key == 'fontweight'):
        if(isChecked):
          value = 'bold'
      else:
        if(isChecked):
          value = 'italic'
      self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeLabelColor(self, targetIndex=None, key=None):
    # colors the text element
    if((targetIndex != None) and (key in self.style)):
      # prevent QMenu from vanishing
      self.togglePersist(True)
      # get current color
      prevColor = [255 * i for i in self.style[key]]
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(key == 'color'):
          self.configColorLabelButton.setMyColor(*value)
        elif(key == 'arrow__facecolor'):
          self.arrowFaceColorButton.setMyColor(*value)
        elif(key == 'arrow__edgecolor'):
          self.arrowLineColorButton.setMyColor(*value)
        elif(key == 'bbox__facecolor'):
          self.bboxFaceColorButton.setMyColor(*value)
        elif(key == 'bbox__edgecolor'):
          self.bboxLineColorButton.setMyColor(*value)
        elif(key == 'shape__facecolor'):
          self.shapeFaceColorButton.setMyColor(*value)
        elif(key == 'line__color'):
          self.lineColorButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

      # bring back the QMenu
      self.togglePersist(False)

  def alterStyle(self, targetIndex=None, key=None, entryfield=None):
    if((targetIndex != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if(key in self.style):
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeStyle(self, targetIndex=None, key=None, entryfield=None, minval=0, maxval=1):
    if((targetIndex != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      if(maxval != None):
        value = np.min((value, maxval))
      if(minval != None):
        value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeSpokeNumber(self, targetIndex=None, key=None, entryfield=None):
    if((targetIndex != None) and (key != None)):
      # get current value
      value = entryfield.value()
      if(key in self.style):
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeLineStyle(self, targetIndex=None, key=None, entryfield=None, minval=0, maxval=1):
    if((targetIndex != None) and (key != None)):
      # check paramter boundaries
      value = str(entryfield.currentText())
      if(key in self.style):
        if('__hatchMultiply' in key):
          value = int(value)
        self.style[key] = value
        if(key == 'line__dash_capstyle'):
          self.parent.parent.extras[targetIndex].setStyle('line__solid_capstyle', value, redraw=False)
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)
        
      # update config menu?
      if(key == 'shape__type'):
        if(self.style['shape__type'] in ['poly', 'star']):
          self.spokeNumberSpinBox.show()
        else:
          self.spokeNumberSpinBox.hide()
        #
        if(self.style['shape__type'] == 'star'):
          self.spikySpokeGroup.show()
        else:
          self.spikySpokeGroup.hide()
        #
        if(self.style['shape__type'] == 'torus'):
          self.innerRadiusGroup.show()
        else:
          self.innerRadiusGroup.hide()
        self.formatLine.adjustSize()
        self.adjustSize()

      # update arrow selection boxes
      if(key == 'arrow__arrowstyle'):
        self.toggleArrowStyles()
        
  def alterZ(self, index, direction):
    field = None
    if(hasattr(self.parent.parent.objectsarea, 'extrasTable')):
      field = self.parent.parent.objectsarea.extrasTable.cellWidget(index, 1)
    if(field != None):
      value, minimum, maximum = field.value(), field.minimum(), field.maximum()
      newValue = value + direction
      newValue = max(minimum, newValue)
      newValue = min(maximum, newValue)
      # set new value
      if(newValue != value):
        field.setValue(newValue)
      # (in)activate control buttons
      if(newValue == minimum):
        self.zDownButton.setEnabled(False)
      else:
        self.zDownButton.setEnabled(True)
      if(newValue == maximum):
        self.zUpButton.setEnabled(False)
      else:
        self.zUpButton.setEnabled(True)

  def setField(self, index):
    text = self.entryField.text()
    if(hasattr(self.parent.parent.objectsarea, 'extrasTable')):
      field = self.parent.parent.objectsarea.extrasTable.cellWidget(index, 2)
      field.setText(text)
      field.editingFinished.emit()

  def toggleFreehandClose(self, targetIndex=None):
    # toggles whether freehand shape is closed
    if(targetIndex != None):
      value = self.closeFreehandButton.isChecked()
      key = 'shape__closed'
      self.style[key] = value
      self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def toggleFreehandReduce(self, targetIndex=None):
    # activates reduction of vertex no. in freehand object
    if(targetIndex != None):
      self.parent.parent.extras[targetIndex].simplifyMe(redraw=True)
      self.configReductionCount.setText(str(len(self.parent.parent.extras[targetIndex].shape__vertices)))
      
  def toggleShapeFill(self, targetIndex=None, key=None, entryfield=None):
    # toggles whether shape elements are filled or not
    if((targetIndex != None) and (key != None)):
      value = entryfield.isChecked()
      self.style[key] = value
      self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class violinBoxMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(violinBoxMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    
    # set up mode
    getStyle = self.target.getViolinStyle()
    if('mode' in getStyle):
      self.mode = getStyle['mode']
    else:
      self.mode = 0

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    self.topContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.topContainer)
    self.hLayout = QtWidgets.QHBoxLayout(self.topContainer)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.hLayout.setSpacing(scaledDPI(2))
    
    # the main violin/box plot selector
    self.violinSelectorGroupBox = QtWidgets.QGroupBox()
    self.violinSelectorGroupBox.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.violinSelectorGroupBox.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.hLayout.addWidget(self.violinSelectorGroupBox)
    self.violinSelectorLayout = QtWidgets.QHBoxLayout(self.violinSelectorGroupBox)
    self.violinSelectorLayout.setContentsMargins(scaledDPI(1), 0, 0, 0)

    self.violinSelectorGroup = QtWidgets.QButtonGroup()
    self.violinSelectorButtons = []
    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 0)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 0))
    self.violinSelectorButtons[-1].setText('none')  

    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 1)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 1))
    self.violinSelectorButtons[-1].setText('violin')
    
    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 2)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 2))
    self.violinSelectorButtons[-1].setText('box')
    
    for entry in self.violinSelectorButtons:
      self.violinSelectorLayout.addWidget(entry)
      self.violinSelectorGroup.addButton(entry)
    self.hLayout.addStretch()
     
    # put the menus
    self.violinContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.violinContainer)
    self.vLayout1 = QtWidgets.QVBoxLayout(self.violinContainer)
    self.vLayout1.setContentsMargins(0, 0, 0, 0)
    self.vLayout1.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout1.setSpacing(scaledDPI(0))
    self.violinStyleMenu = violinStyleMenu(self.parent, self.target)
    self.vLayout1.addWidget(self.violinStyleMenu)
    
    self.boxContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.boxContainer)
    self.vLayout2 = QtWidgets.QVBoxLayout(self.boxContainer)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(0))
    self.boxStyleMenu = boxStyleMenu(self.parent, self.target)
    self.vLayout2.addWidget(self.boxStyleMenu)
    
    # initialize menus
    self.setMenuDisplay()
    
  def setMenuDisplay(self):
    # sets display of menus
    if(self.mode == 1):
      self.violinContainer.show()
    else:
      self.violinContainer.hide()
    if(self.mode == 2):
      self.boxContainer.show()
    else:
      self.boxContainer.hide()
      
    # resize to contents
    self.adjustSize()
    self.parent.violinRow.adjustSize()
    self.parent.adjustSize()

  def toggleViolin(self, mode=0):
    # toggles on/off violin plot
    # only trigger event for button that was turned on
    if(self.violinSelectorButtons[mode].isChecked()):
      self.mode = mode
      self.setMenuDisplay()
        
      if(self.target != None):
        self.target.toggleViolin(mode, redraw=True)

class violinStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(violinStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target

    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      getStyle = self.target.getViolinStyle()

      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        if(type(getStyle[entry]) == type({})):
          # have to deepcopy inner dicts to prevent inadvertent overwriting of values
          self.style[entry] = deepcopy(getStyle[entry])
        else:
          self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {}
    defaultStyle['mode'] = 0
    defaultStyle['bodies'] = {'facecolor': [0.8, 0.8, 0.9, 1.0], 'edgecolor': [0.2, 0.2, 0.2, 1.0], 'linestyle': 'solid', 'linewidth': 1.0,\
                'capstyle': 'butt', 'hatch': '', 'hatchMultiply': 1, 'visible': True, 'width': 0.5, 'doFill': True}
    defaultStyle['cmaxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'capstyle': 'butt', 'visible': True}
    for slaved in ['cbars', 'cmeans']:
      defaultStyle[slaved] = {}
      defaultStyle[slaved].update(defaultStyle['cmaxes'])
    defaultStyle['cmedians'] = {'visible': False}
    defaultStyle['cmins'] = {'visible': True}
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout = QtWidgets.QHBoxLayout(self)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.hLayout.setSpacing(scaledDPI(2))
    
    # bodies
    self.bodiesContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.bodiesContainer)
    self.vLayout = QtWidgets.QVBoxLayout(self.bodiesContainer)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
      
    self.displayBodiesGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayBodiesGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayBodiesGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesStyleLabel = QtWidgets.QLabel()
    self.bodiesStyleLabel.setText('Bodies')
    font = self.bodiesStyleLabel.font()
    font.setBold(True)
    self.bodiesStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesStyleLabel.setFont(font)
    self.hLayout0.addWidget(self.bodiesStyleLabel)    
    
    # display bodies?
    self.displayBodiesLabel = QPushButtonCheckable()
    self.displayBodiesLabel.setText('Show?')
    self.displayBodiesLabel.setToolTip('Show violin bodies of object')
    self.displayBodiesLabel.setChecked(self.style['bodies']['visible'])
    self.displayBodiesLabel.clicked.connect(partial(self.setDisplay, self.target, 'bodies', self.displayBodiesLabel))
    self.displayBodiesLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayBodiesLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayBodiesLabel)

    # line width
    self.bodiesLineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineWidthGroup)
    self.hLayout1 = QtWidgets.QHBoxLayout(self.bodiesLineWidthGroup)
    self.hLayout1.setContentsMargins(0, 0, 0, 0)
    self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineWidthLabel = QtWidgets.QLabel('Width')
    self.bodiesLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.bodiesLineWidthLabel)
    # line width spin box
    self.bodiesLineWidthSpin = QDoubleSpinClick()
    self.hLayout1.addWidget(self.bodiesLineWidthSpin)
    self.bodiesLineWidthSpin.setMinimum(0.0)
    self.bodiesLineWidthSpin.setMaximum(100.0)
    self.bodiesLineWidthSpin.setValue(self.style['bodies']['linewidth'])
    self.bodiesLineWidthSpin.setToolTip('Violin bodies line width of object')
    self.bodiesLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'bodies', 'linewidth', self.bodiesLineWidthSpin))
    
    # line color
    self.bodiesLineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.bodiesLineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineColorLabel = QtWidgets.QLabel('Color')
    self.bodiesLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.bodiesLineColorLabel)
      
    self.bodiesLineColorButton = QPushButtonColor()
    self.bodiesLineColorButton.setToolTip('Violin bodies line color of object')
    self.bodiesLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['bodies']['edgecolor'][0:3]]
    self.bodiesLineColorButton.setMyColor(*colorvalue)
    self.bodiesLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.bodiesLineColorButton.clicked.connect(partial(self.setColor, self.target, 'bodies', 'edgecolor'))
    self.hLayout2.addWidget(self.bodiesLineColorButton)
      
    # line style
    self.bodiesLineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.bodiesLineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineStyleLabel = QtWidgets.QLabel('Style')
    self.bodiesLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.bodiesLineStyleLabel)
    self.bodiesComboStyle = QComboBoxMac()
    self.bodiesComboStyle.setToolTip('Violin bodies line style of object')
    for entry in self.linestyles:
      self.bodiesComboStyle.addItem(entry)
    if(self.style['bodies']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['bodies']['linestyle'])
    else:
      currindex = 0
    self.bodiesComboStyle.setCurrentIndex(currindex)
    self.bodiesComboStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'linestyle', self.bodiesComboStyle))
    self.bodiesComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.bodiesComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.bodiesComboStyle)

    # cap style
    self.bodiesLineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.bodiesLineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.bodiesLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.bodiesLineDashStyleLabel)
    self.bodiesComboDashStyle = QComboBoxMac()
    self.bodiesComboDashStyle.setToolTip('Violin bodies cap style of object')
    for entry in self.dashstyles:
      self.bodiesComboDashStyle.addItem(entry)
    if(self.style['bodies']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['bodies']['capstyle'])
    else:
      currindex = 0
    self.bodiesComboDashStyle.setCurrentIndex(currindex)
    self.bodiesComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'capstyle', self.bodiesComboDashStyle))
    self.bodiesComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.bodiesComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.bodiesComboDashStyle)

    # fill color
    self.bodiesFillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesFillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.bodiesFillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesFillColorLabel = QPushButtonCheckable()
    self.bodiesFillColorLabel.setText('Fill')
    self.bodiesFillColorLabel.setToolTip('Show violin bodies fill of object')
    self.bodiesFillColorLabel.setChecked(self.style['bodies']['doFill'])
    self.bodiesFillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesFillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesFillColorLabel.clicked.connect(partial(self.toggleBodyFill, self.target, self.bodiesFillColorLabel))
    self.hLayout5.addWidget(self.bodiesFillColorLabel)
      
    self.bodiesFillColorButton = QPushButtonColor()
    self.bodiesFillColorButton.setToolTip('Violin bodies fill color of object')
    self.bodiesFillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['bodies']['facecolor'][0:3]]
    self.bodiesFillColorButton.setMyColor(*colorvalue)
    self.bodiesFillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesFillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesFillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.bodiesFillColorButton.clicked.connect(partial(self.setColor, self.target, 'bodies', 'facecolor'))
    self.hLayout5.addWidget(self.bodiesFillColorButton)
      
    # hatch style
    self.bodiesHatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesHatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.bodiesHatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesHatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.bodiesHatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesHatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesHatchStyleLabel)
    self.bodiesComboHatchStyle = QComboBoxMac()
    self.bodiesComboHatchStyle.setToolTip('Violin bodies hatch style of object')
    for entry in self.hatchstyles:
      self.bodiesComboHatchStyle.addItem(entry)
    if(self.style['bodies']['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['bodies']['hatch'])
    else:
      currindex = 0
    self.bodiesComboHatchStyle.setCurrentIndex(currindex)
    self.bodiesComboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'hatch', self.bodiesComboHatchStyle))
    self.bodiesComboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.bodiesComboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesComboHatchStyle)
    self.bodiesComboHatchMultiplyStyle = QComboBoxMac()
    self.bodiesComboHatchMultiplyStyle.setToolTip('Violin bodies hatch repeat of object')
    for entry in self.hatchMultiplystyles:
      self.bodiesComboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['bodies']['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['bodies']['hatchMultiply']))
    else:
      currindex = 0
    self.bodiesComboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.bodiesComboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'hatchMultiply', self.bodiesComboHatchMultiplyStyle))
    self.bodiesComboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.bodiesComboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesComboHatchMultiplyStyle)

    # body width
    self.bodiesWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesWidthGroup)
    self.hLayout05 = QtWidgets.QHBoxLayout(self.bodiesWidthGroup)
    self.hLayout05.setContentsMargins(0, 0, 0, 0)
    self.hLayout05.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesWidthLabel = QtWidgets.QLabel('BWid')
    self.bodiesWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.bodiesWidthLabel)
    self.bodiesWidthEntry = QLineEditClick()
    self.bodiesWidthEntry.setToolTip('Violin bodies width of object')
    self.bodiesWidthEntry.setText(str(self.style['bodies']['width']))
    self.bodiesWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.bodiesWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.bodiesWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'bodies', 'width', self.bodiesWidthEntry, 0.0, 100.0))
    self.bodiesWidthEntry.setValidator(self.validFloat)
    self.hLayout05.addWidget(self.bodiesWidthEntry)
    
    # cmaxes/cmins
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cmaxesContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cmaxesContainer)
    self.vLayout2 = QtWidgets.QVBoxLayout(self.cmaxesContainer)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))
      
    self.displayCmaxesGroup = QWidgetMac()
    self.vLayout2.addWidget(self.displayCmaxesGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.displayCmaxesGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesStyleLabel = QtWidgets.QLabel()
    # for time being control min and max lines jointly
    self.cmaxesStyleLabel.setText('Min/Max')
    font = self.cmaxesStyleLabel.font()
    font.setBold(True)
    self.cmaxesStyleLabel.setFont(font)
    self.hLayout8.addWidget(self.cmaxesStyleLabel)    
    
    # display min/max?
    self.displayCmaxesCheck = QPushButtonCheckable()
    self.displayCmaxesCheck.setText('S?')
    self.displayCmaxesCheck.setToolTip('Show violin minima of object')
    self.displayCmaxesCheck.setChecked(self.style['cmins']['visible'])
    self.displayCmaxesCheck.clicked.connect(partial(self.setDisplay, self.target, 'cmins', self.displayCmaxesCheck))
    self.displayCmaxesCheck.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.displayCmaxesCheck)
    self.displayCmaxesCheck2 = QPushButtonCheckable()
    self.displayCmaxesCheck2.setToolTip('Show violin maxima of object')
    self.displayCmaxesCheck2.setText('S?')
    self.displayCmaxesCheck2.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck2.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck2.setChecked(self.style['cmaxes']['visible'])
    self.displayCmaxesCheck2.clicked.connect(partial(self.setDisplay, self.target, 'cmaxes', self.displayCmaxesCheck2))
    self.hLayout8.addWidget(self.displayCmaxesCheck2)
    
    # line width
    self.cmaxesLineWidthGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineWidthGroup)
    self.hLayout9 = QtWidgets.QHBoxLayout(self.cmaxesLineWidthGroup)
    self.hLayout9.setContentsMargins(0, 0, 0, 0)
    self.hLayout9.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineWidthLabel = QtWidgets.QLabel('Width')
    self.cmaxesLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout9.addWidget(self.cmaxesLineWidthLabel)
    # line width spin box
    self.cmaxesLineWidthSpin = QDoubleSpinClick()
    self.hLayout9.addWidget(self.cmaxesLineWidthSpin)
    self.cmaxesLineWidthSpin.setMinimum(0.0)
    self.cmaxesLineWidthSpin.setMaximum(100.0)
    self.cmaxesLineWidthSpin.setValue(self.style['cmaxes']['linewidth'])
    self.cmaxesLineWidthSpin.setToolTip('Violin min/max line width of object')
    self.cmaxesLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'cmaxes', 'linewidth', self.cmaxesLineWidthSpin))
    
    # line color
    self.cmaxesLineColorGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineColorGroup)
    self.hLayout10 = QtWidgets.QHBoxLayout(self.cmaxesLineColorGroup)
    self.hLayout10.setContentsMargins(0, 0, 0, 0)
    self.hLayout10.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineColorLabel = QtWidgets.QLabel('Color')
    self.cmaxesLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout10.addWidget(self.cmaxesLineColorLabel)
      
    self.cmaxesLineColorButton = QPushButtonColor()
    self.cmaxesLineColorButton.setToolTip('Violin min/max line color of object')
    self.cmaxesLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['cmaxes']['color'][0:3]]
    self.cmaxesLineColorButton.setMyColor(*colorvalue)
    self.cmaxesLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmaxesLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmaxesLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cmaxesLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cmaxes', 'color'))
    self.hLayout10.addWidget(self.cmaxesLineColorButton)
      
    # line style
    self.cmaxesLineStyleGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineStyleGroup)
    self.hLayout11 = QtWidgets.QHBoxLayout(self.cmaxesLineStyleGroup)
    self.hLayout11.setContentsMargins(0, 0, 0, 0)
    self.hLayout11.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineStyleLabel = QtWidgets.QLabel('Style')
    self.cmaxesLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout11.addWidget(self.cmaxesLineStyleLabel)
    self.cmaxesComboStyle = QComboBoxMac()
    self.cmaxesComboStyle.setToolTip('Violin min/max line style of object')
    for entry in self.linestyles:
      self.cmaxesComboStyle.addItem(entry)
    if(self.style['cmaxes']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cmaxes']['linestyle'])
    else:
      currindex = 0
    self.cmaxesComboStyle.setCurrentIndex(currindex)
    self.cmaxesComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cmaxes', 'linestyle', self.cmaxesComboStyle))
    self.cmaxesComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmaxesComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout11.addWidget(self.cmaxesComboStyle)

    # cap style
    self.cmaxesLineDashStyleGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineDashStyleGroup)
    self.hLayout12 = QtWidgets.QHBoxLayout(self.cmaxesLineDashStyleGroup)
    self.hLayout12.setContentsMargins(0, 0, 0, 0)
    self.hLayout12.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cmaxesLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout12.addWidget(self.cmaxesLineDashStyleLabel)
    self.cmaxesComboDashStyle = QComboBoxMac()
    self.cmaxesComboDashStyle.setToolTip('Violin min/max cap style of object')
    for entry in self.dashstyles:
      self.cmaxesComboDashStyle.addItem(entry)
    if(self.style['cmaxes']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cmaxes']['capstyle'])
    else:
      currindex = 0
    self.cmaxesComboDashStyle.setCurrentIndex(currindex)
    self.cmaxesComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cmaxes', 'capstyle', self.cmaxesComboDashStyle))
    self.cmaxesComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmaxesComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout12.addWidget(self.cmaxesComboDashStyle)

    # cbars
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cbarsContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cbarsContainer)
    self.vLayout3 = QtWidgets.QVBoxLayout(self.cbarsContainer)
    self.vLayout3.setContentsMargins(0, 0, 0, 0)
    self.vLayout3.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout3.setSpacing(scaledDPI(2))
      
    self.displaycbarsGroup = QWidgetMac()
    self.vLayout3.addWidget(self.displaycbarsGroup)
    self.hLayout13 = QtWidgets.QHBoxLayout(self.displaycbarsGroup)
    self.hLayout13.setContentsMargins(0, 0, 0, 0)
    self.hLayout13.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsStyleLabel = QtWidgets.QLabel()
    # for time being control min and max lines jointly
    self.cbarsStyleLabel.setText('Bars')
    font = self.cbarsStyleLabel.font()
    font.setBold(True)
    self.cbarsStyleLabel.setFont(font)
    self.cbarsStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout13.addWidget(self.cbarsStyleLabel)    
    
    # display bars?
    self.displaycbarsLabel = QPushButtonCheckable()
    self.displaycbarsLabel.setText('Show?')
    self.displaycbarsLabel.setToolTip('Show violin bars of object')
    self.displaycbarsLabel.setChecked(self.style['cbars']['visible'])
    self.displaycbarsLabel.clicked.connect(partial(self.setDisplay, self.target, 'cbars', self.displaycbarsLabel))
    self.displaycbarsLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displaycbarsLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout13.addWidget(self.displaycbarsLabel)

    # line width
    self.cbarsLineWidthGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineWidthGroup)
    self.hLayout14 = QtWidgets.QHBoxLayout(self.cbarsLineWidthGroup)
    self.hLayout14.setContentsMargins(0, 0, 0, 0)
    self.hLayout14.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineWidthLabel = QtWidgets.QLabel('Width')
    self.cbarsLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout14.addWidget(self.cbarsLineWidthLabel)
    # line width spin box
    self.cbarsLineWidthSpin = QDoubleSpinClick()
    self.hLayout14.addWidget(self.cbarsLineWidthSpin)
    self.cbarsLineWidthSpin.setMinimum(0.0)
    self.cbarsLineWidthSpin.setMaximum(100.0)
    self.cbarsLineWidthSpin.setValue(self.style['cbars']['linewidth'])
    self.cbarsLineWidthSpin.setToolTip('Violin bars line width of object')
    self.cbarsLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'cbars', 'linewidth', self.cbarsLineWidthSpin))
    
    # line color
    self.cbarsLineColorGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineColorGroup)
    self.hLayout15 = QtWidgets.QHBoxLayout(self.cbarsLineColorGroup)
    self.hLayout15.setContentsMargins(0, 0, 0, 0)
    self.hLayout15.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineColorLabel = QtWidgets.QLabel('Color')
    self.cbarsLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout15.addWidget(self.cbarsLineColorLabel)
      
    self.cbarsLineColorButton = QPushButtonColor()
    self.cbarsLineColorButton.setToolTip('Violin bars line color of object')
    self.cbarsLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['cbars']['color'][0:3]]
    self.cbarsLineColorButton.setMyColor(*colorvalue)
    self.cbarsLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cbarsLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cbarsLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cbarsLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cbars', 'color'))
    self.hLayout15.addWidget(self.cbarsLineColorButton)
      
    # line style
    self.cbarsLineStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineStyleGroup)
    self.hLayout16 = QtWidgets.QHBoxLayout(self.cbarsLineStyleGroup)
    self.hLayout16.setContentsMargins(0, 0, 0, 0)
    self.hLayout16.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineStyleLabel = QtWidgets.QLabel('Style')
    self.cbarsLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout16.addWidget(self.cbarsLineStyleLabel)
    self.cbarsComboStyle = QComboBoxMac()
    self.cbarsComboStyle.setToolTip('Violin bars line style of object')
    for entry in self.linestyles:
      self.cbarsComboStyle.addItem(entry)
    if(self.style['cbars']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cbars']['linestyle'])
    else:
      currindex = 0
    self.cbarsComboStyle.setCurrentIndex(currindex)
    self.cbarsComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cbars', 'linestyle', self.cbarsComboStyle))
    self.cbarsComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cbarsComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout16.addWidget(self.cbarsComboStyle)

    # cap style
    self.cbarsLineDashStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineDashStyleGroup)
    self.hLayout17 = QtWidgets.QHBoxLayout(self.cbarsLineDashStyleGroup)
    self.hLayout17.setContentsMargins(0, 0, 0, 0)
    self.hLayout17.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cbarsLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout17.addWidget(self.cbarsLineDashStyleLabel)
    self.cbarsComboDashStyle = QComboBoxMac()
    self.cbarsComboDashStyle.setToolTip('Violin bars cap style of object')
    for entry in self.dashstyles:
      self.cbarsComboDashStyle.addItem(entry)
    if(self.style['cbars']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cbars']['capstyle'])
    else:
      currindex = 0
    self.cbarsComboDashStyle.setCurrentIndex(currindex)
    self.cbarsComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cbars', 'capstyle', self.cbarsComboDashStyle))
    self.cbarsComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cbarsComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout17.addWidget(self.cbarsComboDashStyle)

    # cmeans
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cmeansContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cmeansContainer)
    self.vLayout4 = QtWidgets.QVBoxLayout(self.cmeansContainer)
    self.vLayout4.setContentsMargins(0, 0, 0, 0)
    self.vLayout4.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout4.setSpacing(scaledDPI(2))
      
    self.displayCmeansGroup = QWidgetMac()
    self.vLayout4.addWidget(self.displayCmeansGroup)
    self.hLayout18 = QtWidgets.QHBoxLayout(self.displayCmeansGroup)
    self.hLayout18.setContentsMargins(0, 0, 0, 0)
    self.hLayout18.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansStyleLabel = QtWidgets.QLabel()
    # for time being control mean and median lines jointly
    self.cmeansStyleLabel.setText('Mean/Median')
    font = self.cmeansStyleLabel.font()
    font.setBold(True)
    self.cmeansStyleLabel.setFont(font)
    self.hLayout18.addWidget(self.cmeansStyleLabel)    
    
    # display mean/median?
    self.displayCmeansCheck = QPushButtonCheckable()
    self.displayCmeansCheck.setText('S?')
    self.displayCmeansCheck.setToolTip('Show violin means of object')
    self.displayCmeansCheck.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck.setChecked(self.style['cmeans']['visible'])
    self.displayCmeansCheck.clicked.connect(partial(self.setDisplay, self.target, 'cmeans', self.displayCmeansCheck))
    self.hLayout18.addWidget(self.displayCmeansCheck)
    self.displayCmeansCheck2 = QPushButtonCheckable()
    self.displayCmeansCheck2.setText('S?')
    self.displayCmeansCheck2.setToolTip('Show violin medians of object')
    self.displayCmeansCheck2.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck2.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck2.setChecked(self.style['cmedians']['visible'])
    self.displayCmeansCheck2.clicked.connect(partial(self.setDisplay, self.target, 'cmedians', self.displayCmeansCheck2))
    self.hLayout18.addWidget(self.displayCmeansCheck2)
    
    # line width
    self.cmeansLineWidthGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineWidthGroup)
    self.hLayout19 = QtWidgets.QHBoxLayout(self.cmeansLineWidthGroup)
    self.hLayout19.setContentsMargins(0, 0, 0, 0)
    self.hLayout19.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineWidthLabel = QtWidgets.QLabel('Width')
    self.cmeansLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout19.addWidget(self.cmeansLineWidthLabel)
    # line width spin box
    self.cmeansLineWidthSpin = QDoubleSpinClick()
    self.hLayout19.addWidget(self.cmeansLineWidthSpin)
    self.cmeansLineWidthSpin.setMinimum(0.0)
    self.cmeansLineWidthSpin.setMaximum(100.0)
    self.cmeansLineWidthSpin.setValue(self.style['cmeans']['linewidth'])
    self.cmeansLineWidthSpin.setToolTip('Violin means/medians line width of object')
    self.cmeansLineWidthSpin.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthSpin.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthSpin.editingFinished.connect(partial(self.alterStyle, self.target, 'cmeans', 'linewidth', self.cmeansLineWidthSpin))
    
    # line color
    self.cmeansLineColorGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineColorGroup)
    self.hLayout20 = QtWidgets.QHBoxLayout(self.cmeansLineColorGroup)
    self.hLayout20.setContentsMargins(0, 0, 0, 0)
    self.hLayout20.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineColorLabel = QtWidgets.QLabel('Color')
    self.cmeansLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.cmeansLineColorLabel)
      
    self.cmeansLineColorButton = QPushButtonColor()
    self.cmeansLineColorButton.setToolTip('Violin means/medians line color of object')
    self.cmeansLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style['cmeans']['color'][0:3]]
    self.cmeansLineColorButton.setMyColor(*colorvalue)
    self.cmeansLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmeansLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmeansLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cmeansLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cmeans', 'color'))
    self.hLayout20.addWidget(self.cmeansLineColorButton)
      
    # line style
    self.cmeansLineStyleGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineStyleGroup)
    self.hLayout21 = QtWidgets.QHBoxLayout(self.cmeansLineStyleGroup)
    self.hLayout21.setContentsMargins(0, 0, 0, 0)
    self.hLayout21.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineStyleLabel = QtWidgets.QLabel('Style')
    self.cmeansLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.cmeansLineStyleLabel)
    self.cmeansComboStyle = QComboBoxMac()
    self.cmeansComboStyle.setToolTip('Violin means/medians line style of object')
    for entry in self.linestyles:
      self.cmeansComboStyle.addItem(entry)
    if(self.style['cmeans']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cmeans']['linestyle'])
    else:
      currindex = 0
    self.cmeansComboStyle.setCurrentIndex(currindex)
    self.cmeansComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cmeans', 'linestyle', self.cmeansComboStyle))
    self.cmeansComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmeansComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.cmeansComboStyle)

    # cap style
    self.cmeansLineDashStyleGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineDashStyleGroup)
    self.hLayout22 = QtWidgets.QHBoxLayout(self.cmeansLineDashStyleGroup)
    self.hLayout22.setContentsMargins(0, 0, 0, 0)
    self.hLayout22.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cmeansLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.cmeansLineDashStyleLabel)
    self.cmeansComboDashStyle = QComboBoxMac()
    self.cmeansComboDashStyle.setToolTip('Violin means/medians cap style of object')
    for entry in self.dashstyles:
      self.cmeansComboDashStyle.addItem(entry)
    if(self.style['cmeans']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cmeans']['capstyle'])
    else:
      currindex = 0
    self.cmeansComboDashStyle.setCurrentIndex(currindex)
    self.cmeansComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cmeans', 'capstyle', self.cmeansComboDashStyle))
    self.cmeansComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmeansComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.cmeansComboDashStyle)

  def alterStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def changeStyle(self, target=None, subtarget=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setDisplay(self, target=None, subtarget=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle(subtarget, 'visible', value, redraw=True)

  def selectStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key == 'hatchMultiply'):
        value = int(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setColor(self, target=None, subtarget=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if((subtarget != None) and (key in self.style[subtarget])):
        prevColor = [255 * i for i in self.style[subtarget][key]]
        prevColor = QtGui.QColor(*prevColor)
      elif (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(subtarget == 'bodies'):
          if(key == 'edgecolor'):
            self.bodiesLineColorButton.setMyColor(*value)
          elif(key == 'facecolor'):
            self.bodiesFillColorButton.setMyColor(*value)
        elif((subtarget == 'cmaxes') and (key == 'color')):
          self.cmaxesLineColorButton.setMyColor(*value)
        elif((subtarget == 'cbars') and (key == 'color')):
          self.cbarsLineColorButton.setMyColor(*value)
        elif((subtarget == 'cmeans') and (key == 'color')):
          self.cmeansLineColorButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        if(subtarget != None):
          self.style[subtarget][key] = value
        else:
          self.style[key] = value

        target.setViolinStyle(subtarget, key, value, redraw=True)

      # bring back the QMenu
      self.parent.togglePersist(False)

  def toggleBodyFill(self, target=None, entryfield=None):
    # toggles whether to fill violin bodies or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['bodies']['doFill'] = value
      target.toggleViolinBodyFill(value, redraw=True)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class boxStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(boxStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target

    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]

    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    # had to remove a couple of styles as fliers crash otherwise
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 1, 2, 3, 4, 8, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]
    if(self.parent.parent.parent.graphicsarea.advancedExport['advancedGraphics']):
      self.orderedstyles += [i for i in CUSTOM_MARKERS]

    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      getStyle = self.target.getViolinStyle()

      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        if(type(getStyle[entry]) == type({})):
          # have to deepcopy inner dicts to prevent inadvertent overwriting of values
          self.style[entry] = deepcopy(getStyle[entry])
        else:
          self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {}

    defaultStyle['boxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'dash_capstyle': 'butt', 'visible': True}
    for slaved in ['whiskers', 'medians', 'caps']:
      defaultStyle[slaved] = {}
      defaultStyle[slaved].update(defaultStyle['boxes'])
    defaultStyle['boxes'].update({'edgecolor': [0.2, 0.2, 0.2, 1.0], 'width': 0.5, 'boxFill': True, 'facecolor': [0.8, 0.8, 0.9, 1.0], 'hatch': '', 'hatchMultiply': 1})
    # only used this key temporarily for slaving whiskers etc.
    del defaultStyle['boxes']['color']
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]
    defaultStyle['fliers'] = {'visible': True, 'marker': 'o', 'markerfacecolor': [0.89, 0.29, 0.2, 1.0], 'markerfacecoloralt': [0.0, 0.0, 0.0, 1.0],\
                'markeredgecolor': [0.0, 0.0, 0.0, 1.0], 'markeredgewidth': 0.5, 'markersize': 10.0, 'fillstyle': 'full'}

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout = QtWidgets.QHBoxLayout(self)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.hLayout.setSpacing(scaledDPI(2))
    
    self.hLayouts, self.vLayouts = [], []
    self.generalContainers, self.generalLabels, self.generalGroups = [], [], []
    self.displayChecks, self.lineWidthEntries, self.lineColorButtons, self.lineStyleCombos, self.lineCapCombos = [], [], [], [], []
    items, labels = ['boxes', 'whiskers', 'caps', 'medians'], ['Boxes', 'Whisk.', 'Caps', 'Median']
    toolTips = ['box bodies', 'box whiskers', 'box caps', 'box medians']
    for i, j, useTip in zip(items, labels, toolTips):
      # header
      self.generalContainers.append(QWidgetMac(self))
      self.hLayout.addWidget(self.generalContainers[-1])
      self.vLayouts.append(QtWidgets.QVBoxLayout(self.generalContainers[-1]))
      self.vLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.vLayouts[-1].setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayouts[-1].setSpacing(scaledDPI(2))
        
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
      self.generalLabels.append(QtWidgets.QLabel())
      self.generalLabels[-1].setText(j)
      font = self.generalLabels[-1].font()
      font.setBold(True)
      self.generalLabels[-1].setFont(font)
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])    

      # display group
      self.displayChecks.append(QPushButtonCheckable())
      self.displayChecks[-1].setText('Show?')
      self.displayChecks[-1].setToolTip('Show ' + useTip + ' of object')
      self.displayChecks[-1].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.displayChecks[-1].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.displayChecks[-1].setChecked(self.style[i]['visible'])
      self.displayChecks[-1].clicked.connect(partial(self.setDisplay, self.target, i, self.displayChecks[-1]))
      self.hLayouts[-1].addWidget(self.displayChecks[-1])
      
      # line width group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Width'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      # line width spin box
      self.lineWidthEntries.append(QDoubleSpinClick())
      self.hLayouts[-1].addWidget(self.lineWidthEntries[-1])
      self.lineWidthEntries[-1].setMinimum(0.0)
      self.lineWidthEntries[-1].setMaximum(100.0)
      self.lineWidthEntries[-1].setValue(self.style[i]['linewidth'])
      self.lineWidthEntries[-1].setToolTip(useTip.capitalize() + ' line width of object')
      self.lineWidthEntries[-1].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineWidthEntries[-1].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineWidthEntries[-1].editingFinished.connect(partial(self.alterStyle, self.target, i, 'linewidth', self.lineWidthEntries[-1]))
    
      # line color group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
      self.generalLabels.append(QtWidgets.QLabel('Color'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineColorButtons.append(QPushButtonColor())
      self.lineColorButtons[-1].setAutoFillBackground(False)
      self.lineColorButtons[-1].setToolTip(useTip.capitalize() + ' line color of object')
      if(i == 'boxes'):
        colorvalue = [int(i * 255.0) for i in self.style[i]['edgecolor'][0:3]]
      else:
        colorvalue = [int(i * 255.0) for i in self.style[i]['color'][0:3]]
      self.lineColorButtons[-1].setMyColor(*colorvalue)
      self.lineColorButtons[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButtons[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButtons[-1].setCursor(QtCore.Qt.PointingHandCursor)
      if(i == 'boxes'):
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'edgecolor'))
      else:
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'color'))
      self.hLayouts[-1].addWidget(self.lineColorButtons[-1])

      # line styles group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Style'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineStyleCombos.append(QComboBoxMac())
      self.lineStyleCombos[-1].setToolTip(useTip.capitalize() + ' line style of object')
      for entry in self.linestyles:
        self.lineStyleCombos[-1].addItem(entry)
      if(self.style[i]['linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style[i]['linestyle'])
      else:
        currindex = 0
      self.lineStyleCombos[-1].setCurrentIndex(currindex)
      self.lineStyleCombos[-1].activated.connect(partial(self.selectStyle, self.target, i, 'linestyle', self.lineStyleCombos[-1]))
      self.lineStyleCombos[-1].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.lineStyleCombos[-1].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.lineStyleCombos[-1])

      # cap styles group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Cap'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineCapCombos.append(QComboBoxMac())
      self.lineCapCombos[-1].setToolTip(useTip.capitalize() + ' cap style of object')
      for entry in self.dashstyles:
        self.lineCapCombos[-1].addItem(entry)
      if(self.style[i]['dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style[i]['dash_capstyle'])
      else:
        currindex = 0
      self.lineCapCombos[-1].setCurrentIndex(currindex)
      self.lineCapCombos[-1].activated.connect(partial(self.selectStyle, self.target, i, 'dash_capstyle', self.lineCapCombos[-1]))
      self.lineCapCombos[-1].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.lineCapCombos[-1].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.lineCapCombos[-1])
      
      # extra options for boxes
      if(i == 'boxes'):
        # fill color group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
        self.generalLabels.append(QPushButtonCheckable())
        self.generalLabels[-1].setText('Fill')
        self.generalLabels[-1].setToolTip('Show box bodies fill of object')
        self.generalLabels[-1].setChecked(self.style[i]['boxFill'])
        self.generalLabels[-1].clicked.connect(partial(self.toggleBoxFill, self.target, self.generalLabels[-1]))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])
        
        self.lineColorButtons.append(QPushButtonColor())
        self.lineColorButtons[-1].setToolTip('Box bodies fill color of object')
        self.lineColorButtons[-1].setAutoFillBackground(False)
        colorvalue = [int(i * 255.0) for i in self.style[i]['facecolor'][0:3]]
        self.lineColorButtons[-1].setMyColor(*colorvalue)
        self.lineColorButtons[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.lineColorButtons[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.lineColorButtons[-1].setCursor(QtCore.Qt.PointingHandCursor)
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'facecolor'))
        self.hLayouts[-1].addWidget(self.lineColorButtons[-1])

        # hatch group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
  
        self.generalLabels.append(QtWidgets.QLabel('Hatch'))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])

        self.boxesComboHatchStyle = QComboBoxMac()
        self.boxesComboHatchStyle.setToolTip('Box bodies hatch style of object')
        for entry in self.hatchstyles:
          self.boxesComboHatchStyle.addItem(entry)
        if(self.style['boxes']['hatch'] in self.hatchstyles):
          currindex = self.hatchstyles.index(self.style['boxes']['hatch'])
        else:
          currindex = 0
        self.boxesComboHatchStyle.setCurrentIndex(currindex)
        self.boxesComboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'boxes', 'hatch', self.boxesComboHatchStyle))
        self.boxesComboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.boxesComboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.boxesComboHatchStyle)
        self.boxesComboHatchMultiplyStyle = QComboBoxMac()
        self.boxesComboHatchMultiplyStyle.setToolTip('Box bodies hatch repeat of object')
        for entry in self.hatchMultiplystyles:
          self.boxesComboHatchMultiplyStyle.addItem(str(entry))
        if(str(self.style['boxes']['hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['boxes']['hatchMultiply']))
        else:
          currindex = 0
        self.boxesComboHatchMultiplyStyle.setCurrentIndex(currindex)
        self.boxesComboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'boxes', 'hatchMultiply', self.boxesComboHatchMultiplyStyle))
        self.boxesComboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.boxesComboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.boxesComboHatchMultiplyStyle)

        # body width group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
  
        self.generalLabels.append(QtWidgets.QLabel('BWid'))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])
        self.boxesWidthEntry = QLineEditClick()
        self.boxesWidthEntry.setToolTip('Box bodies width of object')
        self.boxesWidthEntry.setText(str(self.style['boxes']['width']))
        self.boxesWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.boxesWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.boxesWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'boxes', 'width', self.boxesWidthEntry, 0.0, 100.0))
        self.boxesWidthEntry.setValidator(self.validFloat)
        self.hLayouts[-1].addWidget(self.boxesWidthEntry)

      # add a spacing line
      blah = self.VLine()
      self.hLayout.addWidget(blah)

    # now put config of outliers
    i, j = 'fliers', 'Outliers'
    # header
    self.generalContainers.append(QWidgetMac(self))
    self.hLayout.addWidget(self.generalContainers[-1])
    self.vLayouts.append(QtWidgets.QVBoxLayout(self.generalContainers[-1]))
    self.vLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.vLayouts[-1].setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayouts[-1].setSpacing(scaledDPI(2))
      
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
    self.generalLabels.append(QtWidgets.QLabel())
    self.generalLabels[-1].setText(j)
    font = self.generalLabels[-1].font()
    font.setBold(True)
    self.generalLabels[-1].setFont(font)
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])    

    # display group
    self.displayChecks.append(QPushButtonCheckable())
    self.displayChecks[-1].setText('Show?')
    self.displayChecks[-1].setToolTip('Show box outliers of object')
    self.displayChecks[-1].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayChecks[-1].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.displayChecks[-1].setChecked(self.style[i]['visible'])
    self.displayChecks[-1].clicked.connect(partial(self.setDisplay, self.target, i, self.displayChecks[-1]))
    self.hLayouts[-1].addWidget(self.displayChecks[-1])
      
    # marker size group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Size'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    # marker size spin box
    self.markerSizeEntry = QDoubleSpinClick()
    self.hLayouts[-1].addWidget(self.markerSizeEntry)
    self.markerSizeEntry.setMinimum(0.0)
    self.markerSizeEntry.setMaximum(100.0)
    self.markerSizeEntry.setValue(self.style[i]['markersize'])
    self.markerSizeEntry.setToolTip('Box outlier marker size of object')
    self.markerSizeEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.editingFinished.connect(partial(self.alterStyle, self.target, i, 'markersize', self.markerSizeEntry))

    # marker color group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QPushButtonCheckable())
    self.generalLabels[-1].setText('Face')
    self.generalLabels[-1].setToolTip('Show box outlier marker fill of object')
    self.generalLabels[-1].setChecked(self.style[i]['doFill'])
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].clicked.connect(partial(self.toggleFliersMarkerFill, self.target, self.generalLabels[-1]))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerFaceColorButton = QPushButtonColor()
    self.markerFaceColorButton.setToolTip('Box outlier marker fill color of object')
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markerfacecolor'][0:3]]
    self.markerFaceColorButton.setMyColor(*colorvalue)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, self.target, i, key='markerfacecolor'))
    self.hLayouts[-1].addWidget(self.markerFaceColorButton)

    self.generalLabels.append(QtWidgets.QLabel('Edge'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerEdgeColorButton = QPushButtonColor()
    self.markerEdgeColorButton.setToolTip('Box outlier marker edge color of object')
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markeredgecolor'][0:3]]
    self.markerEdgeColorButton.setMyColor(*colorvalue)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, self.target, i, key='markeredgecolor'))
    self.hLayouts[-1].addWidget(self.markerEdgeColorButton)

    # marker edge width group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Edgewidth'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    # boxes width spin box
    self.markerEdgeWidthEntry = QDoubleSpinClick()
    self.hLayouts[-1].addWidget(self.markerEdgeWidthEntry)
    self.markerEdgeWidthEntry.setMinimum(0.0)
    self.markerEdgeWidthEntry.setMaximum(100.0)
    self.markerEdgeWidthEntry.setValue(self.style[i]['markeredgewidth'])
    self.markerEdgeWidthEntry.setToolTip('Box outlier marker edge width of object')
    self.markerEdgeWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.editingFinished.connect(partial(self.alterStyle, self.target, i, 'markeredgewidth', self.markerEdgeWidthEntry))

    # marker style group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    # need copy for MarkerMenu
    self.style['marker'] = self.style['fliers']['marker']
    self.generalLabels.append(QtWidgets.QLabel('Style'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.comboStyle = MarkerButton()
    self.comboStyle.setToolTip('Marker symbol of object')
    self.comboStyle.clicked.connect(partial(self.markerCallback, self.comboStyle))
    if(self.style[i]['marker'] in self.orderedstyles):
      self.comboStyle.setSymbol(self.style[i]['marker'])
    else:
      self.comboStyle.setSymbol(self.orderedstyles[0])
    self.comboStyle.setSymbolList(self.orderedstyles)
    self.comboStyle.setParent(self)
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.comboStyle)    

    # marker fillstyle group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Fillstyle'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.comboFillStyle = QComboBoxMac()
    self.comboFillStyle.setToolTip('Box outlier marker fill style of object')
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style[i]['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style[i]['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, i, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.comboFillStyle)

    self.markerAltColorButton = QPushButtonColor()
    self.markerAltColorButton.setToolTip('Box outlier marker alternate fill color of object')
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markerfacecoloralt'][0:3]]
    self.markerAltColorButton.setMyColor(*colorvalue)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, self.target, i, 'markerfacecoloralt'))
    self.hLayouts[-1].addWidget(self.markerAltColorButton)

  def alterStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def changeStyle(self, target=None, subtarget=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def toggleBoxFill(self, target=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle('boxes', 'boxFill', value, redraw=True)

  def setDisplay(self, target=None, subtarget=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle(subtarget, 'visible', value, redraw=True)

  def selectStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key == 'hatchMultiply'):
        value = int(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setColor(self, target=None, subtarget=None, key=None):
    if((target != None) and (key != None)):
      # prevent QMenu from vanishing
      self.parent.togglePersist(True)
      # get current color
      if((subtarget != None) and (key in self.style[subtarget])):
        prevColor = [255 * i for i in self.style[subtarget][key]]
        prevColor = QtGui.QColor(*prevColor)
      elif (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        # update color in QMenu
        if(subtarget == 'boxes'):
          if(key == 'edgecolor'):
            self.lineColorButtons[0].setMyColor(*value)
          elif(key == 'facecolor'):
            self.lineColorButtons[1].setMyColor(*value)
        elif((subtarget == 'whiskers') and (key == 'color')):
          self.lineColorButtons[2].setMyColor(*value)
        elif((subtarget == 'caps') and (key == 'color')):
          self.lineColorButtons[3].setMyColor(*value)
        elif((subtarget == 'medians') and (key == 'color')):
          self.lineColorButtons[4].setMyColor(*value)
        elif(subtarget == 'fliers'):
          if(key == 'markerfacecolor'):
            self.markerFaceColorButton.setMyColor(*value)
          elif(key == 'markeredgecolor'):
            self.markerEdgeColorButton.setMyColor(*value)
          elif(key == 'markerfacecoloralt'):
            self.markerAltFaceColorButton.setMyColor(*value)
        value = [i / 255.0 for i in value]
        if(subtarget != None):
          self.style[subtarget][key] = value
        else:
          self.style[key] = value

        target.setViolinStyle(subtarget, key, value, redraw=True)

      # bring back the QMenu
      self.parent.togglePersist(False)

  def toggleFliersMarkerFill(self, target=None, entryfield=None):
    # toggles whether to fill fliers markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['fliers']['doFill'] = value
      target.toggleFliersMarkerFill(value, redraw=True)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def markerCallback(self, callButton=None):
    # opens menu to access advanced configuration options
    self.menu = MarkerMenu(self)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # bottom align position of QMenu
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def setMarker(self, symbol='', alternate=False):
    # sets marker symbol to selected type
    if((symbol in self.orderedstyles) and (symbol != self.style['fliers']['marker'])):
      self.style['fliers']['marker'] = symbol
      self.comboStyle.setSymbol(symbol)

      self.target.setViolinStyle('fliers', 'marker', symbol, redraw=True)

class ConfigMenu(KuhMenu):
  def __init__(self, parent = None, target = None, residMode = False, residZero = False, displayName=False):
    super(ConfigMenu, self).__init__()
    self.parent = parent
    self.target = target
    self.residMode = residMode
    self.residZero = residZero
    self.displayName = displayName
    self.validFloat = MyValidFloat()
    self.persist = False
    self.persistPos = None
    
    # initialize drag values
    self.startPos = None
      
    # set up GUI
    self.buildRessource()
    
  def togglePersist(self, state):
    # toggles QMenu persistence for click events that would close it, see below
    # when state True, save current menu coordinates
    # when state False, restore QMenu at previous coordinates
    self.persist = state
    if(state):
      self.persistPos = self.pos()
    elif(self.persistPos != None):
      self.popup(self.persistPos)
      self.persistPos = None

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(self.underMouse()):
      if(self.displayName and (event.button() == QtCore.Qt.LeftButton)):
        self.startPos = event.globalPos()
    else:
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def mouseMoveEvent(self, event):
    if((event.buttons() == QtCore.Qt.LeftButton) and (self.startPos != None)):
      currentPos = event.globalPos()
      menuPos = self.mapToGlobal(self.pos()) + (currentPos - self.startPos)
      menuPos = self.mapFromGlobal(menuPos)
      self.move(menuPos)
      self.startPos = currentPos
    
  def mouseReleaseEvent(self, event):
    # turn off tracking
    if(event.button() == QtCore.Qt.LeftButton):
      self.startPos = None

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[scaledDPI(4)]*4)
    
    # display name of item?
    if(self.displayName):
      self.topContainer = QWidgetMac(self)
      self.vLayout.addWidget(self.topContainer)
      self.LayoutTopContainer = QtWidgets.QHBoxLayout(self.topContainer)
      self.LayoutTopContainer.setContentsMargins(0, 0, 0, 0)

      if(self.target in self.parent.parent.data):
        index = self.parent.parent.data.index(self.target)
        if(self.residMode):
          leader = 'Resid ' + str(index)
        else:
          leader = 'Data ' + str(index)
      elif(self.target in self.parent.parent.fit):
        index = self.parent.parent.fit.index(self.target)
        leader = 'Curve ' + str(index)
      elif(self.residZero):
        index = 0
        leader = 'Zero Line'
      else:
        leader = 'unknown'
      self.targetLabel = QtWidgets.QLabel()
      self.targetLabel.setText(leader)
      font = self.targetLabel.font()
      font.setBold(True)
      self.targetLabel.setFont(font)
      self.LayoutTopContainer.addWidget(self.targetLabel)
      # create entry field to edit name
      if(self.residMode and (hasattr(self.target, 'nameResid'))):
        name = self.target.nameResid
        nameTag = 'residuals object ' + str(index)
      elif(hasattr(self.target, 'name')):
        name = self.target.name
        if(self.target in self.parent.parent.data):
          nameTag = 'data object ' + str(index)
        else:
          nameTag = 'curve object ' + str(index)
      else:
        name = None
        nameTag = ''
      
      if(name != None):
        self.entryField = QLineEditClick(name)
        self.entryField.setToolTip('Name of ' + nameTag)
        self.entryField.setAlignment(QtCore.Qt.AlignLeft)
        self.entryField.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.editingFinished.connect(partial(self.setField, leader, index))
        self.LayoutTopContainer.addWidget(self.entryField)
     
      # put controls for altering active item
      self.LayoutTopContainer.addStretch()
      if(leader.startswith('Data') or leader.startswith('Curve')):
        self.activeButton = QPushButtonCheckable()
        self.activeButton.setText('active')
        self.activeButton.setToolTip('Make ' + nameTag + ' active')
        self.activeButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.activeButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        # check whether item is already active
        if((leader.startswith('Data') and (index == self.parent.parent.activeData)) or \
           (leader.startswith('Curve') and (index == self.parent.parent.activeFit))):
          self.activeButton.setChecked(True)
          self.activeButton.setEnabled(False)
        self.activeButton.clicked.connect(partial(self.makeActive, leader, index))
        self.LayoutTopContainer.addWidget(self.activeButton)
      
      # put controls for altering z position
      self.zLabel = QtWidgets.QLabel('z')
      self.LayoutTopContainer.addWidget(self.zLabel)

      self.innerContainer = QWidgetMac(self)
      self.LayoutTopContainer.addWidget(self.innerContainer)
      self.LayoutInnerContainer = QtWidgets.QHBoxLayout(self.innerContainer)
      self.LayoutInnerContainer.setContentsMargins(0, 0, 0, 0)
      self.LayoutInnerContainer.setSpacing(0)

      self.zDownButton = QPushButtonMac()
      self.zDownButton.setText('\u25be')
      self.zDownButton.setToolTip('Lower z order')
      self.zDownButton.setAutoRepeat(True)
      self.zDownButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.clicked.connect(partial(self.alterZ, leader, index, -1))
      self.LayoutInnerContainer.addWidget(self.zDownButton)

      self.zUpButton = QPushButtonMac()
      self.zUpButton.setText('\u25b4')
      self.zUpButton.setToolTip('Raise z order')
      self.zUpButton.setAutoRepeat(True)
      self.zUpButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.clicked.connect(partial(self.alterZ, leader, index, 1))
      self.LayoutInnerContainer.addWidget(self.zUpButton)

      # call alterZ to initiate button disabling
      self.alterZ(leader, index, 0)
     
      blah = self.HLine()
      self.vLayout.addWidget(blah)

    self.upperRow = QWidgetMac()
    
    # populate menu with items
    # set up line style configurator
    if(self.target in self.parent.parent.data + self.parent.parent.fit):
      # generate top row
      self.displayLineButton = QPushButtonCheckable()
      self.displayLineButton.setText('Configure Line and Marker \u25be')
      self.displayLineButton.setChecked(self.parent.displayLineConfig)
      self.vLayout.addWidget(self.displayLineButton)
      self.vLayout.addWidget(self.upperRow)

      self.displayLineButton.clicked.connect(partial(self.toggleDisplay, self.displayLineButton, self.upperRow, 'displayLineConfig'))
      self.toggleDisplay(button=self.displayLineButton, target=self.upperRow, flag='displayLineConfig')
    else:
      self.vLayout.addWidget(self.upperRow)
      
    self.hLayout = QtWidgets.QHBoxLayout(self.upperRow)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.lineStyleMenu = lineStyleMenu(self, self.target, self.residMode, self.residZero)
    self.hLayout.addWidget(self.lineStyleMenu)
    
    if(not self.residZero):
      # set up marker style configurator
      self.hLayout.addWidget(self.VLine())
      self.markerStyleMenu = markerStyleMenu(self, self.target, self.residMode)
      self.hLayout.addWidget(self.markerStyleMenu)
      self.hLayout.addStretch()

    if(self.target in self.parent.parent.data):
      # generate lower row
      self.displayBarButton = QPushButtonCheckable()
      self.displayBarButton.setText('Configure Bar and Stack \u25be')
      self.displayBarButton.setChecked(self.parent.displayBarConfig)
      self.vLayout.addWidget(self.displayBarButton)

      self.lowerRow = QWidgetMac()
      self.vLayout.addWidget(self.lowerRow)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.lowerRow)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.displayBarButton.clicked.connect(partial(self.toggleDisplay, self.displayBarButton, self.lowerRow, 'displayBarConfig'))
      self.toggleDisplay(button=self.displayBarButton, target=self.lowerRow, flag='displayBarConfig')
      
      # set up bar style configurator
      self.barStyleMenu = barStyleMenu(self, self.target, self.residMode)
      self.hLayout2.addWidget(self.barStyleMenu)
  
      # set up stack style configurator
      self.hLayout2.addWidget(self.VLine())
      self.stackStyleMenu = stackStyleMenu(self, self.target, self.residMode)
      self.hLayout2.addWidget(self.stackStyleMenu)
      self.hLayout2.addStretch()
    
      if(not self.residMode):
        # set up errorbar configurator
        self.displayErrorButton = QPushButtonCheckable()
        self.displayErrorButton.setText('Configure Error Bar \u25be')
        self.displayErrorButton.setChecked(self.parent.displayErrorConfig)
        self.vLayout.addWidget(self.displayErrorButton)

        self.lowestRow = QWidgetMac()
        self.vLayout.addWidget(self.lowestRow)
        self.hLayout3 = QtWidgets.QHBoxLayout(self.lowestRow)
        self.hLayout3.setContentsMargins(0, 0, 0, 0)
        self.displayErrorButton.clicked.connect(partial(self.toggleDisplay, self.displayErrorButton, self.lowestRow, 'displayErrorConfig'))
        self.toggleDisplay(button=self.displayErrorButton, target=self.lowestRow, flag='displayErrorConfig')

        self.errorStyleMenu = errorStyleMenu(self, self.target, self.residMode)
        self.hLayout3.addWidget(self.errorStyleMenu)

      # set up violin and box plot configurator
      if(not self.residMode):
        self.displayViolinButton = QPushButtonCheckable()
        self.displayViolinButton.setText('Configure Violin and Box Plots \u25be')
        self.displayViolinButton.setChecked(self.parent.displayViolinConfig)
        self.vLayout.addWidget(self.displayViolinButton)

        self.violinRow = QWidgetMac()
        self.vLayout.addWidget(self.violinRow)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.violinRow)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.displayViolinButton.clicked.connect(partial(self.toggleDisplay, self.displayViolinButton, self.violinRow, 'displayViolinConfig'))
        self.toggleDisplay(button=self.displayViolinButton, target=self.violinRow, flag='displayViolinConfig')
        
        self.violinBoxMenu = violinBoxMenu(self, self.target)
        self.hLayout5.addWidget(self.violinBoxMenu)

      # generate lowest row
      self.displayTextButton = QPushButtonCheckable()
      self.displayTextButton.setText('Configure Text Labels \u25be')
      self.displayTextButton.setChecked(self.parent.displayTextConfig)
      self.vLayout.addWidget(self.displayTextButton)

      self.lowestRow2 = QWidgetMac()
      self.vLayout.addWidget(self.lowestRow2)
      self.hLayout4 = QtWidgets.QHBoxLayout(self.lowestRow2)
      self.hLayout4.setContentsMargins(0, 0, 0, 0)
      self.displayTextButton.clicked.connect(partial(self.toggleDisplay, self.displayTextButton, self.lowestRow2, 'displayTextConfig'))
      self.toggleDisplay(button=self.displayTextButton, target=self.lowestRow2, flag='displayTextConfig')
      
      # set up text style configurator
      self.textStyleMenu = textStyleMenu(self, self.target, self.residMode)
      self.hLayout4.addWidget(self.textStyleMenu)

      # put declustering control
      if(not self.residMode):
        index = self.parent.parent.data.index(self.target)
        self.displayDeclusterButton = QPushButtonCheckable()
        self.displayDeclusterButton.setText('Data Operations \u25be')
        self.displayDeclusterButton.setChecked(self.parent.displayDeclusterConfig)
        self.vLayout.addWidget(self.displayDeclusterButton)
  
        self.declusterRow = QWidgetMac()
        self.vLayout2 = QtWidgets.QVBoxLayout(self.declusterRow)
        self.vLayout2.setContentsMargins(0, 0, 0, 0)
        self.vLayout.addWidget(self.declusterRow)
        self.displayDeclusterButton.clicked.connect(partial(self.toggleDisplay, self.displayDeclusterButton, self.declusterRow, 'displayDeclusterConfig'))
        self.toggleDisplay(button=self.displayDeclusterButton, target=self.declusterRow, flag='displayDeclusterConfig')
  
        self.declusterInnerRow = QWidgetMac()
        self.vLayout2.addWidget(self.declusterInnerRow)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.declusterInnerRow)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.declusterButton = QPushButtonMac()
        self.declusterButton.setText('Decluster')
        self.declusterButton.setToolTip('Move apart data points (swarm plot)')
        self.declusterButton.setMaximumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.declusterButton.setMinimumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.declusterButton.clicked.connect(partial(self.declusterData, index))
        self.hLayout5.addWidget(self.declusterButton)
        
        self.declusterTolXLabel = QtWidgets.QLabel('Tol. ' + u'\N{GREEK CAPITAL LETTER DELTA}' + 'x')
        self.declusterTolXLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.declusterTolXLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.declusterTolXLabel)
        self.declusterTolXEntry = QLineEditClick()
        self.declusterTolXEntry.setToolTip('Tolerance in x for data declustering')
        self.declusterTolXEntry.setText(str(self.parent.declusterTolX))
        self.declusterTolXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolXEntry.editingFinished.connect(partial(self.changeTol, self.declusterTolXEntry, 1e-9, 1e9))
        self.declusterTolXEntry.setValidator(self.validFloat)
        self.hLayout5.addWidget(self.declusterTolXEntry)
  
        self.declusterTolYLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}' + 'y')
        self.declusterTolYLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
        self.declusterTolYLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.declusterTolYLabel)
        self.declusterTolYEntry = QLineEditClick()
        self.declusterTolYEntry.setToolTip('Tolerance in y for data declustering')
        self.declusterTolYEntry.setText(str(self.parent.declusterTolY))
        self.declusterTolYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolYEntry.editingFinished.connect(partial(self.changeTol, self.declusterTolYEntry, 1e-9, 1e9))
        self.declusterTolYEntry.setValidator(self.validFloat)
        self.hLayout5.addWidget(self.declusterTolYEntry)
        self.hLayout5.addStretch()
        
        self.guessDeclusterTol(index)

        blah = self.HLine()
        self.vLayout2.addWidget(blah)
        
        self.declusterInnerRow2 = QWidgetMac()
        self.vLayout2.addWidget(self.declusterInnerRow2)
        self.hLayout6 = QtWidgets.QHBoxLayout(self.declusterInnerRow2)
        self.hLayout6.setContentsMargins(0, 0, 0, 0)
        self.mergeButton = QPushButtonMac()
        self.mergeButton.setText('Merge with')
        self.mergeButton.setToolTip('Combine current and selected data sets into new merged one')
        self.mergeButton.setMaximumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.mergeButton.setMinimumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.mergeButton.clicked.connect(partial(self.mergeData, index))
        self.hLayout6.addWidget(self.mergeButton)
        
        self.dataSetSelector = QComboBoxMac()
        self.dataSetSelector.setToolTip('Data set to be merged')
        self.hLayout6.addWidget(self.dataSetSelector)
        self.dataSetSelector.setMaximumHeight(scaledDPI(BASE_SIZE))
        self.dataSetSelector.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
        self.hLayout6.addStretch()
        
        self.updateDataSetSelector(targetIndex=index)

    # set plot interval configuration
    if(self.target in self.parent.parent.fit):
      # generate row
      self.displayIntervalButton = QPushButtonCheckable()
      self.displayIntervalButton.setText('Configure Plot Interval \u25be')
      self.displayIntervalButton.setChecked(self.parent.displayIntervalConfig)
      self.vLayout.addWidget(self.displayIntervalButton)

      self.intervalRow = QWidgetMac()
      self.vLayout.addWidget(self.intervalRow)
      self.hLayout6 = QtWidgets.QHBoxLayout(self.intervalRow)
      self.hLayout6.setContentsMargins(0, 0, 0, 0)

      self.displayIntervalButton.clicked.connect(partial(self.toggleDisplay, self.displayIntervalButton, self.intervalRow, 'displayIntervalConfig'))
      self.toggleDisplay(button=self.displayIntervalButton, target=self.intervalRow, flag='displayIntervalConfig')

      # controls for limiting plot interval
      restrictMeLow, restrictMeHigh, restrictLow, restrictHigh = self.target.getRestricted()
      if(not restrictMeLow):
        if(self.parent.parent.plotArea.splitShow):
          restrictLow = np.min((self.parent.parent.plotArea.minX, self.parent.parent.plotArea.maxX, self.parent.parent.plotArea.minX_div, self.parent.parent.plotArea.maxX_div))
        else:
          restrictLow = np.min((self.parent.parent.plotArea.minX, self.parent.parent.plotArea.maxX))
      if(not restrictMeHigh):
        if(self.parent.parent.plotArea.splitShow):
          restrictHigh = np.max((self.parent.parent.plotArea.minX, self.parent.parent.plotArea.maxX, self.parent.parent.plotArea.minX_div, self.parent.parent.plotArea.maxX_div))
        else:
          restrictHigh = np.max((self.parent.parent.plotArea.minX, self.parent.parent.plotArea.maxX))
      self.labelDisplayIntervalLow = QPushButtonCheckable()
      self.labelDisplayIntervalLow.setText('Limit min?')
      self.labelDisplayIntervalLow.setToolTip('Restrict lower boundary of interval over which curve is plotted')
      self.labelDisplayIntervalLow.setChecked(restrictMeLow)
      self.labelDisplayIntervalLow.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalLow.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalLow.clicked.connect(partial(self.toggleRestricted, False))
      self.hLayout6.addWidget(self.labelDisplayIntervalLow)
      self.entryDisplayIntervalLow = QLineEditClick()
      self.entryDisplayIntervalLow.setToolTip('Lower limit of plot interval')
      self.entryDisplayIntervalLow.setText(str(restrictLow))
      self.entryDisplayIntervalLow.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalLow.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalLow.editingFinished.connect(partial(self.changeRestricted, 'restrictLow', self.entryDisplayIntervalLow, None, None))
      self.hLayout6.addWidget(self.entryDisplayIntervalLow)

      self.labelDisplayIntervalHigh = QPushButtonCheckable()
      self.labelDisplayIntervalHigh.setText('Limit max?')
      self.labelDisplayIntervalHigh.setToolTip('Restrict upper boundary of interval over which curve is plotted')
      self.labelDisplayIntervalHigh.setChecked(restrictMeHigh)
      self.labelDisplayIntervalHigh.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalHigh.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalHigh.clicked.connect(partial(self.toggleRestricted, True))
      self.hLayout6.addWidget(self.labelDisplayIntervalHigh)
      self.entryDisplayIntervalHigh = QLineEditClick()
      self.entryDisplayIntervalHigh.setToolTip('Upper limit of plot interval')
      self.entryDisplayIntervalHigh.setText(str(restrictHigh))
      self.entryDisplayIntervalHigh.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalHigh.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalHigh.editingFinished.connect(partial(self.changeRestricted, 'restrictHigh', self.entryDisplayIntervalHigh, None, None))
      self.hLayout6.addWidget(self.entryDisplayIntervalHigh)
      self.hLayout6.addStretch()
  
      self.updateRestrictedFields(restrictMeLow, high=False)
      self.updateRestrictedFields(restrictMeHigh, high=True)
      
    self.setFocus()    
    self.focusNextChild()

  def mergeData(self, targetIndex):
    # merges data of selected data set into current data set
    mergeIndex = self.dataSetSelector.currentText()
    mergeIndex = int(mergeIndex.split('-')[0]) - 1
    mergeData = self.parent.parent.data[mergeIndex].value()
    sourceData = self.parent.parent.data[targetIndex].value()
    sourceRoles, mergeRoles = list(sourceData.keys()), list(mergeData.keys())
    
    if(not len(mergeRoles)):
      self.parent.parent.statusbar.showMessage('Data set to be merged contains no data, won\'t merge!', self.parent.parent.STATUS_TIME)
    else:
      if(not len(sourceRoles)):
        # okay, this is easy -- source data set is empty just copy the merge data
        combinedData = mergeData
      else:
        allRoles = list(set(sourceRoles + mergeRoles))
        # expand data sets prior to merger?
        defaultValues = {'xerr': 0.0, 'yerr': 0.0, 'labels': '', 'fval': 0.0, 'resid': 0.0, 'x': 0.0, 'y': 0.0}
        missingRoles = [i for i in allRoles if (not i in sourceRoles)]
        # expand source data set by needed columns
        length = len(sourceData[sourceRoles[0]])
        for entry in missingRoles:
          sourceData[entry] = [defaultValues[entry] for i in range(length)]
        # now append merge data set
        length = len(mergeData[mergeRoles[0]])
        for entry in sourceData:
          if(entry in mergeData):
            sourceData[entry] = np.hstack((sourceData[entry], mergeData[entry]))
          else:
            sourceData[entry] = np.hstack((sourceData[entry], np.array([defaultValues[entry] for i in range(length)])))
        combinedData = sourceData
        
      # now generate a new data set for the merged data
      newData, newRoles = [], []
      for key in combinedData:
        newRoles.append(key)
        if(len(newData)):
          newData = np.vstack((newData, combinedData[key]))
        else:
          newData = combinedData[key]
      newData = np.transpose(newData)

      self.parent.parent.data.append(DataObject(self.parent.parent))
      self.parent.parent.data[-1].setName('Merger_' + self.parent.parent.data[targetIndex].name)
      self.parent.parent.data[-1].setNameResid('Merger_' + self.parent.parent.data[targetIndex].nameResid)
      # need to copy contents of original object
      self.parent.parent.data[-1].spawned(self.parent.parent.data[targetIndex])
      # hide merged data set
      self.parent.parent.data[mergeIndex].setVisibility(False, redraw=False)
      self.parent.parent.data[mergeIndex].setVisibilityResid(False, redraw=False)
      # a number of calls to update plots
      # note that the subsequent call to setData() deliberately ignores fval and resid (although we extended them above)
      # this may be changed in the future, hence the assignment
      self.helperDeclusterAndMerge(sourceIndex=targetIndex, newData=newData, newRoles=newRoles)
      # give voice
      self.parent.parent.statusbar.showMessage('Generated merged data set, while preserving original data sets.', self.parent.parent.STATUS_TIME, color='blue')
      # close menu
      self.close()
    
  def updateDataSetSelector(self, targetIndex):
    # populates and updates the QCombobox data set selector
    items = [entry for entry in self.parent.parent.data]
    self.dataSetSelector.clear()
    for index, item in enumerate(items):
      if(index != targetIndex):
        self.dataSetSelector.addItem(str(index + 1) + ' - ' + item.name)
        
    # do we have any items?
    if(self.dataSetSelector.count()):
      self.dataSetSelector.setEnabled(True)
      self.mergeButton.setEnabled(True)
    else:
      self.dataSetSelector.setEnabled(False)
      self.mergeButton.setEnabled(False)

  def toggleRestricted(self, high=False):
    # toggles restriction of plot intervall
    if(high):
      state = self.labelDisplayIntervalHigh.isChecked()
    else:
      state = self.labelDisplayIntervalLow.isChecked()
    self.updateRestrictedFields(state, high=high)

    if(high):
      if(not state):
        self.target.setRestricted('restrictMeHigh', state, redraw=True)
      else:
        self.target.setRestricted('restrictMeHigh', state, redraw=False)
        self.changeRestricted(key='restrictHigh', entryfield=self.entryDisplayIntervalHigh, minval=None, maxval=None)
    else:
      if(not state):
        self.target.setRestricted('restrictMeLow', state, redraw=True)
      else:
        self.target.setRestricted('restrictMeLow', state, redraw=False)
        self.changeRestricted(key='restrictLow', entryfield=self.entryDisplayIntervalLow, minval=None, maxval=None)

  def updateRestrictedFields(self, state, high=False):
    # changes activity of entry fields for plot interval control
    if(high):
      item = self.entryDisplayIntervalHigh
    else:
      item = self.entryDisplayIntervalLow
    if(hasattr(item, 'setEnabled')):
      item.setEnabled(state)

  def changeRestricted(self, key=None, entryfield=None, minval=0, maxval=1):
    if((self.target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      if(maxval != None):
        value = np.min((value, maxval))
      if(minval != None):
        value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))

      self.target.setRestricted(key, value, redraw=True)
    
  def toggleDisplay(self, button=None, target=None, flag=None):
    # toggles visibility of submenus
    if((button != None) and (target != None)):
      if(button.isChecked()):
        target.show()
        if((flag != None) and (hasattr(self.parent, flag))):
          self.parent.__dict__[flag] = True
      else:
        target.hide()
        if((flag != None) and (hasattr(self.parent, flag))):
          self.parent.__dict__[flag] = False
      self.adjustSize()

  def makeActive(self, leader, index):
    field = None
    if(leader.startswith('Data')):
      if(index != self.parent.parent.activeData):
        if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
          field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 1)
    elif(leader.startswith('Curve')):
      if(index != self.parent.parent.activeFit):
        if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
          field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 1)
    
    if(field != None):
      field.setChecked(True)
    self.activeButton.setEnabled(False)

  def alterZ(self, leader, index, direction):
    field = None
    if(leader.startswith('Data')):
      if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
        field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 2)
    elif(leader.startswith('Curve')):
      if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
        field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 2)
    elif(leader.startswith('Resid')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index + 1, 2)
    elif(leader.startswith('Zero Line')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index, 2)

    if(field != None):
      value, minimum, maximum = field.value(), field.minimum(), field.maximum()
      newValue = value + direction
      newValue = max(minimum, newValue)
      newValue = min(maximum, newValue)
      # set new value
      if(newValue != value):
        field.setValue(newValue)
      # (in)activate control buttons
      if(newValue == minimum):
        self.zDownButton.setEnabled(False)
      else:
        self.zDownButton.setEnabled(True)
      if(newValue == maximum):
        self.zUpButton.setEnabled(False)
      else:
        self.zUpButton.setEnabled(True)

  def setField(self, leader, index):
    text = self.entryField.text()
    field = None
    if(leader.startswith('Data')):
      if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
        field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 3)
    elif(leader.startswith('Curve')):
      if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
        field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 3)
    elif(leader.startswith('Resid')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index + 1, 3)
        
    if(field != None):
      field.setText(text)
      field.editingFinished.emit()

  def guessDeclusterTol(self, index):
    # proposes tolerances for declustering in x and y
    scaleMarker = 1.1
    currWidth, currHeight = 72.0 * self.parent.parent.plotArea.matplot.get_size_inches()
    if(self.parent.parent.data[index].handleData != None):
      markersize = self.parent.parent.data[index].handleData.get_markersize() + self.parent.parent.data[index].handleData.get_markeredgewidth()
      fractionWidth , fractionHeight = currWidth / markersize, currHeight / markersize
      absoluteWidth = scaleMarker * abs(self.parent.parent.plotArea.maxX - self.parent.parent.plotArea.minX) / fractionWidth
      absoluteHeight = scaleMarker * abs(self.parent.parent.plotArea.maxY - self.parent.parent.plotArea.minY) / fractionHeight
      # update tolerances
      self.parent.declusterTolX, self.parent.declusterTolY = absoluteWidth, absoluteHeight
      self.declusterTolXEntry.setText(self.parent.parent.formatNumber(absoluteWidth))
      self.declusterTolYEntry.setText(self.parent.parent.formatNumber(absoluteHeight))

  def declusterData(self, index):
    # declusters data in swarmplot fashion
    deltaX, deltaY = self.parent.declusterTolX, self.parent.declusterTolY
    data = self.parent.parent.data[index].value()
    if(('x' in data) and ('y' in data)):
      # implement option to terminate declustering if stalled
      self.runFlag, self.fev = True, 0
      self.daughterWindow = MinWindow(self, 'Decluster Data')
      # apply styles to popup window
      if(QSTYLE != None):
        self.daughterWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.daughterWindow.setStyleSheet(QSTYLESHEET)
      self.daughterWindow.show()
      self.daughterWindow.messageLabel.setText('')
      self.daughterWindow.iterLabel.setText('no. data points: ' + str(len(data['x'])))
      useData = np.vstack((data['x'], data['y']))
      # loop through data array
      dataChanged, initialSign = False, 1.0
      for line in range(1, len(data['x'])):
        if(self.daughterWindow != None):
          self.daughterWindow.minLabel.setText('current data point: ' + str(line))
        currX, currY = useData[0, line], useData[1, line]
        currDeltaX, initCycle = 0, True
        collisionCheck = True
        while(collisionCheck and self.runFlag):
          collisionCheck, line2 = False, 0
          # adjust delta for current cycle
          if(initCycle):
            initCycle = False
          elif(currDeltaX > 0):
            currDeltaX = -currDeltaX
          else:
            currDeltaX = -currDeltaX + deltaX
          # check for data points spaced too closely
          while(line2 < line):
            if(not (self.fev % 100)):
              QtCore.QCoreApplication.processEvents()
            self.fev += 1
            normDistance = ((useData[0, line2] - currX - initialSign * currDeltaX) / deltaX) ** 2 + ((useData[1, line2] - currY) / deltaY) ** 2
            if(normDistance <= 1.0):
              collisionCheck = True
              line2 = line
            else:
              line2 += 1
        
        # okay, either we did not find a collision or we adjusted delta accordingly
        if(abs(currDeltaX) > 0):
          useData[0, line] += initialSign * currDeltaX
          dataChanged = True
          initialSign *= -1.0
      
      # create declustered data object and plot
      if(not self.runFlag):
        self.parent.parent.statusbar.showMessage('Declustering data aborted by user.', self.parent.parent.STATUS_TIME)
      elif(dataChanged):
        data['x'], data['y'] = useData[0], useData[1]
        newData, newRoles = [], []
        for key in data:
          newRoles.append(key)
          if(len(newData)):
            newData = np.vstack((newData, data[key]))
          else:
            newData = data[key]
        newData = np.transpose(newData)

        self.parent.parent.data.append(DataObject(self.parent.parent))
        self.parent.parent.data[-1].setName('Decluster_' + self.parent.parent.data[index].name)
        self.parent.parent.data[-1].setNameResid('Decluster_' + self.parent.parent.data[index].nameResid)
        # need to copy contents of original object
        self.parent.parent.data[-1].spawned(self.parent.parent.data[index])
        # turn off violin/box display in newly generated object to prevent ungodly mess
        self.parent.parent.data[-1].Violinstyle['mode'] = 0
        # a number of calls to update plots
        self.helperDeclusterAndMerge(sourceIndex=index, newData=newData, newRoles=newRoles)
        # give voice
        self.parent.parent.statusbar.showMessage('Generated declustered copy of data set, while preserving original one.', self.parent.parent.STATUS_TIME, color='blue')
        # close menu
        self.close()
      else:
        self.parent.parent.statusbar.showMessage('No data found that would need declustering!', self.parent.parent.STATUS_TIME, color='blue')

      # clean up as needed
      if(self.daughterWindow != None):
        self.daughterWindow.close()
        self.daughterWindow = None
    else:
      self.parent.parent.statusbar.showMessage('Cannot decluster because x and/or y data missing!', self.parent.parent.STATUS_TIME)

  def helperDeclusterAndMerge(self, sourceIndex, newData, newRoles):
    # jointly issued calls by declusterData() and mergeData()
    # update data in new object
    self.parent.parent.data[-1].setData(newData, newRoles, labels=self.parent.parent.data[-1].labels)
    # set new data object as active
    self.parent.parent.activeData = (len(self.parent.parent.data) - 1)
    self.parent.changeActiveDataSet(len(self.parent.parent.data) - 1, setCheck=False, redraw=False)
    # hide original data set
    self.parent.parent.data[sourceIndex].setVisibility(False, redraw=False)
    self.parent.parent.data[sourceIndex].setVisibilityResid(False, redraw=False)
    # cause data to be drawn
    self.parent.parent.data[-1].drawMe(redraw=False)
    self.parent.refreshDataTable()
    self.parent.dataSetTable.scrollToBottom()
    # also create a new resid object
    self.parent.parent.plotArea.setAxisLimits(lower=self.parent.parent.plotArea.minX, upper=self.parent.parent.plotArea.maxX, axis='x', updateLabel=False, target='resid', redraw=False, updateGrid=True)
    self.parent.parent.plotArea.setAxisLimits(lower=self.parent.parent.plotArea.minX_div, upper=self.parent.parent.plotArea.maxX_div, axis='x2', updateLabel=False, target='resid', redraw=False, updateGrid=True)
    self.parent.parent.data[-1].drawMeResid(redraw=False)
    self.parent.parent.plotArea.handleResidZero = self.parent.parent.plotArea.plotResidZero(self.parent.parent.plotArea.handleResidZero, redraw=True)
    self.parent.refreshResidTable()
    self.parent.residTable.scrollToBottom()
    # also refresh curves table to account for increased total number of items
    self.parent.refreshCurvesTable()
    self.parent.refreshExtrasTable()
    self.parent.parent.globalarea.updateDataSetTable()
    # update results table
    self.parent.parent.resultsarea.setDataSet(currIndex=len(self.parent.parent.data) - 1, maxIndex=len(self.parent.parent.data) - 1)
    # redraw active curve over current x interval
    self.parent.parent.fit[self.parent.parent.activeFit].drawMe(redraw=False, rescale=False)
    # update legend if needed
    self.parent.updateLegend(redraw=True)

  def changeTol(self, entryfield=None, minval=0, maxval=1):
    # check paramter boundaries
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
    # update parameters in parent object
    if(entryfield == self.declusterTolXEntry):
      self.parent.declusterTolX = value
    else:
      self.parent.declusterTolY = value

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class GraphicsArea(QWidgetMac):
  def __init__(self, parent=None, secondAxes=False):
    super(GraphicsArea, self).__init__()
    self.parent = parent
    self.secondAxes = secondAxes
    
    # initial export filter
    self.exportFilter = ''
    
    # initialize filenames
    self.currStyleFile = None
    self.currExportFile = None
    
    # advanced export settings
    self.advancedExport = {'plotDPI': 600, 'plotResid': True, 'SVGtxt2path': False, 'advancedGraphics': False, 'stateFileFormat': 'statez'}
    
    # int and float validators
    self.validInt = MyValidInt()
    self.validFloat = MyValidFloat()

    # set up styles
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.positionstyles = ['axes', 'data']
    # linestyles for graphics elements that do not heed 'None' (e.g. axis spines)
    self.linestyles2 = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # set up GUI
    self.advancedGraphicsSettings = []
    self.buildRessource()
    # now populate fields
    self.updateFields(initialize=True)
    # and connect events
    self.connectEvents()

  def buildRessource(self):
    # build gui
    self.vLayout_0 = QtWidgets.QVBoxLayout(self)
    self.vLayout_0.setContentsMargins(0, 0, 0, 0)
    self.vLayout_0.setAlignment(QtCore.Qt.AlignTop)
    
    # container widget for subsequent widgets
    self.containerScroll = QtWidgets.QScrollArea()
    self.containerScroll.setWidgetResizable(True)
    # don't use palettes as these are incompatible with style sheets
    self.containerScroll.setAutoFillBackground(True)
    self.vLayout_0.addWidget(self.containerScroll)

    self.containerBox = QWidgetMac()
    # setting the background somehow breaks QStyleSet for children :(
    #self.containerBox.setStyleSheet('#stultus {background-color: white;}')
    self.containerBox.setAutoFillBackground(True)
    self.vLayout = QtWidgets.QVBoxLayout(self.containerBox)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setSpacing(scaledDPI(3))
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.containerScroll.setWidget(self.containerBox)
    
    # x label config
    self.alignHorizontal = ['left', 'center', 'right']
    self.alignVertical = ['top', 'center', 'bottom', 'baseline']
    if(not self.secondAxes):
      self.configXBox = QWidgetMac()
      self.vLayout.addWidget(self.configXBox)
      self.Layout_configX = QtWidgets.QHBoxLayout(self.configXBox)
      self.Layout_configX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX.setAlignment(QtCore.Qt.AlignLeft)
      self.configXLabel = QPushButtonCheckable()
      self.configXLabel.setText('x label')
      self.configXLabel.setToolTip('Show x axis label')
      self.configXLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configXLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configX.addWidget(self.configXLabel)
      self.configXName = QLineEditClick()
      self.configXName.setToolTip('Set x axis label')
      self.configXName.setAlignment(QtCore.Qt.AlignLeft)
      self.configXName.setMaximumSize(QtCore.QSize(scaledDPI(298), scaledDPI(BASE_SIZE)))
      self.configXName.setMinimumSize(QtCore.QSize(scaledDPI(298), scaledDPI(BASE_SIZE)))
      self.Layout_configX.addWidget(self.configXName)
  
      # x label config 2nd line
      self.configXBox2 = QWidgetMac()
      self.vLayout.addWidget(self.configXBox2)
      self.Layout_configX2 = QtWidgets.QHBoxLayout(self.configXBox2)
      self.Layout_configX2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(spacer)
      
      self.configXSizeLabel = QtWidgets.QLabel('font')
      self.configXSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configXSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(self.configXSizeLabel)
      self.configXColorButton = QPushButtonColor()
      self.configXColorButton.setToolTip('Color of x axis label')
      self.configXColorButton.setAutoFillBackground(False)
      self.configXColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configX2.addWidget(self.configXColorButton)

      self.configXSize = QDoubleSpinClick()
      self.Layout_configX2.addWidget(self.configXSize)
      self.configXSize.setMinimum(0.0)
      self.configXSize.setMaximum(100.0)
      self.configXSize.setToolTip('Font size of x axis object')
      self.configXSize.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configXSize.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      
      self.configXBold = QPushButtonCheckable()
      self.configXBold.setText('B')
      self.configXBold.setToolTip('Font weight of x axis label')
      self.configXBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configXBold.font()
      useFont.setWeight(75)
      self.configXBold.setFont(useFont)
      self.Layout_configX2.addWidget(self.configXBold)
        
      self.configXItalic = QPushButtonCheckable()
      self.configXItalic.setText('I')
      self.configXItalic.setToolTip('Font style of x axis label')
      self.configXItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configXItalic.font()
      useFont.setItalic(True)
      self.configXItalic.setFont(useFont)
      self.Layout_configX2.addWidget(self.configXItalic)
      
      if(0):
        # unfortunately not supported by matplotlib currently (this is a known bug)
        self.configXVariant = QPushButtonCheckable()
        self.configXVariant.setText('Aa')
        self.configXVariant.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configXVariant.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        useFont = self.configXVariant.font()
        useFont.setCapitalization(QtGui.QFont.SmallCaps)
        self.configXVariant.setFont(useFont)
        self.Layout_configX2.addWidget(self.configXVariant)
  
      self.configXFont = QComboBoxMac()
      self.configXFont.setToolTip('Font of x axis label')
      self.configXFont.addItems(self.parent.fontNames)
      self.configXFont.setMaximumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.configXFont.setMinimumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(self.configXFont)
  
      # x label config 3rd line
      self.configXBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configXBox3)
      self.vLayout.addWidget(self.configXBox3)
      self.Layout_configX3 = QtWidgets.QHBoxLayout(self.configXBox3)
      self.Layout_configX3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(spacer)
      
      self.configXAngleLabel = QtWidgets.QLabel('angle')
      self.configXAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configXAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAngleLabel)

      self.configXAngle = QDoubleSpinClick()
      self.Layout_configX3.addWidget(self.configXAngle)
      self.configXAngle.setMinimum(0.0)
      self.configXAngle.setMaximum(360.0)
      self.configXAngle.setToolTip('Angle of x axis label')
      self.configXAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configXAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configXAngle.setSingleStep(10)
      self.configXAngle.setWrapping(True)
      self.configXAngle.setAdaptive(False)
  
      self.configXAlignmentLabel = QtWidgets.QLabel('align')
      self.configXAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.configXAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignmentLabel)
  
      self.configXAlignment = QComboBoxMac()
      self.configXAlignment.setToolTip('Horizontal alignment of x axis label')
      self.configXAlignment.addItems(self.alignHorizontal)
      self.configXAlignment.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configXAlignment.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignment)
  
      self.configXAlignmentVertical = QComboBoxMac()
      self.configXAlignmentVertical.setToolTip('Vertical alignment of x axis label')
      self.configXAlignmentVertical.addItems(self.alignVertical)
      self.configXAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configXAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignmentVertical)
  
      self.configXPosLabel = QtWidgets.QLabel('pos.')
      self.configXPosLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.configXPosLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXPosLabel)
  
      self.configXPos = QLineEditClick()
      self.configXPos.setToolTip('Relative position of x axis label')
      self.configXPos.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPos.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPos.setValidator(self.validFloat)
      self.Layout_configX3.addWidget(self.configXPos)
  
      self.configXPadLabel = QtWidgets.QLabel('pad')
      self.configXPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configXPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXPadLabel)
  
      self.configXPad = QLineEditClick()
      self.configXPad.setToolTip('Padding of x axis label')
      self.configXPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPad.setValidator(self.validFloat)
      self.Layout_configX3.addWidget(self.configXPad)

    # y label config
    self.configYBox = QWidgetMac()
    self.vLayout.addWidget(self.configYBox)
    self.Layout_configY = QtWidgets.QHBoxLayout(self.configYBox)
    self.Layout_configY.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY.setAlignment(QtCore.Qt.AlignLeft)
    self.configYLabel = QPushButtonCheckable()
    if(self.secondAxes):
      self.configYLabel.setText('y2 label')
      self.configYLabel.setToolTip('Show y2 axis label')
    else:
      self.configYLabel.setText('y label')
      self.configYLabel.setToolTip('Show y axis label')
    self.configYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configY.addWidget(self.configYLabel)
    self.configYName = QLineEditClick()
    if(self.secondAxes):
      self.configYName.setToolTip('Set y2 axis label')
    else:
      self.configYName.setToolTip('Set y axis label')
    self.configYName.setAlignment(QtCore.Qt.AlignLeft)
    self.configYName.setMaximumSize(QtCore.QSize(scaledDPI(298), scaledDPI(BASE_SIZE)))
    self.configYName.setMinimumSize(QtCore.QSize(scaledDPI(298), scaledDPI(BASE_SIZE)))
    self.Layout_configY.addWidget(self.configYName)

    # y label config 2nd line
    self.configYBox2 = QWidgetMac()
    self.vLayout.addWidget(self.configYBox2)
    self.Layout_configY2 = QtWidgets.QHBoxLayout(self.configYBox2)
    self.Layout_configY2.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY2.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(spacer)
    
    self.configYSizeLabel = QtWidgets.QLabel('font')
    self.configYSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configYSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(self.configYSizeLabel)
    self.configYColorButton = QPushButtonColor()
    if(self.secondAxes):
      self.configYColorButton.setToolTip('Color of y2 axis label')
    else:
      self.configYColorButton.setToolTip('Color of y axis label')
    self.configYColorButton.setAutoFillBackground(False)
    self.configYColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.Layout_configY2.addWidget(self.configYColorButton)

    self.configYSize = QDoubleSpinClick()
    self.Layout_configY2.addWidget(self.configYSize)
    self.configYSize.setMinimum(0.0)
    self.configYSize.setMaximum(100.0)
    if(self.secondAxes):
      self.configYSize.setToolTip('Font size of y2 axis label')
    else:
      self.configYSize.setToolTip('Font size of y axis label')
    self.configYSize.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.configYSize.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))

    self.configYBold = QPushButtonCheckable()
    self.configYBold.setText('B')
    if(self.secondAxes):
      self.configYBold.setToolTip('Font weight of y2 axis label')
    else:
      self.configYBold.setToolTip('Font weight of y axis label')
    self.configYBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configYBold.font()
    useFont.setWeight(75)
    self.configYBold.setFont(useFont)
    self.Layout_configY2.addWidget(self.configYBold)
      
    self.configYItalic = QPushButtonCheckable()
    self.configYItalic.setText('I')
    if(self.secondAxes):
      self.configYItalic.setToolTip('Font style of y2 axis label')
    else:
      self.configYItalic.setToolTip('Font style of y axis label')
    self.configYItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configYItalic.font()
    useFont.setItalic(True)
    self.configYItalic.setFont(useFont)
    self.Layout_configY2.addWidget(self.configYItalic)

    if(0):
      # unfortunately not supported by matplotlib currently (this is a known bug)
      self.configYVariant = QPushButtonCheckable()
      self.configYVariant.setText('Aa')
      self.configYVariant.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configYVariant.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configYVariant.font()
      useFont.setCapitalization(QtGui.QFont.SmallCaps)
      self.configYVariant.setFont(useFont)
      self.Layout_configY2.addWidget(self.configYVariant)

    self.configYFont = QComboBoxMac()
    if(self.secondAxes):
      self.configYFont.setToolTip('Font of y2 axis label')
    else:
      self.configYFont.setToolTip('Font of y axis label')
    self.configYFont.addItems(self.parent.fontNames)
    self.configYFont.setMaximumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
    self.configYFont.setMinimumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(self.configYFont)

    # y label config 2nd line
    self.configYBox3 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configYBox3)
    self.vLayout.addWidget(self.configYBox3)
    self.Layout_configY3 = QtWidgets.QHBoxLayout(self.configYBox3)
    self.Layout_configY3.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY3.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(spacer)
    
    self.configYAngleLabel = QtWidgets.QLabel('angle')
    self.configYAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configYAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAngleLabel)

    self.configYAngle = QDoubleSpinClick()
    self.Layout_configY3.addWidget(self.configYAngle)
    self.configYAngle.setMinimum(0.0)
    self.configYAngle.setMaximum(360.0)
    if(self.secondAxes):
      self.configYAngle.setToolTip('Angle of y2 axis label')
    else:
      self.configYAngle.setToolTip('Angle of y axis label')
    self.configYAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configYAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configYAngle.setSingleStep(10)
    self.configYAngle.setWrapping(True)
    self.configYAngle.setAdaptive(False)
    
    self.configYAlignmentLabel = QtWidgets.QLabel('align')
    self.configYAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.configYAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignmentLabel)

    self.configYAlignment = QComboBoxMac()
    if(self.secondAxes):
      self.configYAlignment.setToolTip('Horizontal alignment of y2 axis label')
    else:
      self.configYAlignment.setToolTip('Horizontal alignment of y axis label')
    self.configYAlignment.addItems(self.alignHorizontal)
    self.configYAlignment.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.configYAlignment.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignment)

    self.configYAlignmentVertical = QComboBoxMac()
    if(self.secondAxes):
      self.configYAlignmentVertical.setToolTip('Vertical alignment of y2 axis label')
    else:
      self.configYAlignmentVertical.setToolTip('Vertical alignment of y axis label')
    self.configYAlignmentVertical.addItems(self.alignVertical)
    self.configYAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.configYAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignmentVertical)

    self.configYPosLabel = QtWidgets.QLabel('pos.')
    self.configYPosLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.configYPosLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYPosLabel)

    self.configYPos = QLineEditClick()
    if(self.secondAxes):
      self.configYPos.setToolTip('Relative position of y2 axis label')
    else:
      self.configYPos.setToolTip('Relative position of y axis label')
    self.configYPos.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPos.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPos.setValidator(self.validFloat)
    self.Layout_configY3.addWidget(self.configYPos)

    self.configYPadLabel = QtWidgets.QLabel('pad')
    self.configYPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.configYPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYPadLabel)

    self.configYPad = QLineEditClick()
    if(self.secondAxes):
      self.configYPad.setToolTip('Padding of y2 axis label')
    else:
      self.configYPad.setToolTip('Padding of y axis label')
    self.configYPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPad.setValidator(self.validFloat)
    self.Layout_configY3.addWidget(self.configYPad)

    # axis config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configAxisBox = {}; self.Layout_configAxis = {}
    self.configAxisLabel = {}
    self.configAxisWidthLabel = {}; self.configAxisWidth = {}
    self.configAxisStyle = {}; self.configAxisDashStyle = {}; self.configAxisColor = {}
    self.configAxisBox2 = {}; self.Layout_configAxis2 = {}
    self.configAxisLabel2 = {}; self.configAxisPosition = {};
    self.configAxisPositionValue = {}; self.configAxisPositionReset = {}
    self.configAxisBox3 = {}; self.Layout_configAxis3 = {}; self.configAxisLabel3 = {}
    self.configAxisBoundLabel = {}
    self.configAxisBoundLowerLabel = {}; self.configAxisBoundLower = {}
    self.configAxisBoundUpperLabel = {}; self.configAxisBoundUpper = {}
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configAxisBox[axis])
      self.Layout_configAxis[axis] = QtWidgets.QHBoxLayout(self.configAxisBox[axis])
      self.Layout_configAxis[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configAxis[axis].setAlignment(QtCore.Qt.AlignLeft)
      self.configAxisLabel[axis] = QPushButtonCheckable()
      self.configAxisLabel[axis].setText('ax ' + axis)
      self.configAxisLabel[axis].setToolTip('Show ' + axis + ' axis of plot')
      self.configAxisLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configAxisLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisLabel[axis])

      self.configAxisColor[axis] = QPushButtonColor()
      self.configAxisColor[axis].setToolTip('Color of ' + axis + ' axis')
      self.configAxisColor[axis].setAutoFillBackground(False)
      self.configAxisColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configAxisColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configAxisColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configAxis[axis].addWidget(self.configAxisColor[axis])
  
      self.configAxisWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configAxisWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configAxisWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisWidthLabel[axis])
      # line width spin box
      self.configAxisWidth[axis] = QDoubleSpinClick()
      self.Layout_configAxis[axis].addWidget(self.configAxisWidth[axis])
      self.configAxisWidth[axis].setMinimum(0.0)
      self.configAxisWidth[axis].setMaximum(100.0)
      self.configAxisWidth[axis].setToolTip('Line width of ' + axis + ' axis')
      self.configAxisWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))

      self.configAxisStyle[axis] = QComboBoxMac()
      self.configAxisStyle[axis].setToolTip('Line style of ' + axis + ' axis')
      self.configAxisStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAxisStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisStyle[axis])

      self.configAxisDashStyle[axis] = QComboBoxMac()
      self.configAxisDashStyle[axis].setToolTip('Cap style of ' + axis + ' axis')
      self.advancedGraphicsSettings.append(self.configAxisDashStyle[axis])
      self.configAxisDashStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configAxisDashStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisDashStyle[axis])
      
      # second row
      self.configAxisBox3[axis] = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configAxisBox3[axis])
      self.vLayout.addWidget(self.configAxisBox3[axis])
      self.Layout_configAxis3[axis] = QtWidgets.QHBoxLayout(self.configAxisBox3[axis])
      self.Layout_configAxis3[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configAxis3[axis].setAlignment(QtCore.Qt.AlignLeft)

      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis3[axis].addWidget(spacer)

      self.configAxisBoundLabel[axis] = QPushButtonCheckable()
      self.configAxisBoundLabel[axis].setText('boundary')
      self.configAxisBoundLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLabel[axis].setToolTip('Limit ' + axis + ' axis to boundaries')
      self.Layout_configAxis3[axis].addWidget(self.configAxisBoundLabel[axis])
      
      self.configAxisBoundLowerLabel[axis] = QtWidgets.QLabel('lower')
      self.configAxisBoundLowerLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLowerLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLowerLabel[axis].setToolTip('Lower boundary value of ' + axis + ' axis')
      self.Layout_configAxis3[axis].addWidget(self.configAxisBoundLowerLabel[axis])

      self.configAxisBoundLower[axis] = QLineEditClick()
      self.configAxisBoundLower[axis].setToolTip('Lower boundary value of ' + axis + ' axis')
      self.configAxisBoundLower[axis].setMaximumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLower[axis].setMinimumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisBoundLower[axis].setValidator(self.validFloat)
      self.Layout_configAxis3[axis].addWidget(self.configAxisBoundLower[axis])

      self.configAxisBoundUpperLabel[axis] = QtWidgets.QLabel('upper')
      self.configAxisBoundUpperLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAxisBoundUpperLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAxisBoundUpperLabel[axis].setToolTip('Upper boundary of ' + axis + ' axis')
      self.Layout_configAxis3[axis].addWidget(self.configAxisBoundUpperLabel[axis])

      self.configAxisBoundUpper[axis] = QLineEditClick()
      self.configAxisBoundUpper[axis].setToolTip('Upper boundary value of ' + axis + ' axis')
      self.configAxisBoundUpper[axis].setMaximumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisBoundUpper[axis].setMinimumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisBoundUpper[axis].setValidator(self.validFloat)
      self.Layout_configAxis3[axis].addWidget(self.configAxisBoundUpper[axis])

      # third row
      self.configAxisBox2[axis] = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configAxisBox2[axis])
      self.vLayout.addWidget(self.configAxisBox2[axis])
      self.Layout_configAxis2[axis] = QtWidgets.QHBoxLayout(self.configAxisBox2[axis])
      self.Layout_configAxis2[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configAxis2[axis].setAlignment(QtCore.Qt.AlignLeft)

      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(spacer)

      self.configAxisLabel2[axis] = QtWidgets.QLabel('position')
      self.configAxisLabel2[axis].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configAxisLabel2[axis].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(self.configAxisLabel2[axis])

      self.configAxisPosition[axis] = QComboBoxMac()
      self.configAxisPosition[axis].setToolTip('Positioning of ' + axis + ' axis')
      self.configAxisPosition[axis].setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configAxisPosition[axis].setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(self.configAxisPosition[axis])

      self.configAxisPositionValue[axis] = QLineEditClick()
      self.configAxisPositionValue[axis].setToolTip('Position value of ' + axis + ' axis')
      self.configAxisPositionValue[axis].setMaximumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisPositionValue[axis].setMinimumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configAxisPositionValue[axis].setValidator(self.validFloat)
      self.Layout_configAxis2[axis].addWidget(self.configAxisPositionValue[axis])

      self.configAxisPositionReset[axis] = QPushButtonMac('Reset')
      self.configAxisPositionReset[axis].setToolTip('Reset ' + axis + ' axis to default')
      self.configAxisPositionReset[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE - 2)))
      self.configAxisPositionReset[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE - 2)))
      self.configAxisPositionReset[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configAxis2[axis].addWidget(self.configAxisPositionReset[axis])
  
    # arrow config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    if(not self.secondAxes):
      self.configArrowBox, self.Layout_configArrow = {}, {}
      self.configArrowBox2, self.Layout_configArrow2 = {}, {}
      self.configArrowLabel = {}
      self.configArrowFillColorLabel, self.configArrowLineColorLabel = {}, {}
      self.configArrowLineColor, self.configArrowFillColor = {}, {}
      self.configArrowLineWidth, self.configArrowLineWidthLabel = {}, {}
      self.configArrowHeadLengthLabel, self.configArrowHeadLength = {}, {}
      self.configArrowHeadWidthLabel, self.configArrowHeadWidth = {}, {}
      self.configArrowOverhangLabel, self.configArrowOverhang = {}, {}
      self.configArrowOffsetLabel, self.configArrowOffset = {}, {}
      self.configArrowLocationLabel, self.configArrowLocation = {}, {}
      for axis in ['x', 'y']:
        self.configArrowBox[axis] = QWidgetMac()
        self.vLayout.addWidget(self.configArrowBox[axis])
        self.Layout_configArrow[axis] = QtWidgets.QHBoxLayout(self.configArrowBox[axis])
        self.Layout_configArrow[axis].setContentsMargins(0, 0, 0, 0)
        self.Layout_configArrow[axis].setAlignment(QtCore.Qt.AlignLeft)
        
        self.configArrowLabel[axis] = QPushButtonCheckable()
        self.configArrowLabel[axis].setText('arrow ' + axis)
        self.configArrowLabel[axis].setToolTip('Show ' + axis + ' arrow tip')
        self.configArrowLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
        self.configArrowLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowLabel[axis])

        self.configArrowFillColorLabel[axis] = QPushButtonCheckable()
        self.configArrowFillColorLabel[axis].setText('face')
        self.configArrowFillColorLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.configArrowFillColorLabel[axis].setToolTip('Fill face of ' + axis + ' arrow tip')
        self.Layout_configArrow[axis].addWidget(self.configArrowFillColorLabel[axis])
        self.configArrowFillColor[axis] = QPushButtonColor()
        self.configArrowFillColor[axis].setToolTip('Fill color of ' + axis + ' arrow tip')
        self.configArrowFillColor[axis].setAutoFillBackground(False)
        self.configArrowFillColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowFillColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowFillColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configArrow[axis].addWidget(self.configArrowFillColor[axis])

        self.configArrowLineColorLabel[axis] = QPushButtonCheckable()
        self.configArrowLineColorLabel[axis].setText('edge')
        self.configArrowLineColorLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.configArrowLineColorLabel[axis].setToolTip('Draw border of ' + axis + ' arrow tip')
        self.Layout_configArrow[axis].addWidget(self.configArrowLineColorLabel[axis])
        self.configArrowLineColor[axis] = QPushButtonColor()
        self.configArrowLineColor[axis].setToolTip('Line color of ' + axis + ' arrow tip')
        self.configArrowLineColor[axis].setAutoFillBackground(False)
        self.configArrowLineColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowLineColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowLineColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configArrow[axis].addWidget(self.configArrowLineColor[axis])
        
        self.configArrowLineWidthLabel[axis] = QtWidgets.QLabel('width')
        self.configArrowLineWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.configArrowLineWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowLineWidthLabel[axis])
        # line width spin box
        self.configArrowLineWidth[axis] = QDoubleSpinClick()
        self.Layout_configArrow[axis].addWidget(self.configArrowLineWidth[axis])
        self.configArrowLineWidth[axis].setMinimum(0.0)
        self.configArrowLineWidth[axis].setMaximum(100.0)
        self.configArrowLineWidth[axis].setToolTip('Edge width of ' + axis + ' arrow tip')
        self.configArrowLineWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.configArrowLineWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))

        # second row arrow config
        self.configArrowBox2[axis] = QWidgetMac()
        self.advancedGraphicsSettings.append(self.configArrowBox2[axis])
        self.vLayout.addWidget(self.configArrowBox2[axis])
        self.Layout_configArrow2[axis] = QtWidgets.QHBoxLayout(self.configArrowBox2[axis])
        self.Layout_configArrow2[axis].setContentsMargins(0, 0, 0, 0)
        self.Layout_configArrow2[axis].setAlignment(QtCore.Qt.AlignLeft)
        
        spacer = QtWidgets.QLabel()
        spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
        spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(spacer)

        self.configArrowHeadLengthLabel[axis] = QtWidgets.QLabel('length')
        self.configArrowHeadLengthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLengthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowHeadLengthLabel[axis])
        self.configArrowHeadLength[axis] = QLineEditClick()
        self.configArrowHeadLength[axis].setToolTip('Length of ' + axis + ' arrow tip')
        self.configArrowHeadLength[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLength[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLength[axis].setValidator(self.validFloat)
        self.Layout_configArrow2[axis].addWidget(self.configArrowHeadLength[axis])
        self.configArrowHeadWidthLabel[axis] = QtWidgets.QLabel('width')
        self.configArrowHeadWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(28), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(28), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowHeadWidthLabel[axis])
        self.configArrowHeadWidth[axis] = QLineEditClick()
        self.configArrowHeadWidth[axis].setToolTip('Width of ' + axis + ' arrow tip')
        self.configArrowHeadWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidth[axis].setValidator(self.validFloat)
        self.Layout_configArrow2[axis].addWidget(self.configArrowHeadWidth[axis])
  
        self.configArrowOverhangLabel[axis] = QtWidgets.QLabel('ind.')
        self.configArrowOverhangLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.configArrowOverhangLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowOverhangLabel[axis])
        self.configArrowOverhang[axis] = QLineEditClick()
        self.configArrowOverhang[axis].setToolTip('Indentation of ' + axis + ' arrow tip')
        self.configArrowOverhang[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOverhang[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOverhang[axis].setValidator(self.validFloat)
        self.Layout_configArrow2[axis].addWidget(self.configArrowOverhang[axis])
  
        self.configArrowOffsetLabel[axis] = QtWidgets.QLabel('offset')
        self.configArrowOffsetLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.configArrowOffsetLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowOffsetLabel[axis])
        self.configArrowOffset[axis] = QLineEditClick()
        self.configArrowOffset[axis].setToolTip('Offset of ' + axis + ' arrow tip')
        self.configArrowOffset[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOffset[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOffset[axis].setValidator(self.validFloat)
        self.Layout_configArrow2[axis].addWidget(self.configArrowOffset[axis])

        self.configArrowLocationLabel[axis] = QtWidgets.QLabel('locate')
        self.configArrowLocationLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.configArrowLocationLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowLocationLabel[axis])
        self.configArrowLocation[axis] = QComboBoxMac()
        self.configArrowLocation[axis].setToolTip('Location of ' + axis + ' arrow tip')
        self.configArrowLocation[axis].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
        self.configArrowLocation[axis].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow2[axis].addWidget(self.configArrowLocation[axis])

    # x ticks config
    self.formatOptions = ['default', 'float', 'scientific', 'mathtext']
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configTickXBox = QWidgetMac()
      self.vLayout.addWidget(self.configTickXBox)
      self.Layout_configTickX = QtWidgets.QHBoxLayout(self.configTickXBox)
      self.Layout_configTickX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXLabel = QPushButtonCheckable()
      self.configTickXLabel.setText('x ticks')
      self.configTickXLabel.setToolTip('Show x axis tick labels')
      self.configTickXLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickXLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXLabel)
      
      self.configTickXAuto = QPushButtonCheckable()
      self.configTickXAuto.setText('auto')
      self.configTickXAuto.setToolTip('Automatically set x axis ticks')
      self.configTickXAuto.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configTickXAuto.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXAuto)
          
      self.configTickXEntry = QLineEditClick()
      self.configTickXEntry.setToolTip('Values of x axis ticks')
      self.configTickXEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXEntry.setMaximumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.configTickXEntry.setMinimumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXEntry)
  
      self.configTickUseData = QPushButtonMac()
      self.configTickUseData.setText('labels')
      self.configTickUseData.setToolTip('Use data labels as x axis ticks')
      self.configTickUseData.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configTickUseData.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickUseData)
  
      # tick label formatting ctd.
      self.configTickXBox6 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox6)
      self.vLayout.addWidget(self.configTickXBox6)
      self.Layout_configTickX6 = QtWidgets.QHBoxLayout(self.configTickXBox6)
      self.Layout_configTickX6.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX6.setAlignment(QtCore.Qt.AlignLeft)

      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX6.addWidget(spacer)
      
      self.configMinorTickXLabel = QPushButtonCheckable()
      self.configMinorTickXLabel.setText('minor')
      self.configMinorTickXLabel.setToolTip('Show x axis minor ticks')
      self.configMinorTickXLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configMinorTickXLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX6.addWidget(self.configMinorTickXLabel)
      self.configMinorTickX = QComboBoxMac()
      self.configMinorTickX.setToolTip('Number of x axis minor ticks')
      for entry in [str(i + 1) for i in range(9)]:
        self.configMinorTickX.addItem(str(entry))
      self.configMinorTickX.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configMinorTickX.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX6.addWidget(self.configMinorTickX)

      self.configMinorTickXRelativeLengthLabel = QtWidgets.QLabel('rel length')
      self.configMinorTickXRelativeLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configMinorTickXRelativeLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX6.addWidget(self.configMinorTickXRelativeLengthLabel)
      self.configMinorTickXRelativeLength = QLineEditClick()
      self.configMinorTickXRelativeLength.setToolTip('Relative length of x axis minor ticks')
      self.configMinorTickXRelativeLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickXRelativeLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickXRelativeLength.setValidator(self.validFloat)
      self.Layout_configTickX6.addWidget(self.configMinorTickXRelativeLength)
      
      # font formatting
      self.configTickXBox3 = QWidgetMac()
      self.vLayout.addWidget(self.configTickXBox3)
      self.Layout_configTickX3 = QtWidgets.QHBoxLayout(self.configTickXBox3)
      self.Layout_configTickX3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(spacer)
      
      self.configTickXSizeLabel = QtWidgets.QLabel('font')
      self.configTickXSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickXSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(self.configTickXSizeLabel)
      self.configTickXColorButton = QPushButtonColor()
      self.configTickXColorButton.setToolTip('Color of x axis ticks')
      self.configTickXColorButton.setAutoFillBackground(False)
      self.configTickXColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configTickX3.addWidget(self.configTickXColorButton)
  
      self.configTickXSize = QDoubleSpinClick()
      self.Layout_configTickX3.addWidget(self.configTickXSize)
      self.configTickXSize.setMinimum(0.0)
      self.configTickXSize.setMaximum(100.0)
      self.configTickXSize.setToolTip('Font size of x axis ticks')
      self.configTickXSize.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configTickXSize.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
  
      self.configTickXBold = QPushButtonCheckable()
      self.configTickXBold.setText('B')
      self.configTickXBold.setToolTip('Font weight of x axis ticks')
      self.configTickXBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configTickXBold.font()
      useFont.setWeight(75)
      self.configTickXBold.setFont(useFont)
      self.Layout_configTickX3.addWidget(self.configTickXBold)
        
      self.configTickXItalic = QPushButtonCheckable()
      self.configTickXItalic.setText('I')
      self.configTickXItalic.setToolTip('Font style of x axis ticks')
      self.configTickXItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configTickXItalic.font()
      useFont.setItalic(True)
      self.configTickXItalic.setFont(useFont)
      self.Layout_configTickX3.addWidget(self.configTickXItalic)
  
      self.configTickXFont = QComboBoxMac()
      self.configTickXFont.setToolTip('Font of x axis ticks')
      self.configTickXFont.addItems(self.parent.fontNames)
      self.configTickXFont.setMaximumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.configTickXFont.setMinimumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(self.configTickXFont)
  
      self.configTickXBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox2)
      self.vLayout.addWidget(self.configTickXBox2)
      self.Layout_configTickX2 = QtWidgets.QHBoxLayout(self.configTickXBox2)
      self.Layout_configTickX2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(spacer)
      
      self.configTickXAngleLabel = QtWidgets.QLabel('angle')
      self.configTickXAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickXAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAngleLabel)
  
      self.configTickXAngle = QDoubleSpinClick()
      self.Layout_configTickX2.addWidget(self.configTickXAngle)
      self.configTickXAngle.setMinimum(0.0)
      self.configTickXAngle.setMaximum(360.0)
      self.configTickXAngle.setToolTip('Angle of x axis ticks')
      self.configTickXAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickXAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickXAngle.setSingleStep(10)
      self.configTickXAngle.setWrapping(True)
      self.configTickXAngle.setAdaptive(False)
      
      self.configTickXAlignmentLabel = QtWidgets.QLabel('align')
      self.configTickXAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.configTickXAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignmentLabel)
  
      self.configTickXAlignment = QComboBoxMac()
      self.configTickXAlignment.setToolTip('Horizontal alignment of x axis ticks')
      self.configTickXAlignment.addItems(self.alignHorizontal)
      self.configTickXAlignment.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configTickXAlignment.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignment)
  
      self.configTickXAlignmentVertical = QComboBoxMac()
      self.configTickXAlignmentVertical.setToolTip('Vertical alignment of x axis ticks')
      self.configTickXAlignmentVertical.addItems(self.alignVertical)
      self.configTickXAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configTickXAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignmentVertical)
  
      self.configTickXPadLabel = QtWidgets.QLabel('pad')
      self.configTickXPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.configTickXPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXPadLabel)
  
      self.configTickXPad = QLineEditClick()
      self.configTickXPad.setToolTip('Vertical padding of x axis ticks')
      self.configTickXPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad.setValidator(self.validFloat)
      self.Layout_configTickX2.addWidget(self.configTickXPad)

      self.configTickXPad2Label = QtWidgets.QLabel('pad2')
      self.configTickXPad2Label.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configTickXPad2Label.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXPad2Label)
  
      self.configTickXPad2 = QLineEditClick()
      self.configTickXPad2.setToolTip('Horizontal padding of x axis ticks')
      self.configTickXPad2.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad2.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad2.setValidator(self.validFloat)
      self.Layout_configTickX2.addWidget(self.configTickXPad2)

      # tick label formatting
      self.configTickXBox4 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox4)
      self.vLayout.addWidget(self.configTickXBox4)
      self.Layout_configTickX4 = QtWidgets.QHBoxLayout(self.configTickXBox4)
      self.Layout_configTickX4.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX4.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(spacer)
      
      self.configTickXFormatLabel = QtWidgets.QLabel('fmt')
      self.configTickXFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickXFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatLabel)
  
      self.configTickXFormat = QComboBoxMac()
      self.configTickXFormat.setToolTip('Format of x axis ticks')
      self.configTickXFormat.addItems(self.formatOptions)
      self.configTickXFormat.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickXFormat.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormat)
  
      self.configTickXFormatPrecisionLabel = QtWidgets.QLabel('precision')
      self.configTickXFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatPrecisionLabel)
  
      self.configTickXFormatPrecision = QLineEditClick()
      self.configTickXFormatPrecision.setToolTip('Number precision in x axis ticks')
      self.configTickXFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecision.setValidator(self.validInt)
      self.Layout_configTickX4.addWidget(self.configTickXFormatPrecision)

      self.configTickXFormatTrailZero = QPushButtonCheckable()
      self.configTickXFormatTrailZero.setText('trail 0s?')
      self.configTickXFormatTrailZero.setToolTip('Remove trailing zeros in x axis ticks')
      self.configTickXFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatTrailZero)

      self.configTickXFormatSeparator = QPushButtonCheckable()
      self.configTickXFormatSeparator.setText('separate 1000s?')
      self.configTickXFormatSeparator.setToolTip('Separate 1000\'s in x axis ticks')
      self.configTickXFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.configTickXFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatSeparator)

      self.configTickXFormatComma = QPushButtonCheckable()
      self.configTickXFormatComma.setText('comma?')
      self.configTickXFormatComma.setToolTip('Use comma to denote decimal numbers in x axis ticks?')
      self.configTickXFormatComma.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickXFormatComma.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatComma)
      self.Layout_configTickX4.addStretch()

      # tick label formatting ctd.
      self.configTickXBox5 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox5)
      self.vLayout.addWidget(self.configTickXBox5)
      self.Layout_configTickX5 = QtWidgets.QHBoxLayout(self.configTickXBox5)
      self.Layout_configTickX5.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX5.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(spacer)
      
      self.configTickXPrefixLabel = QtWidgets.QLabel('prefix')
      self.configTickXPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickXPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPrefixLabel)
      self.configTickXPrefix = QLineEditClick()
      self.configTickXPrefix.setToolTip('Constant prefix in x axis ticks')
      self.configTickXPrefix.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXPrefix.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickXPrefix.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPrefix)

      self.configTickXPostfixLabel = QtWidgets.QLabel('postfix')
      self.configTickXPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configTickXPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPostfixLabel)
      self.configTickXPostfix = QLineEditClick()
      self.configTickXPostfix.setToolTip('Constant postfix in x axis ticks')
      self.configTickXPostfix.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPostfix)

    # the inner situation
    if(not self.secondAxes):
      self.configInnerTickXBox = QWidgetMac()
      self.vLayout.addWidget(self.configInnerTickXBox)
      self.Layout_configInnerTickX = QtWidgets.QHBoxLayout(self.configInnerTickXBox)
      self.Layout_configInnerTickX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerTickX.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerLabel = QPushButtonCheckable()
      self.configInnerLabel.setText('split_x')
      self.configInnerLabel.setToolTip('Show split x axis tick labels')
      self.configInnerLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configInnerLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerLabel)
      
      self.configInnerTickXAuto = QPushButtonCheckable()
      self.configInnerTickXAuto.setText('auto')
      self.configInnerTickXAuto.setToolTip('Automatically set split x axis ticks')
      self.configInnerTickXAuto.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configInnerTickXAuto.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickXAuto)
          
      self.configInnerTickXEntry = QLineEditClick()
      self.configInnerTickXEntry.setToolTip('Values of split x axis ticks')
      self.configInnerTickXEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXEntry.setMaximumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.configInnerTickXEntry.setMinimumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickXEntry)
  
      self.configInnerTickUseData = QPushButtonMac()
      self.configInnerTickUseData.setText('labels')
      self.configInnerTickUseData.setToolTip('Use data labels as split x axis ticks')
      self.configInnerTickUseData.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configInnerTickUseData.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickUseData)

      # 4th row
      self.configInnerMinorTickBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerMinorTickBox)
      self.vLayout.addWidget(self.configInnerMinorTickBox)
      self.Layout_configInnerMinorTickBox = QtWidgets.QHBoxLayout(self.configInnerMinorTickBox)
      self.Layout_configInnerMinorTickBox.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerMinorTickBox.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(spacer)

      self.configInnerMinorTickLabel = QPushButtonCheckable()
      self.configInnerMinorTickLabel.setText('minor')
      self.configInnerMinorTickLabel.setToolTip('Show split x axis minor ticks')
      self.configInnerMinorTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickLabel)
      self.configInnerMinorTickX = QComboBoxMac()
      self.configInnerMinorTickX.setToolTip('Number of split x axis minor ticks')
      for entry in [str(i + 1) for i in range(9)]:
        self.configInnerMinorTickX.addItem(str(entry))
      self.configInnerMinorTickX.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickX.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickX)

      '''
      self.configInnerMinorTickRelativeLengthLabel = QtWidgets.QLabel('rel length')
      self.configInnerMinorTickRelativeLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickRelativeLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickRelativeLengthLabel)
      self.configInnerMinorTickRelativeLength = QLineEditClick()
      self.configInnerMinorTickXRelativeLength.setToolTip('Relative length of x axis minor ticks')
      self.configInnerMinorTickRelativeLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickRelativeLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickRelativeLength.setValidator(self.validFloat)
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickRelativeLength)
      '''

      # second row
      self.configInnerBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox2)
      self.vLayout.addWidget(self.configInnerBox2)
      self.Layout_configInnerBox2 = QtWidgets.QHBoxLayout(self.configInnerBox2)
      self.Layout_configInnerBox2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(spacer)
      
      self.configInnerTickXFormatLabel = QtWidgets.QLabel('fmt')
      self.configInnerTickXFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatLabel)
  
      self.configInnerTickXFormat = QComboBoxMac()
      self.configInnerTickXFormat.setToolTip('Format of split x axis ticks')
      self.configInnerTickXFormat.addItems(self.formatOptions)
      self.configInnerTickXFormat.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormat.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormat)
  
      self.configInnerTickXFormatPrecisionLabel = QtWidgets.QLabel('precision')
      self.configInnerTickXFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatPrecisionLabel)
  
      self.configInnerTickXFormatPrecision = QLineEditClick()
      self.configInnerTickXFormatPrecision.setToolTip('Number precision in split x axis ticks')
      self.configInnerTickXFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecision.setValidator(self.validInt)
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatPrecision)

      self.configInnerTickXFormatTrailZero = QPushButtonCheckable()
      self.configInnerTickXFormatTrailZero.setToolTip('Remove trailing zeros in split x axis ticks')
      self.configInnerTickXFormatTrailZero.setText('trail 0s?')
      self.configInnerTickXFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatTrailZero)
  
      self.configInnerTickXFormatSeparator = QPushButtonCheckable()
      self.configInnerTickXFormatSeparator.setText('separate 1000s?')
      self.configInnerTickXFormatSeparator.setToolTip('Separate 1000\'s in split x axis ticks')
      self.configInnerTickXFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatSeparator)

      self.configInnerTickXFormatComma = QPushButtonCheckable()
      self.configInnerTickXFormatComma.setText('comma?')
      self.configInnerTickXFormatComma.setToolTip('Use comma to denote decimal numbers in split x axis ticks?')
      self.configInnerTickXFormatComma.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatComma.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatComma)
      self.Layout_configInnerBox2.addStretch()
      
      # third row
      self.configInnerBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox3)
      self.vLayout.addWidget(self.configInnerBox3)
      self.Layout_configInnerBox3 = QtWidgets.QHBoxLayout(self.configInnerBox3)
      self.Layout_configInnerBox3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(spacer)
      
      self.configInnerTickXPrefixLabel = QtWidgets.QLabel('prefix')
      self.configInnerTickXPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPrefixLabel)
      self.configInnerTickXPrefix = QLineEditClick()
      self.configInnerTickXPrefix.setToolTip('Constant prefix in split x axis ticks')
      self.configInnerTickXPrefix.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXPrefix.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPrefix.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPrefix)

      self.configInnerTickXPostfixLabel = QtWidgets.QLabel('postfix')
      self.configInnerTickXPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPostfixLabel)
      self.configInnerTickXPostfix = QLineEditClick()
      self.configInnerTickXPostfix.setToolTip('Constant postfix in split x axis ticks')
      self.configInnerTickXPostfix.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPostfix)      

      # fourth row
      self.configInnerBox = QWidgetMac()
      self.vLayout.addWidget(self.configInnerBox)
      self.Layout_configInnerBox = QtWidgets.QHBoxLayout(self.configInnerBox)
      self.Layout_configInnerBox.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(spacer)
  
      self.xSplitFractionLabel = QtWidgets.QLabel('fraction')
      self.xSplitFractionLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.xSplitFractionLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.xSplitFractionLabel)
      self.xSplitFraction = QLineEditClick()
      self.xSplitFraction.setToolTip('Size ratio of x and split x axes')
      self.xSplitFraction.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.xSplitFraction.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.xSplitFraction.setValidator(self.validFloat)
      self.Layout_configInnerBox.addWidget(self.xSplitFraction)
          
      self.xSplitPadLabel = QtWidgets.QLabel('pad')
      self.xSplitPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.xSplitPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.xSplitPadLabel)
      self.xSplitPad = QLineEditClick()
      self.xSplitPad.setToolTip('Padding between x and split x axes')
      self.xSplitPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xSplitPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xSplitPad.setValidator(self.validFloat)
      self.Layout_configInnerBox.addWidget(self.xSplitPad)

      self.configInnerAxesLabel = QPushButtonCheckable()
      self.configInnerAxesLabel.setText('axes')
      self.configInnerAxesLabel.setToolTip('Show inner y axes')
      self.configInnerAxesLabel.setMaximumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.configInnerAxesLabel.setMinimumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.configInnerAxesLabel)

      self.configInnerTickLabel = QPushButtonCheckable()
      self.configInnerTickLabel.setText('ticks')
      self.configInnerTickLabel.setToolTip('Show inner y axis ticks')
      self.configInnerTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configInnerTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.configInnerTickLabel)
      self.Layout_configInnerBox.addStretch()

      # fifth row
      self.configInnerBox5 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox5)
      self.vLayout.addWidget(self.configInnerBox5)
      self.Layout_configInnerBox5 = QtWidgets.QHBoxLayout(self.configInnerBox5)
      self.Layout_configInnerBox5.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox5.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox5.addWidget(spacer)

      self.configInnerDividerLine = QPushButtonCheckable()
      self.configInnerDividerLine.setText('divider')
      self.configInnerDividerLine.setToolTip('Show split x axis divider lines')
      self.configInnerDividerLine.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLine.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLine)
      
      self.configInnerDividerLineColor = QPushButtonColor()
      self.configInnerDividerLineColor.setToolTip('Line color of split x axis divider lines')
      self.configInnerDividerLineColor.setAutoFillBackground(False)
      self.configInnerDividerLineColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configInnerDividerLineColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configInnerDividerLineColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineColor)

      self.configInnerDividerLineLengthLabel = QtWidgets.QLabel('length')
      self.configInnerDividerLineLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(38), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(38), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineLengthLabel)
      self.configInnerDividerLineLength = QDoubleSpinClick()
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineLength)
      self.configInnerDividerLineLength.setMinimum(0.0)
      self.configInnerDividerLineLength.setMaximum(2.0)
      self.configInnerDividerLineLength.setToolTip('Length of split x axis divider lines')
      self.configInnerDividerLineLength.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineLength.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))

      self.configInnerDividerLineWidthLabel = QtWidgets.QLabel('width')
      self.configInnerDividerLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineWidthLabel)
      self.configInnerDividerLineWidth = QDoubleSpinClick()
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineWidth)
      self.configInnerDividerLineWidth.setMinimum(0.0)
      self.configInnerDividerLineWidth.setMaximum(100.0)
      self.configInnerDividerLineWidth.setToolTip('Width of split x axis divider lines')
      self.configInnerDividerLineWidth.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineWidth.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
  
      self.configInnerDividerLineDashStyle = QComboBoxMac()
      self.configInnerDividerLineDashStyle.setToolTip('Cap style of split x axis divider lines')
      self.configInnerDividerLineDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(68), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(68), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox5.addWidget(self.configInnerDividerLineDashStyle)

      # sixth row
      self.configInnerBox6 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox6)
      self.vLayout.addWidget(self.configInnerBox6)
      self.Layout_configInnerBox6 = QtWidgets.QHBoxLayout(self.configInnerBox6)
      self.Layout_configInnerBox6.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox6.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox6.addWidget(spacer)

      self.configInnerDividerLineAngleLabel = QtWidgets.QLabel('angle')
      self.configInnerDividerLineAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox6.addWidget(self.configInnerDividerLineAngleLabel)
      self.configInnerDividerLineAngle = QDoubleSpinClick()
      self.Layout_configInnerBox6.addWidget(self.configInnerDividerLineAngle)
      self.configInnerDividerLineAngle.setMinimum(0.0)
      self.configInnerDividerLineAngle.setMaximum(180.0)
      self.configInnerDividerLineAngle.setToolTip('Angle of split x axis divider lines')
      self.configInnerDividerLineAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineAngle.setSingleStep(10)
      self.configInnerDividerLineAngle.setWrapping(True)
      self.configInnerDividerLineAngle.setAdaptive(False)

      self.configInnerDividerLineLocationLabel = QtWidgets.QLabel('location')
      self.configInnerDividerLineLocationLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineLocationLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox6.addWidget(self.configInnerDividerLineLocationLabel)
      self.configInnerDividerLineLocation = QComboBoxMac()
      self.configInnerDividerLineLocation.setToolTip('Location of split x axis divider lines')
      self.configInnerDividerLineLocation.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configInnerDividerLineLocation.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox6.addWidget(self.configInnerDividerLineLocation)

      if(not self.parent.plotArea.splitShow):
        self.configInnerBox.hide()
        self.configInnerTickXBox.hide()
        self.configInnerMinorTickBox.hide()

    # y ticks config
    self.configTickYBox = QWidgetMac()
    self.vLayout.addWidget(self.configTickYBox)
    self.Layout_configTickY = QtWidgets.QHBoxLayout(self.configTickYBox)
    self.Layout_configTickY.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYLabel = QPushButtonCheckable()
    if(self.secondAxes):
      self.configTickYLabel.setText('y2 ticks')
      self.configTickYLabel.setToolTip('Show y2 axis tick labels')
    else:
      self.configTickYLabel.setText('y ticks')
      self.configTickYLabel.setToolTip('Show y axis tick labels')
    self.configTickYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configTickYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYLabel)
    
    self.configTickYAuto = QPushButtonCheckable()
    self.configTickYAuto.setText('auto')
    if(self.secondAxes):
      self.configTickYAuto.setToolTip('Automatically set y2 axis ticks')
    else:
      self.configTickYAuto.setToolTip('Automatically set y axis ticks')
    self.configTickYAuto.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.configTickYAuto.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYAuto)
        
    self.configTickYEntry = QLineEditClick()
    if(self.secondAxes):
      self.configTickYEntry.setToolTip('Values of y2 axis ticks')
    else:
      self.configTickYEntry.setToolTip('Values of y axis ticks')
    self.configTickYEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYEntry.setMaximumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
    self.configTickYEntry.setMinimumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYEntry)

    # minor tick formatting
    self.configTickYBox6 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox6)
    self.vLayout.addWidget(self.configTickYBox6)
    self.Layout_configTickY6 = QtWidgets.QHBoxLayout(self.configTickYBox6)
    self.Layout_configTickY6.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY6.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY6.addWidget(spacer)
    
    self.configMinorTickYLabel = QPushButtonCheckable()
    self.configMinorTickYLabel.setText('minor')
    if(self.secondAxes):
      self.configMinorTickYLabel.setToolTip('Show y2 axis minor ticks')
    else:
      self.configMinorTickYLabel.setToolTip('Show y axis minor ticks')
    self.configMinorTickYLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.configMinorTickYLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY6.addWidget(self.configMinorTickYLabel)
    self.configMinorTickY = QComboBoxMac()
    if(self.secondAxes):
      self.configMinorTickY.setToolTip('Number of y2 axis minor ticks')
    else:
      self.configMinorTickY.setToolTip('Number of y axis minor ticks')
    for entry in [str(i + 1) for i in range(9)]:
      self.configMinorTickY.addItem(str(entry))
    self.configMinorTickY.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.configMinorTickY.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY6.addWidget(self.configMinorTickY)

    self.configMinorTickYRelativeLengthLabel = QtWidgets.QLabel('rel length')
    self.configMinorTickYRelativeLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.configMinorTickYRelativeLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY6.addWidget(self.configMinorTickYRelativeLengthLabel)
    self.configMinorTickYRelativeLength = QLineEditClick()
    if(self.secondAxes):
      self.configMinorTickYRelativeLength.setToolTip('Relative length of y2 axis minor ticks')
    else:
      self.configMinorTickYRelativeLength.setToolTip('Relative length of y axis minor ticks')
    self.configMinorTickYRelativeLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configMinorTickYRelativeLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configMinorTickYRelativeLength.setValidator(self.validFloat)
    self.Layout_configTickY6.addWidget(self.configMinorTickYRelativeLength)
    
    # font formatting
    self.configTickYBox3 = QWidgetMac()
    self.vLayout.addWidget(self.configTickYBox3)
    self.Layout_configTickY3 = QtWidgets.QHBoxLayout(self.configTickYBox3)
    self.Layout_configTickY3.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY3.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(spacer)
    
    self.configTickYSizeLabel = QtWidgets.QLabel('font')
    self.configTickYSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configTickYSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(self.configTickYSizeLabel)
    self.configTickYColorButton = QPushButtonColor()
    if(self.secondAxes):
      self.configTickYColorButton.setToolTip('Color of y2 axis ticks')
    else:
      self.configTickYColorButton.setToolTip('Color of y axis ticks')
    self.configTickYColorButton.setAutoFillBackground(False)
    self.configTickYColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.Layout_configTickY3.addWidget(self.configTickYColorButton)

    self.configTickYSize = QDoubleSpinClick()
    self.Layout_configTickY3.addWidget(self.configTickYSize)
    self.configTickYSize.setMinimum(0.0)
    self.configTickYSize.setMaximum(100.0)
    if(self.secondAxes):
      self.configTickYSize.setToolTip('Font size of y2 axis ticks')
    else:
      self.configTickYSize.setToolTip('Font size of y axis ticks')
    self.configTickYSize.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.configTickYSize.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))

    self.configTickYBold = QPushButtonCheckable()
    self.configTickYBold.setText('B')
    if(self.secondAxes):
      self.configTickYBold.setToolTip('Font weight of y2 axis ticks')
    else:
      self.configTickYBold.setToolTip('Font weight of y axis ticks')
    self.configTickYBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configTickYBold.font()
    useFont.setWeight(75)
    self.configTickYBold.setFont(useFont)
    self.Layout_configTickY3.addWidget(self.configTickYBold)
      
    self.configTickYItalic = QPushButtonCheckable()
    self.configTickYItalic.setText('I')
    if(self.secondAxes):
      self.configTickYItalic.setToolTip('Font style of y2 axis ticks')
    else:
      self.configTickYItalic.setToolTip('Font style of y axis ticks')
    self.configTickYItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configTickYItalic.font()
    useFont.setItalic(True)
    self.configTickYItalic.setFont(useFont)
    self.Layout_configTickY3.addWidget(self.configTickYItalic)

    self.configTickYFont = QComboBoxMac()
    if(self.secondAxes):
      self.configTickYFont.setToolTip('Font of y2 axis ticks')
    else:
      self.configTickYFont.setToolTip('Font of y axis ticks')
    self.configTickYFont.addItems(self.parent.fontNames)
    self.configTickYFont.setMaximumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
    self.configTickYFont.setMinimumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(self.configTickYFont)

    self.configTickYBox2 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox2)
    self.vLayout.addWidget(self.configTickYBox2)
    self.Layout_configTickY2 = QtWidgets.QHBoxLayout(self.configTickYBox2)
    self.Layout_configTickY2.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY2.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(spacer)

    self.configTickYAngleLabel = QtWidgets.QLabel('angle')
    self.configTickYAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configTickYAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAngleLabel)

    self.configTickYAngle = QDoubleSpinClick()
    self.Layout_configTickY2.addWidget(self.configTickYAngle)
    self.configTickYAngle.setMinimum(0.0)
    self.configTickYAngle.setMaximum(360.0)
    if(self.secondAxes):
      self.configTickYAngle.setToolTip('Angle of y2 axis ticks')
    else:
      self.configTickYAngle.setToolTip('Angle of y axis ticks')
    self.configTickYAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configTickYAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configTickYAngle.setSingleStep(10)
    self.configTickYAngle.setWrapping(True)
    self.configTickYAngle.setAdaptive(False)
    
    self.configTickYAlignmentLabel = QtWidgets.QLabel('align')
    self.configTickYAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.configTickYAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignmentLabel)

    self.configTickYAlignment = QComboBoxMac()
    if(self.secondAxes):
      self.configTickYAlignment.setToolTip('Horizontal alignment of y2 axis ticks')
    else:
      self.configTickYAlignment.setToolTip('Horizontal alignment of y axis ticks')
    self.configTickYAlignment.addItems(self.alignHorizontal)
    self.configTickYAlignment.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.configTickYAlignment.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignment)

    self.configTickYAlignmentVertical = QComboBoxMac()
    if(self.secondAxes):
      self.configTickYAlignmentVertical.setToolTip('Vertical alignment of y2 axis ticks')
    else:
      self.configTickYAlignmentVertical.setToolTip('Vertical alignment of y axis ticks')
    self.configTickYAlignmentVertical.addItems(self.alignVertical)
    self.configTickYAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.configTickYAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignmentVertical)

    self.configTickYPadLabel = QtWidgets.QLabel('pad')
    self.configTickYPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.configTickYPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYPadLabel)

    self.configTickYPad = QLineEditClick()
    if(self.secondAxes):
      self.configTickYPad.setToolTip('Horizontal padding of y2 axis ticks')
    else:
      self.configTickYPad.setToolTip('Horizontal padding of y axis ticks')
    self.configTickYPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad.setValidator(self.validFloat)
    self.Layout_configTickY2.addWidget(self.configTickYPad)

    self.configTickYPad2Label = QtWidgets.QLabel('pad2')
    self.configTickYPad2Label.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.configTickYPad2Label.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYPad2Label)

    self.configTickYPad2 = QLineEditClick()
    if(self.secondAxes):
      self.configTickYPad2.setToolTip('Vertical padding of y2 axis ticks')
    else:
      self.configTickYPad2.setToolTip('Vertical padding of y axis ticks')
    self.configTickYPad2.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad2.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad2.setValidator(self.validFloat)
    self.Layout_configTickY2.addWidget(self.configTickYPad2)

    # tick label formatting
    self.configTickYBox4 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox4)
    self.vLayout.addWidget(self.configTickYBox4)
    self.Layout_configTickY4 = QtWidgets.QHBoxLayout(self.configTickYBox4)
    self.Layout_configTickY4.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY4.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(spacer)
    
    self.configTickYFormatLabel = QtWidgets.QLabel('fmt')
    self.configTickYFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configTickYFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatLabel)

    self.configTickYFormat = QComboBoxMac()
    if(self.secondAxes):
      self.configTickYFormat.setToolTip('Format of y2 axis ticks')
    else:
      self.configTickYFormat.setToolTip('Format of y axis ticks')
    self.configTickYFormat.addItems(self.formatOptions)
    self.configTickYFormat.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configTickYFormat.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormat)

    self.configTickYFormatPrecisionLabel = QtWidgets.QLabel('precision')
    self.configTickYFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatPrecisionLabel)

    self.configTickYFormatPrecision = QLineEditClick()
    if(self.secondAxes):
      self.configTickYFormatPrecision.setToolTip('Number precision in y2 axis ticks')
    else:
      self.configTickYFormatPrecision.setToolTip('Number precision in y axis ticks')
    self.configTickYFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecision.setValidator(self.validInt)
    self.Layout_configTickY4.addWidget(self.configTickYFormatPrecision)

    self.configTickYFormatTrailZero = QPushButtonCheckable()
    self.configTickYFormatTrailZero.setText('trail 0s?')
    if(self.secondAxes):
      self.configTickYFormatTrailZero.setToolTip('Remove trailing zeros in y2 axis ticks')
    else:
      self.configTickYFormatTrailZero.setToolTip('Remove trailing zeros in y axis ticks')
    self.configTickYFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatTrailZero)

    self.configTickYFormatSeparator = QPushButtonCheckable()
    self.configTickYFormatSeparator.setText('separate 1000s?')
    if(self.secondAxes):
      self.configTickYFormatSeparator.setToolTip('Separate 1000\'s in y2 axis ticks')
    else:
      self.configTickYFormatSeparator.setToolTip('Separate 1000\'s in y axis ticks')
    self.configTickYFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
    self.configTickYFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatSeparator)

    self.configTickYFormatComma = QPushButtonCheckable()
    self.configTickYFormatComma.setText('comma?')
    if(self.secondAxes):
      self.configTickYFormatComma.setToolTip('Use comma to denote decimal numbers in y2 axis ticks?')
    else:
      self.configTickYFormatComma.setToolTip('Use comma to denote decimal numbers in y axis ticks?')
    self.configTickYFormatComma.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configTickYFormatComma.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatComma)
    self.Layout_configTickY4.addStretch()

    # tick label formatting ctd.
    self.configTickYBox5 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox5)
    self.vLayout.addWidget(self.configTickYBox5)
    self.Layout_configTickY5 = QtWidgets.QHBoxLayout(self.configTickYBox5)
    self.Layout_configTickY5.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY5.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(spacer)
    
    self.configTickYPrefixLabel = QtWidgets.QLabel('prefix')
    self.configTickYPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configTickYPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPrefixLabel)
    self.configTickYPrefix = QLineEditClick()
    if(self.secondAxes):
      self.configTickYPrefix.setToolTip('Constant prefix in y2 axis ticks')
    else:
      self.configTickYPrefix.setToolTip('Constant prefix in y axis ticks')
    self.configTickYPrefix.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYPrefix.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configTickYPrefix.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPrefix)

    self.configTickYPostfixLabel = QtWidgets.QLabel('postfix')
    self.configTickYPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.configTickYPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPostfixLabel)
    self.configTickYPostfix = QLineEditClick()
    if(self.secondAxes):
      self.configTickYPostfix.setToolTip('Constant postfix in y2 axis ticks')
    else:
      self.configTickYPostfix.setToolTip('Constant postfix in y axis ticks')
    self.configTickYPostfix.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPostfix)

    if(not self.secondAxes):
      self.configTickResidYBox = QWidgetMac()
      self.vLayout.addWidget(self.configTickResidYBox)
      self.Layout_configTickResidY = QtWidgets.QHBoxLayout(self.configTickResidYBox)
      self.Layout_configTickResidY.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickResidY.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickResidYLabel = QPushButtonCheckable()
      self.configTickResidYLabel.setText('resid')
      self.configTickResidYLabel.setToolTip('Show residuals y axis tick labels')
      self.configTickResidYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickResidYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYLabel)
  
      self.configTickResidYAuto = QPushButtonCheckable()
      self.configTickResidYAuto.setText('auto')
      self.configTickResidYAuto.setToolTip('Automatically set residuals y axis ticks')
      self.configTickResidYAuto.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configTickResidYAuto.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYAuto)
          
      self.configTickResidYEntry = QLineEditClick()
      self.configTickResidYEntry.setToolTip('Values of residuals y axis ticks')
      self.configTickResidYEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickResidYEntry.setMaximumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.configTickResidYEntry.setMinimumSize(QtCore.QSize(scaledDPI(252), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYEntry)

      # minor tick formatting
      self.configTickResidYBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickResidYBox2)
      self.vLayout.addWidget(self.configTickResidYBox2)
      self.Layout_configTickResidYBox2 = QtWidgets.QHBoxLayout(self.configTickResidYBox2)
      self.Layout_configTickResidYBox2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickResidYBox2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidYBox2.addWidget(spacer)
      
      self.configMinorTickResidLabel = QPushButtonCheckable()
      self.configMinorTickResidLabel.setText('minor')
      self.configMinorTickResidLabel.setToolTip('Show residuals y axis minor ticks')
      self.configMinorTickResidLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configMinorTickResidLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidYBox2.addWidget(self.configMinorTickResidLabel)
      self.configMinorTickResid = QComboBoxMac()
      self.configMinorTickResid.setToolTip('Number of residuals y axis minor ticks')
      for entry in [str(i + 1) for i in range(9)]:
        self.configMinorTickResid.addItem(str(entry))
      self.configMinorTickResid.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configMinorTickResid.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidYBox2.addWidget(self.configMinorTickResid)
  
      self.configMinorTickResidRelativeLengthLabel = QtWidgets.QLabel('rel length')
      self.configMinorTickResidRelativeLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configMinorTickResidRelativeLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidYBox2.addWidget(self.configMinorTickResidRelativeLengthLabel)
      self.configMinorTickResidRelativeLength = QLineEditClick()
      self.configMinorTickResidRelativeLength.setToolTip('Relative length of residuals y axis minor ticks')
      self.configMinorTickResidRelativeLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickResidRelativeLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickResidRelativeLength.setValidator(self.validFloat)
      self.Layout_configTickResidYBox2.addWidget(self.configMinorTickResidRelativeLength)
  
    # tick mark config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configTickMarkBox = {}; self.Layout_configTickMark = {}
    self.configTickMarkLabel = {}
    self.configTickMarkWidthLabel = {}; self.configTickMarkWidth = {}
    self.configTickMarkLengthLabel = {}; self.configTickMarkLength = {}
    self.configTickMarkDirection = {}; self.configTickMarkColor = {}
    self.configTickMarkLabelShow = {}
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configTickMarkBox[axis])
      self.Layout_configTickMark[axis] = QtWidgets.QHBoxLayout(self.configTickMarkBox[axis])
      self.Layout_configTickMark[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickMark[axis].setAlignment(QtCore.Qt.AlignLeft)

      self.configTickMarkLabel[axis] = QPushButtonCheckable()
      self.configTickMarkLabel[axis].setText('tick ' + axis)
      self.configTickMarkLabel[axis].setToolTip('Show ' + axis + ' axis tick marks')
      self.configTickMarkLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickMarkLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLabel[axis])

      self.configTickMarkDirection[axis] = QComboBoxMac()
      self.configTickMarkDirection[axis].setToolTip('Direction of ' + axis + ' axis tick marks')
      self.directionstyles = ['in', 'out', 'inout']
      self.configTickMarkDirection[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickMarkDirection[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkDirection[axis])

      self.configTickMarkColor[axis] = QPushButtonColor()
      self.configTickMarkColor[axis].setToolTip('Color of ' + axis + ' axis tick marks')
      self.configTickMarkColor[axis].setAutoFillBackground(False)
      self.configTickMarkColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickMarkColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickMarkColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkColor[axis])
  
      self.configTickMarkWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configTickMarkWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickMarkWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkWidthLabel[axis])
      self.configTickMarkWidth[axis] = QDoubleSpinClick()
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkWidth[axis])
      self.configTickMarkWidth[axis].setMinimum(0.0)
      self.configTickMarkWidth[axis].setMaximum(100.0)
      self.configTickMarkWidth[axis].setToolTip('Line width of ' + axis + ' axis tick marks')
      self.configTickMarkWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickMarkWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))

      self.configTickMarkLengthLabel[axis] = QtWidgets.QLabel('length')
      self.configTickMarkLengthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickMarkLengthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLengthLabel[axis])
      self.configTickMarkLength[axis] = QDoubleSpinClick()
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLength[axis])
      self.configTickMarkLength[axis].setMinimum(0.0)
      self.configTickMarkLength[axis].setMaximum(100.0)
      self.configTickMarkLength[axis].setToolTip('Line length of ' + axis + ' axis tick marks')
      self.configTickMarkLength[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickMarkLength[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))

      self.configTickMarkLabelShow[axis] = QPushButtonCheckable()
      # better don't initially hide this option as it may be used relatively often
      ###self.advancedGraphicsSettings.append(self.configTickMarkLabelShow[axis])
      self.configTickMarkLabelShow[axis].setText('label')
      self.configTickMarkLabelShow[axis].setToolTip('Show ' + axis + ' axis tick labels')
      self.configTickMarkLabelShow[axis].setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configTickMarkLabelShow[axis].setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLabelShow[axis])

    # grid config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configGridBox = {}; self.Layout_configGrid = {}
    self.configGridLabel = {}
    self.configGridWidthLabel = {}; self.configGridWidth = {}
    self.configGridColor = {}; self.configGridStyle = {}
    self.configGridDashStyle = {}; self.configGridOrder = {}
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configGridBox[axis])
      self.Layout_configGrid[axis] = QtWidgets.QHBoxLayout(self.configGridBox[axis])
      self.Layout_configGrid[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configGrid[axis].setAlignment(QtCore.Qt.AlignLeft)
      self.configGridLabel[axis] = QPushButtonCheckable()
      if(axis != 'x2'):
        self.configGridLabel[axis].setText('grid ' + axis)
        self.configGridLabel[axis].setToolTip('Show ' + axis + ' axis grid')
      else:
        self.configGridLabel[axis].setText('grid split_x')
        self.configGridLabel[axis].setToolTip('Show split x axis grid')
      self.configGridLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configGridLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridLabel[axis])

      self.orderstyles = ['front', 'back']
      self.configGridOrder[axis] = QComboBoxMac()
      self.configGridOrder[axis].setToolTip('z order of ' + axis + ' axis grid')
      if(axis == 'x2'):
        self.configGridOrder[axis].setToolTip('z order of split x axis grid')
      self.configGridOrder[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configGridOrder[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridOrder[axis])

      self.configGridColor[axis] = QPushButtonColor()
      self.configGridColor[axis].setToolTip('Color of ' + axis + ' axis grid')
      if(axis == 'x2'):
        self.configGridColor[axis].setToolTip('Color of split x axis grid')
      self.configGridColor[axis].setAutoFillBackground(False)
      self.configGridColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configGridColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configGridColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configGrid[axis].addWidget(self.configGridColor[axis])
  
      self.configGridWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configGridWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configGridWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridWidthLabel[axis])
      self.configGridWidth[axis] = QDoubleSpinClick()
      self.Layout_configGrid[axis].addWidget(self.configGridWidth[axis])
      self.configGridWidth[axis].setMinimum(0.0)
      self.configGridWidth[axis].setMaximum(100.0)
      self.configGridWidth[axis].setToolTip('Line width of ' + axis + ' axis grid')
      if(axis == 'x2'):
        self.configGridWidth[axis].setToolTip('Line width of split x axis grid')
      self.configGridWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configGridWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))

      self.configGridStyle[axis] = QComboBoxMac()
      self.configGridStyle[axis].setToolTip('Line style of ' + axis + ' axis grid')
      if(axis == 'x2'):
        self.configGridStyle[axis].setToolTip('Line style of split x axis grid')
      self.configGridStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
      self.configGridStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridStyle[axis])

      self.configGridDashStyle[axis] = QComboBoxMac()
      self.configGridDashStyle[axis].setToolTip('Cap style of ' + axis + ' axis grid')
      if(axis == 'x2'):
        self.configGridDashStyle[axis].setToolTip('Cap style of split x axis grid')
      self.advancedGraphicsSettings.append(self.configGridDashStyle[axis])
      self.configGridDashStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(74), scaledDPI(BASE_SIZE)))
      self.configGridDashStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(74), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridDashStyle[axis])

    if((not self.parent.plotArea.splitShow) and ('x2' in self.configGridBox)):
      self.configGridBox['x2'].hide()

    # splitY controls
    if(self.secondAxes):
      self.splitYSeparator = self.HLine()
      self.vLayout.addWidget(self.splitYSeparator)

      self.configSplitYBox = QWidgetMac()
      self.vLayout.addWidget(self.configSplitYBox)
      self.Layout_configSplitY = QtWidgets.QHBoxLayout(self.configSplitYBox)
      self.Layout_configSplitY.setContentsMargins(0, 0, 0, 0)
      self.Layout_configSplitY.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configSplitYLabel = QPushButtonCheckable()
      self.configSplitYLabel.setText('split y')
      self.configSplitYLabel.setToolTip('Split 2nd y axis from 1st y axis?')
      self.configSplitYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configSplitYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitY.addWidget(self.configSplitYLabel)

      self.configSplitYFractionLabel = QtWidgets.QLabel('fraction')
      self.configSplitYFractionLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configSplitYFractionLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitY.addWidget(self.configSplitYFractionLabel)
      self.configSplitYFraction = QLineEditClick()
      self.configSplitYFraction.setToolTip('Size ratio of y and split y axes')
      self.configSplitYFraction.setMaximumSize(QtCore.QSize(scaledDPI(48), scaledDPI(BASE_SIZE)))
      self.configSplitYFraction.setMinimumSize(QtCore.QSize(scaledDPI(48), scaledDPI(BASE_SIZE)))
      self.configSplitYFraction.setValidator(self.validFloat)
      self.Layout_configSplitY.addWidget(self.configSplitYFraction)
          
      self.configSplitYPadLabel = QtWidgets.QLabel('pad')
      self.configSplitYPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configSplitYPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitY.addWidget(self.configSplitYPadLabel)
      self.configSplitYPad = QLineEditClick()
      self.configSplitYPad.setToolTip('Padding between y and split y axes')
      self.configSplitYPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configSplitYPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configSplitYPad.setValidator(self.validFloat)
      self.Layout_configSplitY.addWidget(self.configSplitYPad)

      self.configSplitYAxesLabel = QPushButtonCheckable()
      self.configSplitYAxesLabel.setText('axes')
      self.configSplitYAxesLabel.setToolTip('Show inner x axes')
      self.configSplitYAxesLabel.setMaximumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.configSplitYAxesLabel.setMinimumSize(QtCore.QSize(scaledDPI(42), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitY.addWidget(self.configSplitYAxesLabel)

      self.configSplitYTickLabel = QPushButtonCheckable()
      self.configSplitYTickLabel.setText('ticks')
      self.configSplitYTickLabel.setToolTip('Show inner x axis ticks')
      self.configSplitYTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configSplitYTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitY.addWidget(self.configSplitYTickLabel)
      self.Layout_configSplitY.addStretch()

      # second row
      self.configSplitYBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configSplitYBox2)
      self.vLayout.addWidget(self.configSplitYBox2)
      self.Layout_configSplitYBox2 = QtWidgets.QHBoxLayout(self.configSplitYBox2)
      self.Layout_configSplitYBox2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configSplitYBox2.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox2.addWidget(spacer)

      self.configSplitYDividerLine = QPushButtonCheckable()
      self.configSplitYDividerLine.setText('divider')
      self.configSplitYDividerLine.setToolTip('Show split y axis divider lines')
      self.configSplitYDividerLine.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLine.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLine)

      self.configSplitYDividerLineColor = QPushButtonColor()
      self.configSplitYDividerLineColor.setToolTip('Line color of split y axis divider lines')
      self.configSplitYDividerLineColor.setAutoFillBackground(False)
      self.configSplitYDividerLineColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configSplitYDividerLineColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configSplitYDividerLineColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineColor)

      self.configSplitYDividerLineLengthLabel = QtWidgets.QLabel('length')
      self.configSplitYDividerLineLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineLengthLabel)
      self.configSplitYDividerLineLength = QDoubleSpinClick()
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineLength)
      self.configSplitYDividerLineLength.setMinimum(0.0)
      self.configSplitYDividerLineLength.setMaximum(2.0)
      self.configSplitYDividerLineLength.setToolTip('Length of split y axis divider lines')
      self.configSplitYDividerLineLength.setMaximumSize(QtCore.QSize(scaledDPI(48), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineLength.setMinimumSize(QtCore.QSize(scaledDPI(48), scaledDPI(BASE_SIZE)))

      self.configSplitYDividerLineWidthLabel = QtWidgets.QLabel('width')
      self.configSplitYDividerLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineWidthLabel)
      self.configSplitYDividerLineWidth = QDoubleSpinClick()
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineWidth)
      self.configSplitYDividerLineWidth.setMinimum(0.0)
      self.configSplitYDividerLineWidth.setMaximum(100.0)
      self.configSplitYDividerLineWidth.setToolTip('Width of split y axis divider lines')
      self.configSplitYDividerLineWidth.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineWidth.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
  
      self.configSplitYDividerLineDashStyle = QComboBoxMac()
      self.configSplitYDividerLineDashStyle.setToolTip('Cap style of split y axis divider lines')
      self.configSplitYDividerLineDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox2.addWidget(self.configSplitYDividerLineDashStyle)

      # third row
      self.configSplitYBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configSplitYBox3)
      self.vLayout.addWidget(self.configSplitYBox3)
      self.Layout_configSplitYBox3 = QtWidgets.QHBoxLayout(self.configSplitYBox3)
      self.Layout_configSplitYBox3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configSplitYBox3.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox3.addWidget(spacer)

      self.configSplitYDividerLineAngleLabel = QtWidgets.QLabel('angle')
      self.configSplitYDividerLineAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(44), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(44), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox3.addWidget(self.configSplitYDividerLineAngleLabel)
      self.configSplitYDividerLineAngle = QDoubleSpinClick()
      self.Layout_configSplitYBox3.addWidget(self.configSplitYDividerLineAngle)
      self.configSplitYDividerLineAngle.setMinimum(0.0)
      self.configSplitYDividerLineAngle.setMaximum(180.0)
      self.configSplitYDividerLineAngle.setToolTip('Angle of split y axis divider lines')
      self.configSplitYDividerLineAngle.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineAngle.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineAngle.setSingleStep(10)
      self.configSplitYDividerLineAngle.setWrapping(True)
      self.configSplitYDividerLineAngle.setAdaptive(False)

      self.configSplitYDividerLineLocationLabel = QtWidgets.QLabel('location')
      self.configSplitYDividerLineLocationLabel.setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineLocationLabel.setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox3.addWidget(self.configSplitYDividerLineLocationLabel)
      self.configSplitYDividerLineLocation = QComboBoxMac()
      self.configSplitYDividerLineLocation.setToolTip('Location of split y axis divider lines')
      self.configSplitYDividerLineLocation.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configSplitYDividerLineLocation.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configSplitYBox3.addWidget(self.configSplitYDividerLineLocation)

      if(not self.parent.plotArea.splitY):
        self.configSplitYBox.hide()
        self.configSplitYBox2.hide()
        self.configSplitYBox3.hide()
        self.splitYSeparator.hide()
      
    # legend config
    if(not self.secondAxes):
      self.placementstyles = 'upper right;upper left;lower left;lower right;right;center left;center right;lower center;upper center;center'.split(';')
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configLegendBox = QWidgetMac()
      self.vLayout.addWidget(self.configLegendBox)
      self.Layout_configLegend = QtWidgets.QHBoxLayout(self.configLegendBox)
      self.Layout_configLegend.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configLegendLabel = QPushButtonCheckable()
      self.configLegendLabel.setText('legend')
      self.configLegendLabel.setToolTip('Show figure legend')
      self.configLegendLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configLegendLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendLabel)
  
      self.configLegendPlacement = QComboBoxMac()
      self.configLegendPlacement.setToolTip('Placement of figure legend')
      self.configLegendPlacement.addItems(self.placementstyles)
      self.configLegendPlacement.setMaximumSize(QtCore.QSize(scaledDPI(86), scaledDPI(BASE_SIZE)))
      self.configLegendPlacement.setMinimumSize(QtCore.QSize(scaledDPI(86), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendPlacement)
  
      self.configLegendColor = {}; self.configLegendColorLabel = {}
      for prop in ['face', 'edge']:
        self.configLegendColorLabel[prop] = QPushButtonCheckable()
        self.configLegendColorLabel[prop].setText(prop)
        self.configLegendColorLabel[prop].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        if(prop == 'face'):
          self.configLegendColorLabel[prop].setToolTip('Fill face of figure legend')
        else:
          self.configLegendColorLabel[prop].setToolTip('Draw border of figure legend')
        self.Layout_configLegend.addWidget(self.configLegendColorLabel[prop])
        self.configLegendColor[prop] = QPushButtonColor()
        self.configLegendColor[prop].setToolTip(prop.title() + ' color of figure legend')
        self.configLegendColor[prop].setAutoFillBackground(False)
        self.configLegendColor[prop].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configLegendColor[prop].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configLegendColor[prop].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configLegend.addWidget(self.configLegendColor[prop])
  
      self.configLegendEdgeWidthLabel = QtWidgets.QLabel('width')
      self.configLegendEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendEdgeWidthLabel)
      self.configLegendEdgeWidth = QDoubleSpinClick()
      self.Layout_configLegend.addWidget(self.configLegendEdgeWidth)
      self.configLegendEdgeWidth.setMinimum(0.0)
      self.configLegendEdgeWidth.setMaximum(100.0)
      self.configLegendEdgeWidth.setToolTip('Edge width of figure legend')
      self.configLegendEdgeWidth.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configLegendEdgeWidth.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addStretch()

      self.configLegendBox2 = QWidgetMac()
      self.vLayout.addWidget(self.configLegendBox2)
      self.Layout_configLegend2 = QtWidgets.QHBoxLayout(self.configLegendBox2)
      self.Layout_configLegend2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(spacer)
      
      self.configLegendSizeLabel = QtWidgets.QLabel('font')
      self.configLegendSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configLegendSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(self.configLegendSizeLabel)
      self.configLegendLabelColor = QPushButtonColor()
      self.configLegendLabelColor.setToolTip('Font color of figure legend')
      self.configLegendLabelColor.setAutoFillBackground(False)
      self.configLegendLabelColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configLegend2.addWidget(self.configLegendLabelColor)
  
      self.configLegendLabelSize = QDoubleSpinClick()
      self.Layout_configLegend2.addWidget(self.configLegendLabelSize)
      self.configLegendLabelSize.setMinimum(0.0)
      self.configLegendLabelSize.setMaximum(100.0)
      self.configLegendLabelSize.setToolTip('Font size of figure legend')
      self.configLegendLabelSize.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
      self.configLegendLabelSize.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
  
      self.configLegendLabelBold = QPushButtonCheckable()
      self.configLegendLabelBold.setText('B')
      self.configLegendLabelBold.setToolTip('Font weight of figure legend')
      self.configLegendLabelBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configLegendLabelBold.font()
      useFont.setWeight(75)
      self.configLegendLabelBold.setFont(useFont)
      self.Layout_configLegend2.addWidget(self.configLegendLabelBold)
        
      self.configLegendLabelItalic = QPushButtonCheckable()
      self.configLegendLabelItalic.setText('I')
      self.configLegendLabelItalic.setToolTip('Font style of figure legend')
      self.configLegendLabelItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configLegendLabelItalic.font()
      useFont.setItalic(True)
      self.configLegendLabelItalic.setFont(useFont)
      self.Layout_configLegend2.addWidget(self.configLegendLabelItalic)
  
      self.configLegendLabelFont = QComboBoxMac()
      self.configLegendLabelFont.setToolTip('Font of figure legend')
      self.configLegendLabelFont.addItems(self.parent.fontNames)
      self.configLegendLabelFont.setMaximumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.configLegendLabelFont.setMinimumSize(QtCore.QSize(scaledDPI(188), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(self.configLegendLabelFont)
  
      self.configLegendBox6 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox6)
      self.vLayout.addWidget(self.configLegendBox6)
      self.Layout_configLegend6 = QtWidgets.QHBoxLayout(self.configLegendBox6)
      self.Layout_configLegend6.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend6.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend6.addWidget(spacer)

      self.configLegendShadowLabel = QPushButtonCheckable()
      self.configLegendShadowLabel.setText('shadow')
      self.configLegendShadowLabel.setToolTip('Show shadow of figure legend')
      self.configLegendShadowLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configLegendShadowLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend6.addWidget(self.configLegendShadowLabel)
      
      self.configLegendShadowColor = QPushButtonColor()
      self.configLegendShadowColor.setToolTip('Color of shadow of figure legend')
      self.configLegendShadowColor.setAutoFillBackground(False)
      self.configLegendShadowColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendShadowColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendShadowColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configLegend6.addWidget(self.configLegendShadowColor)
      
      self.configLegendShadowOffXLabel = QtWidgets.QLabel('offX')
      self.configLegendShadowOffXLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffXLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend6.addWidget(self.configLegendShadowOffXLabel)
      self.configLegendShadowOffX = QLineEditClick()
      self.configLegendShadowOffX.setToolTip('Offset x of shadow of figure legend')
      self.configLegendShadowOffX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffX.setValidator(self.validFloat)
      self.Layout_configLegend6.addWidget(self.configLegendShadowOffX)
      
      self.configLegendShadowOffYLabel = QtWidgets.QLabel('offY')
      self.configLegendShadowOffYLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffYLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend6.addWidget(self.configLegendShadowOffYLabel)
      self.configLegendShadowOffY = QLineEditClick()
      self.configLegendShadowOffY.setToolTip('Offset y of shadow of figure legend')
      self.configLegendShadowOffY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendShadowOffY.setValidator(self.validFloat)
      self.Layout_configLegend6.addWidget(self.configLegendShadowOffY)
      self.Layout_configLegend6.addStretch()
  
      self.configLegendBox5 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox5)
      self.vLayout.addWidget(self.configLegendBox5)
      self.Layout_configLegend5 = QtWidgets.QHBoxLayout(self.configLegendBox5)
      self.Layout_configLegend5.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend5.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend5.addWidget(spacer)

      self.configLegendHatchLabel = QtWidgets.QLabel('hatch')
      self.configLegendHatchLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configLegendHatchLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend5.addWidget(self.configLegendHatchLabel)

      self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
      self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
      self.legendComboHatchStyle = QComboBoxMac()
      self.legendComboHatchStyle.setToolTip('Hatch style of legend')
      for entry in self.hatchstyles:
        self.legendComboHatchStyle.addItem(entry)
      self.legendComboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.legendComboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend5.addWidget(self.legendComboHatchStyle)
      self.legendComboHatchMultiplyStyle = QComboBoxMac()
      self.legendComboHatchMultiplyStyle.setToolTip('Hatch repeat of legend')
      for entry in self.hatchMultiplystyles:
        self.legendComboHatchMultiplyStyle.addItem(str(entry))
      self.legendComboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.legendComboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend5.addWidget(self.legendComboHatchMultiplyStyle)

      self.configLegendRoundingLabel = QtWidgets.QLabel('rounding')
      self.configLegendRoundingLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configLegendRoundingLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend5.addWidget(self.configLegendRoundingLabel)
      self.configLegendRounding = QLineEditClick()
      self.configLegendRounding.setToolTip('Box rounding of figure legend')
      self.configLegendRounding.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendRounding.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendRounding.setValidator(self.validFloat)
      self.Layout_configLegend5.addWidget(self.configLegendRounding)
      self.Layout_configLegend5.addStretch()

      self.configLegendBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox3)
      self.vLayout.addWidget(self.configLegendBox3)
      self.Layout_configLegend3 = QtWidgets.QHBoxLayout(self.configLegendBox3)
      self.Layout_configLegend3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(spacer)
      
      self.configLegendNColLabel = QtWidgets.QLabel('#cols')
      self.configLegendNColLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configLegendNColLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendNColLabel)
      self.configLegendNCol = QComboBoxMac()
      self.configLegendNCol.setToolTip('Number of columns in figure legend')
      for entry in [str(i + 1) for i in range(10)]:
        self.configLegendNCol.addItem(str(entry))
      self.configLegendNCol.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configLegendNCol.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendNCol)
  
      self.configLegendMarkerFirstLabel = QPushButtonCheckable()
      self.configLegendMarkerFirstLabel.setText('mark. 1st')
      self.configLegendMarkerFirstLabel.setToolTip('Draw markers first in figure legend')
      self.configLegendMarkerFirstLabel.setMaximumSize(QtCore.QSize(scaledDPI(62), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerFirstLabel.setMinimumSize(QtCore.QSize(scaledDPI(62), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerFirstLabel)
      # disable this control on Linux platforms
      if(platform in ['linux', 'darwin']):
        self.configLegendMarkerFirstLabel.hide()
  
      self.configLegendMarkerScaleLabel = QtWidgets.QLabel('scale')
      self.configLegendMarkerScaleLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScaleLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerScaleLabel)
      self.configLegendMarkerScale = QLineEditClick()
      self.configLegendMarkerScale.setToolTip('Scale factor of markers in figure legend')
      self.configLegendMarkerScale.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScale.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScale.setValidator(self.validFloat)
      self.Layout_configLegend3.addWidget(self.configLegendMarkerScale)
  
      self.configLegendMarkerNumPointsLabel = QtWidgets.QLabel('#pts')
      self.configLegendMarkerNumPointsLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerNumPointsLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerNumPointsLabel)
      self.configLegendMarkerNumPoints = QComboBoxMac()
      self.configLegendMarkerNumPoints.setToolTip('Number of markers in figure legend')
      for entry in [str(i + 1) for i in range(10)]:
        self.configLegendMarkerNumPoints.addItem(str(entry))
      self.configLegendMarkerNumPoints.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerNumPoints.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerNumPoints)
  
      self.configLegendBox4 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox4)
      self.vLayout.addWidget(self.configLegendBox4)
      self.Layout_configLegend4 = QtWidgets.QHBoxLayout(self.configLegendBox4)
      self.Layout_configLegend4.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend4.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(spacer)
      
      self.configLegendPadLabel = QtWidgets.QLabel('pad')
      self.configLegendPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.configLegendPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadLabel)
      self.configLegendPadBorderLabel = QtWidgets.QLabel('border')
      self.configLegendPadBorderLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorderLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadBorderLabel)
      self.configLegendPadBorder = QLineEditClick()
      self.configLegendPadBorder.setToolTip('Border padding in figure legend')
      self.configLegendPadBorder.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorder.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorder.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadBorder)
      
      self.configLegendPadRowLabel = QtWidgets.QLabel('rows')
      self.configLegendPadRowLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadRowLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadRowLabel)
      self.configLegendPadRow = QLineEditClick()
      self.configLegendPadRow.setToolTip('Row padding in figure legend')
      self.configLegendPadRow.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadRow.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadRow.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadRow)
      
      self.configLegendPadColLabel = QtWidgets.QLabel('cols')
      self.configLegendPadColLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadColLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadColLabel)
      self.configLegendPadCol = QLineEditClick()
      self.configLegendPadCol.setToolTip('Column padding in figure legend')
      self.configLegendPadCol.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadCol.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadCol.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadCol)

    # canvas config
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configCanvasBox = QWidgetMac()
      self.vLayout.addWidget(self.configCanvasBox)
      self.Layout_configCanvas = QtWidgets.QHBoxLayout(self.configCanvasBox)
      self.Layout_configCanvas.setContentsMargins(0, 0, 0, 0)
      self.Layout_configCanvas.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configFigureLabel = QPushButtonCheckable()
      self.configFigureLabel.setText('figure')
      self.configFigureLabel.setToolTip('Show figure background')
      self.configFigureLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configFigureLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configCanvas.addWidget(self.configFigureLabel)
      self.configFigureColorButton = QPushButtonColor()
      self.configFigureColorButton.setToolTip('Color of figure background')
      self.configFigureColorButton.setAutoFillBackground(False)
      self.configFigureColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFigureColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFigureColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configCanvas.addWidget(self.configFigureColorButton)
  
      self.configCanvasLabel = QPushButtonCheckable()
      self.configCanvasLabel.setText('canvas')
      self.configCanvasLabel.setToolTip('Show figure canvas')
      self.configCanvasLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configCanvasLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configCanvas.addWidget(self.configCanvasLabel)
      self.configCanvasColorButton = QPushButtonColor()
      self.configCanvasColorButton.setToolTip('Color of figure canvas')
      self.configCanvasColorButton.setAutoFillBackground(False)
      self.configCanvasColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configCanvas.addWidget(self.configCanvasColorButton)

      # canvas gradient
      self.canvasGradientBox = QWidgetMac()
      self.vLayout.addWidget(self.canvasGradientBox)
      self.Layout_canvasGradient = QtWidgets.QHBoxLayout(self.canvasGradientBox)
      self.Layout_canvasGradient.setContentsMargins(0, 0, 0, 0)
      self.Layout_canvasGradient.setAlignment(QtCore.Qt.AlignLeft)
      self.advancedGraphicsSettings.append(self.canvasGradientBox)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(spacer)

      self.configCanvasGradientLabel = QPushButtonCheckable()
      self.configCanvasGradientLabel.setText('gradient')
      self.configCanvasGradientLabel.setToolTip('Show gradient on figure canvas')
      self.configCanvasGradientLabel.setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientLabel.setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientLabel)

      self.configCanvasGradientStyle = QComboBoxMac()
      self.configCanvasGradientStyle.setToolTip('Style of gradient on figure canvas')
      self.configCanvasGradientStyle.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientStyle.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      for entry in ['linear', 'radial']:
        self.configCanvasGradientStyle.addItem(str(entry))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientStyle)

      self.configCanvasGradientColor1Button = QPushButtonColor()
      self.configCanvasGradientColor1Button.setToolTip('Color #1 of gradient on figure canvas')
      self.configCanvasGradientColor1Button.setAutoFillBackground(False)
      self.configCanvasGradientColor1Button.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor1Button.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor1Button.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientColor1Button)  
      self.configCanvasGradientColor2Button = QPushButtonColor()
      self.configCanvasGradientColor2Button.setToolTip('Color #2 of gradient on figure canvas')
      self.configCanvasGradientColor2Button.setAutoFillBackground(False)
      self.configCanvasGradientColor2Button.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor2Button.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor2Button.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientColor2Button)  

      self.configCanvasGradientAngleLabel = QtWidgets.QLabel('angle')
      self.configCanvasGradientAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientAngleLabel)
      self.configCanvasGradientAngle = QLineEditClick()
      self.configCanvasGradientAngle.setToolTip('Angle of gradient on figure canvas')
      self.configCanvasGradientAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngle.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientAngle)

      self.configCanvasGradientCenterLabel = QtWidgets.QLabel('center')
      self.configCanvasGradientCenterLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterLabel)
      self.configCanvasGradientCenterX = QLineEditClick()
      self.configCanvasGradientCenterX.setToolTip('Center x position of gradient on figure canvas')
      self.configCanvasGradientCenterX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterX.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterX)
      self.configCanvasGradientCenterY = QLineEditClick()
      self.configCanvasGradientCenterY.setToolTip('Center y position of gradient on figure canvas')
      self.configCanvasGradientCenterY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterY.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterY)
      
      self.configCanvasGradientWidthLabel = QtWidgets.QLabel('width')
      self.configCanvasGradientWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientWidthLabel)
      self.configCanvasGradientWidth = QLineEditClick()
      self.configCanvasGradientWidth.setToolTip('Width of gradient on figure canvas')
      self.configCanvasGradientWidth.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidth.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidth.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientWidth)

      # canvas dimensions
      self.exportSizeBox = QWidgetMac()
      self.vLayout.addWidget(self.exportSizeBox)
      self.Layout_exportSize = QtWidgets.QHBoxLayout(self.exportSizeBox)
      self.Layout_exportSize.setContentsMargins(0, 0, 0, 0)
      self.Layout_exportSize.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(spacer)
      
      self.exportSizeBaseLabel = QtWidgets.QLabel('fig.')
      self.exportSizeBaseLabel.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.exportSizeBaseLabel.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeBaseLabel)
      self.exportSizeXLabel = QtWidgets.QLabel('width')
      self.exportSizeXLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.exportSizeXLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeXLabel)
      self.exportSizeX = QLineEditClick()
      self.exportSizeX.setToolTip('Width of exported figure in inches')
      self.exportSizeX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeX.setValidator(self.validFloat)
      self.Layout_exportSize.addWidget(self.exportSizeX)
      self.exportSizeYLabel = QtWidgets.QLabel('height')
      self.exportSizeYLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.exportSizeYLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeYLabel)
      self.exportSizeY = QLineEditClick()
      self.exportSizeY.setToolTip('Height of exported figure in inches')
      self.exportSizeY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeY.setValidator(self.validFloat)
      self.Layout_exportSize.addWidget(self.exportSizeY)
      self.exportSizeCurrentButton = QPushButtonMac()
      self.exportSizeCurrentButton.setText('Use screen')
      self.exportSizeCurrentButton.setToolTip('Use current dimensions on screen for exporting figure')
      self.exportSizeCurrentButton.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.exportSizeCurrentButton.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeCurrentButton)
      
      # pad graphics
      self.exportPadBox = QWidgetMac()
      self.vLayout.addWidget(self.exportPadBox)
      self.Layout_exportPad = QtWidgets.QHBoxLayout(self.exportPadBox)
      self.Layout_exportPad.setContentsMargins(0, 0, 0, 0)
      self.Layout_exportPad.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_exportPad.addWidget(spacer)
  
      self.exportPadLabelMain = QtWidgets.QLabel('pad')
      self.exportPadLabelMain.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.exportPadLabelMain.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_exportPad.addWidget(self.exportPadLabelMain)
  
      self.exportPadLabel = {}; self.exportPadEntry = {}
      for axis in ['bottom', 'top', 'left', 'right']:
        self.exportPadLabel[axis] = QtWidgets.QLabel(axis)
        self.exportPadLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
        self.exportPadLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
        self.Layout_exportPad.addWidget(self.exportPadLabel[axis])
  
        self.exportPadEntry[axis] = QLineEditClick()
        self.exportPadEntry[axis].setToolTip('Pad ' + axis + ' of figure')
        self.exportPadEntry[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.exportPadEntry[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.exportPadEntry[axis].setValidator(self.validFloat)
        self.Layout_exportPad.addWidget(self.exportPadEntry[axis])
      
      # format frame
      self.configFrameBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configFrameBox)
      self.vLayout.addWidget(self.configFrameBox)
      self.Layout_configFrame = QtWidgets.QHBoxLayout(self.configFrameBox)
      self.Layout_configFrame.setContentsMargins(0, 0, 0, 0)
      self.Layout_configFrame.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configFrameLabel = QPushButtonCheckable()
      self.configFrameLabel.setText('frame')
      self.configFrameLabel.setToolTip('Show figure frame')
      self.configFrameLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configFrameLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameLabel)
      
      self.configFrameColor = QPushButtonColor()
      self.configFrameColor.setToolTip('Color of figure frame')
      self.configFrameColor.setAutoFillBackground(False)
      self.configFrameColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFrameColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFrameColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configFrame.addWidget(self.configFrameColor)

      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(spacer)
    
      self.configFrameWidthLabel = QtWidgets.QLabel('width')
      self.configFrameWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configFrameWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameWidthLabel)
      self.configFrameWidth = QDoubleSpinClick()
      self.Layout_configFrame.addWidget(self.configFrameWidth)
      self.configFrameWidth.setMinimum(0.0)
      self.configFrameWidth.setMaximum(100.0)
      self.configFrameWidth.setToolTip('Line width of figure frame')
      self.configFrameWidth.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configFrameWidth.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
  
      self.configFrameStyle = QComboBoxMac()
      self.configFrameStyle.setToolTip('Line style of figure frame')
      self.configFrameStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configFrameStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameStyle)
  
      self.configFrameDashStyle = QComboBoxMac()
      self.configFrameDashStyle.setToolTip('Cap style of figure frame')
      self.configFrameDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configFrameDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameDashStyle)
    
    # xkcdify
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configXkcdBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configXkcdBox)
      self.vLayout.addWidget(self.configXkcdBox)
      self.Layout_configXkcd = QtWidgets.QHBoxLayout(self.configXkcdBox)
      self.Layout_configXkcd.setContentsMargins(0, 0, 0, 0)
      self.Layout_configXkcd.setAlignment(QtCore.Qt.AlignLeft)

      self.configXkcdLabel = QPushButtonCheckable()
      self.configXkcdLabel.setText('xkcdify')
      self.configXkcdLabel.setToolTip('Use xkcd effects')
      self.configXkcdLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configXkcdLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.configXkcdLabel)
  
      self.xkcdScaleLabel = QtWidgets.QLabel('scale')
      self.xkcdScaleLabel.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdScaleLabel.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdScaleLabel)
      self.xkcdScale = QLineEditClick()
      self.xkcdScale.setToolTip('Amplitude of xkcd effects')
      self.xkcdScale.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdScale.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdScale.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdScale)
  
      self.xkcdLengthLabel = QtWidgets.QLabel('length')
      self.xkcdLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.xkcdLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdLengthLabel)
      self.xkcdLength = QLineEditClick()
      self.xkcdLength.setToolTip('Length scale of xkcd effects')
      self.xkcdLength.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdLength.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdLength.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdLength)
  
      self.xkcdRandomLabel = QtWidgets.QLabel('random')
      self.xkcdRandomLabel.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.xkcdRandomLabel.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdRandomLabel)
      self.xkcdRandom = QLineEditClick()
      self.xkcdRandom.setToolTip('Randomness of xkcd effects')
      self.xkcdRandom.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdRandom.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.xkcdRandom.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdRandom)
  
      # path effects -- stroke
      self.configPathEffectsBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configPathEffectsBox)
      self.vLayout.addWidget(self.configPathEffectsBox)
      self.Layout_configPathEffects = QtWidgets.QHBoxLayout(self.configPathEffectsBox)
      self.Layout_configPathEffects.setContentsMargins(0, 0, 0, 0)
      self.Layout_configPathEffects.setAlignment(QtCore.Qt.AlignLeft)

      self.configPathEffectsLabel = QPushButtonCheckable()
      self.configPathEffectsLabel.setText('outline')
      self.configPathEffectsLabel.setToolTip('Use outline effects')
      self.configPathEffectsLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configPathEffectsLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configPathEffects.addWidget(self.configPathEffectsLabel)
  
      self.configPathEffectsColorButton = QPushButtonColor()
      self.configPathEffectsColorButton.setToolTip('Color of outline')
      self.configPathEffectsColorButton.setAutoFillBackground(False)
      self.configPathEffectsColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathEffectsColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathEffectsColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configPathEffects.addWidget(self.configPathEffectsColorButton)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      self.Layout_configPathEffects.addWidget(spacer)
    
      self.configPathEffectsWidthLabel = QtWidgets.QLabel('width')
      self.configPathEffectsWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configPathEffectsWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configPathEffects.addWidget(self.configPathEffectsWidthLabel)

      self.configPathEffectsWidth = QDoubleSpinClick()
      self.Layout_configPathEffects.addWidget(self.configPathEffectsWidth)
      self.configPathEffectsWidth.setMinimum(0.0)
      self.configPathEffectsWidth.setMaximum(100.0)
      self.configPathEffectsWidth.setToolTip('Line width of outline')
      self.configPathEffectsWidth.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configPathEffectsWidth.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
   
      # path effects -- shadow
      self.configPathShadowBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configPathShadowBox)
      self.vLayout.addWidget(self.configPathShadowBox)
      self.Layout_configPathShadow = QtWidgets.QHBoxLayout(self.configPathShadowBox)
      self.Layout_configPathShadow.setContentsMargins(0, 0, 0, 0)
      self.Layout_configPathShadow.setAlignment(QtCore.Qt.AlignLeft)

      self.configPathShadowLabel = QPushButtonCheckable()
      self.configPathShadowLabel.setText('shadow')
      self.configPathShadowLabel.setToolTip('Use shadow effects')
      self.configPathShadowLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configPathShadowLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowLabel)
  
      self.configPathShadowColorButton = QPushButtonColor()
      self.configPathShadowColorButton.setToolTip('Color of shadow')
      self.configPathShadowColorButton.setAutoFillBackground(False)
      self.configPathShadowColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathShadowColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathShadowColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configPathShadow.addWidget(self.configPathShadowColorButton)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(7), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(spacer)
    
      self.configPathShadowOffXLabel = QtWidgets.QLabel('offX')
      self.configPathShadowOffXLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffXLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffXLabel)
      self.configPathShadowOffX = QLineEditClick()
      self.configPathShadowOffX.setToolTip('Offset x of shadow')
      self.configPathShadowOffX.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffX.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffX.setValidator(self.validFloat)
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffX)
   
      self.configPathShadowOffYLabel = QtWidgets.QLabel('offY')
      self.configPathShadowOffYLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffYLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffYLabel)
      self.configPathShadowOffY = QLineEditClick()
      self.configPathShadowOffY.setToolTip('Offset y of shadow')
      self.configPathShadowOffY.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffY.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffY.setValidator(self.validFloat)
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffY)

    # additional button to control visibility of advanced graphics settings
    if(not self.secondAxes):
      blah = self.HLine()
      self.advancedGraphicsSettings.append(blah)
      self.vLayout.addWidget(blah)
      
      self.configAdvancedSettings = QWidgetMac()
      self.vLayout.addWidget(self.configAdvancedSettings)
      self.Layout_configAdvancedSettings = QtWidgets.QHBoxLayout(self.configAdvancedSettings)
      self.Layout_configAdvancedSettings.setContentsMargins(0, 0, 0, 0)
      self.Layout_configAdvancedSettings.setAlignment(QtCore.Qt.AlignLeft)

      self.configAdvancedSettingsLabel = QtWidgets.QLabel('Adv. settings')
      self.configAdvancedSettingsLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configAdvancedSettingsLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configAdvancedSettings.addWidget(self.configAdvancedSettingsLabel)
      
      self.configAdvancedSettingsButton = QPushButtonCheckable()
      self.configAdvancedSettingsButton.setText('show')
      self.configAdvancedSettingsButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.configAdvancedSettingsButton.setToolTip('Display advanced graphics options')
      self.Layout_configAdvancedSettings.addWidget(self.configAdvancedSettingsButton)
      
    self.vLayout.addStretch()
 
    # export graphics
    if(not self.secondAxes):
      self.exportBox = QWidgetMac()
      self.vLayout_0.addWidget(self.exportBox)
      self.Layout_export = QtWidgets.QHBoxLayout(self.exportBox)
      self.Layout_export.setContentsMargins(0, 0, 0, 0)
      self.Layout_export.setAlignment(QtCore.Qt.AlignLeft)
      self.previewButton = QPushButtonMac()
      self.previewButton.setText('Preview')
      self.previewButton.setToolTip('Display plot graphics preview\n(F5)')
      self.previewButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.previewButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.previewButton)
      self.exportButton = QPushButtonMac()
      self.exportButton.setText('Export graphics')
      self.exportButton.setToolTip('Export graphics in bitmapped and vector formats\n(Ctrl-P)')
      self.exportButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.exportButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.exportButton)
      self.reportButton = QPushButtonMac()
      self.reportButton.setText('Create report')
      self.reportButton.setToolTip('Compile report of current graphics and fit results\n(Ctrl-G or F3)')
      self.reportButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.reportButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.reportButton)
  
      # load/save style
      self.loadStyleSet = QPushButtonMac()
      self.loadStyleSet.setText('Open style')
      self.loadStyleSet.setToolTip('Load graphics style settings')
      self.loadStyleSet.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.loadStyleSet.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.loadStyleSet)
      self.saveStyleSet = QPushButtonMac()
      self.saveStyleSet.setText('Save style')
      self.saveStyleSet.setToolTip('Save current graphics style settings to file')
      self.saveStyleSet.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.saveStyleSet.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.saveStyleSet)

    # hide less frequent options
    for entry in self.advancedGraphicsSettings:
      if((not self.advancedExport['advancedGraphics']) and (hasattr(entry, 'hide'))):
        entry.hide()
        
  def visibilityCanvasGradientControls(self):
    # controls visibility of canvas control elements
    items1 = [self.configCanvasGradientAngleLabel, self.configCanvasGradientAngle]
    items2 = [self.configCanvasGradientCenterLabel, self.configCanvasGradientCenterX,
              self.configCanvasGradientCenterY, self.configCanvasGradientWidthLabel, self.configCanvasGradientWidth]

    # determine state
    if(self.configCanvasGradientStyle.currentText() == 'linear'):
      for entry in items1:
        entry.show()
      for entry in items2:
        entry.hide()
    else:
      for entry in items1:
        entry.hide()
      for entry in items2:
        entry.show()

  def updateFields(self, initialize=False):
    # updates all fields in entry mask
    defaultFont = 'DejaVu Sans'
    # x label config
    if(not self.secondAxes):
      self.configXLabel.setChecked(self.parent.plotArea.labelXShow)
      self.configXName.setText(self.parent.plotArea.labelX)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelXColor[0:3]]
      self.configXColorButton.setMyColor(*colorvalue)
      self.configXSize.setValue(self.parent.plotArea.labelXSize)
      if(self.parent.plotArea.labelXWeight == 'bold'):
        self.configXBold.setChecked(True)
      else:
        self.configXBold.setChecked(False)
      if(self.parent.plotArea.labelXStyle == 'italic'):
        self.configXItalic.setChecked(True)
      else:
        self.configXItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelXVariant == 'small-caps'):
        self.configXVariant.setChecked(True)
      else:
        self.configXVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['x'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['x'])
        self.configXFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configXFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['x'] = defaultFont
      else:
        self.configXFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelXAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelXAlignment)
        self.configXAlignment.setCurrentIndex(currindex)
      else:
        self.configXAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelXAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelXAlignmentVertical)
        self.configXAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configXAlignmentVertical.setCurrentIndex(0)
      self.configXPad.setText(str(self.parent.plotArea.labelXPad))
      self.configXPos.setText(str(self.parent.plotArea.labelXPos))
      self.configXAngle.setValue(self.parent.plotArea.labelXAngle)

    # y label config
    if(not self.secondAxes):
      self.configYLabel.setChecked(self.parent.plotArea.labelYShow)
      self.configYName.setText(self.parent.plotArea.labelY)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelYColor[0:3]]
      self.configYColorButton.setMyColor(*colorvalue)
      self.configYSize.setValue(self.parent.plotArea.labelYSize)
      if(self.parent.plotArea.labelYWeight == 'bold'):
        self.configYBold.setChecked(True)
      else:
        self.configYBold.setChecked(False)
      if(self.parent.plotArea.labelYStyle == 'italic'):
        self.configYItalic.setChecked(True)
      else:
        self.configYItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelYVariant == 'small-caps'):
        self.configYVariant.setChecked(True)
      else:
        self.configYVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['y'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['y'])
        self.configYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configYFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['y'] = defaultFont
      else:
        self.configYFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelYAlignment)
        self.configYAlignment.setCurrentIndex(currindex)
      else:
        self.configYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelYAlignmentVertical)
        self.configYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configYAlignmentVertical.setCurrentIndex(0)
      self.configYPad.setText(str(self.parent.plotArea.labelYPad))
      self.configYPos.setText(str(self.parent.plotArea.labelYPos))
      self.configYAngle.setValue(self.parent.plotArea.labelYAngle)
    else:
      self.configYLabel.setChecked(self.parent.plotArea.labelY2Show)
      self.configYName.setText(self.parent.plotArea.labelY2)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelY2Color[0:3]]
      self.configYColorButton.setMyColor(*colorvalue)
      self.configYSize.setValue(self.parent.plotArea.labelY2Size)
      if(self.parent.plotArea.labelY2Weight == 'bold'):
        self.configYBold.setChecked(True)
      else:
        self.configYBold.setChecked(False)
      if(self.parent.plotArea.labelY2Style == 'italic'):
        self.configYItalic.setChecked(True)
      else:
        self.configYItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelY2Variant == 'small-caps'):
        self.configYVariant.setChecked(True)
      else:
        self.configYVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['y2'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['y2'])
        self.configYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configYFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['y2'] = defaultFont
      else:
        self.configYFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelY2Alignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelY2Alignment)
        self.configYAlignment.setCurrentIndex(currindex)
      else:
        self.configYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelY2AlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelY2AlignmentVertical)
        self.configYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configYAlignmentVertical.setCurrentIndex(0)
      self.configYPad.setText(str(self.parent.plotArea.labelY2Pad))
      self.configYPos.setText(str(self.parent.plotArea.labelY2Pos))
      self.configYAngle.setValue(self.parent.plotArea.labelY2Angle)

    # axis config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisLabel[axis].setChecked(self.parent.plotArea.axisVisible[axis])
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.axisColor[axis][0:3]]
      self.configAxisColor[axis].setMyColor(*colorvalue)
      self.configAxisWidth[axis].setValue(self.parent.plotArea.axisWidth[axis])
      if(initialize):
        for entry in self.linestyles2:
          self.configAxisStyle[axis].addItem(entry)
      if(self.parent.plotArea.axisStyle[axis] in self.linestyles2):
        currindex = self.linestyles2.index(self.parent.plotArea.axisStyle[axis])
        self.configAxisStyle[axis].setCurrentIndex(currindex)
      else:
        self.configAxisStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configAxisDashStyle[axis].addItem(entry)
      if(self.parent.plotArea.axisDashStyle[axis] in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.axisDashStyle[axis])
        self.configAxisDashStyle[axis].setCurrentIndex(currindex)
      else:
        self.configAxisDashStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.positionstyles:
          self.configAxisPosition[axis].addItem(entry)
      if(self.parent.plotArea.axisPosition[axis] in self.positionstyles):
        currindex = self.positionstyles.index(self.parent.plotArea.axisPosition[axis])
        self.configAxisPosition[axis].setCurrentIndex(currindex)
      else:
        self.configAxisPosition[axis].setCurrentIndex(0)
      self.configAxisPositionValue[axis].setText(str(self.parent.plotArea.axisPositionValue[axis]))
      self.configAxisBoundLabel[axis].setChecked(self.parent.plotArea.axisBoundaryCheck[axis])
      self.configAxisBoundLower[axis].setText(str(self.parent.plotArea.axisBoundary[axis][0]))
      self.configAxisBoundUpper[axis].setText(str(self.parent.plotArea.axisBoundary[axis][1]))
        
    # arrow config
    if(not self.secondAxes):
      for axis in ['x', 'y']:
        self.configArrowLabel[axis].setChecked(self.parent.plotArea.arrowVisible[axis])
        self.configArrowLineColorLabel[axis].setChecked(self.parent.plotArea.arrowEdgeShow[axis])
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.arrowColor[axis][0:3]]
        self.configArrowLineColor[axis].setMyColor(*colorvalue)
        self.configArrowFillColorLabel[axis].setChecked(self.parent.plotArea.arrowFillShow[axis])
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.arrowFill[axis][0:3]]
        self.configArrowFillColor[axis].setMyColor(*colorvalue)
        self.configArrowLineWidth[axis].setValue(self.parent.plotArea.arrowEdge[axis])
        self.configArrowHeadLength[axis].setText(str(self.parent.plotArea.arrowHeadLength[axis]))
        self.configArrowHeadWidth[axis].setText(str(self.parent.plotArea.arrowHeadWidth[axis]))
        self.configArrowOverhang[axis].setText(str(self.parent.plotArea.arrowOverhang[axis]))
        self.configArrowOffset[axis].setText(str(self.parent.plotArea.arrowOffset[axis]))

      self.locationXstyles = ['bottom', 'top', 'both']
      self.locationYstyles = ['left', 'right', 'both']
      if(initialize):
        for item in self.locationXstyles:
          self.configArrowLocation['x'].addItem(item)
        for item in self.locationYstyles:
          self.configArrowLocation['y'].addItem(item)
      if(self.parent.plotArea.arrowLocation['x'] in self.locationXstyles):
        currindex = self.locationXstyles.index(self.parent.plotArea.arrowLocation['x'])
        self.configArrowLocation['x'].setCurrentIndex(currindex)
      else:
        self.configArrowLocation['x'].setCurrentIndex(0)
      if(self.parent.plotArea.arrowLocation['y'] in self.locationYstyles):
        currindex = self.locationYstyles.index(self.parent.plotArea.arrowLocation['y'])
        self.configArrowLocation['y'].setCurrentIndex(currindex)
      else:
        self.configArrowLocation['y'].setCurrentIndex(0)

    # x ticks config
    if(not self.secondAxes):
      self.configTickXLabel.setChecked(self.parent.plotArea.ticksXShow)
      self.configTickXAuto.setChecked(self.parent.plotArea.ticksXAuto)
      tickstr = self.magicTickstring(self.parent.plotArea.ticksX)
      self.configTickXEntry.setText(tickstr)
      self.configMinorTickXLabel.setChecked(self.parent.plotArea.ticksXMinor != 0)
      if((self.parent.plotArea.ticksXMinor - 2) in [i for i in range(9)]):
        self.configMinorTickX.setCurrentIndex(self.parent.plotArea.ticksXMinor - 2)
      else:
        self.configMinorTickX.setCurrentIndex(0)
      self.configMinorTickXRelativeLength.setText(str(self.parent.plotArea.ticksXMinorRelativeLength))
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksXColor[0:3]]
      self.configTickXColorButton.setMyColor(*colorvalue)
      self.configTickXSize.setValue(self.parent.plotArea.ticksXSize)
      if(self.parent.plotArea.ticksXWeight == 'bold'):
        self.configTickXBold.setChecked(True)
      else:
        self.configTickXBold.setChecked(False)
      if(self.parent.plotArea.ticksXStyle == 'italic'):
        self.configTickXItalic.setChecked(True)
      else:
        self.configTickXItalic.setChecked(False)
      self.configTickXAngle.setValue(self.parent.plotArea.ticksXAngle)
      if(self.parent.plotArea.ticksXAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksXAlignment)
        self.configTickXAlignment.setCurrentIndex(currindex)
      else:
        self.configTickXAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksXAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksXAlignmentVertical)
        self.configTickXAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickXAlignmentVertical.setCurrentIndex(0)
      self.configTickXPad.setText(str(self.parent.plotArea.ticksXPad))
      self.configTickXPad2.setText(str(self.parent.plotArea.ticksXPad2))
      if(self.parent.plotArea.tickFont['x'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['x'])
        self.configTickXFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickXFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['x'] = defaultFont
      else:
        self.configTickXFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksXFormat in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksXFormat)
        self.configTickXFormat.setCurrentIndex(currindex)
      else:
        self.configTickXFormat.setCurrentIndex(0)
      self.configTickXFormatPrecision.setText(str(self.parent.plotArea.ticksXFormatPrecision))
      self.configTickXFormatTrailZero.setChecked(self.parent.plotArea.ticksXFormatTrailZero)
      self.configTickXFormatSeparator.setChecked(self.parent.plotArea.ticksXFormatSeparator)
      self.configTickXFormatComma.setChecked(self.parent.plotArea.ticksXFormatComma)
      self.configTickXPrefix.setText(str(self.parent.plotArea.ticksXFormatPrefix))
      self.configTickXPostfix.setText(str(self.parent.plotArea.ticksXFormatPostfix))
      self.updateTickFormatFields(axis='x', tickFormat=self.parent.plotArea.ticksXFormat)      

    # y ticks config
    if(not self.secondAxes):
      self.configTickYLabel.setChecked(self.parent.plotArea.ticksYShow)
      self.configTickYAuto.setChecked(self.parent.plotArea.ticksYAuto)
      tickstr = self.magicTickstring(self.parent.plotArea.ticksY)
      self.configTickYEntry.setText(tickstr)
      self.configMinorTickYLabel.setChecked(self.parent.plotArea.ticksYMinor != 0)
      if((self.parent.plotArea.ticksYMinor - 2) in [i for i in range(9)]):
        self.configMinorTickY.setCurrentIndex(self.parent.plotArea.ticksYMinor - 2)
      else:
        self.configMinorTickY.setCurrentIndex(0)
      self.configMinorTickYRelativeLength.setText(str(self.parent.plotArea.ticksYMinorRelativeLength))
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksYColor[0:3]]
      self.configTickYColorButton.setMyColor(*colorvalue)
      self.configTickYSize.setValue(self.parent.plotArea.ticksYSize)
      if(self.parent.plotArea.ticksYWeight == 'bold'):
        self.configTickYBold.setChecked(True)
      else:
        self.configTickYBold.setChecked(False)
      if(self.parent.plotArea.ticksYStyle == 'italic'):
        self.configTickYItalic.setChecked(True)
      else:
        self.configTickYItalic.setChecked(False)
      self.configTickYAngle.setValue(self.parent.plotArea.ticksYAngle)
      if(self.parent.plotArea.ticksYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksYAlignment)
        self.configTickYAlignment.setCurrentIndex(currindex)
      else:
        self.configTickYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksYAlignmentVertical)
        self.configTickYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickYAlignmentVertical.setCurrentIndex(0)
      self.configTickYPad.setText(str(self.parent.plotArea.ticksYPad))
      self.configTickYPad2.setText(str(self.parent.plotArea.ticksYPad2))
      if(self.parent.plotArea.tickFont['y'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['y'])
        self.configTickYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickYFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['y'] = defaultFont
      else:
        self.configTickYFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYFormat in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksYFormat)
        self.configTickYFormat.setCurrentIndex(currindex)
      else:
        self.configTickYFormat.setCurrentIndex(0)
      self.configTickYFormatPrecision.setText(str(self.parent.plotArea.ticksYFormatPrecision))
      self.configTickYFormatTrailZero.setChecked(self.parent.plotArea.ticksYFormatTrailZero)
      self.configTickYFormatSeparator.setChecked(self.parent.plotArea.ticksYFormatSeparator)
      self.configTickYFormatComma.setChecked(self.parent.plotArea.ticksYFormatComma)
      self.configTickYPrefix.setText(str(self.parent.plotArea.ticksYFormatPrefix))
      self.configTickYPostfix.setText(str(self.parent.plotArea.ticksYFormatPostfix))
      self.updateTickFormatFields(axis='y', tickFormat=self.parent.plotArea.ticksYFormat)      
    else:
      self.configTickYLabel.setChecked(self.parent.plotArea.ticksY2Show)
      self.configTickYAuto.setChecked(self.parent.plotArea.ticksY2Auto)
      tickstr = self.magicTickstring(self.parent.plotArea.ticksY2)
      self.configTickYEntry.setText(tickstr)
      self.configMinorTickYLabel.setChecked(self.parent.plotArea.ticksY2Minor != 0)
      if((self.parent.plotArea.ticksY2Minor - 2) in [i for i in range(9)]):
        self.configMinorTickY.setCurrentIndex(self.parent.plotArea.ticksY2Minor - 2)
      else:
        self.configMinorTickY.setCurrentIndex(0)
      self.configMinorTickYRelativeLength.setText(str(self.parent.plotArea.ticksY2MinorRelativeLength))
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksY2Color[0:3]]
      self.configTickYColorButton.setMyColor(*colorvalue)
      self.configTickYSize.setValue(self.parent.plotArea.ticksY2Size)
      if(self.parent.plotArea.ticksY2Weight == 'bold'):
        self.configTickYBold.setChecked(True)
      else:
        self.configTickYBold.setChecked(False)
      if(self.parent.plotArea.ticksY2Style == 'italic'):
        self.configTickYItalic.setChecked(True)
      else:
        self.configTickYItalic.setChecked(False)
      self.configTickYAngle.setValue(self.parent.plotArea.ticksY2Angle)
      if(self.parent.plotArea.ticksYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksY2Alignment)
        self.configTickYAlignment.setCurrentIndex(currindex)
      else:
        self.configTickYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksY2AlignmentVertical)
        self.configTickYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickYAlignmentVertical.setCurrentIndex(0)
      self.configTickYPad.setText(str(self.parent.plotArea.ticksY2Pad))
      self.configTickYPad2.setText(str(self.parent.plotArea.ticksY2Pad2))
      if(self.parent.plotArea.tickFont['y2'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['y2'])
        self.configTickYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickYFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['y2'] = defaultFont
      else:
        self.configTickYFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksY2Format in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksY2Format)
        self.configTickYFormat.setCurrentIndex(currindex)
      else:
        self.configTickYFormat.setCurrentIndex(0)
      self.configTickYFormatPrecision.setText(str(self.parent.plotArea.ticksY2FormatPrecision))
      self.configTickYFormatTrailZero.setChecked(self.parent.plotArea.ticksY2FormatTrailZero)
      self.configTickYFormatSeparator.setChecked(self.parent.plotArea.ticksY2FormatSeparator)
      self.configTickYFormatComma.setChecked(self.parent.plotArea.ticksY2FormatComma)
      self.configTickYPrefix.setText(str(self.parent.plotArea.ticksY2FormatPrefix))
      self.configTickYPostfix.setText(str(self.parent.plotArea.ticksY2FormatPostfix))
      self.updateTickFormatFields(axis='y2', tickFormat=self.parent.plotArea.ticksY2Format)      

    # y resid ticks config
    if(not self.secondAxes):
      self.configTickResidYLabel.setChecked(self.parent.plotArea.ticksResidYShow)
      self.configTickResidYAuto.setChecked(self.parent.plotArea.ticksResidYAuto)
      tickstr = self.magicTickstring(self.parent.plotArea.ticksResidY)
      self.configTickResidYEntry.setText(tickstr)
      self.configMinorTickResidLabel.setChecked(self.parent.plotArea.ticksResidYMinor != 0)
      if((self.parent.plotArea.ticksResidYMinor - 2) in [i for i in range(9)]):
        self.configMinorTickResid.setCurrentIndex(self.parent.plotArea.ticksResidYMinor - 2)
      else:
        self.configMinorTickResid.setCurrentIndex(0)
      self.configMinorTickResidRelativeLength.setText(str(self.parent.plotArea.ticksResidYMinorRelativeLength))

    # tick mark config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkLabel[axis].setChecked(self.parent.plotArea.ticksVisible[axis])
      if(initialize):
        for entry in self.directionstyles:
          self.configTickMarkDirection[axis].addItem(entry)
      if(self.parent.plotArea.ticksDirection[axis] in self.directionstyles):
        currindex = self.directionstyles.index(self.parent.plotArea.ticksDirection[axis])
        self.configTickMarkDirection[axis].setCurrentIndex(currindex)
      else:
        self.configTickMarkDirection[axis].setCurrentIndex(0)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksColor[axis][0:3]]
      self.configTickMarkColor[axis].setMyColor(*colorvalue)
      self.configTickMarkWidth[axis].setValue(self.parent.plotArea.ticksWidth[axis])
      self.configTickMarkLength[axis].setValue(self.parent.plotArea.ticksLength[axis])
      self.configTickMarkLabelShow[axis].setChecked(self.parent.plotArea.ticksLabelShow[axis])

    # inner situation config
    if(not self.secondAxes):
      self.xSplitFraction.setText(str(self.parent.plotArea.splitFraction))
      self.xSplitPad.setText(str(self.parent.plotArea.splitPad))

      self.configInnerAxesLabel.setChecked(self.parent.plotArea.innerAxes)
      self.configInnerTickLabel.setChecked(self.parent.plotArea.innerTicks)
      self.configInnerTickXAuto.setChecked(self.parent.plotArea.ticksXAuto_div)
        
      self.configInnerLabel.setChecked(self.parent.plotArea.ticksXShow_div)
      tickstr = self.magicTickstring(self.parent.plotArea.ticksX_div)
      self.configInnerTickXEntry.setText(tickstr)

      if(self.parent.plotArea.ticksXFormat_div in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksXFormat_div)
        self.configInnerTickXFormat.setCurrentIndex(currindex)
      else:
        self.configInnerTickXFormat.setCurrentIndex(0)
      self.configInnerTickXFormatPrecision.setText(str(self.parent.plotArea.ticksXFormatPrecision_div))
      self.configInnerTickXFormatTrailZero.setChecked(self.parent.plotArea.ticksXFormatTrailZero_div)
      self.configInnerTickXFormatSeparator.setChecked(self.parent.plotArea.ticksXFormatSeparator_div)
      self.configInnerTickXFormatComma.setChecked(self.parent.plotArea.ticksXFormatComma_div)
      self.configInnerTickXPrefix.setText(str(self.parent.plotArea.ticksXFormatPrefix_div))
      self.configInnerTickXPostfix.setText(str(self.parent.plotArea.ticksXFormatPostfix_div))
      self.updateTickFormatFields(axis='x2', tickFormat=self.parent.plotArea.ticksXFormat_div)

      self.configInnerMinorTickLabel.setChecked(self.parent.plotArea.ticksXMinor_div != 0)
      if((self.parent.plotArea.ticksXMinor_div - 2) in [i for i in range(9)]):
        self.configInnerMinorTickX.setCurrentIndex(self.parent.plotArea.ticksXMinor_div - 2)
      else:
        self.configInnerMinorTickX.setCurrentIndex(0)

      self.configInnerDividerLine.setChecked(self.parent.plotArea.splitDivider)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.splitDividerColor[0:3]]
      self.configInnerDividerLineColor.setMyColor(*colorvalue)
      self.configInnerDividerLineLength.setValue(self.parent.plotArea.splitDividerLength)
      self.configInnerDividerLineWidth.setValue(self.parent.plotArea.splitDividerWidth)
      if(initialize):
        for entry in self.dashstyles:
          self.configInnerDividerLineDashStyle.addItem(entry)
      if(self.parent.plotArea.splitDividerDashStyle in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.splitDividerDashStyle)
        self.configInnerDividerLineDashStyle.setCurrentIndex(currindex)
      else:
        self.configInnerDividerLineDashStyle.setCurrentIndex(0)
      self.configInnerDividerLineAngle.setValue(self.parent.plotArea.splitDividerAngle)
      self.locationstyles = ['bottom', 'top', 'both']
      if(initialize):
        for entry in self.locationstyles:
          self.configInnerDividerLineLocation.addItem(entry)
      if(self.parent.plotArea.splitDividerLocation in self.locationstyles):
        currindex = self.locationstyles.index(self.parent.plotArea.splitDividerLocation)
        self.configInnerDividerLineLocation.setCurrentIndex(currindex)
      else:
        self.configInnerDividerLineLocation.setCurrentIndex(0)
      
    # grid config
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridLabel[axis].setChecked(self.parent.plotArea.gridVisible[axis])
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.gridColor[axis][0:3]]
      self.configGridColor[axis].setMyColor(*colorvalue)
      self.configGridWidth[axis].setValue(self.parent.plotArea.gridWidth[axis])
      useLineStyle = [i for i in self.linestyles if (i != 'None')]
      if(initialize):
        for entry in useLineStyle:
          self.configGridStyle[axis].addItem(entry)
      if(self.parent.plotArea.gridStyle[axis] in useLineStyle):
        currindex = useLineStyle.index(self.parent.plotArea.gridStyle[axis])
        self.configGridStyle[axis].setCurrentIndex(currindex)
      else:
        self.configGridStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configGridDashStyle[axis].addItem(entry)
      if(self.parent.plotArea.gridDashStyle[axis] in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.gridDashStyle[axis])
        self.configGridDashStyle[axis].setCurrentIndex(currindex)
      else:
        self.configGridDashStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.orderstyles:
          self.configGridOrder[axis].addItem(entry)
      if(self.parent.plotArea.gridOrder[axis] in self.orderstyles):
        currindex = self.orderstyles.index(self.parent.plotArea.gridOrder[axis])
        self.configGridOrder[axis].setCurrentIndex(currindex)
      else:
        self.configGridOrder[axis].setCurrentIndex(0)

    # splitY controls
    if(self.secondAxes):
      self.configSplitYLabel.setChecked(self.parent.plotArea.splitY)
      self.configSplitYFraction.setText(str(self.parent.plotArea.splitYFraction))
      self.configSplitYPad.setText(str(self.parent.plotArea.splitYPad))
      self.configSplitYAxesLabel.setChecked(self.parent.plotArea.innerAxesY)
      self.configSplitYTickLabel.setChecked(self.parent.plotArea.innerTicksY)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.splitYDividerColor[0:3]]
      self.configSplitYDividerLineColor.setMyColor(*colorvalue)
      self.configSplitYDividerLine.setChecked(self.parent.plotArea.splitYDivider)
      self.configSplitYDividerLineLength.setValue(self.parent.plotArea.splitYDividerLength)
      self.configSplitYDividerLineWidth.setValue(self.parent.plotArea.splitYDividerWidth)
      if(initialize):
        for entry in self.dashstyles:
          self.configSplitYDividerLineDashStyle.addItem(entry)
      if(self.parent.plotArea.splitYDividerDashStyle in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.splitYDividerDashStyle)
        self.configSplitYDividerLineDashStyle.setCurrentIndex(currindex)
      else:
        self.configSplitYDividerLineDashStyle.setCurrentIndex(0)
      self.configSplitYDividerLineAngle.setValue(self.parent.plotArea.splitYDividerAngle)
      self.locationstyles = ['left', 'right', 'both']
      if(initialize):
        for entry in self.locationstyles:
          self.configSplitYDividerLineLocation.addItem(entry)
      if(self.parent.plotArea.splitYDividerLocation in self.locationstyles):
        currindex = self.locationstyles.index(self.parent.plotArea.splitYDividerLocation)
        self.configSplitYDividerLineLocation.setCurrentIndex(currindex)
      else:
        self.configSplitYDividerLineLocation.setCurrentIndex(0)
      
    # legend config
    if(not self.secondAxes):
      self.configLegendLabel.setChecked(self.parent.plotArea.legendVisible)
      if(self.parent.plotArea.legendPlacement in self.placementstyles):
        currindex = self.placementstyles.index(self.parent.plotArea.legendPlacement)
        self.configLegendPlacement.setCurrentIndex(currindex)
      else:
        self.configLegendPlacement.setCurrentIndex(0)
      for prop in ['face', 'edge']:
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendColor[prop][0:3]]
        self.configLegendColor[prop].setMyColor(*colorvalue)
      self.configLegendColorLabel['face'].setChecked(self.parent.plotArea.legendFill)
      self.configLegendColorLabel['edge'].setChecked(self.parent.plotArea.legendEdge)
      self.configLegendEdgeWidth.setValue(self.parent.plotArea.legendEdgeWidth)
      if(self.parent.plotArea.legendHatch in self.hatchstyles):
        currindex = self.hatchstyles.index(self.parent.plotArea.legendHatch)
        self.legendComboHatchStyle.setCurrentIndex(currindex)
      else:
        self.legendComboHatchStyle.setCurrentIndex(0)
      if(self.parent.plotArea.legendHatchMultiply in self.hatchMultiplystyles):
        currindex = self.hatchMultiplystyles.index(self.parent.plotArea.legendHatchMultiply)
        self.legendComboHatchMultiplyStyle.setCurrentIndex(currindex)
      else:
        self.legendComboHatchMultiplyStyle.setCurrentIndex(0)
      self.configLegendRounding.setText(str(self.parent.plotArea.legendRounding))
      self.configLegendShadowLabel.setChecked(self.parent.plotArea.legendShadow)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendShadowFaceColor[0:3]]
      self.configLegendShadowColor.setMyColor(*colorvalue)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendLabelColor[0:3]]
      self.configLegendShadowOffX.setText(str(self.parent.plotArea.legendShadowDeltaX))
      self.configLegendShadowOffY.setText(str(self.parent.plotArea.legendShadowDeltaY))
      self.configLegendLabelColor.setMyColor(*colorvalue)
      self.configLegendLabelSize.setValue(self.parent.plotArea.legendLabelSize)
      if(self.parent.plotArea.legendLabelWeight == 'bold'):
        self.configLegendLabelBold.setChecked(True)
      else:
        self.configLegendLabelBold.setChecked(False)
      if(self.parent.plotArea.legendLabelStyle == 'italic'):
        self.configLegendLabelItalic.setChecked(True)
      else:
        self.configLegendLabelItalic.setChecked(False)
      if(self.parent.plotArea.legendLabelFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.legendLabelFont)
        self.configLegendLabelFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configLegendLabelFont.setCurrentIndex(currindex)
        self.parent.plotArea.legendLabelFont = defaultFont
      else:
        self.configLegendLabelFont.setCurrentIndex(0)
      if(self.parent.plotArea.legendNumPoints in [(i+1) for i in range(10)]):
        self.configLegendMarkerNumPoints.setCurrentIndex(self.parent.plotArea.legendNumPoints - 1)
      else:
        self.configLegendMarkerNumPoints.setCurrentIndex(0)
      if(self.parent.plotArea.legendMarkerFirst):
        self.configLegendMarkerFirstLabel.setChecked(True)
      else:
        self.configLegendMarkerFirstLabel.setChecked(False)
      self.configLegendMarkerScale.setText(str(self.parent.plotArea.legendMarkerScale))
      if(self.parent.plotArea.legendNumCol in [(i+1) for i in range(10)]):
        self.configLegendNCol.setCurrentIndex(self.parent.plotArea.legendNumCol - 1)
      else:
        self.configLegendNCol.setCurrentIndex(0)
      self.configLegendPadBorder.setText(str(self.parent.plotArea.legendBorderPad))
      self.configLegendPadRow.setText(str(self.parent.plotArea.legendLabelSpacing))
      self.configLegendPadCol.setText(str(self.parent.plotArea.legendColumnSpacing))

    # canvas config
    if(not self.secondAxes):
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.figureColor[0:3]]
      self.configFigureColorButton.setMyColor(*colorvalue)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasColor[0:3]]
      self.configCanvasColorButton.setMyColor(*colorvalue)
      
      # canvas and figure fill?
      self.configFigureLabel.setChecked(self.parent.plotArea.figureFill)
      self.configCanvasLabel.setChecked(self.parent.plotArea.canvasFill)
      self.configFrameLabel.setChecked(self.parent.plotArea.frameDraw)
      
      # canvas gradient
      self.configCanvasGradientLabel.setChecked(self.parent.plotArea.canvasGradientVisible)
      
      if(self.parent.plotArea.canvasGradientStyle == 'radial'):
        self.configCanvasGradientStyle.setCurrentIndex(1)
      else:
        self.configCanvasGradientStyle.setCurrentIndex(0)
      # control visibility of canvas gradient controls
      self.visibilityCanvasGradientControls()
      
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasGradientColor1[0:3]]
      self.configCanvasGradientColor1Button.setMyColor(*colorvalue)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasGradientColor2[0:3]]
      self.configCanvasGradientColor2Button.setMyColor(*colorvalue)

      self.configCanvasGradientAngle.setText(str(self.parent.plotArea.canvasGradientAngle))
      self.configCanvasGradientCenterX.setText(str(self.parent.plotArea.canvasGradientCenter[0]))
      self.configCanvasGradientCenterY.setText(str(self.parent.plotArea.canvasGradientCenter[1]))
      self.configCanvasGradientWidth.setText(str(self.parent.plotArea.canvasGradientWidth))
      
      # canvas dimensions
      self.exportSizeX.setText(str(self.parent.plotArea.exportWidth))
      self.exportSizeY.setText(str(self.parent.plotArea.exportHeight))
      
      # pad graphics
      for axis in ['bottom', 'top', 'left', 'right']:
        self.exportPadEntry[axis].setText(str(self.parent.plotArea.padSize[axis]))
        
      # frame
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.frameColor[0:3]]
      self.configFrameColor.setMyColor(*colorvalue)
      self.configFrameWidth.setValue(self.parent.plotArea.frameWidth)
      if(initialize):
        self.linestyles__ = [i for i in self.linestyles if (i != 'None')]
        for entry in self.linestyles__:
          self.configFrameStyle.addItem(entry)
      if(self.parent.plotArea.frameStyle in self.linestyles__):
        currindex = self.linestyles__.index(self.parent.plotArea.frameStyle)
        self.configFrameStyle.setCurrentIndex(currindex)
      else:
        self.configFrameStyle.setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configFrameDashStyle.addItem(entry)
      if(self.parent.plotArea.frameDashStyle in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.frameDashStyle)
        self.configFrameDashStyle.setCurrentIndex(currindex)
      else:
        self.configGridDashStyle.setCurrentIndex(0)

    # xkcd
    if(not self.secondAxes):
      self.configXkcdLabel.setChecked(self.parent.plotArea.xkcd)
      self.xkcdScale.setText(str(self.parent.plotArea.xkcdScale))
      self.xkcdLength.setText(str(self.parent.plotArea.xkcdLength))
      self.xkcdRandom.setText(str(self.parent.plotArea.xkcdRandomness))
      
      # path effects
      self.configPathEffectsLabel.setChecked(self.parent.plotArea.applyPathStroke)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.pathStrokeColor[0:3]]
      self.configPathEffectsColorButton.setMyColor(*colorvalue)
      self.configPathEffectsWidth.setValue(self.parent.plotArea.pathStrokeWidth)
  
      self.configPathShadowLabel.setChecked(self.parent.plotArea.applyPathShadow)
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.pathShadowColor[0:3]]
      self.configPathShadowColorButton.setMyColor(*colorvalue)
      self.configPathShadowOffX.setText(str(self.parent.plotArea.pathShadowX))
      self.configPathShadowOffY.setText(str(self.parent.plotArea.pathShadowY))
      
    # advanced graphics
    if(not self.secondAxes):
      self.configAdvancedSettingsButton.setChecked(self.advancedExport['advancedGraphics'])
  
  def connectEvents(self):
    # connects all events in entry mask
    # x label config
    if(not self.secondAxes):
      self.configXLabel.clicked.connect(partial(self.toggleAxisLabel, 'x'))
      self.configXName.editingFinished.connect(partial(self.changeAxisLabel, 'x'))
      self.configXColorButton.clicked.connect(partial(self.changeAxisLabelColor, axis = 'x'))
      self.configXSize.editingFinished.connect(partial(self.alterAxisLabelSize, entryfield = self.configXSize, axis = 'x'))
      self.configXBold.clicked.connect(partial(self.changeAxisLabelBold, axis = 'x'))
      self.configXItalic.clicked.connect(partial(self.changeAxisLabelItalic, axis = 'x'))
      ###self.configXVariant.clicked.connect(partial(self.changeAxisLabelVariant, axis = 'x'))
      self.configXFont.activated.connect(partial(self.setAxisFont, axis = 'x'))
      self.configXAlignment.activated.connect(partial(self.setAxisLabelAlignment, axis = 'x'))
      self.configXAlignmentVertical.activated.connect(partial(self.setAxisLabelAlignmentVertical, axis = 'x'))
      self.configXPad.editingFinished.connect(partial(self.changeAxisLabelPad, entryfield = self.configXPad, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configXPos.editingFinished.connect(partial(self.changeAxisLabelPos, entryfield = self.configXPos, axis = 'x', minval = -10, maxval = 10))
      self.configXAngle.editingFinished.connect(partial(self.alterAxisLabelAngle, entryfield=self.configXAngle, axis='x'))
    
    # y label config
    if(not self.secondAxes):
      targetAxis = 'y'
    else:
      targetAxis = 'y2'
    self.configYLabel.clicked.connect(partial(self.toggleAxisLabel, targetAxis))
    self.configYName.editingFinished.connect(partial(self.changeAxisLabel, targetAxis))
    self.configYColorButton.clicked.connect(partial(self.changeAxisLabelColor, axis = targetAxis))
    self.configYSize.editingFinished.connect(partial(self.alterAxisLabelSize, entryfield = self.configYSize, axis = targetAxis))
    self.configYBold.clicked.connect(partial(self.changeAxisLabelBold, axis = targetAxis))
    self.configYItalic.clicked.connect(partial(self.changeAxisLabelItalic, axis = targetAxis))
    ###self.configYVariant.clicked.connect(partial(self.changeAxisLabelVariant, axis = targetAxis))
    self.configYFont.activated.connect(partial(self.setAxisFont, axis = targetAxis))
    self.configYAlignment.activated.connect(partial(self.setAxisLabelAlignment, axis = targetAxis))
    self.configYAlignmentVertical.activated.connect(partial(self.setAxisLabelAlignmentVertical, axis = targetAxis))
    self.configYPad.editingFinished.connect(partial(self.changeAxisLabelPad, entryfield = self.configYPad, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configYPos.editingFinished.connect(partial(self.changeAxisLabelPos, entryfield = self.configYPos, axis = targetAxis, minval = -10, maxval = 10))
    self.configYAngle.editingFinished.connect(partial(self.alterAxisLabelAngle, entryfield=self.configYAngle, axis=targetAxis))

    # axis config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisLabel[axis].clicked.connect(partial(self.setAxisVisibility, axis = axis))
      self.configAxisColor[axis].clicked.connect(partial(self.changeAxisColor, axis = axis))
      self.configAxisWidth[axis].editingFinished.connect(partial(self.alterAxisWidth, axis=axis))
      self.configAxisStyle[axis].activated.connect(partial(self.setAxisStyle, axis = axis))
      self.configAxisDashStyle[axis].activated.connect(partial(self.setAxisDashStyle, axis = axis))
      self.configAxisPosition[axis].activated.connect(partial(self.setAxisPosition, axis = axis))
      self.configAxisPositionValue[axis].editingFinished.connect(partial(self.changeAxisPositionValue, axis = axis))
      self.configAxisPositionReset[axis].clicked.connect(partial(self.resetAxisPosition, axis = axis))
      self.configAxisBoundLabel[axis].clicked.connect(partial(self.setAxisBoundary, axis=axis))
      self.configAxisBoundLower[axis].editingFinished.connect(partial(self.changeAxisBoundary, axis=axis, lower=True))
      self.configAxisBoundUpper[axis].editingFinished.connect(partial(self.changeAxisBoundary, axis=axis, lower=False))

    # arrow config
    if(not self.secondAxes):
      for axis in ['x', 'y']:
        self.configArrowLabel[axis].clicked.connect(partial(self.setAxisArrow, axis = axis, item='all'))
        self.configArrowLineColorLabel[axis].clicked.connect(partial(self.setAxisArrow, axis=axis, item='edge'))
        self.configArrowFillColorLabel[axis].clicked.connect(partial(self.setAxisArrow, axis=axis, item='fill'))
        self.configArrowLineWidth[axis].editingFinished.connect(partial(self.alterArrowLineWidth, axis=axis))
        self.configArrowLineColor[axis].clicked.connect(partial(self.changeArrowColor, axis = axis, item='line'))
        self.configArrowFillColor[axis].clicked.connect(partial(self.changeArrowColor, axis = axis, item='fill'))
        self.configArrowHeadWidth[axis].editingFinished.connect(partial(self.changeArrowHeadWidth, axis = axis, minval = 0.0, maxval = 1.0))
        self.configArrowHeadLength[axis].editingFinished.connect(partial(self.changeArrowHeadLength, axis = axis, minval = 0.0, maxval = 1.0))
        self.configArrowOverhang[axis].editingFinished.connect(partial(self.changeArrowOverhang, axis = axis, minval = -1.0, maxval = 1.0))
        self.configArrowOffset[axis].editingFinished.connect(partial(self.changeArrowOffset, axis = axis, minval = 0.0, maxval = 1.0))
        self.configArrowLocation[axis].activated.connect(partial(self.changeArrowLocation, axis=axis))

    # x ticks config
    if(not self.secondAxes):
      self.configTickXLabel.clicked.connect(partial(self.toggleTicksLabel, 'x'))
      self.configTickXAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'x'))
      self.configTickXEntry.editingFinished.connect(partial(self.changeAxisTicks, 'x'))
      self.configTickUseData.clicked.connect(partial(self.dataAxisTicks, False))
      self.configMinorTickXLabel.clicked.connect(partial(self.toggleMinorTicks, entryfield=self.configMinorTickXLabel, axis='x'))
      self.configMinorTickXRelativeLength.editingFinished.connect(partial(self.changeMinorTickRelativeLength, entryfield = self.configMinorTickXRelativeLength, axis='x', minval = 0.1, maxval = 10.0))
      self.configTickXColorButton.clicked.connect(partial(self.changeTickLabelColor, axis = 'x'))
      self.configTickXSize.editingFinished.connect(partial(self.alterTickLabelSize, entryfield=self.configTickXSize, axis='x'))
      self.configTickXBold.clicked.connect(partial(self.changeTickLabelBold, axis = 'x'))
      self.configTickXItalic.clicked.connect(partial(self.changeTickLabelItalic, axis = 'x'))
      self.configTickXAngle.editingFinished.connect(partial(self.alterTickLabelAngle, entryfield=self.configTickXAngle, axis='x'))
      self.configTickXAlignment.activated.connect(partial(self.setTickLabelAlignment, axis = 'x'))
      self.configTickXAlignmentVertical.activated.connect(partial(self.setTickLabelAlignmentVertical, axis = 'x'))
      self.configTickXPad.editingFinished.connect(partial(self.changeTickLabelPad, entryfield = self.configTickXPad, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configTickXPad2.editingFinished.connect(partial(self.changeTickLabelPad2, entryfield = self.configTickXPad2, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configTickXFont.activated.connect(partial(self.setTickFont, axis = 'x'))
      self.configMinorTickX.activated.connect(partial(self.setMinorTick, axis = 'x'))
      self.configTickXFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configTickXFormat, axis = 'x'))
      self.configTickXFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configTickXFormatPrecision, axis = 'x', minval = 0, maxval = 20))
      self.configTickXFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configTickXFormatTrailZero, axis = 'x'))
      self.configTickXFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configTickXFormatSeparator, axis = 'x'))
      self.configTickXFormatComma.clicked.connect(partial(self.setFormatComma, entryfield=self.configTickXFormatComma, axis = 'x'))
      self.configTickXPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickXPrefix, axis='x', prefix=True))
      self.configTickXPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickXPostfix, axis='x', prefix=False))

    # y ticks config
    if(not self.secondAxes):
      targetAxis = 'y'
    else:
      targetAxis = 'y2'
    self.configTickYLabel.clicked.connect(partial(self.toggleTicksLabel, targetAxis))
    self.configTickYAuto.clicked.connect(partial(self.automaticAxisTicks, axis = targetAxis))
    self.configTickYEntry.editingFinished.connect(partial(self.changeAxisTicks, targetAxis))
    self.configMinorTickYLabel.clicked.connect(partial(self.toggleMinorTicks, entryfield=self.configMinorTickYLabel, axis=targetAxis))
    self.configMinorTickYRelativeLength.editingFinished.connect(partial(self.changeMinorTickRelativeLength, entryfield = self.configMinorTickYRelativeLength, axis=targetAxis, minval = 0.1, maxval = 10.0))
    self.configTickYColorButton.clicked.connect(partial(self.changeTickLabelColor, axis = targetAxis))
    self.configTickYSize.editingFinished.connect(partial(self.alterTickLabelSize, entryfield=self.configTickYSize, axis=targetAxis))
    self.configTickYBold.clicked.connect(partial(self.changeTickLabelBold, axis = targetAxis))
    self.configTickYItalic.clicked.connect(partial(self.changeTickLabelItalic, axis = targetAxis))
    self.configTickYAngle.editingFinished.connect(partial(self.alterTickLabelAngle, entryfield=self.configTickYAngle, axis=targetAxis))
    self.configTickYAlignment.activated.connect(partial(self.setTickLabelAlignment, axis = targetAxis))
    self.configTickYAlignmentVertical.activated.connect(partial(self.setTickLabelAlignmentVertical, axis = targetAxis))
    self.configTickYPad.editingFinished.connect(partial(self.changeTickLabelPad, entryfield = self.configTickYPad, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configTickYPad2.editingFinished.connect(partial(self.changeTickLabelPad2, entryfield = self.configTickYPad2, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configTickYFont.activated.connect(partial(self.setTickFont, axis = targetAxis))
    self.configMinorTickY.activated.connect(partial(self.setMinorTick, axis = targetAxis))
    self.configTickYFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configTickYFormat, axis = targetAxis))
    self.configTickYFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configTickYFormatPrecision, axis = targetAxis, minval = 0, maxval = 20))
    self.configTickYFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configTickYFormatTrailZero, axis = targetAxis))
    self.configTickYFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configTickYFormatSeparator, axis = targetAxis))
    self.configTickYFormatComma.clicked.connect(partial(self.setFormatComma, entryfield=self.configTickYFormatComma, axis = targetAxis))
    self.configTickYPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickYPrefix, axis=targetAxis, prefix=True))
    self.configTickYPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickYPostfix, axis=targetAxis, prefix=False))

    if(not self.secondAxes):
      self.configTickResidYLabel.clicked.connect(partial(self.toggleTicksLabel, 'resid'))
      self.configTickResidYAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'resid'))
      self.configTickResidYEntry.editingFinished.connect(partial(self.changeAxisTicks, 'resid'))
      self.configMinorTickResidLabel.clicked.connect(partial(self.toggleMinorTicks, entryfield=self.configMinorTickResidLabel, axis='resid'))
      self.configMinorTickResidRelativeLength.editingFinished.connect(partial(self.changeMinorTickRelativeLength, entryfield = self.configMinorTickResidRelativeLength, axis='resid', minval = 0.1, maxval = 10.0))
      self.configMinorTickResid.activated.connect(partial(self.setMinorTick, axis = 'resid'))
    
    # tick mark config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkLabel[axis].clicked.connect(partial(self.setTicksVisibility, axis = axis))
      self.configTickMarkDirection[axis].activated.connect(partial(self.setTickMarkDirection, axis = axis))
      self.configTickMarkColor[axis].clicked.connect(partial(self.changeTickMarkColor, axis = axis))
      self.configTickMarkWidth[axis].editingFinished.connect(partial(self.alterTickMarkWidth, axis=axis))
      self.configTickMarkLength[axis].editingFinished.connect(partial(self.alterTickMarkLength, axis=axis))
      self.configTickMarkLabelShow[axis].clicked.connect(partial(self.setTickMarkLabelShow, axis=axis))

    # inner situation config
    if(not self.secondAxes):
      self.xSplitFraction.editingFinished.connect(partial(self.changeSplitFraction, 0.05, 20, True))
      self.xSplitPad.editingFinished.connect(partial(self.changeSplitPad, 0.0, 10 , True))
      self.configInnerLabel.clicked.connect(partial(self.toggleTicksLabel, 'x2'))
      self.configInnerAxesLabel.clicked.connect(partial(self.setInnerParameter, param='axes'))
      self.configInnerTickLabel.clicked.connect(partial(self.setInnerParameter, param='ticks'))

      self.configInnerTickXAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'x2'))
      self.configInnerTickXEntry.editingFinished.connect(partial(self.changeAxisTicks, 'x2'))
      self.configInnerTickUseData.clicked.connect(partial(self.dataAxisTicks, True))

      self.configInnerTickXFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configInnerTickXFormat, axis = 'x2'))
      self.configInnerTickXFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configInnerTickXFormatPrecision, axis = 'x2', minval = 0, maxval = 20))
      self.configInnerTickXFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configInnerTickXFormatTrailZero, axis = 'x2'))
      self.configInnerTickXFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configInnerTickXFormatSeparator, axis = 'x2'))
      self.configInnerTickXFormatComma.clicked.connect(partial(self.setFormatComma, entryfield=self.configInnerTickXFormatComma, axis = 'x2'))
      self.configInnerTickXPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configInnerTickXPrefix, axis='x2', prefix=True))
      self.configInnerTickXPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configInnerTickXPostfix, axis='x2', prefix=False))

      self.configInnerMinorTickX.activated.connect(partial(self.setMinorTick, axis = 'x2'))
      self.configInnerMinorTickLabel.clicked.connect(partial(self.toggleMinorTicks, entryfield=self.configInnerMinorTickLabel, axis='x2'))

      self.configInnerDividerLine.clicked.connect(self.setSplitDivider)
      self.configInnerDividerLineColor.clicked.connect(self.changeInnerDividerLineColor)
      self.configInnerDividerLineLength.editingFinished.connect(self.alterInnerDividerLineLength)
      self.configInnerDividerLineWidth.editingFinished.connect(self.alterInnerDividerLineWidth)
      self.configInnerDividerLineDashStyle.activated.connect(self.changeInnerDividerLineDashStyle)
      self.configInnerDividerLineAngle.editingFinished.connect(self.alterInnerDividerLineAngle)
      self.configInnerDividerLineLocation.activated.connect(self.changeInnerDividerLineLocation)

    # grid config
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridLabel[axis].clicked.connect(partial(self.setGridVisibility, axis = axis))
      self.configGridColor[axis].clicked.connect(partial(self.changeGridColor, axis = axis))
      self.configGridWidth[axis].editingFinished.connect(partial(self.alterGridWidth, axis=axis))
      self.configGridStyle[axis].activated.connect(partial(self.setGridStyle, axis = axis))
      self.configGridDashStyle[axis].activated.connect(partial(self.setGridDashStyle, axis = axis))
      self.configGridOrder[axis].activated.connect(partial(self.setGridOrder, axis = axis))
      
    # splitY controls
    if(self.secondAxes):
      self.configSplitYLabel.clicked.connect(self.toggleSplitY)
      self.configSplitYFraction.editingFinished.connect(partial(self.changeSplitYFraction, minval=0.05, maxval=20.0))
      self.configSplitYPad.editingFinished.connect(partial(self.changeSplitYPad, 0.0, 0.3))
      self.configSplitYAxesLabel.clicked.connect(partial(self.setInnerYParameter, param='axes'))
      self.configSplitYTickLabel.clicked.connect(partial(self.setInnerYParameter, param='ticks'))

      self.configSplitYDividerLine.clicked.connect(self.setSplitYDivider)
      self.configSplitYDividerLineColor.clicked.connect(self.changeSplitYDividerLineColor)
      self.configSplitYDividerLineLength.editingFinished.connect(self.alterSplitYDividerLineLength)
      self.configSplitYDividerLineWidth.editingFinished.connect(self.alterSplitYDividerLineWidth)
      self.configSplitYDividerLineDashStyle.activated.connect(self.changeSplitYDividerLineDashStyle)
      self.configSplitYDividerLineAngle.editingFinished.connect(self.alterSplitYDividerLineAngle)
      self.configSplitYDividerLineLocation.activated.connect(self.changeSplitYDividerLineLocation)

    # legend config
    if(not self.secondAxes):
      self.configLegendLabel.clicked.connect(self.setLegend)
      self.configLegendPlacement.activated.connect(self.setLegendPlacement)
      for prop in ['face', 'edge']:
        self.configLegendColor[prop].clicked.connect(partial(self.changeLegendColor, prop))
      self.configLegendColorLabel['face'].clicked.connect(self.toggleLegendFill)
      self.configLegendColorLabel['edge'].clicked.connect(self.toggleLegendEdge)
      self.configLegendEdgeWidth.editingFinished.connect(self.alterLegendEdgeWidth)
      self.legendComboHatchStyle.activated.connect(partial(self.changeLegendHatch, item='hatch'))
      self.legendComboHatchMultiplyStyle.activated.connect(partial(self.changeLegendHatch, item='multiply'))
      self.configLegendRounding.editingFinished.connect(partial(self.changeLegendRounding, minval=0.0, maxval=10.0))
      self.configLegendShadowLabel.clicked.connect(self.setLegendShadow)
      self.configLegendShadowColor.clicked.connect(self.changeLegendShadowColor)
      self.configLegendShadowOffX.editingFinished.connect(partial(self.changeLegendShadowOffset, direction='x', minval=-100.0, maxval=100.0))
      self.configLegendShadowOffY.editingFinished.connect(partial(self.changeLegendShadowOffset, direction='y', minval=-100.0, maxval=100.0))
      self.configLegendLabelColor.clicked.connect(self.changeLegendLabelColor)
      self.configLegendLabelSize.editingFinished.connect(partial(self.alterLegendLabelSize, entryfield=self.configLegendLabelSize))
      self.configLegendLabelBold.clicked.connect(self.changeLegendLabelBold)
      self.configLegendLabelItalic.clicked.connect(self.changeLegendLabelItalic)
      self.configLegendLabelFont.activated.connect(self.setLegendLabelFont)
      self.configLegendNCol.activated.connect(self.setLegendNCol)
      self.configLegendMarkerFirstLabel.clicked.connect(self.setLegendMarkerFirst)
      self.configLegendMarkerScale.editingFinished.connect(partial(self.changeLegendMarkerScale, entryfield = self.configLegendMarkerScale, minval = 0.0, maxval = 5.0))
      self.configLegendMarkerNumPoints.activated.connect(self.setLegendMarkerNumPoints)
  
      self.configLegendPadBorder.editingFinished.connect(partial(self.changeLegendPadBorder, entryfield = self.configLegendPadBorder, minval = 0.0, maxval = 10.0))
      self.configLegendPadRow.editingFinished.connect(partial(self.changeLegendPadRow, entryfield = self.configLegendPadRow, minval = 0.0, maxval = 10.0))
      self.configLegendPadCol.editingFinished.connect(partial(self.changeLegendPadCol, entryfield = self.configLegendPadCol, minval = 0.0, maxval = 50.0))
    
    # canvas config
    if(not self.secondAxes):
      self.configFigureColorButton.clicked.connect(self.changeFigureColor)  
      self.configCanvasColorButton.clicked.connect(self.changeCanvasColor)
      self.configFigureLabel.clicked.connect(self.toggleFigureFill)
      self.configCanvasLabel.clicked.connect(self.toggleCanvasFill)
      self.configFrameLabel.clicked.connect(self.toggleFrameDraw)
      
      # canvas gradient
      self.configCanvasGradientLabel.clicked.connect(self.setCanvasGradient)
      self.configCanvasGradientStyle.activated.connect(self.changeCanvasGradientStyle)
      self.configCanvasGradientColor1Button.clicked.connect(partial(self.changeCanvasGradientColor, color=0))
      self.configCanvasGradientColor2Button.clicked.connect(partial(self.changeCanvasGradientColor, color=1))
      self.configCanvasGradientAngle.editingFinished.connect(partial(self.changeCanvasGradientAngle, minval=0.0, maxval=360.0))
      self.configCanvasGradientCenterX.editingFinished.connect(partial(self.changeCanvasGradientCenter, minval=0.0, maxval=1.0, axis='x'))
      self.configCanvasGradientCenterY.editingFinished.connect(partial(self.changeCanvasGradientCenter, minval=0.0, maxval=1.0, axis='y'))
      self.configCanvasGradientWidth.editingFinished.connect(partial(self.changeCanvasGradientWidth, minval=0.01, maxval=5.0))
      
      # canvas dimensions
      self.exportSizeX.editingFinished.connect(partial(self.checkExportSize, entryfield = self.exportSizeX, axis='x', minval = 0.05, maxval = 500.0))
      self.exportSizeY.editingFinished.connect(partial(self.checkExportSize, entryfield = self.exportSizeY, axis='y', minval = 0.05, maxval = 500.0))
      self.exportSizeCurrentButton.clicked.connect(self.useCurrentDim)
      
      # pad graphics
      for axis in ['bottom', 'left']:
        self.exportPadEntry[axis].editingFinished.connect(partial(self.changePadding, axis = axis, minval = 0.0, maxval = 0.49))
      for axis in ['top', 'right']:
        self.exportPadEntry[axis].editingFinished.connect(partial(self.changePadding, axis = axis, minval = 0.50, maxval = 1.00))
      
      # frame
      self.configFrameColor.clicked.connect(self.changeFrameColor)
      self.configFrameWidth.editingFinished.connect(self.alterFrameWidth)
      self.configFrameStyle.activated.connect(self.setFrameStyle)
      self.configFrameDashStyle.activated.connect(self.setFrameDashStyle)
    
    # xkcd
    if(not self.secondAxes):
      self.configXkcdLabel.clicked.connect(partial(self.setXkcd,True))
      self.xkcdScale.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdScale, item='scale', minval = 0.0, maxval = 10.0))
      self.xkcdLength.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdLength, item='length', minval = 0.0, maxval = 1000.0))
      self.xkcdRandom.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdRandom, item='random', minval = 0.0, maxval = 10.0))
      
      # path effects
      self.configPathEffectsLabel.clicked.connect(partial(self.setPathStroke, True))
      self.configPathEffectsColorButton.clicked.connect(self.changePathStrokeColor)
      self.configPathEffectsWidth.editingFinished.connect(self.alterPathStrokeWidth)
  
      self.configPathShadowLabel.clicked.connect(partial(self.setPathShadow, True))
      self.configPathShadowColorButton.clicked.connect(self.changePathShadowColor)
      self.configPathShadowOffX.editingFinished.connect(partial(self.changePathShadowOffset, direction='x', minval=-100.0, maxval=100.0))
      self.configPathShadowOffY.editingFinished.connect(partial(self.changePathShadowOffset, direction='y', minval=-100.0, maxval=100.0))

    # advanced graphics
    if(not self.secondAxes):
      self.configAdvancedSettingsButton.clicked.connect(self.toggleGraphicsOption)

    # preview and export graphics
    if(not self.secondAxes):
      self.previewButton.clicked.connect(self.previewThis)
      self.exportButton.clicked.connect(self.exportThis)
      self.reportButton.clicked.connect(self.reportThis)
    
      # load/save style
      self.loadStyleSet.clicked.connect(partial(self.processStyleSet, 'load', 'file'))
      self.saveStyleSet.clicked.connect(partial(self.processStyleSet,'save', 'file'))

  def processStyleSet(self, operation='load', modus='file', zoffsetData=0, zoffsetCurve=0, redraw=True, rescale=True):
    # loads/saves style set
    if(operation in ['load', 'save']):
      # items in plot style to save
      items = ['labelX', 'labelXShow', 'labelXColor', 'labelXSize', 'labelY', 'labelYShow', 'labelYColor', 'labelYSize',\
        'labelXWeight', 'labelYWeight', 'labelXStyle', 'labelYStyle', 'labelXVariant', 'labelYVariant', 'labelXAlignment', 'labelYAlignment',\
        'labelXAlignmentVertical', 'labelYAlignmentVertical', 'labelXPad', 'labelYPad', 'labelXPos', 'labelYPos', 'labelXAngle', 'labelYAngle',\
        'axisVisible', 'axisColor', 'axisPosition', 'axisPositionValue', 'axisBoundaryCheck', 'axisBoundary', 'axisWidth', 'axisStyle', 'axisDashStyle',\
        'ticksX', 'ticksXShow', 'ticksXColor', 'ticksXSize', 'ticksXAngle',\
        'ticksXWeight', 'ticksYWeight', 'ticksXStyle', 'ticksYStyle',\
        'ticksXAlignment', 'ticksXAlignmentVertical', 'ticksXPad', 'ticksXPad2', 'ticksXLabel', 'ticksXAuto', 'ticksXMinor', \
        'ticksXFormat', 'ticksYFormat', 'ticksY2Format', 'ticksResidYFormat',\
        'ticksXFormatPrecision', 'ticksYFormatPrecision', 'ticksY2FormatPrecision', 'ticksResidYFormatPrecision',\
        'ticksXFormatTrailZero', 'ticksYFormatTrailZero', 'ticksY2FormatTrailZero', 'ticksResidYFormatTrailZero',\
        'ticksXFormatSeparator', 'ticksYFormatSeparator', 'ticksY2FormatSeparator', 'ticksResidYFormatSeparator',\
        'ticksXFormatComma', 'ticksYFormatComma', 'ticksY2FormatComma', 'ticksResidYFormatComma',\
        'ticksXFormatPrefix', 'ticksYFormatPrefix', 'ticksY2FormatPrefix', 'ticksResidYFormatPrefix',\
        'ticksXFormatPostfix', 'ticksYFormatPostfix', 'ticksY2FormatPostfix', 'ticksResidYFormatPostfix',\
        'ticksXFormat_div', 'ticksXFormatPrecision_div', 'ticksXFormatTrailZero_div', 'ticksXFormatSeparator_div', 'ticksXFormatComma_div', 'ticksXFormatPrefix_div', 'ticksXFormatPostfix_div',\
        'ticksX_div', 'ticksXShow_div', 'ticksXAuto_div', 'ticksXLabel_div', 'ticksXMinor_div',\
        'ticksY', 'ticksYShow', 'ticksResidYShow', 'ticksYColor', 'ticksYSize', 'ticksYAngle', 'ticksYAlignment', 'ticksYAlignmentVertical', 'ticksYPad', 'ticksYPad2',\
        'ticksYAuto','ticksYMinor', 'ticksY2Minor', 'ticksResidY', 'ticksResidYAuto', 'ticksVisible', 'ticksResidYMinor', 'ticksDirection', 'ticksLabelShow', 'ticksColor', 'ticksWidth',\
        'ticksLength', 'ticksXMinorRelativeLength', 'ticksYMinorRelativeLength', 'ticksY2MinorRelativeLength', 'ticksResidYMinorRelativeLength',\
        'gridVisible', 'gridColor', 'gridWidth', 'gridStyle', 'gridDashStyle', 'gridOrder', \
        'labelY2', 'labelY2Color', 'labelY2Size', 'labelY2Weight', 'labelY2Style', 'labelY2Variant',\
        'labelY2Pad', 'labelY2Pos', 'labelY2Angle', 'labelY2Alignment', 'labelY2AlignmentVertical',\
        'ticksY2', 'ticksY2Show', 'ticksY2Color',\
        'ticksY2Size', 'ticksY2Angle', 'ticksY2Alignment', 'ticksY2AlignmentVertical', 'ticksY2Pad', 'ticksY2Pad2', 'ticksY2Auto', 'ticksY2Weight', 'ticksY2Style',\
        'figureColor', 'canvasColor', 'canvasFill', 'figureFill', 'frameDraw', 'exportWidth', 'exportHeight', 'axisFont', 'tickFont', 'padSize',\
        'frameWidth', 'frameColor', 'frameStyle', 'frameDashStyle',\
        'legendVisible', 'legendPlacement', 'legendColor', 'legendEdgeWidth', 'legendShadow', 'legendShadowDeltaX', 'legendShadowDeltaY', 'legendShadowFaceColor', 'legendLabelColor',\
        'legendLabelSize', 'legendLabelWeight', 'legendLabelStyle', 'legendHatch', 'legendHatchMultiply', 'legendRounding', 'legendLabelFont', 'legendNumPoints',\
        'legendMarkerFirst', 'legendNumCol', 'legendMarkerScale', 'legendBorderPad', 'legendLabelSpacing', 'legendColumnSpacing', 'legendFill', 'legendEdge',\
        'xkcd', 'xkcdScale', 'xkcdLength', 'xkcdRandomness',\
        'applyPathStroke', 'pathStrokeWidth', 'pathStrokeColor',\
        'applyPathShadow', 'pathShadowX', 'pathShadowY', 'pathShadowColor',\
        'arrowVisible', 'arrowOverhang', 'arrowColor', 'arrowFill', 'arrowHeadLength', 'arrowHeadWidth', 'arrowOffset', 'arrowEdge', 'arrowEdgeShow', 'arrowFillShow', 'arrowLocation',\
        'canvasGradientVisible', 'canvasGradientStyle','canvasGradientColor1', 'canvasGradientColor2', 'canvasGradientAngle', 'canvasGradientWidth', 'canvasGradientCenter',\
        'splitFraction', 'splitPad', 'innerAxes', 'innerTicks', 'splitDivider', 'splitDividerLength', 'splitDividerWidth',\
        'splitDividerColor', 'splitDividerDashStyle', 'splitDividerAngle', 'splitDividerLocation',\
        'splitYFraction', 'splitYPad', 'innerAxesY', 'innerTicksY', 'splitYDivider', 'splitYDividerLength', 'splitYDividerWidth',\
        'splitYDividerColor', 'splitYDividerDashStyle', 'splitYDividerAngle', 'splitYDividerLocation']
      dataobject = ['dataSet', 'dataError', 'dataErrorShady', 'dataBar', 'dataStack', 'dataText', 'dataViolin']
      fitobject = 'curve'
      residobject = ['resid', 'residBar', 'residStack', 'residText']
      residobjectzero = 'residZero'
      flag = True

      if(operation == 'load'):
        # store original axis limits to counteract rescaling when applying styles
        minX, maxX, minY, maxY = self.parent.plotArea.minX, self.parent.plotArea.maxX, self.parent.plotArea.minY, self.parent.plotArea.maxY
        minResidY, maxResidY = self.parent.plotArea.minResidY, self.parent.plotArea.maxResidY
        minY2, maxY2 = self.parent.plotArea.minY2, self.parent.plotArea.maxY2
        # load from file or from string?
        if(modus == 'file'):
          filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self, filter = 'Style set (*.style)', directory = WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR, caption='Open Style Sheet')
          filename = str(filename)
          try:
            loadhandle = open(filename,'r', encoding='utf-8')
            lines = loadhandle.readlines()
            loadhandle.close()
            # save filename for future reference
            self.currStyleFile = filename
            # display busy pointer
            QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            QtCore.QCoreApplication.processEvents()
          except:
            if(filename):
              self.parent.statusbar.showMessage('Cannot load style file ' + filename, self.parent.STATUS_TIME)
            lines = []
            flag = False
        else:
          lines = modus.split('\n')
        
        if(flag):
          entry = ''
          for red in lines:
            if(red.find('>>>') == 0):
              entry = red[3:].strip()
              # replace underscore in key names to avoid mixup with 
              if('000' in entry):
                entry = entry.replace('000', '_')
            elif(entry != ''):
              red = red.strip()
              # convert string input to original data
              try:
                red = literal_eval(red)
                # assign value to plot canvas
                if(hasattr(self.parent.plotArea, entry)):
                  # test whether this is a dictionary
                  if(type(red) == dict):
                    self.parent.plotArea.__dict__[entry].update(red)
                  else:
                    setattr(self.parent.plotArea, entry, red)
              except:
                self.parent.statusbar.showMessage('Failed to restore setting ' + repr(entry) + repr(red), self.parent.STATUS_TIME)
              entry = ''
              
          # loadconfig of data set and curve
          entry = ''
          for red in lines:
            if(red.find('>>>') == 0):
              entry = red[3:].strip()
            elif(entry != ''):
              if('_' in entry):
                splitentry = entry.split('_')
                entry = splitentry[0]; index = int(splitentry[-1])
                
              if((entry in dataobject) or (entry in residobject) or (entry in [fitobject, residobjectzero])):
                red = red.strip()
                # convert string input to original data
                try:
                  red = literal_eval(red)
                  for key in red:
                    if((entry == dataobject[0]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[1]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setErrorStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[2]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setErrorShadyStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[3]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setBarStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[4]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setStackStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[5]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setTextStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[6]) and (index + zoffsetData < len(self.parent.data))):
                      if(key == 'mode'):
                        self.parent.data[index + zoffsetData].toggleViolin(red[key], redraw=False)
                      else:
                        subtarget = key
                        for key in red[subtarget]:
                          self.parent.data[index + zoffsetData].setViolinStyle(subtarget, key, red[subtarget][key], redraw=False, rescale=False)
                    elif((entry == residobject[0]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidStyle(key, red[key], redraw=False)
                    elif((entry == residobject[1]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidBarStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobject[2]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidStackStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobject[3]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidTextStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobjectzero) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidLineStyle(key, red[key], redraw=False)
                    elif((entry == fitobject) and (index + zoffsetCurve < len(self.parent.fit))):
                      self.parent.fit[index + zoffsetCurve].setStyle(key, red[key], redraw=False)
                except:
                  self.parent.statusbar.showMessage('Failed to restore setting ' + repr(entry) + repr(red), self.parent.STATUS_TIME)
  
              entry = ''

          # cause plot to be redrawn
          self.parent.plotArea.initPlot(initialize=False)
          # update entry fields
          self.updateFields(initialize=False)
          self.parent.graphicsarea2.updateFields(initialize=False)
          # check whether we have items on the second axes
          self.parent.objectsarea.checkSecondAxes()
              
          # rescale to original axis limits
          if(rescale):
            self.parent.plotArea.setAxisLimits(lower=minX, upper=maxX, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minY2, upper=maxY2, axis='y2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minY, upper=maxY, axis='y', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minX, upper=maxX, axis='x', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minResidY, upper=maxResidY, axis='y', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            # adjust tick entry fields
            for axis in ['x', 'x2', 'y', 'y2', 'resid']:
              self.parent.plotArea.updateTickEntryField(axis=axis)

          # separately deal with legend so that it updates
          value = self.parent.plotArea.legendVisible
          self.parent.plotArea.setLegend(value=value, redraw=redraw)
          
          # update resid plot?
          if(redraw):
            self.parent.plotArea.residplotwidget.myRefresh()

          # restore original pointer (if needed)
          if(modus == 'file'):
            QtWidgets.QApplication.restoreOverrideCursor()
      else:
        # retrieve plot configuration
        red = ''
        for entry in items:
          if(hasattr(self.parent.plotArea, entry)):
            # replace underscore in key names to avoid mixup with 
            if('_' in entry):
              red += '>>>' + entry.replace('_', '000') + '\n'
            else:
              red += '>>>' + entry + '\n'
            tempOut = self.parent.plotArea.__dict__[entry]
            if(hasattr(tempOut, 'tolist')):
              tempOut = tempOut.tolist()
            red += repr(tempOut)+'\n'
        # save config of data set and curve
        for index in range(len(self.parent.data)):
          red += '>>>' + dataobject[0] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getStyle()) + '\n'
          red += '>>>' + dataobject[1] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getErrorStyle()) + '\n'
          red += '>>>' + dataobject[2] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getErrorShadyStyle()) + '\n'
          red += '>>>' + dataobject[3] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getBarStyle()) + '\n'
          red += '>>>' + dataobject[4] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getStackStyle()) + '\n'
          red += '>>>' + dataobject[5] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getTextStyle()) + '\n'
          red += '>>>' + dataobject[6] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getViolinStyle()) + '\n'
          red += '>>>' + residobject[0] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidStyle()) + '\n'
          red += '>>>' + residobject[1] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidBarStyle()) + '\n'
          red += '>>>' + residobject[2] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidStackStyle()) + '\n'
          red += '>>>' + residobject[3] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidTextStyle()) + '\n'
          red += '>>>' + residobjectzero + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidLineStyle()) + '\n'
        
        for index in range(len(self.parent.fit)):
          red += '>>>' + fitobject + '_' + str(index) + '\n'
          red += repr(self.parent.fit[index].getStyle()) + '\n'

        if (modus == 'file'):
          usedir = WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR
          if(self.currStyleFile != None):
            usedir = self.currStyleFile
          filename, fitler_ = QtWidgets.QFileDialog.getSaveFileName(self, filter = 'Style set (*.style)', directory = usedir, caption='Save Style Sheet')
          filename = str(filename)
          try:
            savehandle=open(filename,'w', encoding='utf-8')
            savehandle.write(red)
            savehandle.close()
            # save filename for future reference
            self.currStyleFile = filename
          except:
            self.parent.statusbar.showMessage('Cannot write style file ' + filename, self.parent.STATUS_TIME)
        else:
          return red

  def magicTickstring(self, ticks=[]):
    # ensures better formatting of tick values in tickstring
    if(not len(ticks)):
      return ''

    # define nested helper function
    def formatThis(number):
      NUMBER_SWITCH = 1e3
      FORMAT_DECIMAL = '{:.3f}'
      FORMAT_SCIENTIFIC = '{:.3e}'
      # determine return string
      try:
        if(number == 0.0):
          return '0'
        
        if(np.isfinite(float(number))):
          if((np.abs(number) >= 10 * NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
            numberstr = FORMAT_SCIENTIFIC.format(number)
            numberstr = numberstr.lower()
            # chop away trailing zeros and decimal dots
            pre, post = numberstr.split('e')
            while pre.endswith('0'):
              pre = pre[:-1]
            if(pre.endswith('.')):
              pre = pre[:-1]
            numberstr = pre + 'e' + post
          else:
            numberstr = FORMAT_DECIMAL.format(number)
            # chop away trailing zeros and decimal dots
            while numberstr.endswith('0'):
              numberstr = numberstr[:-1]
            if(numberstr.endswith('.')):
              numberstr = numberstr[:-1]
        else:
          numberstr = str(number)
        
        return numberstr
      except:
        return ''
    
    tickli = [formatThis(i) for i in ticks]
    tickstr = ', '.join([i for i in tickli if len(i)])
    return tickstr

  def changeSplitFraction(self, minval=0, maxval=1, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.xSplitFraction.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.xSplitFraction.setText(str(value))

    self.parent.plotArea.changeSplitFraction(value=value, redraw=redraw)

  def changeSplitPad(self, minval=0, maxval=1, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.xSplitPad.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.xSplitPad.setText(str(value))

    self.parent.plotArea.changeSplitPad(value=value, redraw=redraw)

  def alterInnerDividerLineAngle(self):
    # change angle of split x axis divider lines
    try:
      value = float(self.configInnerDividerLineAngle.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configInnerDividerLineAngle.setValue(value)

    self.parent.plotArea.updateSplitDivider(param='angle', value=value, redraw=True)

  def changeInnerDividerLineLocation(self):
    # change location of split x axis divider lines
    style = str(self.configInnerDividerLineLocation.currentText())
    self.parent.plotArea.updateSplitDivider(param='location', value=style, redraw=True)

  def changeInnerDividerLineDashStyle(self):
    # change dash style of split x axis divider lines
    style = str(self.configInnerDividerLineDashStyle.currentText())
    self.parent.plotArea.updateSplitDivider(param='dash', value=style, redraw=True)

  def alterInnerDividerLineWidth(self):
    # change width of split x axis divider lines
    try:
      value = float(self.configInnerDividerLineWidth.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configInnerDividerLineWidth.setValue(value)

    self.parent.plotArea.updateSplitDivider(param='width', value=value, redraw=True)

  def alterInnerDividerLineLength(self):
    # change length of split x axis divider lines
    try:
      value = float(self.configInnerDividerLineLength.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configInnerDividerLineLength.setValue(value)

    self.parent.plotArea.updateSplitDivider(param='length', value=value, redraw=True)

  def changeInnerDividerLineColor(self):
    # change color of split x axis divider lines
    prevColor = [255 * i for i in self.parent.plotArea.splitDividerColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.updateSplitDivider(param='color', value=value, redraw=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.splitDividerColor[0:3]]
      self.configInnerDividerLineColor.setMyColor(*colorvalue)

  def alterSplitYDividerLineAngle(self):
    # change angle of split y axis divider lines
    try:
      value = float(self.configSplitYDividerLineAngle.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configSplitYDividerLineAngle.setValue(value)

    self.parent.plotArea.updateSplitYDivider(param='angle', value=value, redraw=True)

  def changeSplitYDividerLineLocation(self):
    # change location of split y axis divider lines
    style = str(self.configSplitYDividerLineLocation.currentText())
    self.parent.plotArea.updateSplitYDivider(param='location', value=style, redraw=True)

  def changeSplitYDividerLineDashStyle(self):
    # change dash style of split y axis divider lines
    style = str(self.configSplitYDividerLineDashStyle.currentText())
    self.parent.plotArea.updateSplitYDivider(param='dash', value=style, redraw=True)

  def alterSplitYDividerLineWidth(self):
    # change width of split y axis divider lines
    try:
      value = float(self.configSplitYDividerLineWidth.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configSplitYDividerLineWidth.setValue(value)

    self.parent.plotArea.updateSplitYDivider(param='width', value=value, redraw=True)

  def alterSplitYDividerLineLength(self):
    # change length of split y axis divider lines
    try:
      value = float(self.configSplitYDividerLineLength.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configSplitYDividerLineLength.setValue(value)

    self.parent.plotArea.updateSplitYDivider(param='length', value=value, redraw=True)

  def changeSplitYDividerLineColor(self):
    # change color of split y axis divider lines
    prevColor = [255 * i for i in self.parent.plotArea.splitYDividerColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.updateSplitYDivider(param='color', value=value, redraw=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.splitYDividerColor[0:3]]
      self.configSplitYDividerLineColor.setMyColor(*colorvalue)

  def toggleSplitY(self):
    # toggles split y axes
    state = self.configSplitYLabel.isChecked()
    self.parent.plotArea.setSplitY(value=state, redraw=True)

  def changeSplitYFraction(self, minval=0, maxval=1, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.configSplitYFraction.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configSplitYFraction.setText(str(value))

    self.parent.plotArea.changeSplitYFraction(value=value, redraw=redraw)

  def changeSplitYPad(self, minval=0, maxval=0.5, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.configSplitYPad.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configSplitYPad.setText(str(value))

    self.parent.plotArea.changeSplitYPad(value=value, redraw=redraw)

  def setInnerYParameter(self, param='axes'):
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        state = self.configSplitYAxesLabel.isChecked()
      else:
        state = self.configSplitYTickLabel.isChecked()
        
      self.parent.plotArea.setInnerYParameter(param=param, state=state, redraw=True)
          
  def setSplitYDivider(self):
    # toggles display of split divider lines
    state = self.configSplitYDividerLine.isChecked()
    self.parent.plotArea.setSplitYDivider(value=state, redraw=True)

  def setSplitDivider(self):
    # toggles display of split divider lines
    state = self.configInnerDividerLine.isChecked()
    self.parent.plotArea.setSplitDivider(value=state, redraw=True)

  def setInnerParameter(self, param='axes'):
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        state = self.configInnerAxesLabel.isChecked()
      else:
        state = self.configInnerTickLabel.isChecked()
        
      self.parent.plotArea.setInnerParameter(param=param, state=state, redraw=True)
          
  def changePadding(self, axis='bottom', minval=0, maxval=1):
    # adjusts padding around figure
    if(axis in ['bottom', 'top', 'left', 'right']):
      # check paramter boundaries
      try:
        value = float(self.exportPadEntry[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.exportPadEntry[axis].setText(str(value))
        
      self.parent.plotArea.setPadding(value=value, axis=axis, redraw=True, target='plot')
      self.parent.plotArea.setPadding(value=value, axis=axis, redraw=True, target='resid')

  def alterArrowLineWidth(self, axis='x'):
    # changes arrow edge width
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowLineWidth[axis].value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        self.configArrowLineWidth[axis].setValue(value)
        
      self.parent.plotArea.setAxisArrowLineWidth(value=value, axis=axis, redraw=True)

  def changeArrowHeadWidth(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arrow head width
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowHeadWidth[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowHeadWidth[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowHeadWidth(value=value, axis=axis, redraw=True)

  def changeArrowHeadLength(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arrow head length
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowHeadLength[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowHeadLength[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowHeadLength(value=value, axis=axis, redraw=True)

  def changeArrowOverhang(self, axis='x', minval = -1.0, maxval = 1.0):
    # changes arrow head overhang
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowOverhang[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowOverhang[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowOverhang(value=value, axis=axis, redraw=True)

  def changeArrowOffset(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arrow head offset
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowOffset[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowOffset[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowOffset(value=value, axis=axis, redraw=True)

  def changeArrowLocation(self, axis='x'):
    # changes arrow head location
    if(axis in ['x', 'y']):
      location = self.configArrowLocation[axis].currentText()
      self.parent.plotArea.setAxisArrowLocation(value=location, axis=axis, redraw=True)

  def changeArrowColor(self, axis='x', item='fill'):
    # sets arrow color(s)
    if((axis in ['x', 'y']) and (item in ['fill', 'line'])):
      # get current color
      if(item == 'line'):
        prevColor = [255 * i for i in self.parent.plotArea.arrowColor[axis]]
      else:
        prevColor = [255 * i for i in self.parent.plotArea.arrowFill[axis]]
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        self.parent.plotArea.setAxisArrowColor(value=value, axis=axis, item=item, redraw=True)
        # update color button
        if(item == 'line'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.arrowColor[axis][0:3]]
          self.configArrowLineColor[axis].setMyColor(*colorvalue)
        else:
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.arrowFill[axis][0:3]]
          self.configArrowFillColor[axis].setMyColor(*colorvalue)

  def setAxisArrow(self, axis='x', item='all'):
    # toggles arrow visibility
    if(axis in ['x', 'y']):
      if(item in ['all', 'edge', 'fill']):
        if(item == 'all'):
          state = self.configArrowLabel[axis].isChecked()
        elif(item == 'edge'):
          state = self.configArrowLineColorLabel[axis].isChecked()
        else:
          state = self.configArrowFillColorLabel[axis].isChecked()
          
        for target in ['plot', 'resid']:
          self.parent.plotArea.setAxisArrow(state=state, axis=axis, item=item, redraw=True, target=target)

  def setPathStroke(self, redraw=True):
    # toggles path effects
    state = self.configPathEffectsLabel.isChecked()
    self.parent.plotArea.setPathStroke(state=state, redraw=redraw)

  def changePathStrokeColor(self):
    # changes color of path stroke
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.pathStrokeColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setPathStrokeColor(value=value, redraw=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.pathStrokeColor[0:3]]
      self.configPathEffectsColorButton.setMyColor(*colorvalue)

  def alterPathStrokeWidth(self):
    # changes path stroke width
    # check paramter boundaries
    try:
      value = float(self.configPathEffectsWidth.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configPathEffectsWidth.setValue(value)
      
    self.parent.plotArea.setPathStrokeWidth(value=value, redraw=True)

  def setPathShadow(self, redraw=True):
    # toggles path effects
    state = self.configPathShadowLabel.isChecked()
    self.parent.plotArea.setPathShadow(state=state, redraw=redraw)

  def changePathShadowColor(self):
    # changes color of path shadow
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.pathShadowColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setPathShadowColor(value=value, redraw=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.pathShadowColor[0:3]]
      self.configPathShadowColorButton.setMyColor(*colorvalue)

  def changePathShadowOffset(self, direction = 'x', minval = 0.0, maxval = 100.0):
    # changes path shadow offset
    if(direction in ['x', 'y']):
      # check paramter boundaries
      if(direction == 'x'):
        try:
          value = float(self.configPathShadowOffX.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      else:
        try:
          value = float(self.configPathShadowOffY.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        if(direction == 'x'):
          self.configPathShadowOffX.setText(str(value))
        else:
          self.configPathShadowOffY.setText(str(value))
        
      self.parent.plotArea.setPathShadowOffset(value=value, direction=direction, redraw=True)

  def setFrame(self):
    # toggles visibility of frame
    state = self.configFrameCheck.isChecked()
    self.parent.plotArea.setFrame(value=state, redraw=True, target='plot')
    self.parent.plotArea.setFrame(value=state, redraw=True, target='resid')

  def alterFrameWidth(self):
    # changes frame line width
    # check paramter boundaries
    try:
      value = float(self.configFrameWidth.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configFrameWidth.setValue(value)
      
    self.parent.plotArea.setFrameWidth(value=value, redraw=True, target='plot')
    self.parent.plotArea.setFrameWidth(value=value, redraw=True, target='resid')

  def setFrameStyle(self):
    # sets grid style
    style = str(self.configFrameStyle.currentText())
    self.parent.plotArea.setFrameStyle(value=style, redraw=True, target='plot')
    self.parent.plotArea.setFrameStyle(value=style, redraw=True, target='resid')

  def setFrameDashStyle(self):
    # sets grid style
    style = str(self.configFrameDashStyle.currentText())
    self.parent.plotArea.setFrameDashStyle(value=style, redraw=True, target='plot')
    self.parent.plotArea.setFrameDashStyle(value=style, redraw=True, target='resid')

  def changeFrameColor(self):
    # sets frame color
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.frameColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setFrameColor(value=value, redraw=True, target='plot')
      self.parent.plotArea.setFrameColor(value=value, redraw=True, target='resid')
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.frameColor[0:3]]
      self.configFrameColor.setMyColor(*colorvalue)

  def setXkcd(self, redraw=True):
    # toggles Xkcd
    state = self.configXkcdLabel.isChecked()
    self.parent.plotArea.xkcdify(state=state, redraw=redraw)

  def setCanvasGradient(self):
    # toggles visibility of canvas gradient
    state = self.configCanvasGradientLabel.isChecked()
    self.parent.plotArea.setCanvasGradient(state=state, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradient(state=state, redraw=True, target='resid')

  def changeCanvasGradientStyle(self):
    # sets style of canvas gradient
    value = self.configCanvasGradientStyle.currentText()
    self.parent.plotArea.setCanvasGradientStyle(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientStyle(value=value, redraw=True, target='resid')
    # additionally control visibility of canvas gradient controls
    self.visibilityCanvasGradientControls()

  def changeCanvasGradientWidth(self, minval=0.01, maxval=3.0):
    # changes angle of canvas gradient
    # check paramter boundaries
    try:
      value = float(self.configCanvasGradientWidth.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configCanvasGradientWidth.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientWidth(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientWidth(value=value, redraw=True, target='resid')

  def changeCanvasGradientCenter(self, minval=0.0, maxval=1.0, axis='x'):
    # changes angle of canvas gradient
    if(axis == 'x'):
      item = self.configCanvasGradientCenterX
    else:
      item = self.configCanvasGradientCenterY
    # check paramter boundaries
    try:
      value = float(item.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      item.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientCenter(value=value, redraw=True, target='plot', axis=axis)
    self.parent.plotArea.setCanvasGradientCenter(value=value, redraw=True, target='resid', axis=axis)

  def changeCanvasGradientAngle(self, minval=0.0, maxval=360.0):
    # changes angle of canvas gradient
    # check paramter boundaries
    try:
      value = float(self.configCanvasGradientAngle.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configCanvasGradientAngle.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientAngle(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientAngle(value=value, redraw=True, target='resid')

  def changeCanvasGradientColor(self, color=0):
    # changes color of path stroke
    # get current color
    if(color):
      prevColor = [255 * i for i in self.parent.plotArea.canvasGradientColor2]
    else:
      prevColor = [255 * i for i in self.parent.plotArea.canvasGradientColor1]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setCanvasGradientColor(value=value, redraw=True, target='plot', color=color)
      self.parent.plotArea.setCanvasGradientColor(value=value, redraw=True, target='resid', color=color)
      # update color button
      if(color):
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasGradientColor2[0:3]]
        self.configCanvasGradientColor2Button.setMyColor(*colorvalue)
      else:
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasGradientColor1[0:3]]
        self.configCanvasGradientColor1Button.setMyColor(*colorvalue)

  def setLegend(self):
    # toggles visibility of legend
    state = self.configLegendLabel.isChecked()
    self.parent.plotArea.setLegend(value=state, redraw=True, target='plot')

  def setLegendShadow(self):
    # toggles visibility of legend shadow
    state = self.configLegendShadowLabel.isChecked()
    self.parent.plotArea.setLegendShadow(value=state, redraw=True, target='plot')

  def setLegendPlacement(self):
    # toggles visibility of legend
    placement = str(self.configLegendPlacement.currentText())
    self.parent.plotArea.setLegendPlacement(value=placement, redraw=True, target='plot')

  def changeLegendColor(self, prop='face'):
    # sets color of legend box
    if(prop in ['face', 'edge']):
      # get current color
      prevColor = [255 * i for i in self.parent.plotArea.legendColor[prop]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        self.parent.plotArea.setLegendColor(value=value, prop=prop, redraw=True, target='plot')
        # update color button
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendColor[prop][0:3]]
        self.configLegendColor[prop].setMyColor(*colorvalue)

  def changeLegendRounding(self, minval=0, maxval=1):
    # changes rounding of legend box
    # check paramter boundaries
    try:
      value = float(self.configLegendRounding.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configLegendRounding.setText(str(value))
      
    self.parent.plotArea.setLegendRounding(value=value, redraw=True, target='plot')

  def changeLegendHatch(self, item='hatch'):
    # toggles visibility of legend
    if(item == 'hatch'):
      value = str(self.legendComboHatchStyle.currentText())
    else:
      value = int(self.legendComboHatchMultiplyStyle.currentText())
    self.parent.plotArea.setLegendHatchParameter(item=item, value=value, redraw=True, target='plot')

  def changeLegendShadowOffset(self, direction = 'x', minval = -100.0, maxval = 100.0):
    # changes figure legend shadow offset
    if(direction in ['x', 'y']):
      # check paramter boundaries
      if(direction == 'x'):
        try:
          value = float(self.configLegendShadowOffX.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      else:
        try:
          value = float(self.configLegendShadowOffY.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        if(direction == 'x'):
          self.configPathShadowOffX.setText(str(value))
        else:
          self.configPathShadowOffY.setText(str(value))

      self.parent.plotArea.setLegendShadowParameter(item=direction, value=value, redraw=True, target='plot')

  def changeLegendShadowColor(self):
    # sets color of legend shadow
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.legendShadowFaceColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setLegendShadowParameter(item='color', value=value, redraw=True, target='plot')
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendShadowFaceColor[0:3]]
      self.configLegendShadowColor.setMyColor(*colorvalue)

  def changeLegendLabelColor(self):
    # sets color of legend labels
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.legendLabelColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setLegendLabelColor(value=value, redraw=True, target='plot')
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.legendLabelColor[0:3]]
      self.configLegendLabelColor.setMyColor(*colorvalue)

  def alterLegendEdgeWidth(self):
    # changes width of legend edge
    # check paramter boundaries
    try:
      value = float(self.configLegendEdgeWidth.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      self.configLegendEdgeWidth.setValue(value)
      
    self.parent.plotArea.setLegendEdgeWidth(value=value, redraw=True, target='plot')

  def changeLegendPadBorder(self, entryfield=None, minval=0, maxval=1):
    # changes border padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadBorder(value=value, redraw=True, target='plot')

  def changeLegendPadRow(self, entryfield=None, minval=0, maxval=1):
    # changes row padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadRow(value=value, redraw=True, target='plot')

  def changeLegendPadCol(self, entryfield=None, minval=0, maxval=1):
    # changes column padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadCol(value=value, redraw=True, target='plot')

  def alterLegendLabelSize(self, entryfield=None):
    # changes font size of legend label
    try:
      value = float(entryfield.value())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    # update parameters
    if (value != originalvalue):
      entryfield.setValue(value)
      
    self.parent.plotArea.setLegendLabelSize(value=value, redraw=True, target='plot')

  def changeLegendLabelBold(self):
    # changes formatting of legend label
    isChecked = self.configLegendLabelBold.isChecked()
    if(isChecked):
      value = 'bold'
    else:
      value = 'normal'
      
    self.parent.plotArea.setLegendLabelBold(value=value, redraw=True, target='plot')

  def changeLegendLabelItalic(self):
    # changes formatting of legend label
    isChecked = self.configLegendLabelItalic.isChecked()
    if(isChecked):
      value = 'italic'
    else:
      value = 'normal'
      
    self.parent.plotArea.setLegendLabelItalic(value=value, redraw=True, target='plot')

  def setLegendLabelFont(self):
    # sets legend label font
    useFont = str(self.configLegendLabelFont.currentText())
      
    if(useFont in self.parent.fontNames):
      self.parent.plotArea.setLegendLabelFont(value=useFont, redraw=True, target='plot')

  def setLegendNCol(self):
    # sets number of columns in legend
    value = self.configLegendNCol.currentIndex() + 1
    self.parent.plotArea.setLegendNCol(value=value, redraw=True, target='plot')

  def setLegendMarkerFirst(self):
    # toggles whether to display marker first in legend
    state = self.configLegendMarkerFirstLabel.isChecked()
    self.parent.plotArea.setLegendMarkerFirst(value=state, redraw=True, target='plot')

  def changeLegendMarkerScale(self, entryfield=None, minval=0, maxval=1):
    # changes relative size of legend marker
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendMarkerScale(value=value, redraw=True, target='plot')

  def setLegendMarkerNumPoints(self):
    # sets number of marker points in legend
    value = self.configLegendMarkerNumPoints.currentIndex() + 1
    self.parent.plotArea.setLegendMarkerNumPoints(value=value, redraw=True, target='plot')

  def toggleLegendFill(self):
    # toggles whether legend filled or not
    state = self.configLegendColorLabel['face'].isChecked()
    self.parent.plotArea.toggleLegendFill(value=state, redraw=True, target='plot')

  def toggleLegendEdge(self):
    # toggles whether legend boxed or not
    state = self.configLegendColorLabel['edge'].isChecked()
    self.parent.plotArea.toggleLegendEdge(value=state, redraw=True, target='plot')

  def setGridVisibility(self, axis='x'):
    # toggles grid visibility
    if(axis in ['x', 'x2', 'y', 'y2']):
      state = self.configGridLabel[axis].isChecked()
      self.parent.plotArea.setGridVisibility(value=state, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridVisibility(value=state, axis=axis, redraw=True, target='resid')

  def changeGridColor(self, axis='x'):
    # sets grid color
    if(axis in ['x', 'x2', 'y', 'y2']):
      # get current color
      prevColor = [255*i for i in self.parent.plotArea.gridColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setGridColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'x2', 'y']):
          self.parent.plotArea.setGridColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.gridColor[axis][0:3]]
        self.configGridColor[axis].setMyColor(*colorvalue)

  def alterGridWidth(self, axis='x'):
    # changes grid line width
    if(axis in ['x', 'x2', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(self.configGridWidth[axis].value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        self.configGridWidth[axis].setValue(value)
        
      self.parent.plotArea.setGridWidth(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridWidth(value=value, axis=axis, redraw=True, target='resid')

  def setGridOrder(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      order = str(self.configGridOrder[axis].currentText())
      index = self.configGridOrder[axis].currentIndex()
     
      self.parent.plotArea.setGridOrder(value=order, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridOrder(value=order, axis=axis, redraw=True, target='resid')

  def setGridStyle(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      style = str(self.configGridStyle[axis].currentText())
      self.parent.plotArea.setGridStyle(value=style, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridStyle(value=style, axis=axis, redraw=True, target='resid')

  def setGridDashStyle(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      style = str(self.configGridDashStyle[axis].currentText())
      self.parent.plotArea.setGridDashStyle(value=style, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridDashStyle(value=style, axis=axis, redraw=True, target='resid')

  def changeAxisColor(self, axis='left'):
    # sets axis color
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # get current color
      prevColor = [255 * i for i in self.parent.plotArea.axisColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
          self.parent.plotArea.setAxisColor(value=value, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
          self.parent.plotArea.setAxisColor(value=value, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setAxisColor(value=value, axis=axis, redraw=True, target='plot')
        if(not (axis in ['left2', 'right2'])):
          self.parent.plotArea.setAxisColor(value=value, axis=axis, redraw=True, target='resid')
        elif(self.parent.plotArea.splitY):
          self.parent.plotArea.setAxisColor(value=value, axis=axis[:-1], redraw=True, target='resid')
        # update color button
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.axisColor[axis][0:3]]
        self.configAxisColor[axis].setMyColor(*colorvalue)
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
          self.parent.graphicsarea2.configAxisColor[axis + '2'].setMyColor(*colorvalue)
        if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
          self.parent.graphicsarea.configAxisColor[axis[:-1]].setMyColor(*colorvalue)

  def setTickFont(self, axis='x'):
    # sets tick font
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        useFont = str(self.configTickXFont.currentText())
      else:
        useFont = str(self.configTickYFont.currentText())
      
      if(useFont in self.parent.fontNames):
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y')):
          index = self.configTickYFont.currentIndex()
          self.parent.graphicsarea2.configTickYFont.setCurrentIndex(index)
          self.parent.plotArea.setTickFont(value=useFont, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis == 'y2')):
          index = self.configTickYFont.currentIndex()
          self.parent.graphicsarea.configTickYFont.setCurrentIndex(index)
          self.parent.plotArea.setTickFont(value=useFont, axis='y', redraw=False, target='plot')
        self.parent.plotArea.setTickFont(value=useFont, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickFont(value=useFont, axis=axis, redraw=True, target='resid')
        elif(self.parent.plotArea.splitY):
          self.parent.plotArea.setTickFont(value=useFont, axis=axis[:-1], redraw=True, target='resid')

  def setMinorTick(self, axis='x'):
    # sets minor tick number
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        value = self.configMinorTickX.currentIndex() + 2
        toggleButton = self.configMinorTickXLabel
      elif(axis == 'x2'):
        value = self.configInnerMinorTickX.currentIndex() + 2
        toggleButton = self.configInnerMinorTickLabel
      elif(axis in ['y', 'y2']):
        value = self.configMinorTickY.currentIndex() + 2
        toggleButton = self.configMinorTickYLabel
      else:
        value = self.configMinorTickResid.currentIndex() + 2
        toggleButton = self.configMinorTickResidLabel

      if(axis in ['x', 'x2']):
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='resid')
      elif(axis == 'y'):
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          index = self.configMinorTickY.currentIndex()
          self.parent.graphicsarea2.configMinorTickY.setCurrentIndex(index)
          self.parent.plotArea.setMinorTick(value=value, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
      elif(axis == 'y2'):
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
      else:
        self.parent.plotArea.setMinorTick(value=value, axis='y', redraw=True, target='resid')
        
      # silently toggle on check button
      toggleButton.setChecked(True)

  def toggleTicksLabel(self, axis='x'):
    # toggles visibility of tick labels
    if(axis in ['x', 'x2', 'y', 'y2', 'resid']):
      if(axis == 'x'):
        state = self.configTickXLabel.isChecked()
      elif(axis == 'x2'):
        state = self.configInnerLabel.isChecked()
      elif(axis in ['y', 'y2']):
        state = self.configTickYLabel.isChecked()
      else:
        state = self.configTickResidYLabel.isChecked()
        
      if(axis == 'resid'):
        self.parent.plotArea.toggleTicksLabel(value=state, axis='y', redraw=True, target='resid')
      else:
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y')):
          self.parent.graphicsarea2.configTickYLabel.setChecked(state)
          self.parent.plotArea.toggleTicksLabel(value=state, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis == 'y2')):
          self.parent.graphicsarea.configTickYLabel.setChecked(state)
          self.parent.plotArea.toggleTicksLabel(value=state, axis='y', redraw=False, target='plot')
        self.parent.plotArea.toggleTicksLabel(value=state, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'x2']):
          self.parent.plotArea.toggleTicksLabel(value=state, axis=axis, redraw=True, target='resid')

  def toggleAxisLabel(self, axis='x'):
    # toggles visibility of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        state = self.configXLabel.isChecked()
      else:
        state = self.configYLabel.isChecked()
      self.parent.plotArea.toggleAxisLabel(value=state, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.toggleAxisLabel(value=state, axis=axis, redraw=True, target='resid')

  def setAxisLabelAlignment(self, axis='x'):
    # sets alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configXAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      else:
        useAlignment = str(self.configYAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      
      if(flag):
        self.parent.plotArea.setAxisLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='resid')

  def setAxisLabelAlignmentVertical(self, axis='x'):
    # sets vertical alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configXAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      else:
        useAlignment = str(self.configYAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      
      if(flag):
        self.parent.plotArea.setAxisLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='resid')

  def changeAxisLabelBold(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXBold.isChecked()
      else:
        isChecked = self.configYBold.isChecked()
        
      if(isChecked):
        value = 'bold'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelBold(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelBold(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelItalic(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXItalic.isChecked()
      else:
        isChecked = self.configYItalic.isChecked()
        
      if(isChecked):
        value = 'italic'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelItalic(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelItalic(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelVariant(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXVariant.isChecked()
      else:
        isChecked = self.configYVariant.isChecked()
        
      if(isChecked):
        value = 'small-caps'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelVariant(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelVariant(value=value, axis=axis, redraw=True, target='resid')

  def setAxisFont(self, axis='x'):
    # sets axis font
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        useFont = str(self.configXFont.currentText())
      else:
        useFont = str(self.configYFont.currentText())
      
      if(useFont in self.parent.fontNames):
        self.parent.plotArea.setAxisFont(value=useFont, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          	self.parent.plotArea.setAxisFont(value=useFont, axis=axis, redraw=True, target='resid')

  def setAxisStyle(self, axis='left'):
    # sets axis style
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisStyle[axis].currentText())
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        index = self.configAxisStyle[axis].currentIndex()
        self.parent.graphicsarea2.configAxisStyle[axis + '2'].setCurrentIndex(index)
        self.parent.plotArea.setAxisStyle(value=style, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        index = self.configAxisStyle[axis].currentIndex()
        self.parent.graphicsarea.configAxisStyle[axis[:-1]].setCurrentIndex(index)
        self.parent.plotArea.setAxisStyle(value=style, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setAxisStyle(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisStyle(value=style, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisStyle(value=style, axis=axis[:-1], redraw=True, target='resid')

  def setAxisDashStyle(self, axis='left'):
    # sets axis style
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisDashStyle[axis].currentText())
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        index = self.configAxisDashStyle[axis].currentIndex()
        self.parent.graphicsarea2.configAxisDashStyle[axis + '2'].setCurrentIndex(index)
        self.parent.plotArea.setAxisDashStyle(value=style, axis=axis + '2', redraw=False, target='plot')
      self.parent.plotArea.setAxisDashStyle(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisDashStyle(value=style, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisDashStyle(value=style, axis=axis[:-1], redraw=True, target='resid')

  def setAxisPosition(self, axis='left'):
    # sets axis position
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisPosition[axis].currentText())
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        index = self.configAxisPosition[axis].currentIndex()
        self.parent.graphicsarea2.configAxisPosition[axis + '2'].setCurrentIndex(index)
        self.parent.plotArea.setAxisPosition(value=style, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        index = self.configAxisPosition[axis].currentIndex()
        self.parent.graphicsarea.configAxisPosition[axis[:-1]].setCurrentIndex(index)
        self.parent.plotArea.setAxisPosition(value=style, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setAxisPosition(value=style, axis=axis, redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['bottom', 'top'])):
        # phew, we will need to update setAxisPositionHelper() to accommodate this option
        self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax, target='plot', secondAxes=False, splitX=False, splitY=True)
        self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax_div, target='plot', secondAxes=False, splitX=False, splitY=True)
      self.parent.plotArea.dataplotwidget.myRefresh()
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisPosition(value=style, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisPosition(value=style, axis=axis[:-1], redraw=True, target='resid')

  def changeAxisPositionValue(self, axis='left', minval=-np.inf, maxval=np.inf):
    # changes axis position value
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configAxisPositionValue[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configAxisPositionValue[axis].setText(str(value))
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configAxisPositionValue[axis + '2'].setText(str(value))
        self.parent.plotArea.setAxisPositionValue(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configAxisPositionValue[axis[:-1]].setText(str(value))
        self.parent.plotArea.setAxisPositionValue(value=value, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setAxisPositionValue(value=value, axis=axis, redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['bottom', 'top'])):
        # phew, we will need to update setAxisPositionHelper() to accommodate this option
        self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax, target='plot', secondAxes=False, splitX=False, splitY=True)
        self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax_div, target='plot', secondAxes=False, splitX=False, splitY=True)
      self.parent.plotArea.dataplotwidget.myRefresh()
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisPositionValue(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisPositionValue(value=value, axis=axis[:-1], redraw=True, target='resid')

  def resetAxisPosition(self, axis='left'):
    # resets axis position to original one
    # first update entry fields
    originalPosition = {'left':('axes', 0), 'right':('axes', 1.0), 'bottom':('axes', 0), 'top':('axes', 1.0), 'left2':('axes', 0), 'right2':('axes', 1.0)}
    if(axis in originalPosition):
      value = str(self.configAxisPosition[axis].currentText())
      if(value != originalPosition[axis][0]):
        if(originalPosition[axis][0] in self.positionstyles):
          self.configAxisPosition[axis].blockSignals(True)
          currindex = self.positionstyles.index(originalPosition[axis][0])
          self.configAxisPosition[axis].setCurrentIndex(currindex)
          self.configAxisPosition[axis].blockSignals(False)
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
            self.parent.graphicsarea2.configAxisPosition[axis + '2'].setCurrentIndex(currindex)
          if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
            self.parent.graphicsarea.configAxisPosition[axis[:-1]].setCurrentIndex(currindex)
      try:
        value = float(self.configAxisPositionValue[axis].text())
      except:
        value = -9
      if(value != originalPosition[axis][1]):
        self.configAxisPositionValue[axis].blockSignals(True)
        self.configAxisPositionValue[axis].setText(str(originalPosition[axis][1]))
        self.configAxisPositionValue[axis].blockSignals(False)
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
          self.parent.graphicsarea2.configAxisPositionValue[axis + '2'].setText(str(originalPosition[axis][1]))
        if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
          self.parent.graphicsarea.configAxisPositionValue[axis[:-1]].setText(str(originalPosition[axis][1]))
      
    # reset the axisn
    # check for split y axis and slave setting if needed
    if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
      self.parent.plotArea.resetAxisPosition(axis=axis + '2', redraw=False)
    if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
      self.parent.plotArea.resetAxisPosition(axis=axis[:-1], redraw=False)
    self.parent.plotArea.resetAxisPosition(axis=axis, redraw=False)
    if(self.parent.plotArea.splitY and (axis in ['bottom', 'top'])):
      # phew, we will need to update setAxisPositionHelper() to accommodate this option
      self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax, target='plot', secondAxes=False, splitX=False, splitY=True)
      self.parent.plotArea.setAxisPositionHelper(axis=axis, plotobject=self.parent.plotArea.dataplotwidget, axisobject=self.parent.plotArea.ax_div, target='plot', secondAxes=False, splitX=False, splitY=True)
    self.parent.plotArea.dataplotwidget.myRefresh()
    self.parent.plotArea.residplotwidget.myRefresh()

  def alterAxisWidth(self, axis='left'):
    # changes axis width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configAxisWidth[axis].value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        self.configAxisWidth[axis].setValue(value)
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configAxisWidth[axis + '2'].setValue(value)
        self.parent.plotArea.setAxisWidth(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configAxisWidth[axis[:-1]].setValue(value)
        self.parent.plotArea.setAxisWidth(value=value, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setAxisWidth(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisWidth(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisWidth(value=value, axis=axis[:-1], redraw=True, target='resid')

  def changeAxisBoundary(self, axis='left', lower=True):
    # changes axis boundary
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      if(lower):
        entryfield = self.configAxisBoundLower[axis]
      else:
        entryfield = self.configAxisBoundUpper[axis]
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      # check whether redraw should be issued (only whne boundaries are active)
      if(self.configAxisBoundLabel[axis].isChecked()):
        redraw = True
      else:
        redraw = False
        
      self.parent.plotArea.setAxisBoundaryValue(value=value, lower=lower, axis=axis, redraw=redraw, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisBoundaryValue(value=value, lower=lower, axis=axis, redraw=redraw, target='resid')

  def setAxisBoundary(self, axis='left'):
    # toggles axis boundary
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      value = self.configAxisBoundLabel[axis].isChecked()
      self.parent.plotArea.setAxisBoundary(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisBoundary(value=value, axis=axis, redraw=True, target='resid')

  def setAxisVisibility(self, axis='left'):
    # toggles axis visibility
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      state = self.configAxisLabel[axis].isChecked()
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configAxisLabel[axis + '2'].setChecked(state)
        self.parent.plotArea.setAxisVisibility(value=state, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configAxisLabel[axis[:-1]].setChecked(state)
        self.parent.plotArea.setAxisVisibility(value=state, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setAxisVisibility(value=state, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisVisibility(value=state, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setAxisVisibility(value=state, axis=axis[:-1], redraw=True, target='resid')

  def setTickMarkDirection(self, axis='left'):
    # sets tick mark direction
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configTickMarkDirection[axis].currentText())
      index = self.configTickMarkDirection[axis].currentIndex()
      # update parameters
      if(axis in ['left', 'right']):
        for entry in ['left', 'right']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)
      elif(axis in ['top', 'bottom']):
        for entry in ['top', 'bottom']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)
      else:
        for entry in ['left2', 'right2']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)

      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        for entry in ['left2', 'right2']:
          self.parent.graphicsarea2.configTickMarkDirection[entry].setCurrentIndex(index)
        self.parent.plotArea.setTickMarkDirection(value=style, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        for entry in ['left', 'right']:
          self.parent.graphicsarea.configTickMarkDirection[entry].setCurrentIndex(index)
        self.parent.plotArea.setTickMarkDirection(value=style, axis=axis[:-1], redraw=False, target='plot')

      self.parent.plotArea.setTickMarkDirection(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkDirection(value=style, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickMarkDirection(value=style, axis=axis[:-1], redraw=True, target='resid')

  def setTickMarkLabelShow(self, axis='left'):
    # toggles ticks visibility
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      state = self.configTickMarkLabelShow[axis].isChecked()

      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configTickMarkLabelShow[axis + '2'].setChecked(state)
        self.parent.plotArea.setTickMarkLabelShow(value=state, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configTickMarkLabelShow[axis[:-1]].setChecked(state)
        self.parent.plotArea.setTickMarkLabelShow(value=state, axis=axis + '2', redraw=False, target='plot')
      self.parent.plotArea.setTickMarkLabelShow(value=state, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkLabelShow(value=state, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickMarkLabelShow(value=state, axis=axis[:-1], redraw=True, target='resid')

  def setTicksVisibility(self, axis='left'):
    # toggles ticks visibility
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        splitY = True
      else:
        splitY = False

      state = self.configTickMarkLabel[axis].isChecked()
      if(splitY):
        self.parent.graphicsarea2.configTickMarkLabel[axis + '2'].setChecked(state)
        self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis + '2', redraw=False, target='plot')
      if((axis in ['left2', 'right2']) and self.parent.plotArea.splitY):
        self.parent.graphicsarea.configTickMarkLabel[axis[:-1]].setChecked(state)
        self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis, redraw=False, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis, redraw=False, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis[:-1], redraw=False, target='resid')

      # need to reapply tick formatting as there is the possiblity we switched from left to right of from top to bottom or vice versa
      if(axis in ['top', 'bottom']):
        axis = 'x'
        tickLabelColor = self.parent.plotArea.ticksXColor
        tickLabelSize = self.parent.plotArea.ticksXSize
        tickLabelWeight = self.parent.plotArea.ticksXWeight
        tickLabelStyle = self.parent.plotArea.ticksXStyle
        tickLabelAngle = self.parent.plotArea.ticksXAngle
        tickLabelAlignment = self.parent.plotArea.ticksXAlignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksXAlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
        useShow, useShow_resid = self.parent.plotArea.ticksXShow, self.parent.plotArea.ticksXShow_resid
        ##### need to deal with div plot as well
      elif(axis in ['left', 'right']):
        axis = 'y'
        tickLabelColor = self.parent.plotArea.ticksYColor
        tickLabelSize = self.parent.plotArea.ticksYSize
        tickLabelWeight = self.parent.plotArea.ticksYWeight
        tickLabelStyle = self.parent.plotArea.ticksYStyle
        tickLabelAngle = self.parent.plotArea.ticksYAngle
        tickLabelAlignment = self.parent.plotArea.ticksYAlignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksYAlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
        useShow, useShow_resid = self.parent.plotArea.ticksYShow, self.parent.plotArea.ticksResidYShow
      else:
        axis = 'y2'
        tickLabelColor = self.parent.plotArea.ticksY2Color
        tickLabelSize = self.parent.plotArea.ticksY2Size
        tickLabelWeight = self.parent.plotArea.ticksY2Weight
        tickLabelStyle = self.parent.plotArea.ticksY2Style
        tickLabelAngle = self.parent.plotArea.ticksY2Angle
        tickLabelAlignment = self.parent.plotArea.ticksY2Alignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksY2AlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
        useShow, useShow_resid = self.parent.plotArea.ticksY2Show, None
      
      if(axis == 'y2'):
        usePlots = ['plot']
      else:
        usePlots = ['plot', 'resid']
      for target in usePlots:
        self.parent.plotArea.setTickLabelColor(value=tickLabelColor, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelSize(value=tickLabelSize, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelBold(value=tickLabelWeight, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelItalic(value=tickLabelStyle, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelAngle(value=tickLabelAngle, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelAlignment(value=tickLabelAlignment, axis=axis, redraw = False, target=target)
        self.parent.plotArea.setTickLabelAlignmentVertical(value=tickLabelAlignmentVertical, axis=axis, redraw = False, target=target)
        self.parent.plotArea.setTickFont(value=tickLabelFont, axis=axis, redraw=False, target=target)
        if(target == 'plot'):
          self.parent.plotArea.toggleTicksLabel(value=useShow, axis=axis, redraw=False, target=target)
        else:
          self.parent.plotArea.toggleTicksLabel(value=useShow_resid, axis=axis, redraw=False, target=target)
          
      # check for split y axis and slave setting if needed
      if(splitY):
        self.parent.plotArea.setTickLabelColor(value=tickLabelColor, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelSize(value=tickLabelSize, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelBold(value=tickLabelWeight, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelItalic(value=tickLabelStyle, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAngle(value=tickLabelAngle, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignment(value=tickLabelAlignment, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignmentVertical(value=tickLabelAlignmentVertical, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.setTickFont(value=tickLabelFont, axis=axis + '2', redraw=False, target='plot')
        self.parent.plotArea.toggleTicksLabel(value=useShow, axis=axis + '2', redraw=False, target='plot')
      elif((axis in ['left2', 'right2']) and self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelColor(value=tickLabelColor, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelSize(value=tickLabelSize, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelBold(value=tickLabelWeight, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelItalic(value=tickLabelStyle, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAngle(value=tickLabelAngle, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignment(value=tickLabelAlignment, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignmentVertical(value=tickLabelAlignmentVertical, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickFont(value=tickLabelFont, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.toggleTicksLabel(value=useShow, axis=axis[:-1], redraw=False, target='plot')

      # redraw
      self.parent.plotArea.dataplotwidget.myRefresh()
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.residplotwidget.myRefresh()
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.residplotwidget.myRefresh()
      
  def alterTickMarkLength(self, axis='left'):
    # changes tick mark width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configTickMarkLength[axis].value())
      except:
        value = 0.0
      # update parameters
      if(axis in ['left', 'right']):
        self.configTickMarkLength['left'].setValue(value)
        self.configTickMarkLength['right'].setValue(value)
      elif(axis in ['left2', 'right2']):
        self.configTickMarkLength['left2'].setValue(value)
        self.configTickMarkLength['right2'].setValue(value)
      else:
        self.configTickMarkLength['top'].setValue(value)
        self.configTickMarkLength['bottom'].setValue(value)
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configTickMarkLength['left2'].setValue(value)
        self.parent.graphicsarea2.configTickMarkLength['right2'].setValue(value)
        self.parent.plotArea.setTickMarkLength(value=value, axis=axis + '2', redraw=False, target='plot', forceRedraw=False)
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configTickMarkLength['left'].setValue(value)
        self.parent.graphicsarea.configTickMarkLength['right'].setValue(value)
        self.parent.plotArea.setTickMarkLength(value=value, axis=axis[:-1], redraw=False, target='plot', forceRedraw=False)
      self.parent.plotArea.setTickMarkLength(value=value, axis=axis, redraw=True, target='plot', forceRedraw=False)
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkLength(value=value, axis=axis, redraw=True, target='resid', forceRedraw=False)
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickMarkLength(value=value, axis=axis[:-1], redraw=True, target='resid', forceRedraw=False)

  def alterTickMarkWidth(self, axis='left'):
    # changes tick mark width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configTickMarkWidth[axis].value())
      except:
        value = 0.0
      # update parameters
      if(axis in ['left', 'right']):
        self.configTickMarkWidth['left'].setValue(value)
        self.configTickMarkWidth['right'].setValue(value)
      elif(axis in ['left2', 'right2']):
        self.configTickMarkWidth['left2'].setValue(value)
        self.configTickMarkWidth['right2'].setValue(value)
      else:
        self.configTickMarkWidth['top'].setValue(value)
        self.configTickMarkWidth['bottom'].setValue(value)
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
        self.parent.graphicsarea2.configTickMarkWidth['left2'].setValue(value)
        self.parent.graphicsarea2.configTickMarkWidth['right2'].setValue(value)
        self.parent.plotArea.setTickMarkWidth(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
        self.parent.graphicsarea.configTickMarkWidth['left'].setValue(value)
        self.parent.graphicsarea.configTickMarkWidth['right'].setValue(value)
        self.parent.plotArea.setTickMarkWidth(value=value, axis=axis[:-1], redraw=False, target='plot')
      self.parent.plotArea.setTickMarkWidth(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkWidth(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickMarkWidth(value=value, axis=axis[:-1], redraw=True, target='resid')

  def changeTickMarkColor(self, axis='x'):
    # changes color of tick marks
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # get current color
      prevColor = [255 * i for i in self.parent.plotArea.ticksColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis in ['left', 'right'])):
          self.parent.plotArea.setTickMarkColor(value=value, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis in ['left2', 'right2'])):
          self.parent.plotArea.setTickMarkColor(value=value, axis=axis[:-1], redraw=False, target='plot')
        self.parent.plotArea.setTickMarkColor(value=value, axis=axis, redraw=True, target='plot')
        if(not (axis in ['left2', 'right2'])):
          self.parent.plotArea.setTickMarkColor(value=value, axis=axis, redraw=True, target='resid')
        elif(self.parent.plotArea.splitY):
          self.parent.plotArea.setTickMarkColor(value=value, axis=axis[:-1], redraw=True, target='resid')
        # update color button
        colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksColor[axis][0:3]]
        if(axis in ['left', 'right']):
          self.configTickMarkColor['left'].setMyColor(*colorvalue)
          self.configTickMarkColor['right'].setMyColor(*colorvalue)
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY):
            self.parent.graphicsarea2.configTickMarkColor['left2'].setMyColor(*colorvalue)
            self.parent.graphicsarea2.configTickMarkColor['right2'].setMyColor(*colorvalue)
        elif(axis in ['left2', 'right2']):
          self.configTickMarkColor['left2'].setMyColor(*colorvalue)
          self.configTickMarkColor['right2'].setMyColor(*colorvalue)
          if(self.parent.plotArea.splitY):
            self.parent.graphicsarea.configTickMarkColor['left'].setMyColor(*colorvalue)
            self.parent.graphicsarea.configTickMarkColor['right'].setMyColor(*colorvalue)
        else:
          self.configTickMarkColor['top'].setMyColor(*colorvalue)
          self.configTickMarkColor['bottom'].setMyColor(*colorvalue)

  def automaticAxisTicks(self, axis='x'):
    # automatically sets axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis in ['x', 'x2']):
        if(((axis == 'x') and self.configTickXAuto.isChecked()) or ((axis == 'x2') and self.configInnerTickXAuto.isChecked())):
          nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='resid')
          nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='plot')
          # update entryfield
          tickstr = self.magicTickstring(nuTicks)
          if(axis == 'x'):
            self.configTickXEntry.setText(tickstr)
          else:
            self.configInnerTickXEntry.setText(tickstr)
        else:
          # activate custom ticks
          self.changeAxisTicks(axis=axis)
      elif(axis in ['y', 'y2']):
        if(self.configTickYAuto.isChecked()):
          nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='plot')
          # update entryfield
          tickstr = self.magicTickstring(nuTicks)
          self.configTickYEntry.setText(tickstr)
        else:
          # activate custom ticks
          self.changeAxisTicks(axis=axis)
      else:
        if(self.configTickResidYAuto.isChecked()):
          nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='resid')
          # update entryfield
          tickstr = self.magicTickstring(nuTicks)
          self.configTickResidYEntry.setText(tickstr)
        else:
          # activate custom ticks
          self.changeAxisTicks(axis=axis)

  def dataAxisTicks(self, splitX=False):
    # set x ticks to label values
    currDataSet = self.parent.activeData
    self.parent.plotArea.setDataAxisTicks(currDataSet, redraw=True, target='plot', splitX=splitX)
    self.parent.plotArea.setDataAxisTicks(currDataSet, redraw=True, target='resid', splitX=splitX)

  def useCurrentDim(self):
    # sets export dimensions to current dimensions on screen
    # obtain current dimensions
    currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
    self.exportSizeX.setText('{:4.2f}'.format(currwidth))
    self.exportSizeY.setText('{:4.2f}'.format(currheight))
    self.parent.plotArea.exportWidth = currwidth
    self.parent.plotArea.exportHeight = currheight

  def checkXkcdSetting(self, entryfield=None, item='scale', minval=0, maxval=1):
    # restrains dimensions for figure export
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setXkcdSetting(value=value, item=item, redraw=True)
    
  def checkExportSize(self, entryfield=None, axis='x', minval=0, maxval=1):
    # restrains dimensions for figure export
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    if(axis=='x'):
      self.parent.plotArea.exportWidth = value
    elif(axis=='y'):
      self.parent.plotArea.exportHeight = value
        
  def changeAxisTicks(self, axis='x'):
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        entryfield = self.configTickXEntry
      elif(axis in ['y', 'y2']):
        entryfield = self.configTickYEntry
      elif(axis == 'resid'):
        entryfield = self.configTickResidYEntry
      else:
        entryfield = self.configInnerTickXEntry
      
      tickstr = str(entryfield.text())
      # process new tick string
      nuTicks = tickstr.split(',')
      nuTicks = [i.strip() for i in nuTicks]
      
      # convert to floats
      nuTicks_num = []
      for entry in nuTicks:
        if(self.parent.isNumber(entry)):
          nuTicks_num.append(float(entry))
      nuTicks_num = np.array(sorted(nuTicks_num))

      # update entryfield
      tickstr = self.magicTickstring(nuTicks_num)
      entryfield.setText(tickstr)
      
      # set ticks in plot
      if(axis == 'x'):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')
      elif(axis in ['y', 'y2']):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
      elif(axis == 'resid'):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')
      else:
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')

  def toggleMinorTicks(self, entryfield=None, axis='x'):
    # turns on/off display of minor ticks
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
        value = entryfield.isChecked()
        if(value):
          # retrieve minor ticks value
          if(axis == 'x'):
            value = self.configMinorTickX.currentIndex() + 2
          elif(axis == 'x2'):
            value = self.configInnerMinorTickX.currentIndex() + 2
          elif(axis in ['y', 'y2']):
            value = self.configMinorTickY.currentIndex() + 2
          else:
            value = self.configMinorTickResid.currentIndex() + 2
        else:
          # this will turn off the ticklis
          value = 0
  
        # set the minor ticks
        if(axis in ['x', 'x2']):
          self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
          self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='resid')
        elif(axis == 'y'):
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY):
            toggled = entryfield.isChecked()
            self.parent.graphicsarea2.configMinorTickYLabel.setChecked(toggled)
            self.parent.plotArea.setMinorTick(value=value, axis=axis + '2', redraw=False, target='plot')
          self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
        elif(axis == 'y2'):
          if(self.parent.plotArea.splitY):
            toggled = entryfield.isChecked()
            self.parent.graphicsarea.configMinorTickYLabel.setChecked(toggled)
            self.parent.plotArea.setMinorTick(value=value, axis='y', redraw=False, target='plot')
          self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
        else:
          self.parent.plotArea.setMinorTick(value=value, axis='y', redraw=True, target='resid')

  def changeMinorTickRelativeLength(self, entryfield=None, axis='x', minval=0.1, maxval=10.0):
    # check paramter boundaries
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    if(axis == 'x'):
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='plot')
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='resid')
    elif(axis == 'y'):
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY):
        self.parent.graphicsarea2.configMinorTickYRelativeLength.setText(str(value))
        self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis + '2', redraw=False, target='plot')
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='plot')
    elif(axis == 'y2'):
      if(self.parent.plotArea.splitY):
        self.parent.graphicsarea.configMinorTickYRelativeLength.setText(str(value))
        self.parent.plotArea.setMinorTickRelativeLength(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='plot')
    elif(axis == 'resid'):
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis='y', redraw=True, target='resid')
    else:
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='plot')
      self.parent.plotArea.setMinorTickRelativeLength(value=value, axis=axis, redraw=True, target='resid')

  def changeTickLabelPad(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYPad.setText(str(value))
        self.parent.plotArea.setTickLabelPad(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYPad.setText(str(value))
        self.parent.plotArea.setTickLabelPad(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelPad(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelPad(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelPad(value=value, axis=axis[:-1], redraw=True, target='resid')
      
  def changeTickLabelPad2(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYPad2.setText(str(value))
        self.parent.plotArea.setTickLabelPad2(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYPad2.setText(str(value))
        self.parent.plotArea.setTickLabelPad2(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelPad2(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelPad2(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelPad2(value=value, axis=axis[:-1], redraw=True, target='resid')
      
  def changeTickLabelBold(self, axis='x'):
    # changes formatting of tick label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configTickXBold.isChecked()
      else:
        isChecked = self.configTickYBold.isChecked()
        
      if(isChecked):
        value = 'bold'
      else:
        value = 'normal'
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYBold.setChecked(isChecked)
        self.parent.plotArea.setTickLabelBold(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYBold.setChecked(isChecked)
        self.parent.plotArea.setTickLabelBold(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelBold(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelBold(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelBold(value=value, axis=axis[:-1], redraw=True, target='resid')

  def changeTickLabelItalic(self, axis='x'):
    # changes formatting of tick label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configTickXItalic.isChecked()
      else:
        isChecked = self.configTickYItalic.isChecked()
        
      if(isChecked):
        value = 'italic'
      else:
        value = 'normal'
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYItalic.setChecked(isChecked)
        self.parent.plotArea.setTickLabelItalic(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYItalic.setChecked(isChecked)
        self.parent.plotArea.setTickLabelItalic(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelItalic(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelItalic(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelItalic(value=value, axis=axis[:-1], redraw=True, target='resid')

  def setTickLabelAlignment(self, axis='x'):
    # sets alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configTickXAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      else:
        useAlignment = str(self.configTickYAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      
      if(flag):
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y')):
          index = self.configTickYAlignment.currentIndex()
          self.parent.graphicsarea2.configTickYAlignment.setCurrentIndex(index)
          self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis == 'y2')):
          index = self.configTickYAlignment.currentIndex()
          self.parent.graphicsarea.configTickYAlignment.setCurrentIndex(index)
          self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis='y', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='resid')
        elif(self.parent.plotArea.splitY):
          self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis[:-1], redraw=True, target='resid')

  def setTickLabelAlignmentVertical(self, axis='x'):
    # sets vertical alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configTickXAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      else:
        useAlignment = str(self.configTickYAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      
      if(flag):
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y')):
          index = self.configTickYAlignmentVertical.currentIndex()
          self.parent.graphicsarea2.configTickYAlignmentVertical.setCurrentIndex(index)
          self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis == 'y2')):
          index = self.configTickYAlignmentVertical.currentIndex()
          self.parent.graphicsarea.configTickYAlignmentVertical.setCurrentIndex(index)
          self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis='y', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='resid')
        elif(self.parent.plotArea.splitY):
          self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis[:-1], redraw=True, target='resid')

  def alterTickLabelAngle(self, entryfield=None, axis='x'):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYAngle.setValue(value)
        self.parent.plotArea.setTickLabelAngle(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYAngle.setValue(value)
        self.parent.plotArea.setTickLabelAngle(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelAngle(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelAngle(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelAngle(value=value, axis=axis[:-1], redraw=True, target='resid')

  def alterTickLabelSize(self, entryfield=None, axis='x'):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
        
      # check for split y axis and slave setting if needed
      if(self.parent.plotArea.splitY and (axis == 'y')):
        self.parent.graphicsarea2.configTickYSize.setValue(value)
        self.parent.plotArea.setTickLabelSize(value=value, axis=axis + '2', redraw=False, target='plot')
      if(self.parent.plotArea.splitY and (axis == 'y2')):
        self.parent.graphicsarea.configTickYSize.setValue(value)
        self.parent.plotArea.setTickLabelSize(value=value, axis='y', redraw=False, target='plot')
      self.parent.plotArea.setTickLabelSize(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelSize(value=value, axis=axis, redraw=True, target='resid')
      elif(self.parent.plotArea.splitY):
        self.parent.plotArea.setTickLabelSize(value=value, axis=axis[:-1], redraw=True, target='resid')

  def setTickFormat(self, entryfield=None, axis='x'):
    # sets format of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        flag = False
        useOption = str(entryfield.currentText())
        if(useOption in self.formatOptions):
          flag = True
          self.updateTickFormatFields(axis=axis, tickFormat=useOption, slaved=False)
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
            self.updateTickFormatFields(axis=axis + '2', tickFormat=useOption, slaved=True)
          if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
            self.updateTickFormatFields(axis='y', tickFormat=useOption, slaved=True)
        
        if(flag):
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
            index = self.configTickYFormat.currentIndex()
            self.parent.graphicsarea2.configTickYFormat.setCurrentIndex(index)
            self.parent.plotArea.setTickFormat(axis=axis + '2', value=useOption, redraw=False)
          if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
            index = self.configTickYFormat.currentIndex()
            self.parent.graphicsarea.configTickYFormat.setCurrentIndex(index)
            self.parent.plotArea.setTickFormat(axis='y', value=useOption, redraw=False)
          self.parent.plotArea.setTickFormat(axis=axis, value=useOption, redraw=True)
          if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
            self.parent.plotArea.setTickFormat(axis='resid', value=useOption, redraw=True)
          if(axis == 'x'):
            self.parent.plotArea.setTickFormat(axis='residx', value=useOption, redraw=True)
          if(axis == 'x2'):
            self.parent.plotArea.setTickFormat(axis='residx2', value=useOption, redraw=True)

  def updateTickFormatFields(self, axis='x', tickFormat='default', slaved=False):
    # changes activity of entry fields for tick label formatting
    if(axis == 'x'):
      items = ('configTickXFormatPrecision', 'configTickXFormatTrailZero', 'configTickXFormatSeparator', 'configTickXFormatComma', 'configTickXPrefix', 'configTickXPostfix')
    elif(axis == 'x2'):
      items = ('configInnerTickXFormatPrecision', 'configInnerTickXFormatTrailZero', 'configInnerTickXFormatSeparator', 'configInnerTickXFormatComma', 'configInnerTickXPrefix', 'configInnerTickXPostfix')
    elif(axis in ['y', 'y2']):
      items = ('configTickYFormatPrecision', 'configTickYFormatTrailZero', 'configTickYFormatSeparator', 'configTickYFormatComma', 'configTickYPrefix', 'configTickYPostfix')
    else:
      items = ()
    
    # do this for split y axis
    if(slaved):
      target = self.parent.graphicsarea2
      if(target == self):
        target = self.parent.graphicsarea
    else:
      target = self
      
    for itemName in items:
      if(hasattr(target, itemName)):
        item = target.__dict__[itemName]
        if(hasattr(item, 'setEnabled')):
          item.setEnabled(tickFormat != 'default')

  def setFormatTrailZero(self, entryfield=None, axis='x'):
    # sets trailing zeros of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.isChecked()
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea2.configTickYFormatTrailZero.setChecked(value)
          self.parent.plotArea.setFormatTrailZero(axis=axis + '2', value=value, redraw=False)
        if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea.configTickYFormatTrailZero.setChecked(value)
          self.parent.plotArea.setFormatTrailZero(axis='y', value=value, redraw=False)
        self.parent.plotArea.setFormatTrailZero(axis=axis, value=value, redraw=True)
        if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
          self.parent.plotArea.setFormatTrailZero(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setFormatTrailZero(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatTrailZero(axis='residx2', value=value, redraw=True)

  def setFormatComma(self, entryfield=None, axis='x'):
    # sets comma as decimal sign in tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.isChecked()
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea2.configTickYFormatComma.setChecked(value)
          self.parent.plotArea.setFormatComma(axis=axis + '2', value=value, redraw=False)
        if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea.configTickYFormatComma.setChecked(value)
          self.parent.plotArea.setFormatComma(axis='y', value=value, redraw=False)
        self.parent.plotArea.setFormatComma(axis=axis, value=value, redraw=True)
        if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
          self.parent.plotArea.setFormatComma(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setFormatComma(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatComma(axis='residx2', value=value, redraw=True)

  def setFormatSeparator(self, entryfield=None, axis='x'):
    # sets separating 1000s of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.isChecked()
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea2.configTickYFormatSeparator.setChecked(value)
          self.parent.plotArea.setFormatSeparator(axis=axis + '2', value=value, redraw=False)
        if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea.configTickYFormatSeparator.setChecked(value)
          self.parent.plotArea.setFormatSeparator(axis='y', value=value, redraw=False)
        self.parent.plotArea.setFormatSeparator(axis=axis, value=value, redraw=True)
        if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
          self.parent.plotArea.setFormatSeparator(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setFormatSeparator(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatSeparator(axis='residx2', value=value, redraw=True)

  def setFormatFix(self, entryfield=None, axis='x', prefix=True):
    # sets pre/postfix of axis labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.text()
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          if(prefix):
            self.parent.graphicsarea2.configTickYPrefix.setText(value)
          else:
            self.parent.graphicsarea2.configTickYPostfix.setText(value)
          self.parent.plotArea.setFormatFix(axis=axis + '2', value=value, redraw=False, prefix=prefix)
        if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          if(prefix):
            self.parent.graphicsarea.configTickYPrefix.setText(value)
          else:
            self.parent.graphicsarea.configTickYPostfix.setText(value)
          self.parent.plotArea.setFormatFix(axis='y', value=value, redraw=False, prefix=prefix)
        self.parent.plotArea.setFormatFix(axis=axis, value=value, redraw=True, prefix=prefix)
        if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
          self.parent.plotArea.setFormatFix(axis='resid', value=value, redraw=True, prefix=prefix)
        if(axis == 'x'):
          self.parent.plotArea.setFormatFix(axis='residx', value=value, redraw=True, prefix=prefix)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatFix(axis='residx2', value=value, redraw=True, prefix=prefix)

  def changeTickFormatPrecision(self, entryfield=None, axis='x', minval=0, maxval=20):
    # sets precision in format of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        # check paramter boundaries
        try:
          value = int(entryfield.text())
          originalvalue = value
        except:
          value = 0
          originalvalue = 1
        value = np.min((value, maxval))
        value = np.max((value, minval))
        # update parameters
        if (value != originalvalue):
          entryfield.setText(str(value))

        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea2.configTickYFormatPrecision.setText(str(value))
          self.parent.plotArea.setTickFormatPrecision(axis=axis + '2', value=value, redraw=False)
        if(self.parent.plotArea.splitY and (axis == 'y2') and (self.parent.plotArea.modeY == self.parent.plotArea.modeY2)):
          self.parent.graphicsarea.configTickYFormatPrecision.setText(str(value))
          self.parent.plotArea.setTickFormatPrecision(axis='y', value=value, redraw=False)
        self.parent.plotArea.setTickFormatPrecision(axis=axis, value=value, redraw=True)
        if((axis == 'y') or ((axis == 'y2') and self.parent.plotArea.splitY)):
          self.parent.plotArea.setTickFormatPrecision(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setTickFormatPrecision(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setTickFormatPrecision(axis='residx2', value=value, redraw=True)

  def alterAxisLabelAngle(self, entryfield=None, axis='x'):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
        
      self.parent.plotArea.setAxisLabelAngle(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelAngle(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelPad(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelPad(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelPad(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelPos(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelPos(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelPos(value=value, axis=axis, redraw=True, target='resid')

  def alterAxisLabelSize(self, entryfield=None, axis='x'):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.value())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      # update parameters
      if (value != originalvalue):
        entryfield.setValue(value)
        
      self.parent.plotArea.setAxisLabelSize(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelSize(value=value, axis=axis, redraw=True, target='resid')

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a horizontal line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def changeFigureColor(self):
    # changes color of canvas
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.figureColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setFigureColor(value=value, redraw=True, target='plot', silent=False)
      self.parent.plotArea.setFigureColor(value=value, redraw=True, target='resid', silent=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.figureColor[0:3]]
      self.configFigureColorButton.setMyColor(*colorvalue)

  def toggleFigureFill(self):
    # toggles whether figure filled or not
    state = self.configFigureLabel.isChecked()
    self.parent.plotArea.toggleFigureFill(value=state, redraw=True, target='plot', silent=False)
    self.parent.plotArea.toggleFigureFill(value=state, redraw=True, target='resid', silent=True)
    
  def toggleFrameDraw(self):
    # toggles whether figure frame is drawn or not
    state = self.configFrameLabel.isChecked()
    self.parent.plotArea.toggleFrameDraw(value=state, redraw=True, target='plot')
    self.parent.plotArea.toggleFrameDraw(value=state, redraw=True, target='resid')

  def toggleCanvasFill(self):
    # toggles whether canvas filled or not
    state = self.configCanvasLabel.isChecked()
    self.parent.plotArea.toggleCanvasFill(value=state, redraw=True, target='plot')
    self.parent.plotArea.toggleCanvasFill(value=state, redraw=True, target='resid')
    
  def changeCanvasColor(self):
    # changes color of canvas
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.canvasColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setCanvasColor(value=value, redraw=True, target='plot')
      self.parent.plotArea.setCanvasColor(value=value, redraw=True, target='resid')
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasColor[0:3]]
      self.configCanvasColorButton.setMyColor(*colorvalue)
    
  def changeTickLabelColor(self, axis='x'):
    # changes color of axis ticks
    if(axis in ['x', 'y', 'y2']):
      # get current color
      if(axis == 'x'):
        prevColor = [255 * i for i in self.parent.plotArea.ticksXColor]
      else:
        prevColor = [255 * i for i in self.parent.plotArea.ticksYColor]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        # check for split y axis and slave setting if needed
        if(self.parent.plotArea.splitY and (axis == 'y')):
          self.parent.plotArea.setTickLabelColor(value=value, axis=axis + '2', redraw=False, target='plot')
        if(self.parent.plotArea.splitY and (axis == 'y2')):
          self.parent.plotArea.setTickLabelColor(value=value, axis='y', redraw=False, target='plot')
        self.parent.plotArea.setTickLabelColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        if (axis == 'x'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksXColor[0:3]]
          self.configTickXColorButton.setMyColor(*colorvalue)
        elif(axis == 'y'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksYColor[0:3]]
          self.configTickYColorButton.setMyColor(*colorvalue)
          # check for split y axis and slave setting if needed
          if(self.parent.plotArea.splitY):
            self.parent.graphicsarea2.configTickYColorButton.setMyColor(*colorvalue)
        elif(axis == 'y2'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksY2Color[0:3]]
          self.configTickYColorButton.setMyColor(*colorvalue)
          if(self.parent.plotArea.splitY):
            self.parent.graphicsarea.configTickYColorButton.setMyColor(*colorvalue)

  def changeAxisLabelColor(self, axis='x'):
    # changes color of axis label
    if(axis in ['x', 'y', 'y2']):
      # get current color
      if(axis == 'x'):
        prevColor = [255 * i for i in self.parent.plotArea.labelXColor]
      elif(axis == 'y'):
        prevColor = [255 * i for i in self.parent.plotArea.labelYColor]
      else:
        prevColor = [255 * i for i in self.parent.plotArea.labelY2Color]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        self.parent.plotArea.setAxisLabelColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        if (axis == 'x'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelXColor[0:3]]
          self.configXColorButton.setMyColor(*colorvalue)
        elif(axis == 'y'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelYColor[0:3]]
          self.configYColorButton.setMyColor(*colorvalue)
        elif(axis == 'y2'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelY2Color[0:3]]
          self.configYColorButton.setMyColor(*colorvalue)

  def changeAxisLabel(self, axis='x'):
    # updates axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        labeltext = str(self.configXName.text())
        # encode/recode to process newlines correctly
        #labeltext = labeltext.encode('utf-8').decode('unicode-escape')
        labeltext2 = labeltext
      else:
        labeltext = str(self.configYName.text())
        #labeltext = labeltext.encode('utf-8').decode('unicode-escape')
        labeltext2 = labeltext
 
      self.parent.plotArea.setAxisLabel(labeltext=labeltext, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabel(labeltext=labeltext2, axis=axis, redraw=True, target='resid')

  def toggleGraphicsOption(self):
    # toggles display of advanced graphics
    value = self.configAdvancedSettingsButton.isChecked()
    self.advancedExport['advancedGraphics'] = value
    
    self.parent.graphicsarea.setAdvancedGraphics(value=value)
    if(hasattr(self.parent, 'graphicsarea2')):
      self.parent.graphicsarea2.setAdvancedGraphics(value=value)

    # scroll to bottom
    QtCore.QCoreApplication.processEvents()
    scrollbar = self.parent.graphicsarea.containerScroll.verticalScrollBar()
    scrollbar.setValue(scrollbar.maximum())
    QtCore.QCoreApplication.processEvents()

  def previewThis(self):
    # generates and displays a figure preview
    filename = WORKINGDIR + PATH_SEPARATOR + TEMP_PREVIEWFILE
    if('linux' in platform):
      filename = HOMEDIR + PATH_SEPARATOR + TEMP_PREVIEWFILE
    
    # save main graphics
    # obtain target dimensions
    targetwidth = float(self.exportSizeX.text())
    targetheight = float(self.exportSizeY.text())
    # obtain current dimensions
    currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
    
    # set new dimensions and save
    self.parent.plotArea.matplot.set_size_inches(targetwidth, targetheight)
    success = False
    if(self.parent.plotArea.figureFill):
      useFaceColor = self.parent.plotArea.figureColor
    else:
      useFaceColor = 'none'
    if(self.parent.plotArea.frameDraw):
      useFrameColor = self.parent.plotArea.frameColor
    else:
      useFrameColor = 'none'
    try:
      self.parent.plotArea.matplot.savefig(filename, format='png', dpi=150, facecolor=useFaceColor, edgecolor=useFrameColor)
      success = True
    except:
      # some kind of error occurred
      self.parent.statusbar.showMessage('Cannot generate temporary file ' + filename, self.parent.STATUS_TIME)
      
    # revert to old dimensions
    self.parent.plotArea.matplot.set_size_inches(currwidth, currheight)
      
    # issue plot redraws b/c for some reason display vanishes
    self.parent.plotArea.dataplotwidget.myRefresh()
    
    # now open a new window to display the preview image
    if(success):
      if(not (hasattr(self.parent, 'previewWindow'))):
        self.parent.previewWindow = PreviewWindow()
        self.parent.previewWindow.setWindowTitle('Preview')
    
        self.centralwidget = QWidgetMac(self.parent.previewWindow)
        self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(320), scaledDPI(240)))
        self.parent.previewWindow.setCentralWidget(self.centralwidget)
        
        self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.vLayout.setContentsMargins(*[scaledDPI(2)]*4)
        
        # export button
        self.clipboardButton = QPushButtonMac()
        self.clipboardButton.setText('Copy to Clipboard')
        self.clipboardButton.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.clipboardButton.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.clipboardButton.clicked.connect(self.copyImageClipboard)
        self.vLayout.addWidget(self.clipboardButton)
  
        # generate QLabel for display
        self.displayPreview = QtWidgets.QLabel()
        self.vLayout.addWidget(self.displayPreview)
        self.parent.previewWindow.setDisplayPreview(self.displayPreview)
        
      # update picture
      self.displayPicture = QtGui.QPixmap(filename)
      currSize = self.displayPicture.size()
      # scale to compensate DPI ratio 150/100
      self.scaledPicture = self.displayPicture.scaled(currSize.width() / 1.5, currSize.height() / 1.5, QtCore.Qt.KeepAspectRatio)
      self.displayPreview.resize(self.scaledPicture.width(), self.scaledPicture.height())
      self.displayPreview.setPixmap(self.scaledPicture)
      # explicitly update windows size
      self.parent.previewWindow.setFixedSize(self.vLayout.sizeHint())
      
      # apply styles and show
      if(QSTYLE != None):
        self.parent.previewWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.parent.previewWindow.setStyleSheet(QSTYLESHEET)
      self.parent.previewWindow.show()
      self.parent.previewWindow.activateWindow()
      self.parent.previewWindow.focusNextChild()

  def copyImageClipboard(self):
    # copies preview image to clipboard
    data = QtCore.QMimeData()
    # first check whether we still find the temp image file generated for the preview
    filename = WORKINGDIR + PATH_SEPARATOR + TEMP_PREVIEWFILE
    if(isfile(filename)):
      url = QtCore.QUrl.fromLocalFile(filename)
      data.setUrls([url])

    # for good measure also add a regular bitmap image and let downstream applications chose which to use
    if(hasattr(self, 'displayPicture')):
      image = self.displayPicture.toImage()
      data.setImageData(image)
      
    # check whether we managed to retrieve any image
    if(len(data.formats())):
      QtWidgets.QApplication.clipboard().setMimeData(data)
      
  def setAdvancedExport(self, key=None, value=None):
    # updates advanced export settings
    if(key in self.advancedExport):
      self.advancedExport[key] = value

  def setAdvancedGraphics(self, value=True):
    # toggles advanced graphics options
    self.advancedExport['advancedGraphics'] = value
    for entry in self.advancedGraphicsSettings:
      if(value):
        if(hasattr(entry, 'show')):
          entry.show()
      elif(hasattr(entry, 'hide')):
        entry.hide()
    # special treatment for splitAxes control
    value =  value and self.parent.plotArea.splitShow
    for item in ['configInnerBox2', 'configInnerBox3', 'configInnerBox5', 'configInnerBox6', 'configInnerMinorTickBox']:
      if(hasattr(self, item)):
        entry = self.__dict__[item]
        if(value):
          if(hasattr(entry, 'show')):
            entry.show()
        elif(hasattr(entry, 'hide')):
          entry.hide()

  def reportThis(self):
    # generates an HTML report
    self.parent.resultsarea.exportWrapper(modeHTMLOnly=True)

  def exportThis(self):
    global REMEMBERDIR
    # exports current figure and residuals
    filter_options = ['PDF files (*.pdf)', 'Scalable vector graphic (*.svg)', 'Postscript (*.ps)', 'Encapsulated postscript (*.eps)', 'PNG image (*.png)', 'Python script (*.py)', 'All files (*.*)']
    format_options = ['pdf', 'svg', 'ps', 'eps', 'png', 'py', 'pdf']
    filterstring = ';;'.join(filter_options)
    # get save file name
    usedir = REMEMBERDIR
    if(self.currExportFile != None):
      usedir = self.currExportFile
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self, filter = filterstring, directory=usedir, caption='Export Graphics', initialFilter=self.exportFilter)
    self.exportFilter = filter_
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    
    # evaluate file format
    if(filter_ in filter_options):
      index = filter_options.index(filter_)
      format_ = format_options[index]
    else:
      # use PDF as default
      format_ = 'pdf'
    
    if(filename != ''):
      # check whether save as Python script selected
      if(format_ != 'py'):
        # enable text export to SVG
        if (format_ == 'svg'):
          if(self.advancedExport['SVGtxt2path']):
            matplotlib.rcParams.update({'svg.fonttype': 'path'})
          else:
            matplotlib.rcParams.update({'svg.fonttype': 'none'})
        # save main graphics
        # obtain target dimensions
        targetwidth = float(self.exportSizeX.text())
        targetheight = float(self.exportSizeY.text())
        # obtain current dimensions
        currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
        
        if(self.parent.plotArea.figureFill):
          useFaceColor = self.parent.plotArea.figureColor
        else:
          useFaceColor = 'none'
        if(self.parent.plotArea.frameDraw):
          useFrameColor = self.parent.plotArea.frameColor
        else:
          useFrameColor = 'none'
        # set new dimensions and save
        self.parent.plotArea.matplot.set_size_inches(targetwidth, targetheight)
        try:
          self.parent.plotArea.matplot.savefig(filename, format=format_, dpi=self.advancedExport['plotDPI'], facecolor=useFaceColor, edgecolor=useFrameColor)
          # save filename for future reference
          self.currExportFile = filename
        except:
          # some kind of error occurred
          self.parent.statusbar.showMessage('Cannot save graphics file ' + filename, self.parent.STATUS_TIME)
        
        # revert to old dimensions
        self.parent.plotArea.matplot.set_size_inches(currwidth, currheight)
        
        # save resid graphics?
        if(self.advancedExport['plotResid']):
          if('.' in filename):
            filename_split = filename.split('.')
            filename = '.'.join(filename_split[:-1])
            filename += '_resid.' + filename_split[-1]
          else:
            filename += '_resid'
          # obtain target dimensions
          try:
            relativeSizes = self.parent.plotArea.masterwidget.sizes()
            sizeRatio = 1. * relativeSizes[0] / relativeSizes[1]
          except:
            sizeRatio = 4.0
          targetwidth = float(self.exportSizeX.text())
          targetheight = float(self.exportSizeY.text()) / sizeRatio
          # obtain current dimensions
          currwidth, currheight = self.parent.plotArea.residplot.get_size_inches()
          
          # set new dimensions and save
          self.parent.plotArea.residplot.set_size_inches(targetwidth, targetheight)
          try:
            self.parent.plotArea.residplot.savefig(filename, format=format_, dpi=self.advancedExport['plotDPI'], facecolor=useFaceColor, edgecolor=useFrameColor)
          except:
            # some kind of error occurred
            self.parent.statusbar.showMessage('Cannot save graphics file ' + filename, self.parent.STATUS_TIME)
          
          # revert to old dimensions
          self.parent.plotArea.residplot.set_size_inches(currwidth, currheight)
          
        # issue plot redraws b/c for some reason display vanishes
        self.parent.plotArea.dataplotwidget.myRefresh()
        self.parent.plotArea.residplotwidget.myRefresh()
      else:
        # save graphics as Python script
        pythonOutput = '##############################################\n# plot script generated by Fit-o-mat         #\n'
        pythonOutput += '# version ' + VERSION + '                              #\n'
        pythonOutput += '''# by A.M. (andreas.moeglich@uni-bayreuth.de) #
##############################################

# initialization
import matplotlib      
import matplotlib.pyplot as plt
from matplotlib import patheffects as PathEffects
import numpy as np
from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh

# create figures for data/curves and residuals
plt.ioff()
matplot = plt.figure()
residplot = plt.figure()

'''
        # apply xkcd and pathEffects up front
        settings = self.parent.plotArea.rememberSetting
        for entry in ['xkcd', 'pathEffects']:
         if entry in settings:
           pythonOutput += settings[entry]
           
        # check whether we should display second axis
        if(self.parent.plotArea.isSecondAxesActive()):
          pythonOutput += '''
# define 2nd axes system      
ax2 = matplot.add_subplot(111)
ax2.xaxis.set_label_text('x')
ax2.yaxis.set_label_text('y')
ax2.yaxis.set_label_position('right')
ax2.yaxis.set_ticks_position('right')
gridlines = ax2.get_xgridlines()
gridlines.extend(ax2.get_ygridlines())
for entry in gridlines:
  entry.set_visible(False)
ax2.patch.set_facecolor('none')
'''
          pythonOutput += 'ax2.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
          pythonOutput += 'ax2.set_yscale(' + repr(self.parent.plotArea.modeY2) + ')\n'
          pythonOutput += '''# define 1st axes system
ax = ax2.twinx()
ax.xaxis.set_visible(False)
ax.yaxis.set_label_position('left')
ax.yaxis.set_ticks_position('left')
# for good measure, reset label position for ax2
ax2.yaxis.set_ticks_position('right')'''
        else:
          pythonOutput += '''\n
# define axes system      
ax = matplot.add_subplot(111)'''
  
        pythonOutput += '''
ax_resid = residplot.add_subplot(111)

curves = []
dataset = []
extras = []

# set axes scale
'''
        # set linear/log on axes
        pythonOutput += 'ax.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
        pythonOutput += 'ax.set_yscale(' + repr(self.parent.plotArea.modeY) + ')\n'
        pythonOutput += 'ax_resid.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
        pythonOutput += 'ax_resid.set_yscale(\'linear\')'
  
        # cycle over all extras
        for index in range(len(self.parent.extras)):
          # generate curve
          pythonOutput += '\n\n###############\n'
          pythonOutput += '# extra no. ' + str(index) + ' #\n'
          pythonOutput += '###############\n'
          
          # obtain settings
          settings = self.parent.extras[index].rememberSetting
          
          # plot and format extra
          if(('origin_before' in settings) and (settings['origin_before'] != '')):
            pythonOutput += settings['origin_before'] + '\n'
            
          if('origin' in settings):
            pythonOutput += 'extras.append({})\n'
            if(settings['origin'].startswith('plot')):
              pythonOutput += 'extras[-1][\'handle\'], = ax.' + settings['origin'] + '\n'
            else:
              pythonOutput += 'extras[-1][\'handle\'] = ax.' + settings['origin'] + '\n'
              
            # apply styles to extra
            for entry in settings:
              if(not (entry in ['origin', 'origin_before'])):
                pythonOutput += 'extras[-1][\'handle\'].' + settings[entry] + '\n'
  
        # cycle over all curves
        for index in range(len(self.parent.fit)):
          # generate curve
          pythonOutput += '\n\n###############\n'
          pythonOutput += '# curve no. ' + str(index) + ' #\n'
          pythonOutput += '###############\n'
          data = self.parent.fit[index].reportState()
          if(self.parent.fit[index].onSecondAxes):
            currAxis = 'ax2'
          else:
            currAxis = 'ax'
  
          # write function
          param = data['paramAll']
          pythonOutput += '# define function\n'
          pythonOutput += 'def ffunc_' + str(index) + '(x, ' + ', '.join(data['paramNames']) + '):\n'
          pythonOutput += '\t' + '\n\t'.join(data['ffuncstr_base'].split('\n'))
          pythonOutput += '\n\treturn y\n\n'
  
          # write curve data
          pythonOutput += '# curve data\n'
          pythonOutput += 'curves.append({})\n'
          pythonOutput += 'curves[-1][\'x\'] = np.array(' + self.wrapString(repr(data['x'])) + ')\n\n'
          
          # plot and format function
          pythonOutput += '# plot and format curve\n'
          param = data['paramAll']
          pythonOutput += 'param_' + str(index) + ' = ' + repr(param) + '\n'
          
          # plot curve
          pythonOutput += 'curves[-1][\'handle\'], = ' + currAxis + '.plot(curves[-1][\'x\'], ffunc_' + str(index)
          if(len(param)):
            pythonOutput += '(curves[-1][\'x\'], *param_' + str(index) + '))\n'
          else:
            pythonOutput += '(curves[-1][\'x\']))\n'
            
          # apply styles to curve
          settings = self.parent.fit[index].rememberSetting
          for entry in settings:
            pythonOutput += 'curves[-1][\'handle\'].' + settings[entry] + '\n'
            
        # cycle over all data sets
        for index in range(len(self.parent.data)):
          # generate data set
          pythonOutput += '\n\n##############\n'
          pythonOutput += '# data no. ' + str(index) + ' #\n'
          pythonOutput += '##############\n'
          data = self.parent.data[index].reportState()
          if(self.parent.data[index].onSecondAxes):
            currAxis = 'ax2'
          else:
            currAxis = 'ax'
  
          # write plot data
          pythonOutput += 'dataset.append({})\n'
          for entry in ['x', 'y', 'yerr', 'resid']:
            if(entry in data):
              pythonOutput += 'dataset[-1][' + repr(entry) + '] = np.array(' + self.wrapString(repr(data[entry])) + ')\n\n'
          
          # plot and format function
          if(('x' in data) and ('y' in data)):
            pythonOutput += '# plot and format line/scatter graphics\n'
            pythonOutput += 'dataset[-1][\'handle\'], = ' + currAxis + '.plot(dataset[-1][\'x\'], dataset[-1][\'y\'])\n'
            # apply styles to data set
            settings = self.parent.data[index].rememberSetting
            for entry in settings:
              pythonOutput += 'dataset[-1][\'handle\'].' + settings[entry] + '\n'
            
            # check for presence of stack plot
            if(self.parent.data[index].handleStack != None):
              pythonOutput += '\n# plot and format stackplot graphics\n'
              pythonOutput += 'dataset[-1][\'handleStack\'], = ' + currAxis + '.stackplot(dataset[-1][\'x\'], dataset[-1][\'y\'], where=(dataset[-1][\'y\'] >= 0), interpolate=True)\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingStack
              for entry in settings:
                pythonOutput += 'dataset[-1][\'handleStack\'].' + settings[entry] + '\n'
            
            # check for presence of negative stack plot
            if(self.parent.data[index].handleStackNeg != None):
              pythonOutput += '\n# plot and format stackplot graphics\n'
              pythonOutput += 'dataset[-1][\'handleStackNeg\'], = ' + currAxis + '.stackplot(dataset[-1][\'x\'], dataset[-1][\'y\'], where=(dataset[-1][\'y\'] < 0), interpolate=True)\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingStackNeg
              for entry in settings:
                if(entry != 'facecolor'):
                  pythonOutput += 'dataset[-1][\'handleStackNeg\'].' + settings[entry] + '\n'
            
            # check for presence of bar plot
            if(self.parent.data[index].handleBar != None):
              pythonOutput += '\n# plot and format bar graphics\n'
              offset = self.parent.data[index].Barstyle['offset']
              pythonOutput += 'offset = ' + repr(offset) + '\n'
              useWidth = self.parent.data[index].Barstyle['width']
              pythonOutput += 'dataset[-1][\'handleBar\'] = ' + currAxis + '.bar(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'], width=' + repr(useWidth) +')\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingBar
              if(len(settings.keys())):
                pythonOutput += 'for entry in dataset[-1][\'handleBar\']:\n'
                for entry in settings:
                  if(not (entry.startswith('facecolor'))):
                    pythonOutput += '\tentry.' + settings[entry] + '\n'
              for item in ['facecolor', 'facecolorAlt']:
                if(item in settings):
                  pythonOutput += 'for entry in dataset[-1][\'handleBar\'].patches:\n'
                  if(item == 'facecolor'):
                    pythonOutput += '\tif(entry.get_height() >= 0):\n'
                    pythonOutput += '\t\tentry.' + settings['facecolor'] + '\n'
                  else:
                    pythonOutput += '\tif(entry.get_height() < 0):\n'
                    pythonOutput += '\t\tentry.' + settings['facecolorAlt'] + '\n'
            else:
              pythonOutput += 'offset = 0.0\n'
            
            # check for presence of error
            if(('yerr' in data) and (self.parent.data[index].handleErr != None)):
              pythonOutput += '\n# plot and format error bars\n'
              pythonOutput += 'dataset[-1][\'handleErr\'] = ' + currAxis + '.errorbar(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'], yerr=dataset[-1][\'yerr\'], capsize=1)\n'
              # apply styles to error bars
              pythonOutput += 'dataset[-1][\'handleErr\'][0].set_linewidth(0)\n'
              pythonOutput += 'dataset[-1][\'handleErr\'][0].set_markersize(0)\n'
              settings = self.parent.data[index].rememberSettingError
              if(len(self.parent.data[index].handleErr[1])):
                pythonOutput += 'for entry in dataset[-1][\'handleErr\'][1]:\n'
                for entry in settings:
                  if(hasattr(self.parent.data[index].handleErr[1][0], 'set_' + entry)):
                    # prevent turning on off connecting lines
                    if(entry == 'linewidth'):
                      pythonOutput += '\tentry.set_linewidth(0)\n'
                    else:
                      pythonOutput += '\tentry.' + settings[entry] + '\n'
              if(len(self.parent.data[index].handleErr[2])):
                pythonOutput += 'for entry in dataset[-1][\'handleErr\'][2]:\n'
                for entry in settings:
                  if(hasattr(self.parent.data[index].handleErr[2][0], 'set_' + entry)):
                    pythonOutput += '\tentry.' + settings[entry] + '\n'
  
            # check for presence of error shading
            if(('yerr' in data) and (self.parent.data[index].handleErrShady != None)):
              pythonOutput += '\n# plot and format error shading\n'
              pythonOutput += 'dataset[-1][\'handleErrShady\'] = ' + currAxis + '.fill_between(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'] - dataset[-1][\'yerr\'], dataset[-1][\'y\'] + dataset[-1][\'yerr\'])\n'
              # apply styles to error bars
              settings = self.parent.data[index].rememberSettingErrorShady
              for entry in settings:
                if(hasattr(self.parent.data[index].handleErrShady, 'set_' + entry)):
                  pythonOutput += 'dataset[-1][\'handleErrShady\'].' + settings[entry] + '\n'
  
            # check for presence of residuals
            if(('resid' in data) and (len(data['resid']) == len(data['x']))):
              pythonOutput += '\n# plot and format line/scatter graphics of residuals\n'
              pythonOutput += 'dataset[-1][\'handleResid\'], = ax_resid.plot(dataset[-1][\'x\'], dataset[-1][\'resid\'])\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingResid
              for entry in settings:
                pythonOutput += 'dataset[-1][\'handleResid\'].' + settings[entry] + '\n'
  
              # check for presence of resid stack plot
              if(self.parent.data[index].handleResidStack != None):
                pythonOutput += '\n# plot and format stackplot graphics of residuals\n'
                pythonOutput += 'dataset[-1][\'handleResidStack\'], = ax_resid.stackplot(dataset[-1][\'x\'], dataset[-1][\'resid\'], where=(dataset[-1][\'resid\'] >= 0), interpolate=True)\n'
                # apply styles to bar graphics
                settings = self.parent.data[index].rememberSettingResidStack
                for entry in settings:
                  pythonOutput += 'dataset[-1][\'handleResidStack\'].' + settings[entry] + '\n'
              
              # check for presence of negative resid stack plot
              if(self.parent.data[index].handleResidStackNeg != None):
                pythonOutput += '\n# plot and format stackplot graphics of residuals\n'
                pythonOutput += 'dataset[-1][\'handleResidStackNeg\'], = ax_resid.stackplot(dataset[-1][\'x\'], dataset[-1][\'resid\'], where=(dataset[-1][\'resid\'] < 0), interpolate=True)\n'
                # apply styles to bar graphics
                settings = self.parent.data[index].rememberSettingResidStackNeg
                for entry in settings:
                  if(entry != 'facecolor'):
                    pythonOutput += 'dataset[-1][\'handleResidStackNeg\'].' + settings[entry] + '\n'
            
              # check for presence of resid bar plot
              if(self.parent.data[index].handleResidBar != None):
                pythonOutput += '\n# plot and format bar graphics of residuals\n'
                offset = self.parent.data[index].ResidBarstyle['offset']
                pythonOutput += 'offset = ' + repr(offset) + '\n'
                useWidth = self.parent.data[index].ResidBarstyle['width']
                pythonOutput += 'dataset[-1][\'handleResidBar\'] = ax_resid.bar(dataset[-1][\'x\'] + offset, dataset[-1][\'resid\'], width=' + repr(useWidth) +')\n'
                # apply styles to bar graphics
                settings = self.parent.data[index].rememberSettingResidBar
                if(len(settings.keys())):
                  pythonOutput += 'for entry in dataset[-1][\'handleResidBar\']:\n'
                  for entry in settings:
                    if(not (entry.startswith('facecolor'))):
                      pythonOutput += '\tentry.' + settings[entry] + '\n'
                for item in ['facecolor', 'facecolorAlt']:
                  if(item in settings):
                    pythonOutput += 'for entry in dataset[-1][\'handleResidBar\'].patches:\n'
                    if(item == 'facecolor'):
                      pythonOutput += '\tif(entry.get_height() >= 0):\n'
                      pythonOutput += '\t\tentry.' + settings['facecolor'] + '\n'
                    else:
                      pythonOutput += '\tif(entry.get_height() < 0):\n'
                      pythonOutput += '\t\tentry.' + settings['facecolorAlt'] + '\n'
              else:
                pythonOutput += 'offset = 0.0\n'
   
        # draw residline zero
        settings = self.parent.plotArea.rememberSettingResidLine
        if('init' in settings):
          pythonOutput += '\n# plot and format zero line of residuals\n'
          pythonOutput += 'handleResidLine, = ' + settings['init'] + '\n'
          for entry in settings:
            if(entry != 'init'):
              pythonOutput += 'handleResidLine.' + settings[entry] + '\n'
  
        # apply plot settings
        pythonOutput += '\n\n###########################\n'
        pythonOutput += '# general plot formatting #\n'
        pythonOutput += '###########################\n'
        pythonOutput += 'ax.grid(b=True)\nax_resid.grid(b=True)\n'
        settings = self.parent.plotArea.rememberSetting
        if(not self.parent.plotArea.isSecondAxesActive()):
          toKill = []
          # replace ax2 by ax in this case
          for entry in settings:
            ###if(settings[entry].startswith('ax2.')):
            ###  settings[entry] = settings[entry].replace('ax2.', 'ax.', 1)
            if(('set_ticks_position' in settings[entry]) and ('ax2' in settings[entry])):
              # kill this item to prevent erroneous axis display
              toKill.append(entry)
            else:
              settings[entry] = settings[entry].replace('ax2.', 'ax.')
          for entry in toKill:
              del settings[entry]
        for entry in sorted(settings.keys()):
          if(not entry in ['xkcd', 'PathEffects']):
            pythonOutput += settings[entry]# + '\n'
  
        # set axes limits
        pythonOutput += 'ax.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
        pythonOutput += 'ax.set_ylim([' + repr(self.parent.plotArea.minY) + ', ' + repr(self.parent.plotArea.maxY) + '])\n'
        pythonOutput += 'ax_resid.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
        pythonOutput += 'ax_resid.set_ylim([' + repr(self.parent.plotArea.minResidY) + ', ' + repr(self.parent.plotArea.maxResidY) + '])\n'
        if(self.parent.plotArea.isSecondAxesActive()):
          pythonOutput += 'ax2.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
          pythonOutput += 'ax2.set_ylim([' + repr(self.parent.plotArea.minY2) + ', ' + repr(self.parent.plotArea.maxY2) + '])\n'
  
        # set window size
        targetwidth = float(self.exportSizeX.text())
        targetheight = float(self.exportSizeY.text())
        pythonOutput += 'matplot.set_size_inches('+ repr(targetwidth) + ', ' + repr(targetheight) +')\n'
        pythonOutput += 'residplot.set_size_inches('+ repr(targetwidth) + ', ' + repr(targetheight / 4.0) +')\n'
  
        # plot the data and show
        pythonOutput += '\n\n##########################\n'
        pythonOutput += '# draw and display plots #\n'
        pythonOutput += '##########################\n'
        pythonOutput += 'plt.draw()\nplt.show()\n'
        
        # save output to file
        try:
          writehandle = open(filename, 'w', encoding='utf-8')
          writehandle.write(pythonOutput)
          writehandle.close()
          # save filename for future reference
          self.currExportFile = filename
        except:
          self.parent.statusbar.showMessage('Error writing Python output file ' + filename, self.parent.STATUS_TIME)
  
  def wrapString(self, string, limit=80, breakat=',', delimiter='\n\t'):
    # wraps long string into several lines
    outstring = ''
    while(len(string)):
      if((len(string) <= limit) or (string[limit:].find(breakat) == -1)):
        outstring += string
        string = ''
      else:
        breakposition = limit + string[limit:].find(breakat)
        outstring += string[:breakposition + 1] + delimiter
        string = string[breakposition + 1:]
    return outstring

class myCentralWidget(QWidgetMac):
  def __init__(self, argument=None, parent=None):
    super(myCentralWidget, self).__init__(argument)
    self.parent = parent

  def resizeEvent(self, event):
    # custom resize event
    ###self.parent.plotArea.destructAboutLogo()
    QWidgetMac.resizeEvent(self, event)
    
class myQMessageBox(QtWidgets.QMessageBox):
  def __init__(self, argument=None, parent=None):
    super(myQMessageBox, self).__init__(argument)
    self.parent = parent
    # add checkbox
    self.discardCheckBox = QtWidgets.QCheckBox()
    self.discardCheckBox.setText('Do not ask again')
    self.setCheckBox(self.discardCheckBox)

  def exec_(self, *args, **kwargs):
    # override exec_ to return additional argument
    return QtWidgets.QMessageBox.exec_(self, *args, **kwargs), not self.discardCheckBox.isChecked()

class OptionMenu(KuhMenu):
  def __init__(self, parent = None):
    super(OptionMenu, self).__init__()
    self.parent = parent
      
    # float validator
    self.validFloat = MyValidFloat()
    self.validInt = MyValidInt()

    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.hLayout0 = QtWidgets.QHBoxLayout(self)
    self.hLayout0.setContentsMargins(*[0]*4)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    
    self.exportOptionsGroup = QWidgetMac()
    self.hLayout0.addWidget(self.exportOptionsGroup)    
    self.vLayout = QtWidgets.QVBoxLayout(self.exportOptionsGroup)
    self.vLayout.setContentsMargins(*[0]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.exportSettingLabel = QtWidgets.QLabel()
    useFont = self.exportSettingLabel.font()
    useFont.setBold(True)
    self.exportSettingLabel.setFont(useFont)
    self.exportSettingLabel.setText('Export options')
    self.vLayout.addWidget(self.exportSettingLabel)    
    
    # export options
    # plot resid?
    self.exportResidGroup = QWidgetMac()
    self.vLayout.addWidget(self.exportResidGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.exportResidGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.exportResidLabel = QtWidgets.QLabel('export resid')
    self.exportResidLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.exportResidLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.exportResidLabel)
    self.exportResidCheck = QPushButtonCheckable()
    self.exportResidCheck.setCheckMe(True)
    self.exportResidCheck.setChecked(self.parent.graphicsarea.advancedExport['plotResid'])
    self.exportResidCheck.setToolTip('Create residuals plot (in addition to data plot) when exporting graphics')
    self.exportResidCheck.clicked.connect(partial(self.toggleOption, self.exportResidCheck, 'plotResid'))
    self.exportResidCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.exportResidCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout.addWidget(self.exportResidCheck)

    # plot DPI
    self.exportDPIGroup = QWidgetMac()
    self.vLayout.addWidget(self.exportDPIGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.exportDPIGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.exportDPILabel = QtWidgets.QLabel('export DPI')
    self.exportDPILabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.exportDPILabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.exportDPILabel)

    self.exportDPIEntry = QLineEditClick()
    self.exportDPIEntry.setToolTip('Resolution in pixels per inch of bitmapped graphics')
    self.exportDPIEntry.setText(str(self.parent.graphicsarea.advancedExport['plotDPI']))
    self.exportDPIEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.exportDPIEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.exportDPIEntry.editingFinished.connect(partial(self.changeOption, self.exportDPIEntry, 'plotDPI', 60, 1200))
    self.exportDPIEntry.setValidator(self.validFloat)
    self.hLayout2.addWidget(self.exportDPIEntry)

    # SVG txt2path
    self.svgPathGroup = QWidgetMac()
    self.vLayout.addWidget(self.svgPathGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.svgPathGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.svgPathLabel = QtWidgets.QLabel('Text2Path')
    self.svgPathLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.svgPathLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.svgPathLabel)

    self.svgPathCheck = QPushButtonCheckable(self.svgPathGroup)
    self.svgPathCheck.setToolTip('Convert text to curves in vector graphics')
    self.svgPathCheck.setCheckMe(True)
    self.svgPathCheck.setChecked(self.parent.graphicsarea.advancedExport['SVGtxt2path'])
    self.svgPathCheck.clicked.connect(partial(self.toggleOption, self.exportResidCheck, 'SVGtxt2path'))
    self.svgPathCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.svgPathCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout3.addWidget(self.svgPathCheck)
    
    # heading
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.graphicsSettingLabel = QtWidgets.QLabel()
    useFont = self.graphicsSettingLabel.font()
    useFont.setBold(True)
    self.graphicsSettingLabel.setFont(useFont)
    self.graphicsSettingLabel.setText('Graphics options')
    self.vLayout.addWidget(self.graphicsSettingLabel)    

    # plot resid?
    self.advancedGraphicsGroup = QWidgetMac()
    self.vLayout.addWidget(self.advancedGraphicsGroup)
    self.hLayout35 = QtWidgets.QHBoxLayout(self.advancedGraphicsGroup)
    self.hLayout35.setContentsMargins(0, 0, 0, 0)
    self.hLayout35.setAlignment(QtCore.Qt.AlignLeft)
    self.advancedGraphicsLabel = QtWidgets.QLabel('advanced')
    self.advancedGraphicsLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.advancedGraphicsLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout35.addWidget(self.advancedGraphicsLabel)

    self.advancedGraphicsCheck = QPushButtonCheckable(self.advancedGraphicsGroup)
    self.advancedGraphicsCheck.setCheckMe(True)
    self.advancedGraphicsCheck.setChecked(self.parent.graphicsarea.advancedExport['advancedGraphics'])
    self.advancedGraphicsCheck.setToolTip('Display advanced graphics options')
    self.advancedGraphicsCheck.clicked.connect(self.toggleGraphicsOption)
    self.advancedGraphicsCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.advancedGraphicsCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout35.addWidget(self.advancedGraphicsCheck)

    # heading
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.stateFileSettingLabel = QtWidgets.QLabel()
    useFont = self.stateFileSettingLabel.font()
    useFont.setBold(True)
    self.stateFileSettingLabel.setFont(useFont)
    self.stateFileSettingLabel.setText('Save state files')
    self.vLayout.addWidget(self.stateFileSettingLabel)    

    self.stateFileFormatGroup = QWidgetMac()
    self.vLayout.addWidget(self.stateFileFormatGroup)
    self.hLayout31 = QtWidgets.QHBoxLayout(self.stateFileFormatGroup)
    self.hLayout31.setContentsMargins(0, 0, 0, 0)
    self.hLayout31.setAlignment(QtCore.Qt.AlignLeft)
    self.stateFileFormatLabel = QtWidgets.QLabel('format')
    self.stateFileFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.stateFileFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.stateFileFormatLabel)

    self.stateFileFormat = QComboBoxMac()
    self.stateFileFormat.setToolTip('Output format of state files')
    self.availableStateFileFormats = ['state', 'statez', 'both']
    self.stateFileFormat.addItems(self.availableStateFileFormats)
    self.stateFileFormat.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.stateFileFormat.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.stateFileFormat)
    if(self.parent.graphicsarea.advancedExport['stateFileFormat'] in self.availableStateFileFormats):
      currindex = self.availableStateFileFormats.index(self.parent.graphicsarea.advancedExport['stateFileFormat'])
      self.stateFileFormat.setCurrentIndex(currindex)
    else:
      self.stateFileFormat.setCurrentIndex(0)
    self.stateFileFormat.activated.connect(self.changeStateFileFormat)
    
    # minimization options
    blah = self.VLine()
    self.hLayout0.addWidget(blah)

    self.minOptionsGroup = QWidgetMac()
    self.hLayout0.addWidget(self.minOptionsGroup)    
    self.vLayout2 = QtWidgets.QVBoxLayout(self.minOptionsGroup)
    self.vLayout2.setContentsMargins(*[0]*4)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))
    
    # heading
    self.minSettingLabel = QtWidgets.QLabel()
    useFont = self.minSettingLabel.font()
    useFont.setBold(True)
    self.minSettingLabel.setFont(useFont)
    self.minSettingLabel.setText('Minimization options')
    self.vLayout2.addWidget(self.minSettingLabel)    
    
    # which algorithm?
    self.minAlgorithmGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minAlgorithmGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.minAlgorithmGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.minAlgorithmLabel = QtWidgets.QLabel('algorithm')
    self.minAlgorithmLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minAlgorithmLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.minAlgorithmLabel)

    self.minAlgorithm = QComboBoxMac()
    self.minAlgorithm.setToolTip('Algorithm used for numerical minimization')
    self.availableMinAlgorithms = ['Nelder-Mead', 'Powell', 'CG', 'BFGS']
    self.minAlgorithm.addItems(self.availableMinAlgorithms)
    self.minAlgorithm.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.minAlgorithm.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.minAlgorithm)
    if(self.parent.fitarea.advancedMinimization['algorithm'] in self.availableMinAlgorithms):
      currindex = self.availableMinAlgorithms.index(self.parent.fitarea.advancedMinimization['algorithm'])
      self.minAlgorithm.setCurrentIndex(currindex)
    else:
      self.minAlgorithm.setCurrentIndex(0)
    self.minAlgorithm.activated.connect(self.changeMinAlgorithm)
  
    # which tolerance
    self.minToleranceGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minToleranceGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.minToleranceGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.minToleranceLabel = QtWidgets.QLabel('tolerance')
    self.minToleranceLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minToleranceLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.minToleranceLabel)

    self.minToleranceEntry = QLineEditClick()
    self.minToleranceEntry.setToolTip('Target tolerance in numerical minimization')
    self.minToleranceEntry.setText(str(self.parent.fitarea.advancedMinimization['xtol']))
    self.minToleranceEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minToleranceEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minToleranceEntry.editingFinished.connect(partial(self.changeOptionMin, self.minToleranceEntry, 'xtol', 0, 1000))
    self.minToleranceEntry.setValidator(self.validFloat)
    self.hLayout5.addWidget(self.minToleranceEntry)

    # max fev
    self.minFevGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minFevGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.minFevGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.minFevLabel = QtWidgets.QLabel('max. fev')
    self.minFevLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minFevLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.minFevLabel)

    self.minFevEntry = QLineEditClick()
    self.minFevEntry.setToolTip('Maximum allowed function evaluations in numerical minimization')
    self.minFevEntry.setText(str(int(self.parent.fitarea.advancedMinimization['maxfev'])))
    self.minFevEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minFevEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minFevEntry.editingFinished.connect(partial(self.changeOptionMinInt, self.minFevEntry, 'maxfev', 1, 1e6))
    self.minFevEntry.setValidator(self.validInt)
    self.hLayout6.addWidget(self.minFevEntry)

    # heading
    blah = self.HLine()
    self.vLayout2.addWidget(blah)
    self.randomSettingLabel = QtWidgets.QLabel()
    useFont = self.randomSettingLabel.font()
    useFont.setBold(True)
    self.randomSettingLabel.setFont(useFont)
    self.randomSettingLabel.setText('Random search options')
    self.vLayout2.addWidget(self.randomSettingLabel)    
    
    # number cycles
    self.randomCyclesGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomCyclesGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.randomCyclesGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.randomCyclesLabel = QtWidgets.QLabel('#cycles')
    self.randomCyclesLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomCyclesLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.randomCyclesLabel)

    self.randomCyclesEntry = QLineEditClick()
    self.randomCyclesEntry.setToolTip('Number of search cycles in random parameter optimization')
    self.randomCyclesEntry.setText(str(int(self.parent.fitarea.advancedRandomSearch['cycles'])))
    self.randomCyclesEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomCyclesEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomCyclesEntry.editingFinished.connect(partial(self.changeOptionRandomInt, self.randomCyclesEntry, 'cycles', 1, 20))
    self.randomCyclesEntry.setValidator(self.validInt)
    self.hLayout7.addWidget(self.randomCyclesEntry)

    # escalate
    self.randomEscalateGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomEscalateGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.randomEscalateGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.randomEscalateLabel = QtWidgets.QLabel('escalate')
    self.randomEscalateLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomEscalateLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.randomEscalateLabel)

    self.randomEscalateEntry = QLineEditClick()
    self.randomEscalateEntry.setToolTip('Search amplitude increase during random parameter optimization')
    self.randomEscalateEntry.setText(str(self.parent.fitarea.advancedRandomSearch['escalate']))
    self.randomEscalateEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomEscalateEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomEscalateEntry.editingFinished.connect(partial(self.changeOptionRandom, self.randomEscalateEntry, 'escalate', 0, 10))
    self.randomEscalateEntry.setValidator(self.validFloat)
    self.hLayout8.addWidget(self.randomEscalateEntry)

    # max fev
    self.randomFevGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomFevGroup)
    self.hLayout9 = QtWidgets.QHBoxLayout(self.randomFevGroup)
    self.hLayout9.setContentsMargins(0, 0, 0, 0)
    self.hLayout9.setAlignment(QtCore.Qt.AlignLeft)
    self.randomFevLabel = QtWidgets.QLabel('max. fev')
    self.randomFevLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomFevLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout9.addWidget(self.randomFevLabel)

    self.randomFevEntry = QLineEditClick()
    self.randomFevEntry.setToolTip('Maximum allowed function evaluations per cylce in random optimization')
    self.randomFevEntry.setText(str(int(self.parent.fitarea.advancedRandomSearch['maxfev'])))
    self.randomFevEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomFevEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomFevEntry.editingFinished.connect(partial(self.changeOptionRandomInt, self.randomFevEntry, 'maxfev', 1, 1e6))
    self.randomFevEntry.setValidator(self.validInt)
    self.hLayout9.addWidget(self.randomFevEntry)

    self.setFocus()    
    self.focusNextChild()
    
  def toggleGraphicsOption(self):
    # toggles display of advanced graphics
    value = self.advancedGraphicsCheck.isChecked()
    self.parent.graphicsarea.configAdvancedSettingsButton.setChecked(value)
    self.parent.graphicsarea.setAdvancedGraphics(value=value)
    self.parent.graphicsarea2.setAdvancedGraphics(value=value)

  def toggleOption(self, entryfield=None, key=None):
    # toggles option of target
    if((entryfield != None) and (key != None)):
      value = entryfield.isChecked()
      self.parent.graphicsarea.setAdvancedExport(key=key, value=value)

  def changeOption(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.graphicsarea.setAdvancedExport(key=key, value=value)

  def changeOptionMin(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedMinimization(key=key, value=value)
      self.parent.globalarea.setAdvancedMinimization(key=key, value=value)

  def changeOptionMinInt(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedMinimization(key=key, value=value)
      self.parent.globalarea.setAdvancedMinimization(key=key, value=value)
      
  def changeOptionRandom(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedRandomSearch(key=key, value=value)
      self.parent.globalarea.setAdvancedRandomSearch(key=key, value=value)

  def changeOptionRandomInt(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedRandomSearch(key=key, value=value)
      self.parent.globalarea.setAdvancedRandomSearch(key=key, value=value)
      
  def changeMinAlgorithm(self):
    useAlgorithm = str(self.minAlgorithm.currentText())
    self.parent.fitarea.setAdvancedMinimization(key='algorithm', value=useAlgorithm)
    self.parent.globalarea.setAdvancedMinimization(key='algorithm', value=useAlgorithm)

  def changeStateFileFormat(self):
    useStateFile = str(self.stateFileFormat.currentText())
    self.parent.graphicsarea.setAdvancedExport(key='stateFileFormat', value=useStateFile)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

class SelectedDataObject(DataObject):
  def __init__(self, parent=None):
    super(SelectedDataObject, self).__init__(parent)
    # undo increase in zcount upon creation of data object
    self.parent.zcount -= 1
    self.indices = np.array([])
    self.isLive = False
    
    # define custom marker
    selectionMarker = matplotlib.path.Path.unit_circle()
    val = np.sin(np.pi / 4.0)
    verts = np.array([[-val, val], [val, -val], [-val, -val], [val, val]])
    codes = [matplotlib.path.Path.MOVETO, matplotlib.path.Path.LINETO, matplotlib.path.Path.MOVETO, matplotlib.path.Path.LINETO]
    verts = np.concatenate([selectionMarker.vertices, verts])
    codes = np.concatenate([selectionMarker.codes, codes])
    self.selectionMarker = matplotlib.path.Path(verts, codes)
    # use crosshairs
    self.selectionMarker = '$\u2316$'
    # use rotated crosshairs -- it is better to hard-code this because we cannot assume the font symbol is present on each and every platform
    self.selectionMarker = matplotlib.path.Path([[  9.93051613e-01,  -8.69218182e-01],
       [  6.77802346e-01,  -5.53968915e-01], [  8.72817009e-01,  -3.13792962e-01], [  8.72817009e-01,   1.74956012e-03], [  8.72817009e-01,   3.16705572e-01],
       [  6.79561877e-01,   5.55121994e-01], [  9.94811144e-01,   8.70371261e-01], [  8.70764223e-01,   9.94418182e-01], [  5.55514956e-01,   6.79168915e-01],
       [  3.15339003e-01,   8.74183578e-01], [ -1.66979472e-03,   8.74476833e-01], [ -3.18971848e-01,   8.74476833e-01], [ -5.57388270e-01,   6.81221701e-01],
       [ -8.72637537e-01,   9.96470968e-01], [ -9.96684457e-01,   8.72424047e-01], [ -6.83194721e-01,   5.58934311e-01], [ -8.78209384e-01,   3.18758358e-01],
       [ -8.77329619e-01,   5.76539589e-04], [ -8.76449853e-01,  -3.17605279e-01], [ -6.79382405e-01,  -5.55728446e-01], [ -9.94631672e-01,  -8.70977713e-01],
       [ -8.70584751e-01,  -9.95024633e-01], [ -5.55335484e-01,  -6.79775367e-01], [ -3.17212317e-01,  -8.76842815e-01], [ -1.08328446e-03,  -8.75669795e-01],
       [  3.15339003e-01,  -8.74790029e-01], [  5.53755425e-01,  -6.78015836e-01], [  8.69004692e-01,  -9.93265103e-01], [ -5.62960117e-01,   1.50497537e+00],
       [  8.97360704e-05,  -1.24350147e-01], [  4.29708504e-01,  -5.53968915e-01], [  2.44078006e-01,  -6.98543695e-01], [  8.97360704e-05,  -6.98543695e-01],
       [ -2.43898534e-01,  -6.98543695e-01], [ -4.31581818e-01,  -5.56021701e-01], [ -5.62960117e-01,   1.50497537e+00], [ -1.23957185e-01,  -3.03225806e-04],
       [ -5.55628739e-01,  -4.31974780e-01], [ -6.99910264e-01,  -2.42531965e-01], [ -7.01083284e-01,   2.62932551e-03], [ -7.01963050e-01,   2.47497361e-01],
       [ -5.57388270e-01,   4.33127859e-01], [ -5.62960117e-01,   1.50497537e+00], [  5.51995894e-01,  -4.28162463e-01], [  1.24136657e-01,  -3.03225806e-04],
       [  5.55808211e-01,   4.31368328e-01], [  6.98036950e-01,   2.47497361e-01], [  6.96277419e-01,   3.50909091e-03], [  6.94517889e-01,  -2.40479179e-01],
       [  5.51995894e-01,  -4.28162463e-01], [ -5.62960117e-01,   1.50497537e+00], [  4.31761290e-01,   5.55415249e-01], [  8.97360704e-05,   1.23743695e-01],
       [ -4.33341349e-01,   5.57174780e-01], [ -2.45658065e-01,   6.99696774e-01], [  8.97360704e-05,   6.99696774e-01], [  2.45837537e-01,   6.99696774e-01],
       [  4.31761290e-01,   5.55415249e-01], [ -5.62960117e-01,   1.50497537e+00]],
       [1, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 79, 1, 2, 3, 3, 3, 3, 79, 1, 2, 3, 3, 3, 3, 79, 1, 2, 2, 3, 3, 3, 3, 79, 1, 2, 2, 3, 3, 3, 3, 79])

    # change some style values
    self.theseStyles = {'markerfacecolor': [1.0, 1.0, 1.0, 1.0], 'markeredgecolor': [0.2, 0.2, 0.2, 1.0], 'markeredgewidth': 0.5, 'markersize': 18.0,
                   'marker': self.selectionMarker, 'markevery': 1, 'linestyle': 'None', 'zorder': 2000,
                   'path_effects': [PathEffects.withStroke(linewidth=1.5, foreground=[0.4, 0.4, 0.8, 0.7])]}
    self.style.update(self.theseStyles)
    self.Residstyle.update(self.theseStyles)

  # override drawMeResid() function
  def drawMeResid(self, axisobject=None, axisobject2=None, redraw=True):
    if((axisobject != None) or (axisobject2 != None)):
      if(self.handleResid != None):
        self.handleResid.remove()
        self.handleResid = None
      if(self.handleResid_div != None):
        self.handleResid_div.remove()
        self.handleResid_div = None
      # plot resid
      if(len(self.x)):
        # first get current resdiual values
        values, roles = self.parent.data[self.parent.activeData].getData_n_Fit()
        if('resid' in roles):
          self.resid = values[:, roles.index('resid')][self.indices]
        if(axisobject != None):
          self.handleResid, = axisobject.plot(self.x, self.resid)
          if(axisobject2 != None):
            self.handleResid_div, = axisobject2.plot(self.x, self.resid)
          # apply styles
          items = ['markerfacecolor', 'markeredgecolor', 'markeredgewidth', 'markersize', 'marker', 'markevery', 'linestyle', 'zorder', 'path_effects']
          for item in items:
            if(axisobject != None):
              if(hasattr(self.handleResid, 'set_' + item)):
                method2call = getattr(self.handleResid, 'set_' + item)
                method2call(self.Residstyle[item])
            if(axisobject2 != None):
              if(hasattr(self.handleResid_div, 'set_' + item)):
                method2call = getattr(self.handleResid_div, 'set_' + item)
                method2call(self.Residstyle[item])
        # adjust marker size
        self.adjustMarkerSize(resid=True)
            
      # redraw?
      if(redraw):
        self.parent.plotArea.residplotwidget.myRefresh()
    
  # override drawMe() function
  def drawMe(self, axisobject=None, axisobject2=None, redraw=True):
    if((axisobject != None) or (axisobject2 != None)):
      if(self.handleData != None):
        self.handleData.remove()
        self.handleData = None
      if(self.handleData_div != None):
        self.handleData_div.remove()
        self.handleData_div = None
      # plot data
      if(len(self.x)):
        self.isLive = True
        self.toggleParentalButtons(True)
        if(axisobject != None):
          self.handleData, = axisobject.plot(self.x, self.y)
        if(axisobject2 != None):
          self.handleData_div, = axisobject2.plot(self.x, self.y)
        # duplicate me
        if(self.parent.plotArea.splitY):
          self.duplicateForSplit()
        # apply styles
        items = ['markerfacecolor', 'markeredgecolor', 'markeredgewidth', 'markersize', 'marker', 'markevery', 'linestyle', 'zorder', 'path_effects']
        for item in items:
          if(axisobject != None):
            if(hasattr(self.handleData, 'set_' + item)):
              method2call = getattr(self.handleData, 'set_' + item)
              method2call(self.style[item])
          if(axisobject2 != None):
            if(hasattr(self.handleData_div, 'set_' + item)):
              method2call = getattr(self.handleData_div, 'set_' + item)
              method2call(self.style[item])
          # split y items
          if(('handleData' in self.handlesBothAxes) and (self.handlesBothAxes['handleData'] != None)):
            method2call = getattr(self.handlesBothAxes['handleData'], 'set_' + item)
            method2call(self.style[item])
          if(('handleData_div' in self.handlesBothAxes) and (self.handlesBothAxes['handleData_div'] != None)):
            method2call = getattr(self.handlesBothAxes['handleData_div'], 'set_' + item)
            method2call(self.style[item])
        # adjust marker size
        self.adjustMarkerSize(resid=False)
      # redraw?
      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
        
  def adjustMarkerSize(self, resid=False):
    # dynamically adjusts marker size based on zoom level
    relativeZoomLevel = 1.0
    currentZoomText = self.parent.zoomSelector.currentText()
    currentZoom = currentZoomText.split('%')
    if(len(currentZoom) > 1):
      try:
        relativeZoomLevel = 200.0 / float(currentZoom[0])
      except:
        pass
      
    # update plot handles
    if(resid):
      handles = [self.handleResid, self.handleResid_div]
    else:
      handles = [self.handleData, self.handleData_div]
      if(('handleData' in self.handlesBothAxes) and (self.handlesBothAxes['handleData'] != None)):
        handles.append(self.handlesBothAxes['handleData'])
      if(('handleData_div' in self.handlesBothAxes) and (self.handlesBothAxes['handleData_div'] != None)):
        handles.append(self.handlesBothAxes['handleData_div'])
    
    for handle in handles:
      if(hasattr(handle, 'set_markersize')):
        handle.set_markersize(self.style['markersize'] * relativeZoomLevel)
      if(hasattr(handle, 'set_markeredgewidth')):
        handle.set_markeredgewidth(self.style['markeredgewidth'] * relativeZoomLevel)
      if(hasattr(handle, 'set_path_effects')):
        # have to hard-code the style value
        handle.set_path_effects([PathEffects.withStroke(linewidth=1.5 * relativeZoomLevel, foreground=[0.4, 0.4, 0.8, 0.7])])

  def clearMe(self, redraw=True):
    # resets everything
    deleteResid = (len(self.resid) > 0)
    self.initValues()
    self.indices = np.array([])
    self.isLive = False
    self.toggleParentalButtons(False)
    if(self.handleData != None):
      self.handleData.remove()
      self.handleData = None
    if(self.handleData_div != None):
      self.handleData_div.remove()
      self.handleData_div = None
    if(self.handleResid != None):
      self.handleResid.remove()
      self.handleResid = None
    if(self.handleResid_div != None):
      self.handleResid_div.remove()
      self.handleResid_div = None
    # remove from split y axis
    self.removeFromSplit()
      
    # redraw?
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()
      if(deleteResid):
        self.parent.plotArea.residplotwidget.myRefresh()

  def duplicateForSplit(self, xval=[], yval=[], xerr=[], yerr=[]):
    # duplicates current data set and draws it on split y axis
    # delete all previous items (if any)
    self.removeFromSplit()
    
    # assign x and y values
    if(not len(xval)):
      xval, yval, xerr, yerr = self.x, self.y, self.xerr, self.yerr
    xval, yval, xerr, yerr = np.array(xval), np.array(yval), np.array(xerr), np.array(yerr)

    if(self.onSecondAxes):
      axisobjectBase = 'ax'
    else:
      axisobjectBase = 'ax2'
      
    # intialize dictionary with None
    self.handlesBothAxes['handleData'] = None
    self.handlesBothAxes['handleData_div'] = None
      
    # copy plot objects
    for extension in ['', '_div']:
      if(extension == ''):
        # first treat main x axes
        handleData = self.handleData
      else:
        # then treat spit x axes
        handleData = self.handleData_div
      axisobject = self.parent.plotArea.__dict__[axisobjectBase + extension]
        
      if(handleData != None):
        handle = 'handleData' + extension
        self.handlesBothAxes[handle], = axisobject.plot(xval, yval, 'ko')
       
    # apply all styles
    items = ['markerfacecolor', 'markeredgecolor', 'markeredgewidth', 'markersize', 'marker', 'markevery', 'linestyle', 'zorder', 'path_effects']
    for item in items:
      # split y items
      if(('handleData' in self.handlesBothAxes) and (self.handlesBothAxes['handleData'] != None)):
        method2call = getattr(self.handlesBothAxes['handleData'], 'set_' + item)
        method2call(self.style[item])
      if(('handleData_div' in self.handlesBothAxes) and (self.handlesBothAxes['handleData_div'] != None)):
        method2call = getattr(self.handlesBothAxes['handleData_div'], 'set_' + item)
        method2call(self.style[item])
   
  def removeFromSplit(self):
    # removes duplicated data set from split y axes
    for handle in self.handlesBothAxes:
      if(hasattr(self.handlesBothAxes[handle], 'remove')):
        self.handlesBothAxes[handle].remove()
    self.handlesBothAxes = {}

  def mouseSelectIndices(self, selind=np.array([]), redraw=True):
    # selects given indices (callback for plot panel)
    if(len(selind)):
      values, roles = self.parent.data[self.parent.activeData].getData_n_Fit()
      if(('x' in roles) and ('y' in roles)):
        if(len(self.indices) == len(selind)):
          selind = np.logical_xor(selind, self.indices)
        filteredValues = values[selind]
        # check for zero size
        if(len(filteredValues)):
          self.setData(data=filteredValues, roles=roles)
          self.setIndices(indices=selind)
          self.resid, self.fval = np.array([]), np.array([])
          # is item on second axes?
          if(self.parent.data[self.parent.activeData].onSecondAxes):
            useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
          else:
            useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
          self.drawMe(useAxes, useAxes2, redraw=redraw)
        else:
          self.clearMe(redraw=redraw)
        # update the results table
        if(hasattr(self.parent, 'resultsarea')):
          selectIndices = [i for i, j in enumerate(selind) if j]
          self.parent.resultsarea.selectTheseRows(selectIndices)

  def tableSelectIndices(self, selind=[], redraw=True):
    # selects given indices (callback for resultstable)
    if(len(selind)):
      selind = sorted([i.row() for i in selind])
      values, roles = self.parent.data[self.parent.activeData].getData_n_Fit()
      if(('x' in roles) and ('y' in roles) and len(values[:, roles.index('x')])):
        selind = np.array([True if i in selind else False for i in range(len(values[:, roles.index('x')]))])
        filteredValues = values[selind]
        self.setData(data=filteredValues, roles=roles)
        self.setIndices(indices=selind)
        # is item on second axes?
        if(self.parent.data[self.parent.activeData].onSecondAxes):
          useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
        else:
          useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
        self.drawMe(useAxes, useAxes2, redraw=redraw)
      else:
        self.clearMe(redraw=redraw)
    else:
      self.clearMe(redraw=redraw)

  def setIndices(self, indices):
    # updates indices
    self.indices = indices

  def getIndices(self):
    return self.indices
  
  def toggleParentalButtons(self, state=True):
    # toggles activity of buttons in plotArea and resultstable
    for item in ['plotArea', 'resultsarea']:
      if(hasattr(self.parent, item)):
        self.parent.__dict__[item].clearButton.setEnabled(state)
    if(hasattr(self.parent, 'resultsarea')):
      self.parent.resultsarea.spawnButton.setEnabled(state)

class Ui_MainWindow(object):
  def setupUi(self, MainWindow):
    # save MainWindow
    self.MainWindow = MainWindow
    # set up z-order counter
    self.zcount = 0
    # upshift all draw items in zo to ensure display in front of axes and gridlines
    self.zOffset = 3
    # default duration for status messages
    self.STATUS_TIME = 10000
    # set up data and fit objects
    self.fit = []
    self.fit.append(FitObject(self))
    self.data = []
    self.data.append(DataObject(self))
    self.selectedData = SelectedDataObject(self)
    self.extras = []
    self.activeData = 0
    self.activeFit = 0
    self.discardCheck = True
    self.discard = False
    self.zoomLevels = [25, 33, 50, 75, 100, 150, 200, 300, 400, 600]
    self.currStateFile = None
    self.lastFitType = 'none'
    self.lastFitGlobalDataSets, self.lastFitGlobalCurves = [], []
    
    # get font list
    self.fontList = matplotlib.font_manager.fontManager.ttflist
    self.fontNames = [i.name for i in self.fontList]
    self.fontNames= sorted(list(set(self.fontNames)))
    
    # set up GUI
    self.buildRessource()
    
    # set central widget and splitter sizes
    self.MainWindow.setCentralWidget(self.centralwidget)
    self.masterwidget.setSizes([scaledDPI(424), self.masterwidget.size().width() - scaledDPI(424)])

  def buildRessource(self):
    # build the gui
    self.MainWindow.setObjectName("MainWindow")
    self.MainWindow.resize(scaledDPI(1024), scaledDPI(768))
    self.MainWindow.setMinimumWidth(scaledDPI(864))
    self.MainWindow.setMinimumHeight(scaledDPI(600))
    self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION)
    self.centralwidget = myCentralWidget(argument=self.MainWindow, parent=self)
    self.centralwidget.setObjectName("centralwidget")
    self.vLayout0 = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout0.setContentsMargins(0, 0, 0, 0)
    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
    self.vLayout0.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)
    self.masterwidget.setOpaqueResize(False)

    self.tabWidget = myQTabWidget()
    self.masterwidget.addWidget(self.tabWidget)
    self.tabWidget.setEnabled(True)
    self.tabWidget.setGeometry(QtCore.QRect(0, 0, scaledDPI(422), scaledDPI(500)))
    #self.tabWidget.setMaximumSize(QtCore.QSize(scaledDPI(422), 16777215))
    self.tabWidget.setMinimumSize(QtCore.QSize(scaledDPI(422), scaledDPI(500)))
    self.tabWidget.setObjectName("tabWidget")

    # the matplotlib canvas
    self.plotArea = MatplotlibCanvas(self)
    self.plotArea.setMinimumSize(QtCore.QSize(scaledDPI(440), scaledDPI(500)))
    self.masterwidget.addWidget(self.plotArea)
    self.masterwidget.setSizes([scaledDPI(422), self.masterwidget.size().height() - scaledDPI(422)])

    # the data tab
    self.tab = QWidgetMac()
    self.tab.setObjectName("tab")
    self.vLayout = QtWidgets.QVBoxLayout(self.tab)
    self.vLayout.setContentsMargins(2, 2, 2, 2)
    self.dataarea = DataArea(self)
    self.vLayout.addWidget(self.dataarea)
    self.tabWidget.addTab(self.tab, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), "Data")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab), 'This tab serves to import data, optionally allowing to specify data errors\nand perform data reduction and transformation operations.\n(Ctrl-1)')

    # the fit tab
    self.tab_2 = QWidgetMac()
    self.tab_2.setObjectName("tab_2")
    self.hLayout2 = QtWidgets.QHBoxLayout(self.tab_2)
    self.hLayout2.setContentsMargins(2, 2, 2, 2)
    self.fitarea = FitArea(self)
    self.hLayout2.addWidget(self.fitarea)
    self.tabWidget.addTab(self.tab_2, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), "Fit")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_2), 'This tab serves to select, modify and fit functions,\nand to optimize parameters by nonlinear least-\nsquares fitting or numerical minimization.\n(Ctrl-2)')

    # the global fit tab
    self.tab_3 = QWidgetMac()
    self.tab_3.setObjectName("tab_3")
    self.hLayout25 = QtWidgets.QHBoxLayout(self.tab_3)
    self.hLayout25.setContentsMargins(2, 2, 2, 2)
    self.globalarea = GlobalArea(self)
    self.hLayout25.addWidget(self.globalarea)
    self.tabWidget.addTab(self.tab_3, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), "Global")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_3), 'This tab allows to conduct global fits, i.e. fit\nmore than one data set simultaneously to one or more functions.\n(Ctrl-3)')

    # the results tab
    self.tab_4 = QWidgetMac()
    self.tab_4.setObjectName("tab_4")
    self.hLayout3 = QtWidgets.QHBoxLayout(self.tab_4)
    self.hLayout3.setContentsMargins(2, 2, 2, 2)
    self.resultsarea = ResultsArea(self)
    self.hLayout3.addWidget(self.resultsarea)
    self.tabWidget.addTab(self.tab_4, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), "Results")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_4), 'This tab shows the imported data and fit results if present.\n(Ctrl-4)')

    # the objects tab
    self.tab_5 = QWidgetMac()
    self.tab_5.setObjectName("tab_5")
    self.hLayout4 = QtWidgets.QHBoxLayout(self.tab_5)
    self.hLayout4.setContentsMargins(2, 2, 2, 2)
    self.objectsarea = ObjectsArea(self)
    self.hLayout4.addWidget(self.objectsarea)
    self.tabWidget.addTab(self.tab_5, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_5), "Objects")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_5), 'This tab grants control of data, curve and graphics objects.\nObjects can be configured, copied or deleted.\n(Ctrl-5)')
    
    # the graphics export tab
    self.tab_6 = QWidgetMac()
    self.hLayout5 = QtWidgets.QHBoxLayout(self.tab_6)
    self.hLayout5.setContentsMargins(2, 2, 2, 2)
    self.graphicsarea = GraphicsArea(self)
    self.hLayout5.addWidget(self.graphicsarea)
    self.tabWidget.addTab(self.tab_6, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_6), "Graphics")
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_6), 'This tab allows to configure the plot graphics,\nexport them in vector and bitmap formats,\nand compile a report of current fit results.\n(Ctrl-6)')
    
    # the 2nd axes tab
    self.tab_7 = QWidgetMac()
    self.hLayout6 = QtWidgets.QHBoxLayout(self.tab_7)
    self.hLayout6.setContentsMargins(2, 2, 2, 2)
    self.graphicsarea2 = GraphicsArea(parent=self, secondAxes=True)
    self.hLayout6.addWidget(self.graphicsarea2)
    self.tabWidget.setTabToolTip(self.tabWidget.indexOf(self.tab_7), 'This tab contains options for configuring the second axes graphics.\n(Ctrl-7)')

    # initially turn off and on to store tab tooltips
    self.tabWidget.toggleToolTips(False)
    self.tabWidget.toggleToolTips(True)

    # check whether default style exists
    defaultStyle = 'default.style'
    try:
      loadhandle = open(WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR + defaultStyle, 'r', encoding='utf-8')
      red = loadhandle.readlines()
      red = ''.join(red)
      loadhandle.close()

      # apply style sheet
      self.graphicsarea.processStyleSet(operation='load', modus=red, zoffsetData=0, zoffsetCurve=0, redraw=False)
    except:
      pass
    
    self.plotArea.initLegend()
    
    # status bad and buttons
    self.statusbar = KuhStatusBar(self.MainWindow)
    self.MainWindow.setStatusBar(self.statusbar)
    
    blah = QtWidgets.QLabel()
    blah.setText('Status OK')
    self.statusbar.addWidget(blah)

    self.zoomLabel = QtWidgets.QLabel()
    self.zoomLabel.setText('Zoom')
    self.zoomLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.zoomLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.statusbar.addPermanentWidget(self.zoomLabel)

    self.zoomSelector = QComboBoxMac()
    self.zoomSelector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.zoomSelector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    for item in self.zoomLevels[::-1]:
      self.zoomSelector.addItem(str(item) + '%')
    currZoomLevel = self.plotArea.matplot.get_dpi()
    # make sure there are no decimal points
    currZoomLevel = int(currZoomLevel)
    if(currZoomLevel in self.zoomLevels):
      self.zoomSelector.setCurrentIndex(self.zoomLevels[::-1].index(currZoomLevel))
    else:
      self.zoomSelector.setCurrentText('100%')
    self.zoomSelector.currentIndexChanged.connect(self.setZoomLevel)
    self.zoomSelector.setToolTip('Set plot magnification\n(Ctrl-+ and Ctrl--)')
    self.statusbar.addPermanentWidget(self.zoomSelector)

    self.loadStateButton = QPushButtonMac()
    self.loadStateButton.setText('Open State')
    self.loadStateButton.setToolTip('Load program state file\n(Ctrl-O)')
    self.loadStateButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.loadStateButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.loadStateButton.clicked.connect(partial(self.loadState, None))
    self.statusbar.addPermanentWidget(self.loadStateButton)

    self.saveStateButton = QPushButtonMac()
    self.saveStateButton.setText('Save State')
    self.saveStateButton.setToolTip('Save program state to file\n(Ctrl-S)')
    self.saveStateButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.saveStateButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.saveStateButton.clicked.connect(partial(self.saveState, ''))
    self.statusbar.addPermanentWidget(self.saveStateButton)

    self.advancedButton = QPushButtonMac()
    self.advancedButton.setText('Advanced \u25b4')
    self.advancedButton.setToolTip('Configure advanced program settings')
    self.advancedButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.advancedButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.advancedButton.clicked.connect(partial(self.advancedOption, self.advancedButton))
    self.statusbar.addPermanentWidget(self.advancedButton)

    self.aboutButton = QPushButtonMac()
    self.aboutButton.setText('About')
    self.aboutButton.setToolTip('Who dunnit?')
    self.aboutButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.aboutButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.aboutButton.clicked.connect(self.aboutInfo)
    self.statusbar.addPermanentWidget(self.aboutButton)
  
    self.helpButton = QPushButtonMac()
    self.helpButton.setText('Help')
    self.helpButton.setToolTip('Display manual page\n(F1)')
    self.helpButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.helpButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.helpButton.clicked.connect(self.showHelp)
    self.statusbar.addPermanentWidget(self.helpButton)
    
    # add controls for tooltips
    self.toolTipButton = QPushButtonCheckable()
    self.toolTipButton.setText('Tooltips')
    self.toolTipButton.setToolTip('Display tool tips')
    self.toolTipButton.setChecked(True)
    self.toolTipButton.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.toolTipButton.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.toolTipButton.clicked.connect(self.toggleToolTips)
    self.statusbar.addPermanentWidget(self.toolTipButton)
    
    # give focus to empty data table
    self.dataarea.tableWidget.setFocus()

  def toggleToolTips(self):
    # toggles display of tool tips
    state = self.toolTipButton.isChecked()
    myapp.toolTipsShow = state
    # toggle tool tips for tab widget (need to do this separately from other widgets as event catching fails)
    self.tabWidget.toggleToolTips(state)
    # toggle tool tip for data table
    self.dataarea.tableWidget.toggleToolTips(state)
    # toggle tool tip for results table
    self.resultsarea.toggleToolTips(state)

  def setZoomLevel(self):
    # sets DPI level in data and resid plots
    zoomLevel = str(self.zoomSelector.currentText())
    zoomLevel = zoomLevel.split('%')[0]
    zoomLevel = int(zoomLevel)
    self.plotArea.setZoomLevel(zoomLevel)

  def handleDropEvent(self, mimeData):
    # callback function that handles drag and drop events
    success = False
    if(mimeData.hasUrls()):
      urls = mimeData.urls()
      if(len(urls)):
        filename = urls[0].path()
        if((platform == 'win32') and (filename.startswith('/'))):
          # delete leading slash as this causes problems with the subsequent opening of file
          filename = filename[1:]
        if((filename.endswith('.state')) or (filename.endswith('.statez'))):
          self.loadState(filename, dropEvent=True)
          success = True
        elif((filename.endswith('.xls')) or (filename.endswith('.xlsx'))):
          self.dataarea.tableWidget.loadXLS(filename=filename, transpose=self.dataarea.transposeData)
          self.tabWidget.setCurrentIndex(0)
          success = True
        elif(filename.endswith('.txt')):
          self.dataarea.tableWidget.loadTextFile(filename=filename, delimiter=None, transpose=self.dataarea.transposeData)
          self.tabWidget.setCurrentIndex(0)
          success = True
        elif(filename.endswith('.csv')):
          self.dataarea.tableWidget.loadTextFile(filename=filename, delimiter=',', transpose=self.dataarea.transposeData)
          self.tabWidget.setCurrentIndex(0)
          success = True
        elif(filename.endswith('.res')):
          self.dataarea.tableWidget.loadUnicornFile(filename=filename, transpose=self.dataarea.transposeData)
          self.tabWidget.setCurrentIndex(0)
          success = True
      
    if(not success):
      self.statusbar.showMessage('Cannot deal with this input/file type.', self.STATUS_TIME)
  
  def loadState(self, stateFile=None, dropEvent=False):
    # store how many objects we have before the state load
    numberData, numberFit, numberExtras = len(self.data), len(self.fit), len(self.extras)
    # open specific file or select one via file dialog
    if(stateFile != None):
      filename = stateFile
      if(not dropEvent):
        self.discardCheck = False
        self.discard = True
    else:
      global REMEMBERDIR
      # parse state file
      filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, filter = 'State file (*.state; *.statez)', directory = REMEMBERDIR, caption='Open State')
      filename = str(filename)
      if(PATH_SEPARATOR in filename):
        REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
        REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
      elif('/' in filename):
        REMEMBERDIR = filename.split('/')[:-1]
        REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
        
    # read file contents
    settings = {}; activeCategory = ''
    # check whether this state file is a zip archive
    if(zipfile.is_zipfile(filename)):
      try:
        ziphandle = zipfile.ZipFile(filename)
        fileList = ziphandle.filelist
        if(len(fileList)):
          loadhandle = ziphandle.open(fileList[0].filename, 'r')
          # use wrapper to convert bytes into str
          loadhandle = io.TextIOWrapper(loadhandle, encoding='utf-8')
          success = True
        else:
          success = False
      except:
        success = False
    else:
      try:
        loadhandle = open(filename,'r', encoding='utf-8')
        success = True
      except:
        success = False
    
    if(not success):
      if(filename):
        self.statusbar.showMessage('Cannot load state file ' + filename, self.STATUS_TIME)
    else:
      # save filename for future reference
      if(filename.endswith('.statez')):
        self.currStateFile = ''.join(filename.split('.')[:-1]) + '.statez'
      else:
        self.currStateFile = filename
      # display filename in windows title
      self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION + ' -- ' + self.currStateFile)
      # check whether to discard old items
      if(self.discardCheck):
        msgBox = myQMessageBox()
        msgBox.setWindowTitle('Fit-o-mat')
        msgBox.setText('Discard current objects?')
        msgBox.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        msgBox.setDefaultButton(QtWidgets.QMessageBox.No)
        msgBox.setIcon(QtWidgets.QMessageBox.Question)
        # apply styles and show
        if(QSTYLE != None):
          msgBox.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          msgBox.setStyleSheet(QSTYLESHEET)
        reply, self.discardCheck = msgBox.exec_()
        if (reply == QtWidgets.QMessageBox.Yes):
          self.discard = True
        else:
          self.discard = False
      # display busy pointer
      QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
      QtCore.QCoreApplication.processEvents()
      # parse file contents
      red = loadhandle.readline()
      while (red):
        if(activeCategory == 'MESSAGE'):
          if(red.find('</MESSAGE>') == 0):
            activeCategory = ''
          else:
            red = red.strip()
            if(activeCategory in settings):
              settings[activeCategory].append(red)
        elif(activeCategory == 'GLOBAL'):
          if(red.find('</GLOBAL>') == 0):
            activeCategory = ''
          else:
            red = red.strip()
            if(activeCategory in settings):
              settings[activeCategory].append(red)
        else:
          if(red.find('<') == 0):
            if(red.find('/') == 1):
              activeCategory = ''
            else:
              activeCategory = red[1:].split('>')[0]
              if(activeCategory in ['GRAPHICS', 'CANVAS', 'OBJECTS', 'ADVANCED', 'ADVANCED_MIN', 'ADVANCED_RANDOM']):
                settings[activeCategory] = {}
              else:
                settings[activeCategory] = []
          elif(red.find('>>>') == 0):
            if(activeCategory != ''):
              entry = red[3:].strip()
              red = loadhandle.readline()
              red = red.strip()
              # convert string input to original data
              try:
                red = literal_eval(red)
                settings[activeCategory][entry] = red
              except:
                self.statusbar.showMessage('Failed to restore setting ' + repr(entry) + repr(red), self.STATUS_TIME)
                print('Failed to restore setting', entry, red)
          else:
            red = red.strip()
            if(activeCategory in settings):
              settings[activeCategory].append(red)
        red = loadhandle.readline()
        
      loadhandle.close()

      # close zip file if handle had been opened
      if(zipfile.is_zipfile(filename)):
        ziphandle.close()

      # apply settings
      # apply axes mode to avoid problems with log axes
      temp_settings = {}
      # initially set splitY to False (this is to streamline loading older state files that are ignorant of this setting yet)
      temp_settings['splitY'] = False
      for entry in ['modeX', 'modeY', 'modeX_div']:
        if(('CANVAS' in settings) and (entry in settings['CANVAS'])):
          temp_settings[entry] = settings['CANVAS'][entry]
        else:
          temp_settings[entry] = 'linear'
      # also update x limits to have curves drawn over entire interval
      for entry in ['minX', 'maxX', 'minX_div', 'maxX_div']:
        if(('CANVAS' in settings) and (entry in settings['CANVAS'])):
          temp_settings[entry] = settings['CANVAS'][entry]
      self.plotArea.restoreState(temp_settings, updateTicks=False)

      # count data sets and curves already present
      zoffsetData = len(self.data)
      zoffsetCurve = len(self.fit)
      zoffsetResid = zoffsetData
      zoffsetExtras = len(self.extras)
      zoffset = zoffsetData + zoffsetCurve
  
      # data sets
      # helper function for sort routine
      def itemSort(a, b):
        # first try converting to integer
        try:
          ia, ib = a.split('_')[-1], b.split('_')[-1]
          ia = int(ia)
          ib = int(ib)
          return (ia > ib) - (ia < ib)
        except:
          return (a > b) - (a < b)

      duplicateItems = []
      datasets = [i for i in settings if i.startswith('DATA')]
      datasets = sorted(datasets, key=cmp_to_key(itemSort))
      if(len(datasets)):
        for entry in datasets:
          data = ''.join(settings[entry])
          try:
            data = literal_eval(data)
            # need to restore 'inf' as they did not correctly propagate through ast.literal_eval
            for key in data:
              if(type(data[key]) == list):
                data[key] = [np.inf if (i == 'np.inf') else i for i in data[key]]
                data[key] = [-np.inf if (i == '-np.inf') else i for i in data[key]]
            # generate new data set
            self.data.append(DataObject(self))
            # and restore values
            if(self.discard):
              useZoffsetCurve = 0
            else:
              useZoffsetCurve = zoffsetCurve
            self.data[-1].restoreState(data, zoffset, zoffsetResid, useZoffsetCurve)
            # cause data to be drawn
            self.data[-1].drawMe(redraw=False, rescale=False)
            # also create a new resid object
            self.data[-1].drawMeResid(redraw=False, rescale=False)
            # mark for split
            duplicateItems.append(self.data[-1])
          except:
            self.statusbar.showMessage('Failed to restore data set!', self.STATUS_TIME)
            print('Failed to restore data set', data)
          
      # curve sets
      curvesets = [i for i in settings if i.startswith('CURVE')]
      curvesets = sorted(curvesets, key=cmp_to_key(itemSort))
      if(len(curvesets)):
        for entry in curvesets:
          data = ''.join(settings[entry])
          try:
            # evaluate data
            data = literal_eval(data)
            # need to restore 'inf' as they did not correctly propagate through ast.literal_eval
            for key in data:
              if(type(data[key]) == list):
                data[key] = [np.inf if (i == 'np.inf') else i for i in data[key]]
                data[key] = [-np.inf if (i == '-np.inf') else i for i in data[key]]
            # generate new data set
            self.fit.append(FitObject(self))
            # and restore values
            self.fit[-1].restoreState(data, zoffset)
            # cause data to be drawn
            self.fit[-1].drawMe(redraw=False, rescale=False)
            # mark for split
            duplicateItems.append(self.fit[-1])
          except:
            self.statusbar.showMessage('Failed to restore curve!', self.STATUS_TIME)
            print('Failed to restore curve', data)
      
      # extras!
      failedImportExtras = []
      extras = [i for i in settings if i.startswith('EXTRAS')]
      extras = sorted(extras, key=lambda k: k.split('_')[-1])
      if(len(extras)):
        for entry in extras:
          data = ''.join(settings[entry])
          try:
            # generate new data set -- need to do this first in case it fails (keep track on correct extras count)
            self.extras.append(ExtrasObject(self))
            # evaluate data
            data = literal_eval(data)
            # and restore values
            self.extras[-1].restoreState(data, zoffset)
            # cause data to be drawn
            self.extras[-1].drawMe(redraw=False)
            # mark for split
            duplicateItems.append(self.extras[-1])
          except:
            self.statusbar.showMessage('Failed to restore extra object!', self.STATUS_TIME)
            print('Failed to restore extra object', data)
            failedImportExtras.append(len(self.extras) - 1)
      
      if((len(datasets)) or (len(curvesets))):
        # update legend
        self.objectsarea.updateLegend(redraw=False)
        
      # objects tab
      if('OBJECTS' in settings):
        self.objectsarea.restoreState(settings['OBJECTS'], zoffsetData, zoffsetCurve, zoffsetExtras, zoffsetResid)
      
      # data area tab
      if('IMPORTTABLE' in settings):
        self.dataarea.restoreState(settings['IMPORTTABLE'])
      
      # global area tab
      if('GLOBAL' in settings):
        self.globalarea.restoreState(settings['GLOBAL'])
      
      # call canvas comes last to update certain settings
      if('CANVAS' in settings):
        self.plotArea.restoreState(settings['CANVAS'])
        
      # check at this point whether we have splitY axis
      if(self.plotArea.splitY):
        for item in duplicateItems:
          if(item.visibility):
            if(not hasattr(item, 'onBothAxes')):
              # for older state files that don't know this setting
              item.onBothAxes = True
            item.duplicateForSplit()

      # also need to enable zoom on splitY axis and deal w/ cursors
      self.plotArea.toggleSplitYHelper(state=self.plotArea.splitY)
        
      # apply canvas and graphics last to counteract autozoom when generating data and fits
      if('GRAPHICS' in settings):
        red = ''
        for key in settings['GRAPHICS']:
          red += '>>>' + key + '\n'
          red += repr(settings['GRAPHICS'][key]) + '\n'
        self.graphicsarea.processStyleSet(operation='load', modus=red, zoffsetData=zoffsetData,\
                                          zoffsetCurve=zoffsetCurve, redraw=False, rescale=False)

      # very finally check whether state file contained a message to display
      if('MESSAGE' in settings):
        self.displayMessage(settings['MESSAGE'])
        
      # delete extras that failed to import
      for entry in failedImportExtras[::-1]:
        self.objectsarea.deleteExtra(entry, redraw=False)
      
      # delete initial data and curve objects
      if(self.discard):
        # delete surplus fit objects
        numberFit = min(numberFit, len(self.fit) - 1)
        for entry in range(numberFit)[::-1]:
          self.objectsarea.deleteCurve(entry, redraw=False)
        # delete surplus data objects
        numberData = min(numberData, len(self.data) - 1)
        for entry in range(numberData)[::-1]:
          self.objectsarea.deleteDataSet(entry, redraw=False)
        # delete surplus extra objects
        for entry in range(numberExtras)[::-1]:
          self.objectsarea.deleteExtra(entry, redraw=False)

      # and again call canvas comes last to preserve axis settings
      if('CANVAS' in settings):
        self.plotArea.restoreState(settings['CANVAS'])
        
      # set advanced settings
      if('ADVANCED' in settings):
        self.graphicsarea.advancedExport.update(settings['ADVANCED'])
        if('advancedGraphics' in settings['ADVANCED']):
          value = settings['ADVANCED']['advancedGraphics']
          self.graphicsarea.setAdvancedGraphics(value)
          self.graphicsarea2.setAdvancedGraphics(value)
          self.graphicsarea.configAdvancedSettingsButton.setChecked(value)
        
      # set advanced settings
      if('ADVANCED_MIN' in settings):
        self.fitarea.advancedMinimization.update(settings['ADVANCED_MIN'])
        self.globalarea.advancedMinimization.update(settings['ADVANCED_MIN'])
        
      # set advanced settings
      if('ADVANCED_RANDOM' in settings):
        self.fitarea.advancedRandomSearch.update(settings['ADVANCED_RANDOM'])
        self.globalarea.advancedRandomSearch.update(settings['ADVANCED_RANDOM'])
        
      # check whether we have items on the second axes
      self.objectsarea.checkSecondAxes()
        
      # restore discardCheck when loading state on startup
      if((stateFile != None) and (not dropEvent)):
        self.discardCheck = True
        self.discard = False
        
      # finally refresh plots
      try:
        self.plotArea.dataplotwidget.myRefresh()
      except:
        # implement extra check for bad fonts in state file
        safeFont = 'DejaVu Sans'
        # x and y axes
        _, _, descent = self.plotArea.ax.xaxis.label._get_layout(self.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.plotArea.setAxisFont(value=safeFont, axis='x', redraw=True, target='plot')
        _, _, descent = self.plotArea.ax.yaxis.label._get_layout(self.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.plotArea.setAxisFont(value=safeFont, axis='y', redraw=True, target='plot')
          
        # x ticks
        flag = False
        tickLabels = self.plotArea.ax.get_xticklabels()
        for entry in tickLabels:
          _, _, descent = entry._get_layout(self.plotArea.matplot.canvas.renderer)
          if(not (descent > 0)):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='x', redraw=True, target='plot')
          
        # y ticks
        flag = False
        tickLabels = self.plotArea.ax.get_yticklabels()
        for entry in tickLabels:
          _, _, descent = entry._get_layout(self.plotArea.matplot.canvas.renderer)
          if(not (descent > 0)):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='y', redraw=True, target='plot')
          
        # legend (get_layout trick won't work here ... would need to draw extra text ... too complicated)
        # this is easier if clumsy
        probeFont = self.plotArea.legendLabelFont; self.plotArea.legendLabelFont = safeFont
        self.plotArea.setLegendLabelFont(value=probeFont, redraw=True, target='plot')
        
        # now also need to check extras
        for entry in self.extras:
          if(entry.handle != None):
            _, _, descent = entry.handle._get_layout(self.plotArea.matplot.canvas.renderer)
            if(not (descent > 0)):
              entry.handle.set_fontname(safeFont)
              try:
                self.plotArea.dataplotwidget.myRefresh()
              except:
                pass
        
      try:        
        self.plotArea.residplotwidget.myRefresh()
      except:
        # implement extra check for bad fonts in state file
        safeFont = 'DejaVu Sans'
        # x and y axes
        _, _, descent = self.plotArea.ax_resid.xaxis.label._get_layout(self.plotArea.residplot.canvas.renderer)
        if(not (descent > 0)):
          self.plotArea.setAxisFont(value=safeFont, axis='x', redraw=True, target='resid')
        _, _, descent = self.plotArea.ax_resid.yaxis.label._get_layout(self.plotArea.residplot.canvas.renderer)
        if(not (descent > 0)):
          self.plotArea.setAxisFont(value=safeFont, axis='y', redraw=True, target='resid')
          
        # x ticks
        flag = False
        tickLabels = self.plotArea.ax_resid.get_xticklabels()
        for entry in tickLabels:
          _, _, descent = entry._get_layout(self.plotArea.residplot.canvas.renderer)
          if(not (descent > 0)):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='x', redraw=True, target='resid')
          
        # y ticks
        flag = False
        tickLabels = self.plotArea.ax_resid.get_yticklabels()
        for entry in tickLabels:
          _, _, descent = entry._get_layout(self.plotArea.residplot.canvas.renderer)
          if(not (descent > 0)):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='y', redraw=True, target='resid')

      # check version of save file
      if('VERSION' in settings):
        if(len(settings['VERSION'])):
          savedVersion = settings['VERSION'][0].split('.')
          try:
            savedVersion = int(savedVersion[-1])
            currVersion = int(VERSION.split('.')[-1])
            if(savedVersion > currVersion):
              self.statusbar.showMessage('Fyi, state file was generated in a later program version (0.' + str(savedVersion) + ') than the current one (' + VERSION + ').', self.STATUS_TIME, color='blue')
          except:
            pass

      # restore original pointer
      QtWidgets.QApplication.restoreOverrideCursor()

  def saveState(self, errorstring=''):
    global REMEMBERDIR
    # exports current settings and data
    filter_options = ['State file (*.statez; *.state)', 'All files (*.*)']
    filterstring = ';;'.join(filter_options)
    # get save file name
    usedir = REMEMBERDIR
    if(self.currStateFile != None):
      usedir = self.currStateFile
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, filter = filterstring, directory=usedir, caption='Save State')
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)

    if(filename != ''):
      # use StringIO to write memory file
      memoryFile = io.StringIO()
      # save version info
      memoryFile.write('<VERSION>\n' + VERSION + '\n</VERSION>\n\n')
      # do we have an error string to report
      if(len(errorstring)):
        memoryFile.write('<ERROR>\n' + errorstring + '\n</ERROR>\n\n')
      # process canvas
      memoryFile.write('<CANVAS>\n')
      settings = self.plotArea.reportState()
      for key in settings:
        red = '>>>' + key + '\n' + repr(settings[key]) + '\n'
        memoryFile.write(red)
      memoryFile.write('</CANVAS>\n')
      
      # process objects tab
      memoryFile.write('\n<OBJECTS>\n')
      objects = self.objectsarea.reportState()
      memoryFile.write(objects)
      memoryFile.write('</OBJECTS>\n')
      
      # process graphics tab
      memoryFile.write('\n<GRAPHICS>\n')
      settings = self.graphicsarea.processStyleSet(operation='save', modus='string')
      memoryFile.write(settings)
      memoryFile.write('</GRAPHICS>\n')
      
      # process data area
      memoryFile.write('\n<IMPORTTABLE>\n')
      dataTable = self.dataarea.reportState()
      memoryFile.write(repr(dataTable) + '\n')
      memoryFile.write('</IMPORTTABLE>\n')
      
      # process global tab
      memoryFile.write('\n<GLOBAL>\n')
      globalstate = self.globalarea.reportState()
      memoryFile.write(globalstate)
      memoryFile.write('</GLOBAL>\n')
      
      # write all data and fit objects
      for index, entry in enumerate(self.data):
        memoryFile.write('\n<DATA_' + str(index) + '>\n')
        data = entry.reportState()
        data = self.replaceInf(repr(data))
        memoryFile.write(data + '\n')
        memoryFile.write('</DATA_' + str(index) + '>\n')
  
      for index, entry in enumerate(self.fit):
        memoryFile.write('\n<CURVE_' + str(index) + '>\n')
        curve = entry.reportState()
        curve = self.replaceInf(repr(curve))
        memoryFile.write(curve + '\n')
        memoryFile.write('</CURVE_' + str(index) + '>\n')
  
      # write all extra objects
      for index, entry in enumerate(self.extras):
        memoryFile.write('\n<EXTRAS_' + str(index) + '>\n')
        extras = repr(entry.reportState())
        memoryFile.write(extras + '\n')
        memoryFile.write('</EXTRAS_' + str(index) + '>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED>\n')
      for entry in self.graphicsarea.advancedExport:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.graphicsarea.advancedExport[entry]) + '\n')
      memoryFile.write('</ADVANCED>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED_MIN>\n')
      for entry in self.fitarea.advancedMinimization:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.fitarea.advancedMinimization[entry]) + '\n')
      memoryFile.write('</ADVANCED_MIN>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED_RANDOM>\n')
      for entry in self.fitarea.advancedRandomSearch:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.fitarea.advancedRandomSearch[entry]) + '\n')
      memoryFile.write('</ADVANCED_RANDOM>\n')
  
      # prepare file output
      success = False
      if(self.graphicsarea.advancedExport['stateFileFormat'] in ['both', 'state']):
        # save regular state file
        try:
          if(filename.endswith('.state')):
            writehandle = open(filename, 'w', encoding='utf-8')
          else:
            writehandle = open(filename + '.state', 'w', encoding='utf-8')
          writehandle.write(memoryFile.getvalue())
        except:
          self.statusbar.showMessage('Cannot save state file ' + filename, self.STATUS_TIME)
        else:
          writehandle.close()
          success = True
        
      if(self.graphicsarea.advancedExport['stateFileFormat'] in ['both', 'statez']):
        # now zip this file
        try:
          if(filename.endswith('.state')):
            ziphandle = zipfile.ZipFile(filename + 'z', 'w', zipfile.ZIP_DEFLATED)
          elif(filename.endswith('.statez')):
            ziphandle = zipfile.ZipFile(filename, 'w', zipfile.ZIP_DEFLATED)
          else:
            ziphandle = zipfile.ZipFile(filename + '.statez', 'w', zipfile.ZIP_DEFLATED)
          if(PATH_SEPARATOR in filename):
            storeName = filename.split(PATH_SEPARATOR)[-1]
          else:
            storeName = filename.split('/')[-1]
          storeName = storeName.replace('.statez', '.state')
          ziphandle.writestr(storeName, memoryFile.getvalue())
        except:
          self.statusbar.showMessage('Cannot save state file ' + filename, self.STATUS_TIME)
        else:
          ziphandle.close()
          success = True
        
      if(success):
        # save filename for future reference
        self.currStateFile = filename
        # update window title if successful
        self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION + ' -- ' + filename)

  def replaceInf(self, literal):
    # function to replace any 'inf' by 'np.inf' (otherwise data cannot be loaded again)
    literal = literal.replace('-inf]', '\'-np.inf\']')
    literal = literal.replace('-inf,', '\'-np.inf\',')
    literal = literal.replace('inf]', '\'np.inf\']')
    literal = literal.replace('inf,', '\'np.inf\',')
    # and replace nan
    literal = literal.replace('nan]', '\'np.nan\']')
    literal = literal.replace('nan,', '\'np.nan\',')
    return literal
    
  def showHelp(self):
    # display help file in browser
    helpFile = WORKINGDIR + PATH_SEPARATOR + 'manual' + PATH_SEPARATOR + 'Fit-o-mat.html'
    try:
      readhandle = open(helpFile, 'r', encoding='utf-8')
      readhandle.close()
    except:
      self.statusbar.showMessage('Cannot locate local copy of help files, redirecting to homepage!', self.STATUS_TIME)
      helpFile = 'http://www.moeglich.uni-bayreuth.de/en/fit-o-mat'
    webbrowser.open(helpFile)

  def aboutInfo(self):
    # display information on canvas
    self.plotArea.drawAboutLogo()
    
  def advancedOption(self, callButton=None):
    # opens menu to access advanced configuration options
    self.menu = OptionMenu(self)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # bottom align position of QMenu
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    menuX -= self.menu.width() / 2
    menuY -= self.menu.height()
    menuX, menuY = max(menuX, 0), max(menuY, 0)
    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def displayMessage(self, message=''):
    # displays message contained in state file
    if(len(message)):
      messageText = '\n'.join(message)
      # open window that displays message
      self.daughterWindow = QtWidgets.QMainWindow()
      self.daughterWindow.setWindowTitle('Message Window')
      
      self.centralwidget = QWidgetMac(self.daughterWindow)
      self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(320), scaledDPI(240)))
      self.daughterWindow.setCentralWidget(self.centralwidget)
      
      self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
      self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
      self.vLayout.setContentsMargins(0, 0, 0, 0)

      self.messageField = QtWidgets.QTextBrowser()
      self.messageField.setOpenExternalLinks(True)
      self.messageField.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
      self.vLayout.addWidget(self.messageField)
      self.messageField.setReadOnly(True)
      self.messageField.setHtml(messageText)
      
      # apply styles and show
      if(QSTYLE != None):
        self.daughterWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.daughterWindow.setStyleSheet(QSTYLESHEET)
      self.daughterWindow.show()
      
      # adjust window position and size
      winWidth, winHeight = self.daughterWindow.geometry().width(), self.MainWindow.geometry().height()
      self.daughterWindow.resize(winWidth, winHeight)
      winX, winY = self.daughterWindow.geometry().x(), self.MainWindow.geometry().y()
      self.daughterWindow.move(winX, winY)

  def formatPairedNumbers(self, n1, n2):
    # formats numbers for output while successively increasing precision to make resultant strings different
    NUMBER_SWITCH = 1e3
    DECIMAL_PRECISION = 4
    SCIENTIFIC_PRECISION = 3
    # check whether numbers are real
    real1, real2 = False, False
    if((self.isNumber(n1)) and (np.isfinite(float(n1)))):
      real1 = True
    if((self.isNumber(n2)) and (np.isfinite(float(n2)))):
      real2 = True
    # determine paired numbers
    if(real1 and real2 and (n1 != n2)):
      continueFlag = True
      while(continueFlag):
        # generate current formats
        FORMAT_DECIMAL = '{:.' + str(DECIMAL_PRECISION) + 'f}'
        FORMAT_SCIENTIFIC = '{:.' + str(SCIENTIFIC_PRECISION) + 'e}'
        numberstr = []
        for number in [n1, n2]:
          if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
            numberstr.append(FORMAT_SCIENTIFIC.format(number))
          else:
            numberstr.append(FORMAT_DECIMAL.format(number))
        # check whether strings are  still equal
        if(numberstr[0] == numberstr[1]):
          DECIMAL_PRECISION +=1
          SCIENTIFIC_PRECISION += 1
        else:
          continueFlag = False
          n1str, n2str = numberstr[0], numberstr[1]
    else:
      n1str, n2str = self.formatNumber(n1), self.formatNumber(n2)

    return n1str, n2str
    
  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.4f}'
    FORMAT_SCIENTIFIC = '{:.3e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

class MyForm(QtWidgets.QMainWindow):
  def __init__(self, parent=None):
    QtWidgets.QWidget.__init__(self, parent)
    # adjust DPI scaling
    global DPI_SCALING
    self.targetDPI = 96
    actualDPI = QtGui.QPaintDevice.logicalDpiX(self)
    DPI_SCALING = 1.0 * actualDPI / self.targetDPI
    self.ui = Ui_MainWindow()
    self.ui.setupUi(MainWindow=self)

    # enable drop event
    self.setAcceptDrops(True)
    
    # initialize tooltip toggle
    self.toolTipsShow = True
    
  def dropEvent(self, event):
    self.ui.handleDropEvent(event.mimeData())
    event.accept()

  # we must handle dragEnter and dragMove lest we cannot detect the dropEvent
  def dragEnterEvent(self, event):
    event.accept()

  def dragMoveEvent(self, event):
    event.accept()

  def closeEvent(self, event):
    msgBox = QtWidgets.QMessageBox()
    msgBox.setWindowTitle('Fit-o-mat')
    msgBox.setText('Close program?')
    msgBox.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    msgBox.setDefaultButton(QtWidgets.QMessageBox.Yes)
    msgBox.setIcon(QtWidgets.QMessageBox.Question)
    # apply styles and show
    if(QSTYLE != None):
      msgBox.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      msgBox.setStyleSheet(QSTYLESHEET)
    reply = msgBox.exec_()
    if (reply == QtWidgets.QMessageBox.Yes):
      # check whether message window exists and close it
      if(hasattr(self.ui, 'daughterWindow')):
        self.ui.daughterWindow.close()
      # check whether preview window exists and close it
      if(hasattr(self.ui, 'previewWindow')):
        self.ui.previewWindow.close()
      # check whether covar window exists and close it
      if(hasattr(self.ui, 'covarWindow')):
        self.ui.covarWindow.close()
      event.accept()
    else:
      event.ignore()

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Save):
      # trigger save state on CTRL-S
      self.ui.saveState(errorstring='')
    elif event.matches(QtGui.QKeySequence.Open):
      # trigger load state on CTRL-O
      self.ui.loadState()
    elif event.matches(QtGui.QKeySequence.HelpContents):
      # trigger help
      self.ui.showHelp()
    elif event.matches(QtGui.QKeySequence.Print):
      # export graphics on CTRL-P
      self.ui.graphicsarea.exportThis()
    elif event.matches(QtGui.QKeySequence.Quit):
      # close program on CTRL-Q
      self.close()
    elif event.matches(QtGui.QKeySequence.Italic):
      # hijack control-I to load new data file and switch to data tab
      retv = self.ui.dataarea.loadData()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(0)
    elif event.matches(QtGui.QKeySequence.ZoomIn):
      # zoom canvas
      self.ui.plotArea.incZoomLevel(increment=-1)
    elif event.matches(QtGui.QKeySequence.ZoomOut):
      # zoom canvas
      self.ui.plotArea.incZoomLevel(increment=1)
    elif event.matches(QtGui.QKeySequence.Find):
      # fit data and switch to fit tab
      retv = self.ui.fitarea.doFit()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(1)
    elif event.matches(QtGui.QKeySequence.New):
      # fit data and switch to fit tab
      retv = self.ui.fitarea.doMin()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(1)
    elif event.matches(QtGui.QKeySequence.Refresh):
      # display preview window
      self.ui.graphicsarea.previewThis()
    elif event.matches(QtGui.QKeySequence.FindNext):
      # generate report
      self.ui.graphicsarea.reportThis()

def scaledDPI(size):
  # adjusts GUI dimensions to correct for DPI
  # implement check for array
  return int(size * DPI_SCALING)

def switchTab(index=0):
  # switches to target tab (handler for keyboard shortcut)
  if(0 <= index < myapp.ui.tabWidget.count()):
    myapp.ui.tabWidget.setCurrentIndex(index)

def criticalFailure(exctype, value, traceback):
  # global except hook for uncaught exceptions as a last ressort
  # => allow dumping of state file to salvage bits
  # determine error information to print and save in file
  errorstring = repr(value)
  if(errorstring.startswith('ValueError(\'zero-size array')):
    # catch and ignore sporadic recursive repaint error
    # this is but a fudge, we should at some point pinpoint and weed out this error
    pass
  else:
    try:
      errorstring = repr(traceback.tb_next.tb_lineno) + '\t' + errorstring
    except:
      pass
  
    # display final dialogue
    msgBox = QtWidgets.QMessageBox()
    msgBox.setWindowTitle('Critical failure Fit-o-mat')
    text = '<span style="white-space:nowrap;text-align:center;">Oooops, a fatal error occurred.<br>It is advised to terminate the program.<br>(You can also ignore the failure but this is definitely not recommended.)<br><br>'
    text += '<b>\u2192 You should save state file NOW! \u2190</b>'
    usestring = 'version ' + VERSION + '\n' + errorstring.replace('"', '&quot;')
    text += '<br>(Ideally, then send state file to <a href="mailto:andreas.moeglich@uni-bayreuth.de?subject=[Fit-o-mat -- Bug Report]&body=' + usestring + '">A.M.</a> for review.)</span>'
    msgBox.setText(text)
    msgBox.setStandardButtons(QtWidgets.QMessageBox.Save | QtWidgets.QMessageBox.Abort | QtWidgets.QMessageBox.Ignore)
    msgBox.setDefaultButton(QtWidgets.QMessageBox.Save)
    msgBox.setIcon(QtWidgets.QMessageBox.Critical)
    # apply styles and show
    if(QSTYLE != None):
      msgBox.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      msgBox.setStyleSheet(QSTYLESHEET)
      
    # get user click
    reply = ''
    while(reply not in [ QtWidgets.QMessageBox.Abort, QtWidgets.QMessageBox.Ignore]):
      reply = msgBox.exec_()
      if (reply == QtWidgets.QMessageBox.Save):
        myapp.ui.saveState(errorstring=errorstring)
  
    if(reply == QtWidgets.QMessageBox.Ignore):
      myapp.ui.statusbar.showMessage('Warning -- program may run unstably after ignoring critical failure!', myapp.ui.STATUS_TIME)
    else:
      # kill the program
      print('This is what killed me in the end ...\n', errorstring)
      
      # execute original except hook
      originalhook(exctype, value, traceback)
      # exit if still running
      sys.exit(1)
  
if __name__ ==  "__main__":
  # suppress warnings (e.g. missing font glyph)
  # missing glyphs still produce output to stdout even though warning is suppressed
  # short of suppressing redirecting entire stdout, not easy to suppress => live with it
  warnings.simplefilter('ignore')

  # are we on win or linux platform?
  if((platform == 'linux') or (platform == 'darwin')):
    PATH_SEPARATOR = '/'
  else:
    PATH_SEPARATOR = '\\'
    
  # determine working directories
  if((len(path)) and (len(path[0]))):
    WORKINGDIR = path[0]
  else:
    WORKINGDIR = '.'
  HOMEDIR = expanduser('~')
  REMEMBERDIR = HOMEDIR
  
  # set name of temp. preview file
  TEMP_PREVIEWFILE = 'temp_fit-o-mat_preview.png'
  
  # check for command line arguments
  STATEFILE = ''; grabNext = False; grabReal = False; WIDGET_FONTSIZE = '8'
  if(len(argv) > 1):
    for argument in argv[1:]:
      if(argument.startswith('-')):
        grabNext = True
        if(argument.startswith('-font')):
          grabReal = True
      elif(grabNext):
        grabNext = False
        # enable dynamic font sizing under Linux
        if(grabReal):
          try:
            float(argument)
            WIDGET_FONTSIZE = str(argument)
          except:
            pass
          grabReal = False
      elif(STATEFILE == ''):
        STATEFILE = argument
  
  # define custom markers
  CUSTOM_MARKERS = {'dag': '$\u2020$', 'ddag': '$\u2021$', 'spade': '$\u2664$', 'fllspd': '$\spadesuit$', 'heart': '$\u2661$', 'fllhrt': '$\u2665$', 'club': '$\u2667$', 'fllclb': '$\clubsuit$',
                    'diamond': '$\diamondsuit$', 'flldmnd': '$\u2666$', 'oslash': '$\oslash$', 'ocross': '$\u2297$', 'owheel': '$\u229b$', 'xdot': '$\u203b$', '+dot': '$\u205c$',
                    'female': '$\u2640$', 'male': '$\u2642$', 'ostar': '$\u272a$', 'malt': '$\u2720$', 'ankh': '$\u2625$', 'smile': '$\u263b$',
                    'skull': '$\u2620$', 'biohzd': '$\u2623$', 'flag': '$\u2691$', 'target': '$\u2316$',
                    'benzene': '$\u232c$'}
  # parsed with svgpath2mpl (thanks!!)
  pac = matplotlib.path.Path([[ -4.57334163e-07,   1.00000000e+00],
       [ -1.31319357e-01,   1.00000045e+00], [ -2.61361423e-01,   9.74133816e-01], [ -3.82684344e-01,   9.23880437e-01], [ -5.04007266e-01,   8.73627058e-01],
       [ -6.14251596e-01,   7.99964248e-01], [ -7.07108048e-01,   7.07107732e-01], [ -7.99964500e-01,   6.14251215e-01], [ -8.73627234e-01,   5.04006835e-01],
       [ -9.23880529e-01,   3.82683879e-01], [ -9.74133825e-01,   2.61360922e-01], [ -1.00000037e+00,   1.31318839e-01], [ -9.99999828e-01,  -6.09627091e-08],
       [ -1.00000030e+00,  -1.31318912e-01], [ -9.74133693e-01,  -2.61360934e-01], [ -9.23880364e-01,  -3.82683824e-01], [ -8.73627035e-01,  -5.04006714e-01],
       [ -7.99964290e-01,  -6.14251026e-01], [ -7.07107845e-01,  -7.07107482e-01], [ -6.14251400e-01,  -7.99963938e-01], [ -5.04007096e-01,  -8.73626696e-01],
       [ -3.82684212e-01,  -9.23880039e-01], [ -2.61361327e-01,  -9.74133382e-01], [ -1.31319309e-01,  -1.00000000e+00], [ -4.57327544e-07,  -9.99999547e-01],
       [  1.67377288e-01,  -9.99798760e-01], [  3.32056481e-01,  -9.57577983e-01], [  4.78883935e-01,  -8.77222221e-01], [  6.25711390e-01,  -7.96866459e-01],
       [  7.50041091e-01,  -6.80918384e-01], [  8.40432667e-01,  -5.40047121e-01], [  2.30754229e-01,  -6.53483713e-01], [ -1.62094774e-01,  -2.70024166e-01],
       [ -1.47296937e-01,  -1.77718060e-01], [ -1.27785774e-01,  -2.16696348e-01], [  5.63238397e-01,  -2.84483501e-01], [  9.93759973e-01,  -1.08050406e-01],
       [  9.99999285e-01,   1.31318824e-01], [  9.74132743e-01,   2.61360894e-01], [  9.23879459e-01,   3.82683839e-01], [  8.73626174e-01,   5.04006784e-01],
       [  7.99963456e-01,   6.14251157e-01], [  7.07107022e-01,   7.07107671e-01], [  6.14250588e-01,   7.99964185e-01], [  5.04006278e-01,   8.73626998e-01],
       [  3.82683377e-01,   9.23880387e-01], [  2.61360475e-01,   9.74133777e-01], [  1.31318428e-01,   1.00000043e+00], [ -4.57338189e-07,   1.00000000e+00],
       [ -4.57334163e-07,   1.00000000e+00], [  2.61853154e-01,   6.53803236e-01], [  3.17592952e-01,   6.53801526e-01], [  3.71106303e-01,   6.31634574e-01],
       [  4.10520248e-01,   5.92220543e-01], [  4.49934194e-01,   5.52806511e-01], [  4.72101029e-01,   4.99293111e-01], [  4.72102617e-01,   4.43553314e-01],
       [  4.72100876e-01,   3.87813616e-01], [  4.49933974e-01,   3.34300365e-01], [  4.10520045e-01,   2.94886457e-01], [  3.71106116e-01,   2.55472549e-01],
       [  3.17592852e-01,   2.33305677e-01], [  2.61853154e-01,   2.33303967e-01], [  2.06113447e-01,   2.33305661e-01], [  1.52600168e-01,   2.55472527e-01],
       [  1.13186226e-01,   2.94886437e-01], [  7.37722849e-02,   3.34300346e-01], [  5.16053750e-02,   3.87813606e-01], [  5.16036345e-02,   4.43553314e-01],
       [  5.16052226e-02,   4.99293121e-01], [  7.37720652e-02,   5.52806530e-01], [  1.13186023e-01,   5.92220563e-01], [  1.52599981e-01,   6.31634596e-01],
       [  2.06113347e-01,   6.53801542e-01], [  2.61853154e-01,   6.53803236e-01], [  2.61853154e-01,   6.53803236e-01],
       [  2.61853154e-01,   6.53803236e-01]], [ 1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  1,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  1,  4,  4,  4,  4,  4,  1,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  1, 79,  1,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  2, 79])
  ghost = matplotlib.path.Path([[  1.70144218e-05,   1.00000000e+00],
       [ -1.89252585e-01,   9.99902986e-01], [ -3.71050753e-01,   9.25162344e-01], [ -5.05658763e-01,   7.92107188e-01], [ -6.40266773e-01,   6.59052032e-01],
       [ -7.17111726e-01,   4.78133291e-01], [ -7.19404763e-01,   2.88877558e-01], [ -7.19846940e-01,   2.80170075e-01], [ -7.19846940e-01,  -7.40170066e-01],
       [ -6.70758522e-01,  -8.43356038e-01], [ -6.47629357e-01,  -1.00000000e+00], [ -5.48452382e-01,  -1.00000000e+00], [ -4.00686376e-01,  -1.00000000e+00],
       [ -4.21966629e-01,  -6.51700680e-01], [ -2.74200677e-01,  -6.51700680e-01], [ -1.26434534e-01,  -6.51700680e-01], [ -1.47749007e-01,  -1.00000000e+00],
       [  1.70144218e-05,  -1.00000000e+00], [  1.47783001e-01,  -1.00000000e+00], [  1.26468737e-01,  -6.51700680e-01], [  2.74234688e-01,  -6.51700680e-01],
       [  4.22000710e-01,  -6.51700680e-01], [  4.00686428e-01,  -1.00000000e+00], [  5.48452380e-01,  -1.00000000e+00], [  6.47607832e-01,  -1.00000000e+00],
       [  6.70780639e-01,  -8.43425350e-01], [  7.19846940e-01,  -7.40238089e-01], [  7.19846940e-01,   2.80170075e-01], [  7.17247557e-01,   4.78150916e-01],
       [  6.40388501e-01,   6.59085018e-01], [  5.05758522e-01,   7.92143020e-01], [  3.71128542e-01,   9.25201022e-01], [  1.89304252e-01,   9.99929806e-01],
       [  1.70144218e-05,   1.00000000e+00], [ -2.63928564e-01,   4.27789113e-01], [ -2.12132956e-01,   4.27785942e-01], [ -1.62406707e-01,   4.07186871e-01],
       [ -1.25781682e-01,   3.70561846e-01], [ -8.91566563e-02,   3.33936821e-01], [ -6.85575857e-02,   2.84210571e-01], [ -6.85544141e-02,   2.32414964e-01],
       [ -6.85575857e-02,   1.80619356e-01], [ -8.91566563e-02,   1.30893107e-01], [ -1.25781682e-01,   9.42680815e-02], [ -1.62406707e-01,   5.76430563e-02],
       [ -2.12132956e-01,   3.70439857e-02], [ -2.63928564e-01,   3.70408141e-02], [ -2.89587283e-01,   3.70379165e-02], [ -3.14997058e-01,   4.20894226e-02],
       [ -3.38703605e-01,   5.19062187e-02], [ -3.62410152e-01,   6.17230147e-02], [ -3.83952409e-01,   7.61141761e-02], [ -4.02097444e-01,   9.42560505e-02],
       [ -4.20242478e-01,   1.12397925e-01], [ -4.34637391e-01,   1.33937675e-01], [ -4.44458315e-01,   1.57642513e-01], [ -4.54279240e-01,   1.81347350e-01],
       [ -4.59335171e-01,   2.06756245e-01], [ -4.59336742e-01,   2.32414964e-01], [ -4.59335171e-01,   2.58073683e-01], [ -4.54279240e-01,   2.83482578e-01],
       [ -4.44458315e-01,   3.07187415e-01], [ -4.34637391e-01,   3.30892252e-01], [ -4.20242478e-01,   3.52432003e-01], [ -4.02097444e-01,   3.70573877e-01],
       [ -3.83952409e-01,   3.88715752e-01], [ -3.62410152e-01,   4.03106913e-01], [ -3.38703605e-01,   4.12923709e-01], [ -3.14997058e-01,   4.22740505e-01],
       [ -2.89587283e-01,   4.27792011e-01], [ -2.63928564e-01,   4.27789113e-01], [ -2.63928564e-01,   4.27789113e-01], [  2.63928564e-01,   4.27789113e-01],
       [  2.89587282e-01,   4.27792009e-01], [  3.14997056e-01,   4.22740501e-01], [  3.38703602e-01,   4.12923704e-01], [  3.62410149e-01,   4.03106907e-01],
       [  3.83952405e-01,   3.88715746e-01], [  4.02097439e-01,   3.70573872e-01], [  4.20242472e-01,   3.52431998e-01], [  4.34637385e-01,   3.30892249e-01],
       [  4.44458311e-01,   3.07187412e-01], [  4.54279236e-01,   2.83482576e-01], [  4.59335169e-01,   2.58073682e-01], [  4.59336742e-01,   2.32414964e-01],
       [  4.59335169e-01,   2.06756245e-01], [  4.54279236e-01,   1.81347352e-01], [  4.44458311e-01,   1.57642515e-01], [  4.34637385e-01,   1.33937679e-01],
       [  4.20242472e-01,   1.12397930e-01], [  4.02097439e-01,   9.42560556e-02], [  3.83952405e-01,   7.61141816e-02], [  3.62410149e-01,   6.17230202e-02],
       [  3.38703602e-01,   5.19062233e-02], [  3.14997056e-01,   4.20894265e-02], [  2.89587282e-01,   3.70379188e-02], [  2.63928564e-01,   3.70408141e-02],
       [  2.12132958e-01,   3.70439903e-02], [  1.62406711e-01,   5.76430623e-02], [  1.25781687e-01,   9.42680866e-02], [  8.91566623e-02,   1.30893111e-01],
       [  6.85575903e-02,   1.80619358e-01], [  6.85544141e-02,   2.32414964e-01], [  6.85575903e-02,   2.84210570e-01], [  8.91566623e-02,   3.33936817e-01],
       [  1.25781687e-01,   3.70561841e-01], [  1.62406711e-01,   4.07186865e-01], [  2.12132958e-01,   4.27785937e-01], [  2.63928564e-01,   4.27789113e-01],
       [  2.63928564e-01,   4.27789113e-01]], [ 1,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  4,  4,  4,  4,  4,  1,
        1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4, 79,  1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4, 79])
  stark = matplotlib.path.Path([[ -1.35511295e-01,   9.50000000e-01], [ -1.36811295e-01,   8.94370102e-01],
       [ -9.52546968e-02,   8.37967504e-01], [ -3.20347989e-02,   7.81147506e-01], [ -1.67004794e-01,   7.51957507e-01], [ -2.90659690e-01,   7.62264206e-01],
       [ -3.99329587e-01,   8.25034304e-01], [ -3.76789687e-01,   7.74874306e-01], [ -3.36919789e-01,   7.33069007e-01], [ -2.79739791e-01,   6.99629008e-01],
       [ -4.14399786e-01,   6.47529010e-01], [ -5.43710412e-01,   6.46180710e-01], [ -6.67630428e-01,   6.95600608e-01], [ -6.42820429e-01,   6.58430610e-01],
       [ -5.97491480e-01,   6.21839211e-01], [ -5.29671462e-01,   5.85869212e-01], [ -7.03791457e-01,   5.13399215e-01], [ -8.35858732e-01,   4.88556815e-01],
       [ -8.92908760e-01,   5.48676813e-01], [ -8.78188731e-01,   5.07106815e-01], [ -8.15542653e-01,   4.73654916e-01], [ -7.23162686e-01,   4.45214917e-01],
       [ -8.06472683e-01,   4.16554918e-01], [ -1.01339843e+00,   3.41300720e-01], [ -1.10208840e+00,   4.08930818e-01], [ -1.07194845e+00,   3.63080720e-01],
       [ -1.01974628e+00,   3.27157521e-01], [ -9.53846258e-01,   2.97397522e-01], [ -1.01506628e+00,   2.67087523e-01], [ -1.08353948e+00,   2.50791823e-01],
       [ -1.14516945e+00,   2.40971824e-01], [ -1.20841950e+00,   2.30871824e-01], [ -1.26443018e+00,   2.27978524e-01], [ -1.29514021e+00,   2.54858523e-01],
       [ -1.26492023e+00,   2.10818525e-01], [ -1.21511993e+00,   1.77553726e-01], [ -1.14910995e+00,   1.53183727e-01], [ -1.28801993e+00,   5.50436298e-02],
       [ -1.37676990e+00,   5.15390299e-02], [ -1.44160995e+00,   9.31690286e-02], [ -1.37230995e+00,   2.23190309e-02], [ -1.29577013e+00,  -3.60972671e-02],
       [ -1.19660018e+00,  -5.55272665e-02], [ -1.20310013e+00,  -8.33672656e-02], [ -1.22570933e+00,  -7.45198658e-02], [ -1.24496933e+00,  -1.07499965e-01],
       [ -1.21687928e+00,  -1.10309865e-01], [ -1.19010128e+00,  -8.37583655e-02], [ -1.16301128e+00,  -9.04783653e-02], [ -1.20510128e+00,  -1.50648463e-01],
       [ -1.15316175e+00,  -1.98256462e-01], [ -1.21945170e+00,  -2.70976459e-01], [ -1.14806175e+00,  -2.73926459e-01], [ -1.18779375e+00,  -2.40202460e-01],
       [ -1.05332377e+00,  -2.47392460e-01], [ -1.03696381e+00,  -2.48262460e-01], [ -1.02066998e+00,  -2.43962260e-01], [ -9.96399977e-01,  -2.34692261e-01],
       [ -1.04550998e+00,  -3.39052357e-01], [ -9.87130357e-01,  -3.70861356e-01], [ -1.04430038e+00,  -4.71191253e-01], [ -1.03967288e+00,  -4.68811353e-01],
       [ -1.03506751e+00,  -4.66650853e-01], [ -1.03048688e+00,  -4.64672753e-01], [ -9.61777358e-01,  -4.35000654e-01], [ -8.98125380e-01,  -4.48105953e-01],
       [ -8.32894132e-01,  -4.30893454e-01], [ -8.31554102e-01,  -5.02683452e-01], [ -8.34838352e-01,  -5.75716949e-01], [ -8.75008351e-01,  -6.53037047e-01],
       [ -8.32308382e-01,  -6.25711947e-01], [ -7.95311183e-01,  -6.25666347e-01], [ -7.55462485e-01,  -6.25981347e-01], [ -7.50481355e-01,  -6.26021347e-01],
       [ -7.45461535e-01,  -6.26071347e-01], [ -7.40374585e-01,  -6.26071347e-01], [ -7.04765637e-01,  -6.26061347e-01], [ -6.66143178e-01,  -6.23745148e-01],
       [ -6.18792529e-01,  -6.01095748e-01], [ -6.65672558e-01,  -6.76195746e-01], [ -6.06417230e-01,  -7.50835743e-01], [ -6.54637278e-01,  -8.22345741e-01],
       [ -6.52285728e-01,  -8.20978941e-01], [ -6.49934178e-01,  -8.19712841e-01], [ -6.47591408e-01,  -8.18522541e-01], [ -5.74964181e-01,  -7.81622842e-01],
       [ -5.06541233e-01,  -8.26972341e-01], [ -4.42322785e-01,  -7.94586942e-01], [ -4.58982835e-01,  -9.87146935e-01], [ -4.02280087e-01,  -1.09049453e+00],
       [ -3.30350189e-01,  -1.17531453e+00], [ -3.23580189e-01,  -1.06536453e+00], [ -3.28956489e-01,  -9.49360437e-01], [ -2.30916492e-01,  -8.85070439e-01],
       [ -2.09936593e-01,  -9.24940438e-01], [ -1.86193494e-01,  -9.62823736e-01], [ -1.61043495e-01,  -9.99723735e-01], [ -1.62213495e-01,  -8.79963739e-01],
       [ -1.39902795e-01,  -7.73674643e-01], [ -5.98227980e-02,  -7.00514745e-01], [ -4.04627987e-02,  -7.53024743e-01], [ -1.07899996e-02,  -7.96719442e-01],
       [  2.52699992e-02,  -8.34899441e-01], [  2.36043992e-02,  -8.27829441e-01], [  2.20275993e-02,  -8.20753341e-01], [  2.05530993e-02,  -8.13673941e-01],
       [ -1.56259995e-03,  -7.07482245e-01], [  6.14899980e-04,  -6.00093148e-01], [  1.10377296e-01,  -4.87321352e-01], [  1.29577296e-01,  -5.38621350e-01],
       [  1.53302195e-01,  -5.86516349e-01], [  1.82052194e-01,  -6.30656247e-01], [  1.81232194e-01,  -6.23916348e-01], [  1.80506394e-01,  -6.17191848e-01],
       [  1.79884194e-01,  -6.10500048e-01], [  1.70551294e-01,  -5.10123751e-01], [  1.84855894e-01,  -4.15517054e-01], [  2.64449591e-01,  -3.36823357e-01],
       [  2.76779591e-01,  -3.72753256e-01], [  2.96308290e-01,  -4.05413355e-01], [  3.21798289e-01,  -4.35363354e-01], [  3.21600289e-01,  -4.30220254e-01],
       [  3.21551289e-01,  -4.25063754e-01], [  3.21637289e-01,  -4.19894554e-01], [  3.24294689e-01,  -2.59650160e-01], [  4.61042285e-01,  -8.96737653e-02],
       [  5.98566080e-01,  -8.22627656e-02], [  6.42856079e-01,  -7.98827657e-02], [  6.88484577e-01,  -1.09956165e-01], [  7.20294576e-01,  -1.52326263e-01],
       [  7.25024576e-01,  -2.43566260e-01], [  7.01981777e-01,  -2.02964762e-01], [  6.93121677e-01,  -2.55304760e-01], [  6.96731777e-01,  -2.52279760e-01],
       [  7.00454377e-01,  -2.49400260e-01], [  7.04327777e-01,  -2.46676860e-01], [  7.31441676e-01,  -2.27612761e-01], [  7.65470274e-01,  -2.16448261e-01],
       [  8.12711573e-01,  -2.20368161e-01], [  8.13901573e-01,  -2.64258160e-01], [  7.84161074e-01,  -2.60677660e-01], [  8.16271173e-01,  -3.52057657e-01],
       [  8.26931172e-01,  -2.28847661e-01], [  9.66061568e-01,  -3.10986758e-01], [  1.00125157e+00,  -1.04806665e-01], [  1.06154156e+00,  -5.18666666e-02],
       [  1.09776906e+00,   3.49633155e-03], [  1.08635896e+00,   6.36064295e-02], [  1.03090897e+00,   8.30663289e-02], [  1.01512447e+00,   9.65873134e-03],
       [  9.63634368e-01,  -4.51268318e-04], [  9.57894368e-01,   2.74087308e-02], [  9.40184769e-01,   4.74722301e-02], [  9.15704769e-01,   6.31522296e-02],
       [  9.07854670e-01,   3.99122303e-02], [  8.94262870e-01,   2.79373307e-02], [  8.78072871e-01,   2.10673310e-02], [  8.82462871e-01,   5.04773300e-02],
       [  8.71858771e-01,   7.92731290e-02], [  8.47618772e-01,   1.07493128e-01], [  8.23318773e-01,   7.45131292e-02], [  7.92794274e-01,   6.74711294e-02],
       [  7.60724275e-01,   6.67411294e-02], [  7.60898275e-01,   7.15286293e-02], [  7.60841275e-01,   7.62446291e-02], [  7.60548275e-01,   8.08915290e-02],
       [  7.58496975e-01,   1.13419728e-01], [  7.45233775e-01,   1.42569527e-01], [  7.24015076e-01,   1.69309526e-01], [  7.13425076e-01,   1.35099527e-01],
       [  6.92584077e-01,   1.29936527e-01], [  6.68014078e-01,   1.35266527e-01], [  6.78954077e-01,   1.71276526e-01], [  6.71949078e-01,   1.95536125e-01],
       [  6.50099078e-01,   2.10076125e-01], [  6.17339079e-01,   1.36856127e-01], [  4.72343884e-01,   2.38797224e-01], [  5.96353980e-01,   2.99197222e-01],
       [  6.05903880e-01,   2.68057223e-01], [  6.22657979e-01,   2.40926924e-01], [  6.53687878e-01,   2.21707024e-01], [  6.70197878e-01,   2.41027024e-01],
       [  6.88101277e-01,   2.59140823e-01], [  7.14171276e-01,   2.70090823e-01], [  7.36961275e-01,   2.44770824e-01], [  7.41392075e-01,   2.05098825e-01],
       [  7.82682074e-01,   1.96628925e-01], [  8.04812073e-01,   2.10948825e-01], [  8.23734573e-01,   2.37908724e-01], [  8.52994572e-01,   2.53508723e-01],
       [  8.73614571e-01,   2.29338724e-01], [  8.63291571e-01,   2.02522625e-01], [  8.87491670e-01,   1.76472626e-01], [  9.20341669e-01,   1.83582626e-01],
       [  9.34593769e-01,   2.32715824e-01], [  9.69903768e-01,   2.25295824e-01], [  9.90803767e-01,   2.12915825e-01], [  9.92998667e-01,   1.87926925e-01],
       [  9.84698667e-01,   1.55876926e-01], [  1.02498867e+00,   1.47236927e-01], [  1.06532146e+00,   1.63990126e-01], [  1.10562146e+00,   1.98870025e-01],
       [  1.11093146e+00,   1.70380126e-01], [  1.08871006e+00,   1.36293527e-01], [  1.06172016e+00,   1.01223528e-01], [  1.11955006e+00,   9.41336285e-02],
       [  1.17533126e+00,   1.05756428e-01], [  1.21938126e+00,   2.24856424e-01], [  1.26422126e+00,   2.39766424e-01], [  1.29453516e+00,   2.65822123e-01],
       [  1.30359516e+00,   3.08162021e-01], [  1.34777506e+00,   3.23482121e-01], [  1.37520015e+00,   3.60383620e-01], [  1.38422015e+00,   4.21013618e-01],
       [  1.42238015e+00,   4.55233616e-01], [  1.44160995e+00,   4.94320415e-01], [  1.43797995e+00,   5.39270414e-01], [  1.23818986e+00,   5.48530413e-01],
       [  1.20371116e+00,   6.21842911e-01], [  9.59591268e-01,   6.42292910e-01], [  9.02911270e-01,   7.13822908e-01], [  8.65204671e-01,   7.26630207e-01],
       [  8.64654771e-01,   7.51570207e-01], [  8.56884771e-01,   7.50390207e-01], [  8.50779072e-01,   7.44836007e-01], [  8.41349072e-01,   7.47996007e-01],
       [  3.88067787e-01,   8.65344703e-01], [  1.95117793e-01,   7.74534706e-01], [ -6.97712977e-02,   8.40598004e-01], [ -1.35511295e-01,   9.49997900e-01],
       [ -1.35511295e-01,   9.50000000e-01],
       [ -1.35511295e-01,   9.50000000e-01]], [ 1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
        4,  4,  4,  4,  4,  2,  4,  4,  4,  2, 79])
  chaos = matplotlib.path.Path([[  4.29028097e-04,   9.99503600e-01], [  4.29028097e-04,   9.99503600e-01],
       [ -7.49585660e-02,   6.03847063e-01], [ -1.60687423e-01,   4.28706735e-01], [ -1.66497221e-01,   4.16837428e-01], [ -1.00115223e-01,   4.62305952e-01],
       [ -5.07279255e-02,   4.97175041e-01], [ -5.07279255e-02,   1.23401855e-01], [ -3.15028488e-01,   3.87702418e-01], [ -2.55451307e-01,   3.97965977e-01],
       [ -1.76354777e-01,   4.12757192e-01], [ -1.88855822e-01,   4.17041532e-01], [ -3.73318417e-01,   4.80265061e-01], [ -7.06403054e-01,   7.06723805e-01],
       [ -7.06403054e-01,   7.06723805e-01], [ -6.90148467e-01,   6.90386302e-01], [ -7.06475565e-01,   7.06640908e-01], [ -7.06475565e-01,   7.06640908e-01],
       [ -4.80016921e-01,   3.73566656e-01], [ -4.16793353e-01,   1.89104061e-01], [ -4.12508733e-01,   1.76603237e-01], [ -3.97720183e-01,   2.55688099e-01],
       [ -3.87454238e-01,   3.15266323e-01], [ -1.23164020e-01,   5.09761047e-02], [ -4.96937146e-01,   5.09761047e-02], [ -4.62067095e-01,   1.00361016e-01],
       [ -4.16589510e-01,   1.66745761e-01], [ -4.28458556e-01,   1.60935603e-01], [ -6.03599104e-01,   7.52065448e-02], [ -9.99255422e-01,  -1.80848865e-04],
       [ -9.99255422e-01,  -1.80848865e-04], [ -9.76215108e-01,  -2.42996241e-04], [ -9.99255422e-01,  -3.05143618e-04], [ -9.99255422e-01,  -3.05143618e-04],
       [ -6.03599144e-01,  -7.56924771e-02], [ -4.28458556e-01,  -1.61421595e-01], [ -4.16589450e-01,  -1.67231332e-01], [ -4.62057713e-01,  -1.00849394e-01],
       [ -4.96926802e-01,  -5.14620972e-02], [ -1.23164020e-01,  -5.14620972e-02], [ -3.87464583e-01,  -3.15762660e-01], [ -3.97728142e-01,  -2.56185398e-01],
       [ -4.12509053e-01,  -1.77088808e-01], [ -4.16793353e-01,  -1.89590014e-01], [ -4.80016921e-01,  -3.74052468e-01], [ -7.06485910e-01,  -7.07137265e-01],
       [ -7.06485910e-01,  -7.07137265e-01], [ -6.90148467e-01,  -6.90882659e-01], [ -7.06392709e-01,  -7.07220102e-01], [ -7.06392709e-01,  -7.07220102e-01],
       [ -3.73318537e-01,  -4.80751073e-01], [ -1.88855822e-01,  -4.17527545e-01], [ -1.76354937e-01,  -4.13242984e-01], [ -2.55450204e-01,  -3.98454375e-01],
       [ -3.15028488e-01,  -3.88188430e-01], [ -5.07279255e-02,  -1.23887828e-01], [ -5.07279255e-02,  -4.97681742e-01], [ -1.00112777e-01,  -4.62812053e-01],
       [ -1.66497361e-01,  -4.17333344e-01], [ -1.60687423e-01,  -4.29203092e-01], [ -7.49584658e-02,  -6.04343420e-01], [  4.29028097e-04,  -1.00000000e+00],
       [  4.29028097e-04,  -1.00000000e+00], [  4.91175474e-04,  -9.76959562e-01], [  5.43299079e-04,  -1.00000000e+00], [  5.43299079e-04,  -1.00000000e+00],
       [  7.59308331e-02,  -6.04343420e-01], [  1.61659731e-01,  -4.29203092e-01], [  1.67469528e-01,  -4.17333725e-01], [  1.01087590e-01,  -4.62801868e-01],
       [  5.17002527e-02,  -4.97671338e-01], [  5.17002527e-02,  -1.23887828e-01], [  3.16010919e-01,  -3.88198775e-01], [  2.56434219e-01,  -3.98462554e-01],
       [  1.77336627e-01,  -4.13242563e-01], [  1.89838253e-01,  -4.17527545e-01], [  3.74300487e-01,  -4.80751073e-01], [  7.07385445e-01,  -7.07220102e-01],
       [  7.07385445e-01,  -7.07220102e-01], [  6.91130838e-01,  -6.90882659e-01], [  7.07468341e-01,  -7.07137265e-01], [  7.07468341e-01,  -7.07137265e-01],
       [  4.80999312e-01,  -3.74062652e-01], [  4.17775724e-01,  -1.89600418e-01], [  4.13491003e-01,  -1.77099373e-01], [  3.98702414e-01,  -2.56184235e-01],
       [  3.88436669e-01,  -3.15762680e-01], [  1.24136067e-01,  -5.14621173e-02], [  4.97929922e-01,  -5.14621173e-02], [  4.63060252e-01,  -1.00846828e-01],
       [  4.17581544e-01,  -1.67231573e-01], [  4.29451332e-01,  -1.61421615e-01], [  6.04591820e-01,  -7.56927177e-02], [  1.00024822e+00,  -3.05163665e-04],
       [  1.00024822e+00,  -3.05163665e-04], [  9.77207781e-01,  -2.43016289e-04], [  1.00024822e+00,  -1.80868913e-04], [  1.00024822e+00,  -1.80868913e-04],
       [  6.04591459e-01,   7.52068856e-02], [  4.29451332e-01,   1.60935583e-01], [  4.17581965e-01,   1.66745380e-01], [  4.63050108e-01,   1.00363221e-01],
       [  4.97919577e-01,   5.09760847e-02], [  1.24146412e-01,   5.09760847e-02], [  3.88447014e-01,   3.15276727e-01], [  3.98710733e-01,   2.55699807e-01],
       [  4.13490582e-01,   1.76602595e-01], [  4.17775724e-01,   1.89104061e-01], [  4.80999312e-01,   3.73566656e-01], [  7.07468341e-01,   7.06640908e-01],
       [  7.07468341e-01,   7.06640908e-01], [  6.91130838e-01,   6.90396647e-01], [  7.07385445e-01,   7.06734149e-01], [  7.07385445e-01,   7.06734149e-01],
       [  3.74300286e-01,   4.80265061e-01], [  1.89838253e-01,   4.17041532e-01], [  1.77337208e-01,   4.12756812e-01], [  2.56432214e-01,   3.97968001e-01],
       [  3.16010919e-01,   3.87702418e-01], [  5.16999720e-02,   1.23391531e-01], [  5.16999720e-02,   4.97185385e-01], [  1.01084723e-01,   4.62315074e-01],
       [  1.67469408e-01,   4.16837428e-01], [  1.61659450e-01,   4.28706735e-01], [  7.59313543e-02,   6.03847063e-01], [  5.53362945e-04,   9.99503600e-01],
       [  5.53362945e-04,   9.99503600e-01], [  4.91215569e-04,   9.76463283e-01], [  4.29028097e-04,   9.99503600e-01],
       [  4.29028097e-04,   9.99503600e-01]], [ 1,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,
        4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,
        4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,
        4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,
        4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,
        4,  4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,
        4,  2,  2,  4,  4,  4,  4,  4,  4,  2,  2,  4,  4,  4,  4,  4,  4,
        2,  2,  4,  4,  4,  4,  4,  4,  2,  2, 79])
  ubt = matplotlib.path.Path([[-1.        , -1.        ], [-1.        ,  1.        ],
       [-1.        ,  1.        ], [ 1.        ,  1.        ], [ 1.        ,  1.        ], [ 1.        , -1.        ],
       [ 1.        , -1.        ], [-1.        , -1.        ], [-0.9056    , -0.91779998], [ 0.4516    ,  0.44279997],
       [ 0.9006    ,  0.44279997], [ 0.9006    , -0.00940004], [ 0.00509175, -0.91779998], [-0.9056    , -0.91779998],
       [-0.9056    , -0.91779998], [-0.9056    ,  0.90260003], [-0.9056    ,  0.90260003], [-0.3       ,  0.90260003],
       [-0.3       ,  0.90260003],  [-0.3       , -0.30480006]],
       [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2])
  CUSTOM_MARKERS.update({'pac': pac, 'ghost': ghost, 'stark': stark, 'chaos': chaos, 'ubt': ubt})
  
  # start app
  DPI_SCALING = 1.0
  PICK_TOLERANCE = 10
  QSTYLE, QSTYLESHEET = None, None
  if(platform == 'darwin'):
    # special treatment for OS X (native style is just killing me)
    BASE_SIZE = 22
    QSTYLE = QtWidgets.QStyleFactory.create('Fusion')
    # set style sheet to approx. retain correct look
    QSTYLESHEET  = "QComboBox {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding-left: 3px;}\n\
                    QComboBox:hover {color:#6258b8;}\n\
                    QWidget {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding: 0px;}\n\
                    QRadioButton {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding: 0px; spacing: 3px;}\n\
                    QRadioButton::indicator {width: 12px; height: 12px;}\n\
                    QTableView::item:focus {background-color: white; color: black;}\n\
                    QTableView::item:selected {background-color: #0078d7; color: white;}\
                    QTableView::item:focus:selected {background-color: white; color: black;}\n\
                    QTableView::item:!active:selected {background-color: #7799ee; color: white;}\
                    QTableView {alternate-background-color: #f1f1f1;}\n\
                    QTableView#data QTableCornerButton {background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #b0aae8, stop: 0.3 #9288e8, stop: 0.8 #9288e8, stop: 1.0 #8077e8);}\n\
                    QToolTip {color:black;}\n\
                    QPushButton:hover {color: #6258b8;}\n\
                    QPushButton:checked {background-color: #7066ff; color: black;}\n\
                    QPushButton:checked:hover {background-color: #9088ff; color: white;}\n\
                    QPushButton:checked:!enabled {background-color: #c0bbff; color: #787878;}\n\
                    QPushButton#listos {margin-left: " + str(scaledDPI(2)) + "px; margin-top: " + str(scaledDPI(2)) + "px;}\n\
                    QTabBar::tab:!selected:hover {color: #6258b8;}\n\
                    QTabBar::tab:selected {background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #b0aae8, stop: 0.3 #9288e8, stop: 0.8 #9288e8, stop: 1.0 #8077e8);}\n\
                    QTabBar::tab:selected:hover {color: white;}\n\
                    QRadioButton#listos::indicator {subcontrol-position: center;}\n\
                    QLineEdit {border-width: " + str(scaledDPI(1)) + "px; border-color: #ababab; border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                    QGroupBox {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; border-style: none;}\n"
  else:
    BASE_SIZE = 22
    QSTYLE = QtWidgets.QStyleFactory.create('Fusion')
    QSTYLESHEET  = "QTableView::item:focus {background-color: white; color: black;}\n\
                    QTableView::item:selected {background-color: #0078d7; color: white;}\
                    QTableView::item:focus:selected {background-color: white; color: black;}\n\
                    QTableView::item:!active:selected {background-color: #7799ee; color: white;}\
                    QTableView {alternate-background-color: #f1f1f1;}\n\
                    QTableView#data QTableCornerButton {background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #b0aae8, stop: 0.3 #9288e8, stop: 0.8 #9288e8, stop: 1.0 #8077e8);}\n\
                    QComboBox:hover {color: #6258b8;}\n\
                    QPushButton:hover {color: #6258b8;}\n\
                    QPushButton:checked {background-color: #7066ff; color: black;}\n\
                    QPushButton:checked:hover {background-color: #9088ff; color: white;}\n\
                    QPushButton:checked:!enabled {background-color: #c0bbff; color: #787878;}\n\
                    QPushButton#listos {margin-left: " + str(scaledDPI(2)) + "px; margin-top: " + str(scaledDPI(2)) + "px;}\n\
                    QTabBar::tab:!selected:hover {color: #6258b8;}\n\
                    QTabBar::tab:selected {background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #b0aae8, stop: 0.3 #9288e8, stop: 0.8 #9288e8, stop: 1.0 #8077e8);}\n\
                    QTabBar::tab:selected:hover {color: white;}\n\
                    QRadioButton#listos::indicator {subcontrol-position: center;}\n\
                    QLineEdit {border-width: " + str(scaledDPI(1)) + "px; border-color: #ababab; border-style: solid; border-radius: " + str(scaledDPI(4)) + "px;}\n\
                    QGroupBox {border-style: none;}\n"
    if('linux' in platform):
      QSTYLESHEET += "QWidget {font-size: " + WIDGET_FONTSIZE + "pt;}\n\
                      QToolTip {color:black; background-color: #ffffe1; padding: 2px;}"

  app = QtWidgets.QApplication(argv)
  myapp = MyForm()
  if(QSTYLE != None):
    myapp.setStyle(QSTYLE)
  if(QSTYLESHEET != None):
    myapp.setStyleSheet(QSTYLESHEET)
  myapp.show()
  
  # due to stylesheet shenanigans, have to readjust diverse tables ... (a new feature? of recent PyQt5 versions)
  myapp.ui.dataarea.tableWidget.readjustSize()

  # now we have to again adjust splitter sizes
  myapp.ui.masterwidget.setSizes([scaledDPI(422), myapp.ui.masterwidget.size().width() - scaledDPI(422)])
  useHeight =  myapp.ui.plotArea.masterwidget.size().height()
  myapp.ui.plotArea.masterwidget.setSizes([useHeight * 0.65, useHeight * 0.35])
  
  # and update ruler to current canvas size
  QtCore.QCoreApplication.processEvents()
  myapp.ui.plotArea.horizontalRuler.updateRuler()
  myapp.ui.plotArea.verticalRuler.updateRuler()
  myapp.ui.plotArea.verticalRulerResid.updateRuler()
  
  # define custom key bindings
  myapp.bindings = []
  for index in range(myapp.ui.tabWidget.count() + 1):
    # count up one more to account for non-visible 2nd Axes tab
    myapp.bindings.append(QtWidgets.QShortcut(QtGui.QKeySequence('Ctrl+' + str(index + 1)), myapp))
    myapp.bindings[index].activated.connect(partial(switchTab, index))
  
  # now check whether state should be loaded
  if(STATEFILE != ''):
    QtCore.QCoreApplication.processEvents()
    myapp.ui.loadState(stateFile=STATEFILE)

  # initial show of tooltip tooltip :)
  QtWidgets.QToolTip.showText(myapp.ui.dataarea.importButton.mapToGlobal(QtCore.QPoint(scaledDPI(50), scaledDPI(12))), '\u2196 Click here to open your data', myapp.ui.dataarea.importButton)

  # deal with uncaught exceptions
  import sys
  originalhook = sys.excepthook
  sys.excepthook = criticalFailure

  # print Fit-o-mat information (set counter to 1 to counteract initial widget resizes [purely empirical])
  myapp.ui.plotArea.drawAboutLogo(aspect=1.20, destructCounter=1)
  
  # and start the application
  exit(app.exec_())